<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>.tox {
  box-shadow: none;
  box-sizing: content-box;
  color: #222f3e;
  cursor: auto;
  -webkit-tap-highlight-color: transparent;
  text-shadow: none;
  text-transform: none;
  vertical-align: initial;
  white-space: normal;
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen-Sans, Ubuntu, Cantarell, Helvetica Neue, sans-serif;
  font-size: 16px;
  font-style: normal;
  font-weight: normal;
  line-height: normal;
  text-decoration: none;
}

.tox :not(svg):not(rect) {
  box-sizing: inherit;
  color: inherit;
  cursor: inherit;
  direction: inherit;
  font-family: inherit;
  font-size: inherit;
  font-style: inherit;
  font-weight: inherit;
  line-height: inherit;
  -webkit-tap-highlight-color: inherit;
  text-align: inherit;
  text-decoration: inherit;
  text-shadow: inherit;
  text-transform: inherit;
  vertical-align: inherit;
  white-space: inherit;
  box-shadow: none;
  float: none;
  height: auto;
  max-width: none;
  width: auto;
  background: none;
  border: none;
  outline: none;
  margin: 0;
  padding: 0;
  position: static;
}

.tox:not([dir="rtl"]) {
  direction: ltr;
  text-align: left;
}

.tox[dir="rtl"] {
  direction: rtl;
  text-align: right;
}

.tox-tinymce {
  box-shadow: none;
  box-sizing: border-box;
  border: 2px solid #eee;
  border-radius: 10px;
  flex-direction: column;
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen-Sans, Ubuntu, Cantarell, Helvetica Neue, sans-serif;
  display: flex;
  position: relative;
  overflow: hidden;
  visibility: inherit !important;
}

.tox.tox-tinymce-inline {
  box-shadow: none;
  overflow: initial;
  border: none;
}

.tox.tox-tinymce-inline .tox-editor-container {
  overflow: initial;
}

.tox.tox-tinymce-inline .tox-editor-header {
  box-shadow: none;
  background-color: #fff;
  border: 2px solid #eee;
  border-radius: 10px;
  overflow: hidden;
}

.tox-tinymce-aux {
  z-index: 1300;
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen-Sans, Ubuntu, Cantarell, Helvetica Neue, sans-serif;
}

.tox-tinymce :focus, .tox-tinymce-aux :focus {
  outline: none;
}

button::-moz-focus-inner {
  border: none;
}

.tox[dir="rtl"] .tox-icon--flip svg {
  transform: rotateY(180deg);
}

.tox .accessibility-issue__header {
  align-items: center;
  margin-bottom: 4px;
  display: flex;
}

.tox .accessibility-issue__description {
  border: 1px solid #eee;
  border-radius: 6px;
  justify-content: space-between;
  align-items: stretch;
  display: flex;
}

.tox .accessibility-issue__description > div {
  padding-bottom: 4px;
}

.tox .accessibility-issue__description > div > div {
  align-items: center;
  margin-bottom: 4px;
  display: flex;
}

.tox .accessibility-issue__description > :last-child:not(:only-child) {
  border-style: solid;
  border-color: #eee;
}

.tox .accessibility-issue__repair {
  margin-top: 16px;
}

.tox .tox-dialog__body-content .accessibility-issue--info .accessibility-issue__description {
  color: #222f3e;
  background-color: #006ce71a;
  border-color: #006ce7;
}

.tox .tox-dialog__body-content .accessibility-issue--info .accessibility-issue__description > :last-child {
  border-color: #006ce7;
}

.tox .tox-dialog__body-content .accessibility-issue--info .tox-form__group h2 {
  color: #006ce7;
}

.tox .tox-dialog__body-content .accessibility-issue--info .tox-icon svg {
  fill: #006ce7;
}

.tox .tox-dialog__body-content .accessibility-issue--info a .tox-icon {
  color: #006ce7;
}

.tox .tox-dialog__body-content .accessibility-issue--warn .accessibility-issue__description {
  color: #222f3e;
  background-color: #ffa5001a;
  border-color: #ffa50080;
}

.tox .tox-dialog__body-content .accessibility-issue--warn .accessibility-issue__description > :last-child {
  border-color: #ffa50080;
}

.tox .tox-dialog__body-content .accessibility-issue--warn .tox-form__group h2 {
  color: #cc8500;
}

.tox .tox-dialog__body-content .accessibility-issue--warn .tox-icon svg {
  fill: #cc8500;
}

.tox .tox-dialog__body-content .accessibility-issue--warn a .tox-icon {
  color: #cc8500;
}

.tox .tox-dialog__body-content .accessibility-issue--error .accessibility-issue__description {
  color: #222f3e;
  background-color: #cc00001a;
  border-color: #c006;
}

.tox .tox-dialog__body-content .accessibility-issue--error .accessibility-issue__description > :last-child {
  border-color: #c006;
}

.tox .tox-dialog__body-content .accessibility-issue--error .tox-form__group h2 {
  color: #c00;
}

.tox .tox-dialog__body-content .accessibility-issue--error .tox-icon svg {
  fill: #c00;
}

.tox .tox-dialog__body-content .accessibility-issue--error a .tox-icon {
  color: #c00;
}

.tox .tox-dialog__body-content .accessibility-issue--success .accessibility-issue__description {
  color: #222f3e;
  background-color: #78ab461a;
  border-color: #78ab4666;
}

.tox .tox-dialog__body-content .accessibility-issue--success .accessibility-issue__description > :last-child {
  border-color: #78ab4666;
}

.tox .tox-dialog__body-content .accessibility-issue--success .tox-form__group h2 {
  color: #78ab46;
}

.tox .tox-dialog__body-content .accessibility-issue--success .tox-icon svg {
  fill: #78ab46;
}

.tox .tox-dialog__body-content .accessibility-issue--success a .tox-icon {
  color: #78ab46;
}

.tox .tox-dialog__body-content .accessibility-issue__header h1, .tox .tox-dialog__body-content .tox-form__group .accessibility-issue__description h2 {
  margin-top: 0;
}

.tox:not([dir="rtl"]) .tox-dialog__body-content .accessibility-issue__header .tox-button {
  margin-left: 4px;
}

.tox:not([dir="rtl"]) .tox-dialog__body-content .accessibility-issue__header > :nth-last-child(2) {
  margin-left: auto;
}

.tox:not([dir="rtl"]) .tox-dialog__body-content .accessibility-issue__description {
  padding: 4px 4px 4px 8px;
}

.tox:not([dir="rtl"]) .tox-dialog__body-content .accessibility-issue__description > :last-child {
  border-left-width: 1px;
  padding-left: 4px;
}

.tox[dir="rtl"] .tox-dialog__body-content .accessibility-issue__header .tox-button {
  margin-right: 4px;
}

.tox[dir="rtl"] .tox-dialog__body-content .accessibility-issue__header > :nth-last-child(2) {
  margin-right: auto;
}

.tox[dir="rtl"] .tox-dialog__body-content .accessibility-issue__description {
  padding: 4px 8px 4px 4px;
}

.tox[dir="rtl"] .tox-dialog__body-content .accessibility-issue__description > :last-child {
  border-right-width: 1px;
  padding-right: 4px;
}

.tox .tox-anchorbar, .tox .tox-bar {
  flex: none;
  display: flex;
}

.tox .tox-button {
  box-shadow: none;
  box-sizing: border-box;
  color: #fff;
  cursor: pointer;
  letter-spacing: normal;
  text-align: center;
  text-transform: none;
  white-space: nowrap;
  background-color: #006ce7;
  background-image: none;
  background-position: 0 0;
  background-repeat: repeat;
  border: 1px solid #006ce7;
  border-radius: 6px;
  outline: none;
  margin: 0;
  padding: 4px 16px;
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen-Sans, Ubuntu, Cantarell, Helvetica Neue, sans-serif;
  font-size: 14px;
  font-style: normal;
  font-weight: bold;
  line-height: 24px;
  text-decoration: none;
  display: inline-block;
}

.tox .tox-button[disabled] {
  box-shadow: none;
  color: #ffffff80;
  cursor: not-allowed;
  background-color: #006ce7;
  background-image: none;
  border-color: #006ce7;
}

.tox .tox-button:focus:not(:disabled), .tox .tox-button:hover:not(:disabled) {
  box-shadow: none;
  color: #fff;
  background-color: #0060ce;
  background-image: none;
  border-color: #0060ce;
}

.tox .tox-button:active:not(:disabled) {
  box-shadow: none;
  color: #fff;
  background-color: #0054b4;
  background-image: none;
  border-color: #0054b4;
}

.tox .tox-button--secondary {
  box-shadow: none;
  color: #222f3e;
  letter-spacing: normal;
  text-transform: none;
  background-color: #f0f0f0;
  background-image: none;
  background-position: 0 0;
  background-repeat: repeat;
  border: 1px solid #f0f0f0;
  border-radius: 6px;
  outline: none;
  padding: 4px 16px;
  font-size: 14px;
  font-style: normal;
  font-weight: bold;
  text-decoration: none;
}

.tox .tox-button--secondary[disabled] {
  box-shadow: none;
  color: #222f3e80;
  background-color: #f0f0f0;
  background-image: none;
  border-color: #f0f0f0;
}

.tox .tox-button--secondary:focus:not(:disabled), .tox .tox-button--secondary:hover:not(:disabled) {
  box-shadow: none;
  color: #222f3e;
  background-color: #e3e3e3;
  background-image: none;
  border-color: #e3e3e3;
}

.tox .tox-button--secondary:active:not(:disabled) {
  box-shadow: none;
  color: #222f3e;
  background-color: #d6d6d6;
  background-image: none;
  border-color: #d6d6d6;
}

.tox .tox-button--icon, .tox .tox-button.tox-button--icon, .tox .tox-button.tox-button--secondary.tox-button--icon {
  padding: 4px;
}

.tox .tox-button--icon .tox-icon svg, .tox .tox-button.tox-button--icon .tox-icon svg, .tox .tox-button.tox-button--secondary.tox-button--icon .tox-icon svg {
  fill: currentColor;
  display: block;
}

.tox .tox-button-link {
  box-sizing: border-box;
  cursor: pointer;
  white-space: nowrap;
  background: 0;
  border: none;
  margin: 0;
  padding: 0;
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen-Sans, Ubuntu, Cantarell, Helvetica Neue, sans-serif;
  font-size: 16px;
  font-weight: normal;
  line-height: 1.3;
  display: inline-block;
}

.tox .tox-button-link--sm {
  font-size: 14px;
}

.tox .tox-button--naked {
  box-shadow: unset;
  color: #222f3e;
  background-color: #0000;
  border-color: #0000;
}

.tox .tox-button--naked[disabled] {
  box-shadow: unset;
  color: #222f3e80;
  background-color: #222f3e1f;
  border-color: #0000;
}

.tox .tox-button--naked:hover:not(:disabled), .tox .tox-button--naked:focus:not(:disabled) {
  box-shadow: unset;
  color: #222f3e;
  background-color: #222f3e1f;
  border-color: #0000;
}

.tox .tox-button--naked:active:not(:disabled) {
  box-shadow: unset;
  color: #222f3e;
  background-color: #222f3e2e;
  border-color: #0000;
}

.tox .tox-button--naked .tox-icon svg {
  fill: currentColor;
}

.tox .tox-button--naked.tox-button--icon:hover:not(:disabled) {
  color: #222f3e;
}

.tox .tox-checkbox {
  cursor: pointer;
  height: 36px;
  min-width: 36px;
  border-radius: 6px;
  align-items: center;
  display: flex;
}

.tox .tox-checkbox__input {
  height: 1px;
  width: 1px;
  position: absolute;
  top: auto;
  overflow: hidden;
}

.tox .tox-checkbox__icons {
  box-sizing: content-box;
  height: 24px;
  width: 24px;
  border-radius: 6px;
  justify-content: center;
  align-items: center;
  padding: 3px;
  display: flex;
  box-shadow: 0 0 0 2px #0000;
}

.tox .tox-checkbox__icons .tox-checkbox-icon__unchecked svg {
  fill: #222f3e4d;
  display: block;
}

.tox .tox-checkbox__icons .tox-checkbox-icon__indeterminate svg, .tox .tox-checkbox__icons .tox-checkbox-icon__checked svg {
  fill: #006ce7;
  display: none;
}

.tox .tox-checkbox--disabled {
  color: #222f3e80;
  cursor: not-allowed;
}

.tox .tox-checkbox--disabled .tox-checkbox__icons .tox-checkbox-icon__checked svg, .tox .tox-checkbox--disabled .tox-checkbox__icons .tox-checkbox-icon__unchecked svg, .tox .tox-checkbox--disabled .tox-checkbox__icons .tox-checkbox-icon__indeterminate svg {
  fill: #222f3e80;
}

.tox input.tox-checkbox__input:checked + .tox-checkbox__icons .tox-checkbox-icon__unchecked svg {
  display: none;
}

.tox input.tox-checkbox__input:checked + .tox-checkbox__icons .tox-checkbox-icon__checked svg {
  display: block;
}

.tox input.tox-checkbox__input:indeterminate + .tox-checkbox__icons .tox-checkbox-icon__unchecked svg {
  display: none;
}

.tox input.tox-checkbox__input:indeterminate + .tox-checkbox__icons .tox-checkbox-icon__indeterminate svg {
  display: block;
}

.tox input.tox-checkbox__input:focus + .tox-checkbox__icons {
  border-radius: 6px;
  padding: 3px;
  box-shadow: inset 0 0 0 1px #006ce7;
}

.tox:not([dir="rtl"]) .tox-checkbox__label {
  margin-left: 4px;
}

.tox:not([dir="rtl"]) .tox-checkbox__input {
  left: -10000px;
}

.tox:not([dir="rtl"]) .tox-bar .tox-checkbox {
  margin-left: 4px;
}

.tox[dir="rtl"] .tox-checkbox__label {
  margin-right: 4px;
}

.tox[dir="rtl"] .tox-checkbox__input {
  right: -10000px;
}

.tox[dir="rtl"] .tox-bar .tox-checkbox {
  margin-right: 4px;
}

.tox {
}

.tox .tox-collection--toolbar .tox-collection__group {
  padding: 0;
  display: flex;
}

.tox .tox-collection--grid .tox-collection__group {
  max-height: 208px;
  flex-wrap: wrap;
  padding: 0;
  display: flex;
  overflow-x: hidden;
  overflow-y: auto;
}

.tox .tox-collection--list .tox-collection__group {
  border: 0 solid #e3e3e3;
  border-top-width: 1px;
  padding: 4px 0;
}

.tox .tox-collection--list .tox-collection__group:first-child {
  border-top-width: 0;
}

.tox .tox-collection__group-heading {
  color: #222f3eb3;
  cursor: default;
  text-transform: none;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  background-color: #fcfcfc;
  margin-top: -4px;
  margin-bottom: 4px;
  padding: 4px 8px;
  font-size: 12px;
  font-style: normal;
  font-weight: normal;
}

.tox .tox-collection__item {
  color: #222f3e;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  border-radius: 3px;
  align-items: center;
  display: flex;
}

.tox .tox-collection--list .tox-collection__item {
  padding: 4px 8px;
}

.tox .tox-collection--toolbar .tox-collection__item, .tox .tox-collection--grid .tox-collection__item {
  border-radius: 3px;
  padding: 4px;
}

.tox .tox-collection--list .tox-collection__item--enabled {
  color: #222f3e;
  background-color: #fff;
}

.tox .tox-collection--list .tox-collection__item--active {
  background-color: #cce2fa;
}

.tox .tox-collection--toolbar .tox-collection__item--enabled {
  color: #222f3e;
  background-color: #a6ccf7;
}

.tox .tox-collection--toolbar .tox-collection__item--active {
  background-color: #cce2fa;
}

.tox .tox-collection--grid .tox-collection__item--enabled {
  color: #222f3e;
  background-color: #a6ccf7;
}

.tox .tox-collection--grid .tox-collection__item--active:not(.tox-collection__item--state-disabled) {
  color: #222f3e;
  background-color: #cce2fa;
}

.tox .tox-collection--list .tox-collection__item--active:not(.tox-collection__item--state-disabled), .tox .tox-collection--toolbar .tox-collection__item--active:not(.tox-collection__item--state-disabled) {
  color: #222f3e;
}

.tox .tox-collection__item-icon, .tox .tox-collection__item-checkmark {
  height: 24px;
  width: 24px;
  justify-content: center;
  align-items: center;
  display: flex;
}

.tox .tox-collection__item-icon svg, .tox .tox-collection__item-checkmark svg {
  fill: currentColor;
}

.tox .tox-collection--toolbar-lg .tox-collection__item-icon {
  height: 48px;
  width: 48px;
}

.tox .tox-collection__item-label {
  color: currentColor;
  text-transform: none;
  word-break: break-all;
  flex: 1;
  font-size: 14px;
  font-style: normal;
  font-weight: normal;
  line-height: 24px;
  display: inline-block;
}

.tox .tox-collection__item-accessory {
  color: #222f3eb3;
  height: 24px;
  text-transform: none;
  font-size: 14px;
  line-height: 24px;
  display: inline-block;
}

.tox .tox-collection__item-caret {
  min-height: 24px;
  align-items: center;
  display: flex;
}

.tox .tox-collection__item-caret:after {
  content: "";
  min-height: inherit;
  font-size: 0;
}

.tox .tox-collection__item-caret svg {
  fill: #222f3e;
}

.tox .tox-collection__item--state-disabled {
  color: #222f3e80;
  cursor: not-allowed;
  background-color: #0000;
}

.tox .tox-collection__item--state-disabled .tox-collection__item-caret svg {
  fill: #222f3e80;
}

.tox .tox-collection--list .tox-collection__item:not(.tox-collection__item--enabled) .tox-collection__item-checkmark svg, .tox .tox-collection--list .tox-collection__item:not(.tox-collection__item--enabled) .tox-collection__item-accessory + .tox-collection__item-checkmark {
  display: none;
}

.tox .tox-collection--horizontal {
  background-color: #fff;
  border: 1px solid #e3e3e3;
  border-radius: 6px;
  flex-wrap: nowrap;
  flex: none;
  margin-bottom: 0;
  padding: 0;
  display: flex;
  overflow-x: auto;
  box-shadow: 0 0 2px #222f3e33, 0 4px 8px #222f3e26;
}

.tox .tox-collection--horizontal .tox-collection__group {
  flex-wrap: nowrap;
  align-items: center;
  margin: 0;
  padding: 0 4px;
  display: flex;
}

.tox .tox-collection--horizontal .tox-collection__item {
  height: 28px;
  margin: 6px 1px 5px 0;
  padding: 0 4px;
}

.tox .tox-collection--horizontal .tox-collection__item-label {
  white-space: nowrap;
}

.tox .tox-collection--horizontal .tox-collection__item-caret {
  margin-left: 4px;
}

.tox .tox-collection__item-container {
  display: flex;
}

.tox .tox-collection__item-container--row {
  flex-direction: row;
  flex: auto;
  align-items: center;
}

.tox .tox-collection__item-container--row.tox-collection__item-container--align-left {
  margin-right: auto;
}

.tox .tox-collection__item-container--row.tox-collection__item-container--align-right {
  justify-content: flex-end;
  margin-left: auto;
}

.tox .tox-collection__item-container--row.tox-collection__item-container--valign-top {
  align-items: flex-start;
  margin-bottom: auto;
}

.tox .tox-collection__item-container--row.tox-collection__item-container--valign-middle {
  align-items: center;
}

.tox .tox-collection__item-container--row.tox-collection__item-container--valign-bottom {
  align-items: flex-end;
  margin-top: auto;
}

.tox .tox-collection__item-container--column {
  flex-direction: column;
  flex: auto;
  align-self: center;
}

.tox .tox-collection__item-container--column.tox-collection__item-container--align-left {
  align-items: flex-start;
}

.tox .tox-collection__item-container--column.tox-collection__item-container--align-right {
  align-items: flex-end;
}

.tox .tox-collection__item-container--column.tox-collection__item-container--valign-top {
  align-self: flex-start;
}

.tox .tox-collection__item-container--column.tox-collection__item-container--valign-middle {
  align-self: center;
}

.tox .tox-collection__item-container--column.tox-collection__item-container--valign-bottom {
  align-self: flex-end;
}

.tox:not([dir="rtl"]) .tox-collection--horizontal .tox-collection__group:not(:last-of-type) {
  border-right: 1px solid #0000;
}

.tox:not([dir="rtl"]) .tox-collection--list .tox-collection__item > :not(:first-child) {
  margin-left: 8px;
}

.tox:not([dir="rtl"]) .tox-collection--list .tox-collection__item > .tox-collection__item-label:first-child {
  margin-left: 4px;
}

.tox:not([dir="rtl"]) .tox-collection__item-accessory {
  text-align: right;
  margin-left: 16px;
}

.tox:not([dir="rtl"]) .tox-collection .tox-collection__item-caret {
  margin-left: 16px;
}

.tox[dir="rtl"] .tox-collection--horizontal .tox-collection__group:not(:last-of-type) {
  border-left: 1px solid #0000;
}

.tox[dir="rtl"] .tox-collection--list .tox-collection__item > :not(:first-child) {
  margin-right: 8px;
}

.tox[dir="rtl"] .tox-collection--list .tox-collection__item > .tox-collection__item-label:first-child {
  margin-right: 4px;
}

.tox[dir="rtl"] .tox-collection__item-accessory {
  text-align: left;
  margin-right: 16px;
}

.tox[dir="rtl"] .tox-collection .tox-collection__item-caret {
  margin-right: 16px;
  transform: rotateY(180deg);
}

.tox[dir="rtl"] .tox-collection--horizontal .tox-collection__item-caret {
  margin-right: 4px;
}

.tox .tox-color-picker-container {
  height: 225px;
  flex-direction: row;
  margin: 0;
  display: flex;
}

.tox .tox-sv-palette {
  box-sizing: border-box;
  height: 100%;
  display: flex;
}

.tox .tox-sv-palette-spectrum {
  height: 100%;
}

.tox .tox-sv-palette, .tox .tox-sv-palette-spectrum {
  width: 225px;
}

.tox .tox-sv-palette-thumb {
  box-sizing: content-box;
  height: 12px;
  width: 12px;
  background: none;
  border: 1px solid #000;
  border-radius: 50%;
  position: absolute;
}

.tox .tox-sv-palette-inner-thumb {
  height: 10px;
  width: 10px;
  border: 1px solid #fff;
  border-radius: 50%;
  position: absolute;
}

.tox .tox-hue-slider {
  box-sizing: border-box;
  height: 100%;
  width: 25px;
}

.tox .tox-hue-slider-spectrum {
  height: 100%;
  width: 100%;
  background: linear-gradient(red, #ff0080, #f0f, #8000ff, #00f, #0080ff, #0ff, #00ff80, #0f0, #80ff00, #ff0, #ff8000, red);
}

.tox .tox-hue-slider, .tox .tox-hue-slider-spectrum {
  width: 20px;
}

.tox .tox-hue-slider-thumb {
  box-sizing: content-box;
  height: 4px;
  width: 100%;
  background: #fff;
  border: 1px solid #000;
}

.tox .tox-rgb-form {
  flex-direction: column;
  justify-content: space-between;
  display: flex;
}

.tox .tox-rgb-form div {
  width: inherit;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 5px;
  display: flex;
}

.tox .tox-rgb-form input {
  width: 6em;
}

.tox .tox-rgb-form input.tox-invalid {
  border: 1px solid red !important;
}

.tox .tox-rgb-form .tox-rgba-preview {
  border: 1px solid #000;
  flex-grow: 2;
  margin-bottom: 0;
}

.tox:not([dir="rtl"]) .tox-sv-palette, .tox:not([dir="rtl"]) .tox-hue-slider {
  margin-right: 15px;
}

.tox:not([dir="rtl"]) .tox-hue-slider-thumb {
  margin-left: -1px;
}

.tox:not([dir="rtl"]) .tox-rgb-form label {
  margin-right: .5em;
}

.tox[dir="rtl"] .tox-sv-palette, .tox[dir="rtl"] .tox-hue-slider {
  margin-left: 15px;
}

.tox[dir="rtl"] .tox-hue-slider-thumb {
  margin-right: -1px;
}

.tox[dir="rtl"] .tox-rgb-form label {
  margin-left: .5em;
}

.tox .tox-toolbar .tox-swatches, .tox .tox-toolbar__primary .tox-swatches, .tox .tox-toolbar__overflow .tox-swatches {
  margin: 5px 0 6px 11px;
}

.tox .tox-collection--list .tox-collection__group .tox-swatches-menu {
  border: none;
  margin: -4px;
}

.tox .tox-swatches__row {
  display: flex;
}

.tox .tox-swatch {
  height: 30px;
  width: 30px;
  transition: transform .15s, box-shadow .15s;
}

.tox .tox-swatch:hover, .tox .tox-swatch:focus {
  transform: scale(.8);
  box-shadow: inset 0 0 0 1px #7f7f7f4d;
}

.tox .tox-swatch--remove {
  justify-content: center;
  align-items: center;
  display: flex;
}

.tox .tox-swatch--remove svg path {
  stroke: #e74c3c;
}

.tox .tox-swatches__picker-btn {
  cursor: pointer;
  height: 30px;
  width: 30px;
  background-color: #0000;
  border: none;
  outline: none;
  justify-content: center;
  align-items: center;
  padding: 0;
  display: flex;
}

.tox .tox-swatches__picker-btn svg {
  fill: #222f3e;
  height: 24px;
  width: 24px;
}

.tox .tox-swatches__picker-btn:hover {
  background: #cce2fa;
}

.tox:not([dir="rtl"]) .tox-swatches__picker-btn {
  margin-left: auto;
}

.tox[dir="rtl"] .tox-swatches__picker-btn {
  margin-right: auto;
}

.tox .tox-comment-thread {
  background: #fff;
  position: relative;
}

.tox .tox-comment-thread > :not(:first-child) {
  margin-top: 8px;
}

.tox .tox-comment {
  background: #fff;
  border: 1px solid #eee;
  border-radius: 6px;
  padding: 8px 8px 16px;
  position: relative;
  box-shadow: 0 4px 8px #222f3e1a;
}

.tox .tox-comment__header {
  color: #222f3e;
  justify-content: space-between;
  align-items: center;
  display: flex;
}

.tox .tox-comment__date {
  color: #222f3eb3;
  font-size: 12px;
}

.tox .tox-comment__body {
  color: #222f3e;
  text-transform: initial;
  margin-top: 8px;
  font-size: 14px;
  font-style: normal;
  font-weight: normal;
  line-height: 1.3;
  position: relative;
}

.tox .tox-comment__body textarea {
  resize: none;
  white-space: normal;
  width: 100%;
}

.tox .tox-comment__expander {
  padding-top: 8px;
}

.tox .tox-comment__expander p {
  color: #222f3eb3;
  font-size: 14px;
  font-style: normal;
}

.tox .tox-comment__body p {
  margin: 0;
}

.tox .tox-comment__buttonspacing {
  text-align: center;
  padding-top: 16px;
}

.tox .tox-comment-thread__overlay:after {
  content: "";
  opacity: .9;
  z-index: 5;
  background: #fff;
  display: flex;
  position: absolute;
  inset: 0;
}

.tox .tox-comment__reply {
  flex-wrap: wrap;
  flex-shrink: 0;
  justify-content: flex-end;
  margin-top: 8px;
  display: flex;
}

.tox .tox-comment__reply > :first-child {
  width: 100%;
  margin-bottom: 8px;
}

.tox .tox-comment__edit {
  flex-wrap: wrap;
  justify-content: flex-end;
  margin-top: 16px;
  display: flex;
}

.tox .tox-comment__gradient:after {
  content: "";
  height: 5em;
  width: 100%;
  background: linear-gradient(#fff0, #fff);
  margin-top: -40px;
  display: block;
  position: absolute;
  bottom: 0;
}

.tox .tox-comment__overlay {
  opacity: .9;
  text-align: center;
  z-index: 5;
  background: #fff;
  flex-direction: column;
  flex-grow: 1;
  display: flex;
  position: absolute;
  inset: 0;
}

.tox .tox-comment__loading-text {
  color: #222f3e;
  flex-direction: column;
  align-items: center;
  display: flex;
  position: relative;
}

.tox .tox-comment__loading-text > div {
  padding-bottom: 16px;
}

.tox .tox-comment__overlaytext {
  z-index: 10;
  flex-direction: column;
  padding: 1em;
  font-size: 14px;
  position: absolute;
  inset: 0;
}

.tox .tox-comment__overlaytext p {
  color: #222f3e;
  text-align: center;
  background-color: #fff;
  box-shadow: 0 0 8px 8px #fff;
}

.tox .tox-comment__overlaytext div:nth-of-type(2) {
  font-size: .8em;
}

.tox .tox-comment__busy-spinner {
  z-index: 20;
  background-color: #fff;
  justify-content: center;
  align-items: center;
  display: flex;
  position: absolute;
  inset: 0;
}

.tox .tox-comment__scroll {
  flex-direction: column;
  flex-shrink: 1;
  display: flex;
  overflow: auto;
}

.tox .tox-conversations {
  margin: 8px;
}

.tox:not([dir="rtl"]) .tox-comment__edit, .tox:not([dir="rtl"]) .tox-comment__buttonspacing > :last-child, .tox:not([dir="rtl"]) .tox-comment__edit > :last-child, .tox:not([dir="rtl"]) .tox-comment__reply > :last-child {
  margin-left: 8px;
}

.tox[dir="rtl"] .tox-comment__edit, .tox[dir="rtl"] .tox-comment__buttonspacing > :last-child, .tox[dir="rtl"] .tox-comment__edit > :last-child, .tox[dir="rtl"] .tox-comment__reply > :last-child {
  margin-right: 8px;
}

.tox .tox-user {
  align-items: center;
  display: flex;
}

.tox .tox-user__avatar svg {
  fill: #222f3eb3;
}

.tox .tox-user__name {
  color: #222f3eb3;
  text-transform: uppercase;
  font-size: 12px;
  font-style: normal;
  font-weight: bold;
}

.tox:not([dir="rtl"]) .tox-user__avatar svg {
  margin-right: 8px;
}

.tox:not([dir="rtl"]) .tox-user__avatar + .tox-user__name, .tox[dir="rtl"] .tox-user__avatar svg {
  margin-left: 8px;
}

.tox[dir="rtl"] .tox-user__avatar + .tox-user__name {
  margin-right: 8px;
}

.tox .tox-dialog-wrap {
  z-index: 1100;
  justify-content: center;
  align-items: center;
  display: flex;
  position: fixed;
  inset: 0;
}

.tox .tox-dialog-wrap__backdrop {
  z-index: 1;
  background-color: #ffffffbf;
  position: absolute;
  inset: 0;
}

.tox .tox-dialog-wrap__backdrop--opaque {
  background-color: #fff;
}

.tox .tox-dialog {
  max-height: 100%;
  max-width: 480px;
  width: 95vw;
  z-index: 2;
  background-color: #fff;
  border: 0 solid #eee;
  border-radius: 10px;
  flex-direction: column;
  display: flex;
  position: relative;
  overflow: hidden;
  box-shadow: 0 16px 16px -10px #222f3e26, 0 0 40px 1px #222f3e26;
}

@media only screen and (max-width: 767px) {
  body:not(.tox-force-desktop) .tox .tox-dialog {
    width: calc(100vw - 16px);
    align-self: flex-start;
    margin: 8px auto;
  }
}

.tox .tox-dialog-inline {
  z-index: 1100;
}

.tox .tox-dialog__header {
  color: #222f3e;
  background-color: #fff;
  border-bottom: none;
  justify-content: space-between;
  align-items: center;
  padding: 8px 16px 0;
  font-size: 16px;
  display: flex;
  position: relative;
}

.tox .tox-dialog__header .tox-button {
  z-index: 1;
}

.tox .tox-dialog__draghandle {
  cursor: grab;
  height: 100%;
  width: 100%;
  position: absolute;
  top: 0;
  left: 0;
}

.tox .tox-dialog__draghandle:active {
  cursor: grabbing;
}

.tox .tox-dialog__dismiss {
  margin-left: auto;
}

.tox .tox-dialog__title {
  text-transform: none;
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen-Sans, Ubuntu, Cantarell, Helvetica Neue, sans-serif;
  font-size: 20px;
  font-style: normal;
  font-weight: normal;
  line-height: 1.3;
}

.tox .tox-dialog__body {
  color: #222f3e;
  min-width: 0;
  text-align: left;
  text-transform: none;
  flex: 1;
  font-size: 16px;
  font-style: normal;
  font-weight: normal;
  line-height: 1.3;
  display: flex;
}

@media only screen and (max-width: 767px) {
  body:not(.tox-force-desktop) .tox .tox-dialog__body {
    flex-direction: column;
  }
}

.tox .tox-dialog__body-nav {
  flex-direction: column;
  align-items: flex-start;
  padding: 16px;
  display: flex;
}

@media only screen and (max-width: 767px) {
  body:not(.tox-force-desktop) .tox .tox-dialog__body-nav {
    -webkit-overflow-scrolling: touch;
    flex-direction: row;
    padding-bottom: 0;
    overflow-x: auto;
  }
}

.tox .tox-dialog__body-nav-item {
  color: #222f3eb3;
  white-space: nowrap;
  border-bottom: 2px solid #0000;
  margin-bottom: 8px;
  font-size: 14px;
  line-height: 1.3;
  text-decoration: none;
  display: inline-block;
}

.tox .tox-dialog__body-nav-item:focus {
  background-color: #006ce71a;
}

.tox .tox-dialog__body-nav-item--active {
  color: #006ce7;
  border-bottom: 2px solid #006ce7;
}

.tox .tox-dialog__body-content {
  box-sizing: border-box;
  max-height: 650px;
  -webkit-overflow-scrolling: touch;
  flex-direction: column;
  flex: 1;
  padding: 16px;
  display: flex;
  overflow: auto;
}

.tox .tox-dialog__body-content > * {
  margin-top: 16px;
  margin-bottom: 0;
}

.tox .tox-dialog__body-content > :first-child {
  margin-top: 0;
}

.tox .tox-dialog__body-content > :last-child {
  margin-bottom: 0;
}

.tox .tox-dialog__body-content > :only-child {
  margin-top: 0;
  margin-bottom: 0;
}

.tox .tox-dialog__body-content a {
  color: #006ce7;
  cursor: pointer;
  text-decoration: none;
}

.tox .tox-dialog__body-content a:hover, .tox .tox-dialog__body-content a:focus, .tox .tox-dialog__body-content a:active {
  color: #0054b4;
  text-decoration: none;
}

.tox .tox-dialog__body-content svg {
  fill: #222f3e;
}

.tox .tox-dialog__body-content ul {
  margin-bottom: 16px;
  margin-inline: 0;
  padding-inline-start: 2.5rem;
  list-style-type: disc;
  display: block;
}

.tox .tox-dialog__body-content .tox-form__group h1 {
  color: #222f3e;
  letter-spacing: normal;
  text-transform: none;
  margin-top: 2rem;
  margin-bottom: 16px;
  font-size: 20px;
  font-style: normal;
  font-weight: bold;
}

.tox .tox-dialog__body-content .tox-form__group h2 {
  color: #222f3e;
  letter-spacing: normal;
  text-transform: none;
  margin-top: 2rem;
  margin-bottom: 16px;
  font-size: 16px;
  font-style: normal;
  font-weight: bold;
}

.tox .tox-dialog__body-content .tox-form__group p {
  margin-bottom: 16px;
}

.tox .tox-dialog__body-content .tox-form__group h1:first-child, .tox .tox-dialog__body-content .tox-form__group h2:first-child, .tox .tox-dialog__body-content .tox-form__group p:first-child {
  margin-top: 0;
}

.tox .tox-dialog__body-content .tox-form__group h1:last-child, .tox .tox-dialog__body-content .tox-form__group h2:last-child, .tox .tox-dialog__body-content .tox-form__group p:last-child {
  margin-bottom: 0;
}

.tox .tox-dialog__body-content .tox-form__group h1:only-child, .tox .tox-dialog__body-content .tox-form__group h2:only-child, .tox .tox-dialog__body-content .tox-form__group p:only-child {
  margin-top: 0;
  margin-bottom: 0;
}

.tox .tox-dialog--width-lg {
  height: 650px;
  max-width: 1200px;
}

.tox .tox-dialog--width-md {
  max-width: 800px;
}

.tox .tox-dialog--width-md .tox-dialog__body-content {
  overflow: auto;
}

.tox .tox-dialog__body-content--centered {
  text-align: center;
}

.tox .tox-dialog__footer {
  background-color: #fff;
  border-top: none;
  justify-content: space-between;
  align-items: center;
  padding: 8px 16px;
  display: flex;
}

.tox .tox-dialog__footer-start, .tox .tox-dialog__footer-end {
  display: flex;
}

.tox .tox-dialog__busy-spinner {
  z-index: 3;
  background-color: #ffffffbf;
  justify-content: center;
  align-items: center;
  display: flex;
  position: absolute;
  inset: 0;
}

.tox .tox-dialog__table {
  border-collapse: collapse;
  width: 100%;
}

.tox .tox-dialog__table thead th {
  padding-bottom: 8px;
  font-weight: bold;
}

.tox .tox-dialog__table tbody tr {
  border-bottom: 1px solid #eee;
}

.tox .tox-dialog__table tbody tr:last-child {
  border-bottom: none;
}

.tox .tox-dialog__table td {
  padding-top: 8px;
  padding-bottom: 8px;
}

.tox .tox-dialog__popups {
  width: 100%;
  z-index: 1100;
  position: absolute;
}

.tox .tox-dialog__body-iframe {
  flex-direction: column;
  flex: 1;
  display: flex;
}

.tox .tox-dialog__body-iframe .tox-navobj {
  flex: 1;
  display: flex;
}

.tox .tox-dialog__body-iframe .tox-navobj :nth-child(2) {
  height: 100%;
  flex: 1;
}

.tox .tox-dialog-dock-fadeout {
  opacity: 0;
  visibility: hidden;
}

.tox .tox-dialog-dock-fadein {
  opacity: 1;
  visibility: visible;
}

.tox .tox-dialog-dock-transition {
  transition: visibility 0s linear .3s, opacity .3s;
}

.tox .tox-dialog-dock-transition.tox-dialog-dock-fadein {
  transition-delay: 0s;
}

@media only screen and (max-width: 767px) {
  body:not(.tox-force-desktop) .tox:not([dir="rtl"]) .tox-dialog__body-nav {
    margin-right: 0;
  }
}

@media only screen and (max-width: 767px) {
  body:not(.tox-force-desktop) .tox:not([dir="rtl"]) .tox-dialog__body-nav-item:not(:first-child) {
    margin-left: 8px;
  }
}

.tox:not([dir="rtl"]) .tox-dialog__footer .tox-dialog__footer-start > *, .tox:not([dir="rtl"]) .tox-dialog__footer .tox-dialog__footer-end > * {
  margin-left: 8px;
}

.tox[dir="rtl"] .tox-dialog__body {
  text-align: right;
}

@media only screen and (max-width: 767px) {
  body:not(.tox-force-desktop) .tox[dir="rtl"] .tox-dialog__body-nav {
    margin-left: 0;
  }
}

@media only screen and (max-width: 767px) {
  body:not(.tox-force-desktop) .tox[dir="rtl"] .tox-dialog__body-nav-item:not(:first-child) {
    margin-right: 8px;
  }
}

.tox[dir="rtl"] .tox-dialog__footer .tox-dialog__footer-start > *, .tox[dir="rtl"] .tox-dialog__footer .tox-dialog__footer-end > * {
  margin-right: 8px;
}

body.tox-dialog__disable-scroll {
  overflow: hidden;
}

.tox .tox-dropzone-container {
  flex: 1;
  display: flex;
}

.tox .tox-dropzone {
  box-sizing: border-box;
  min-height: 100px;
  background: #fff;
  border: 2px dashed #eee;
  flex-direction: column;
  flex-grow: 1;
  justify-content: center;
  align-items: center;
  padding: 10px;
  display: flex;
}

.tox .tox-dropzone p {
  color: #222f3eb3;
  margin: 0 0 16px;
}

.tox .tox-edit-area {
  flex: 1;
  display: flex;
  position: relative;
  overflow: hidden;
}

.tox .tox-edit-area__iframe {
  box-sizing: border-box;
  height: 100%;
  width: 100%;
  background-color: #fff;
  border: none;
  flex: 1;
  position: absolute;
}

.tox.tox-inline-edit-area {
  border: 1px dotted #eee;
}

.tox .tox-editor-container {
  flex-direction: column;
  flex: auto;
  display: flex;
  overflow: hidden;
}

.tox .tox-editor-header {
  z-index: 1;
}

.tox:not(.tox-tinymce-inline) .tox-editor-header {
  background-color: #fff;
  border-bottom: none;
  padding: 4px 0;
  transition: box-shadow .5s;
  box-shadow: 0 2px 2px -2px #222f3e1a, 0 8px 8px -4px #222f3e12;
}

.tox:not(.tox-tinymce-inline).tox-tinymce--toolbar-bottom .tox-editor-header {
  box-shadow: none;
  border-top: 1px solid #e3e3e3;
}

.tox:not(.tox-tinymce-inline).tox-tinymce--toolbar-sticky-on .tox-editor-header {
  background-color: #fff;
  padding: 4px 0;
  box-shadow: 0 2px 2px -2px #222f3e33, 0 8px 8px -4px #222f3e26;
}

.tox:not(.tox-tinymce-inline).tox-tinymce--toolbar-sticky-on.tox-tinymce--toolbar-bottom .tox-editor-header {
  box-shadow: 0 2px 2px -2px #222f3e33, 0 8px 8px -4px #222f3e26;
}

.tox-editor-dock-fadeout {
  opacity: 0;
  visibility: hidden;
}

.tox-editor-dock-fadein {
  opacity: 1;
  visibility: visible;
}

.tox-editor-dock-transition {
  transition: visibility 0s linear .25s, opacity .25s;
}

.tox-editor-dock-transition.tox-editor-dock-fadein {
  transition-delay: 0s;
}

.tox .tox-control-wrap {
  flex: 1;
  position: relative;
}

.tox .tox-control-wrap:not(.tox-control-wrap--status-invalid) .tox-control-wrap__status-icon-invalid, .tox .tox-control-wrap:not(.tox-control-wrap--status-unknown) .tox-control-wrap__status-icon-unknown, .tox .tox-control-wrap:not(.tox-control-wrap--status-valid) .tox-control-wrap__status-icon-valid {
  display: none;
}

.tox .tox-control-wrap svg {
  display: block;
}

.tox .tox-control-wrap__status-icon-wrap {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
}

.tox .tox-control-wrap__status-icon-invalid svg {
  fill: #c00;
}

.tox .tox-control-wrap__status-icon-unknown svg {
  fill: orange;
}

.tox .tox-control-wrap__status-icon-valid svg {
  fill: green;
}

.tox:not([dir="rtl"]) .tox-control-wrap--status-invalid .tox-textfield, .tox:not([dir="rtl"]) .tox-control-wrap--status-unknown .tox-textfield, .tox:not([dir="rtl"]) .tox-control-wrap--status-valid .tox-textfield {
  padding-right: 32px;
}

.tox:not([dir="rtl"]) .tox-control-wrap__status-icon-wrap {
  right: 4px;
}

.tox[dir="rtl"] .tox-control-wrap--status-invalid .tox-textfield, .tox[dir="rtl"] .tox-control-wrap--status-unknown .tox-textfield, .tox[dir="rtl"] .tox-control-wrap--status-valid .tox-textfield {
  padding-left: 32px;
}

.tox[dir="rtl"] .tox-control-wrap__status-icon-wrap {
  left: 4px;
}

.tox .tox-autocompleter {
  max-width: 25em;
}

.tox .tox-autocompleter .tox-menu {
  box-shadow: none;
  max-width: 25em;
  border-color: #eee;
}

.tox .tox-autocompleter .tox-autocompleter-highlight {
  font-weight: bold;
}

.tox .tox-color-input {
  z-index: 1;
  display: flex;
  position: relative;
}

.tox .tox-color-input .tox-textfield {
  z-index: -1;
}

.tox .tox-color-input span {
  box-shadow: none;
  box-sizing: border-box;
  height: 24px;
  width: 24px;
  border: 1px solid #222f3e33;
  border-radius: 6px;
  position: absolute;
  top: 6px;
}

.tox .tox-color-input span:hover:not([aria-disabled="true"]), .tox .tox-color-input span:focus:not([aria-disabled="true"]) {
  cursor: pointer;
  border-color: #006ce7;
}

.tox .tox-color-input span:before {
  box-sizing: border-box;
  content: "";
  height: 24px;
  width: 24px;
  z-index: -1;
  background-image: linear-gradient(45deg, #00000040 25%, #0000 25%), linear-gradient(-45deg, #00000040 25%, #0000 25%), linear-gradient(45deg, #0000 75%, #00000040 75%), linear-gradient(-45deg, #0000 75%, #00000040 75%);
  background-position: 0 0, 0 6px, 6px -6px, -6px 0;
  background-size: 12px 12px;
  border: 1px solid #fff;
  border-radius: 6px;
  position: absolute;
  top: -1px;
  left: -1px;
}

.tox .tox-color-input span[aria-disabled="true"] {
  cursor: not-allowed;
}

.tox:not([dir="rtl"]) .tox-color-input {
}

.tox:not([dir="rtl"]) .tox-color-input .tox-textfield {
  padding-left: 36px;
}

.tox:not([dir="rtl"]) .tox-color-input span {
  left: 6px;
}

.tox[dir="rtl"] .tox-color-input {
}

.tox[dir="rtl"] .tox-color-input .tox-textfield {
  padding-right: 36px;
}

.tox[dir="rtl"] .tox-color-input span {
  right: 6px;
}

.tox .tox-label, .tox .tox-toolbar-label {
  color: #222f3eb3;
  text-transform: none;
  white-space: nowrap;
  padding: 0 8px 0 0;
  font-size: 14px;
  font-style: normal;
  font-weight: normal;
  line-height: 1.3;
  display: block;
}

.tox .tox-toolbar-label {
  padding: 0 8px;
}

.tox[dir="rtl"] .tox-label {
  padding: 0 0 0 8px;
}

.tox .tox-form {
  flex-direction: column;
  flex: 1;
  display: flex;
}

.tox .tox-form__group {
  box-sizing: border-box;
  margin-bottom: 4px;
}

.tox .tox-form-group--maximize {
  flex: 1;
}

.tox .tox-form__group--error {
  color: #c00;
}

.tox .tox-form__group--collection {
  display: flex;
}

.tox .tox-form__grid {
  flex-flow: wrap;
  justify-content: space-between;
  display: flex;
}

.tox .tox-form__grid--2col > .tox-form__group {
  width: calc(50% - 4px);
}

.tox .tox-form__grid--3col > .tox-form__group {
  width: calc(33.3333% - 4px);
}

.tox .tox-form__grid--4col > .tox-form__group {
  width: calc(25% - 4px);
}

.tox .tox-form__controls-h-stack, .tox .tox-form__group--inline {
  align-items: center;
  display: flex;
}

.tox .tox-form__group--stretched {
  flex-direction: column;
  flex: 1;
  display: flex;
}

.tox .tox-form__group--stretched .tox-textarea {
  flex: 1;
}

.tox .tox-form__group--stretched .tox-navobj {
  flex: 1;
  display: flex;
}

.tox .tox-form__group--stretched .tox-navobj :nth-child(2) {
  height: 100%;
  flex: 1;
}

.tox:not([dir="rtl"]) .tox-form__controls-h-stack > :not(:first-child) {
  margin-left: 4px;
}

.tox[dir="rtl"] .tox-form__controls-h-stack > :not(:first-child) {
  margin-right: 4px;
}

.tox .tox-lock.tox-locked .tox-lock-icon__unlock, .tox .tox-lock:not(.tox-locked) .tox-lock-icon__lock {
  display: none;
}

.tox .tox-textfield, .tox .tox-toolbar-textfield, .tox .tox-listboxfield .tox-listbox--select, .tox .tox-textarea {
  appearance: none;
  box-shadow: none;
  box-sizing: border-box;
  color: #222f3e;
  min-height: 34px;
  resize: none;
  width: 100%;
  background-color: #fff;
  border: 1px solid #eee;
  border-radius: 6px;
  outline: none;
  margin: 0;
  padding: 5px 5.5px;
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen-Sans, Ubuntu, Cantarell, Helvetica Neue, sans-serif;
  font-size: 16px;
  line-height: 24px;
}

.tox .tox-textfield[disabled], .tox .tox-textarea[disabled] {
  color: #222f3ed9;
  cursor: not-allowed;
  background-color: #f2f2f2;
}

.tox .tox-textfield:focus, .tox .tox-listboxfield .tox-listbox--select:focus, .tox .tox-textarea:focus {
  background-color: #fff;
  border-color: #006ce7;
  outline: none;
  box-shadow: 0 0 0 2px #006ce740;
}

.tox .tox-toolbar-textfield {
  max-width: 250px;
  border-width: 0;
  margin-top: 2px;
  margin-bottom: 3px;
}

.tox .tox-naked-btn {
  box-shadow: unset;
  color: #006ce7;
  cursor: pointer;
  background-color: #0000;
  border: none;
  margin: 0;
  padding: 0;
  display: block;
}

.tox .tox-naked-btn svg {
  fill: #222f3e;
  display: block;
}

.tox:not([dir="rtl"]) .tox-toolbar-textfield + * {
  margin-left: 4px;
}

.tox[dir="rtl"] .tox-toolbar-textfield + * {
  margin-right: 4px;
}

.tox .tox-listboxfield {
  cursor: pointer;
  position: relative;
}

.tox .tox-listboxfield .tox-listbox--select[disabled] {
  color: #222f3ed9;
  cursor: not-allowed;
  background-color: #f2f2f2;
}

.tox .tox-listbox__select-label {
  cursor: default;
  flex: 1;
  margin: 0 4px;
}

.tox .tox-listbox__select-chevron {
  width: 16px;
  justify-content: center;
  align-items: center;
  display: flex;
}

.tox .tox-listbox__select-chevron svg {
  fill: #222f3e;
}

.tox .tox-listboxfield .tox-listbox--select {
  align-items: center;
  display: flex;
}

.tox:not([dir="rtl"]) .tox-listboxfield svg {
  right: 8px;
}

.tox[dir="rtl"] .tox-listboxfield svg {
  left: 8px;
}

.tox .tox-selectfield {
  cursor: pointer;
  position: relative;
}

.tox .tox-selectfield select {
  appearance: none;
  box-shadow: none;
  box-sizing: border-box;
  color: #222f3e;
  min-height: 34px;
  resize: none;
  width: 100%;
  background-color: #fff;
  border: 1px solid #eee;
  border-radius: 6px;
  outline: none;
  margin: 0;
  padding: 5px 5.5px;
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen-Sans, Ubuntu, Cantarell, Helvetica Neue, sans-serif;
  font-size: 16px;
  line-height: 24px;
}

.tox .tox-selectfield select[disabled] {
  color: #222f3ed9;
  cursor: not-allowed;
  background-color: #f2f2f2;
}

.tox .tox-selectfield select::-ms-expand {
  display: none;
}

.tox .tox-selectfield select:focus {
  background-color: #fff;
  border-color: #006ce7;
  outline: none;
  box-shadow: 0 0 0 2px #006ce740;
}

.tox .tox-selectfield svg {
  pointer-events: none;
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
}

.tox:not([dir="rtl"]) .tox-selectfield select[size="0"], .tox:not([dir="rtl"]) .tox-selectfield select[size="1"] {
  padding-right: 24px;
}

.tox:not([dir="rtl"]) .tox-selectfield svg {
  right: 8px;
}

.tox[dir="rtl"] .tox-selectfield select[size="0"], .tox[dir="rtl"] .tox-selectfield select[size="1"] {
  padding-left: 24px;
}

.tox[dir="rtl"] .tox-selectfield svg {
  left: 8px;
}

.tox .tox-textarea {
  appearance: textarea;
  white-space: pre-wrap;
}

.tox-fullscreen {
  height: 100%;
  overscroll-behavior: none;
  touch-action: pinch-zoom;
  width: 100%;
  border: none;
  margin: 0;
  padding: 0;
  overflow: hidden;
}

.tox.tox-tinymce.tox-fullscreen .tox-statusbar__resize-handle {
  display: none;
}

.tox.tox-tinymce.tox-fullscreen, .tox-shadowhost.tox-fullscreen {
  z-index: 1200;
  position: fixed;
  top: 0;
  left: 0;
}

.tox.tox-tinymce.tox-fullscreen {
  background-color: #0000;
}

.tox-fullscreen .tox.tox-tinymce-aux, .tox-fullscreen ~ .tox.tox-tinymce-aux {
  z-index: 1201;
}

.tox .tox-help__more-link {
  margin-top: 1em;
  list-style: none;
}

.tox .tox-imagepreview {
  height: 380px;
  width: 100%;
  background-color: #666;
  position: relative;
  overflow: hidden;
}

.tox .tox-imagepreview.tox-imagepreview__loaded {
  overflow: auto;
}

.tox .tox-imagepreview__container {
  display: flex;
  position: absolute;
  top: 100vw;
  left: 100vw;
}

.tox .tox-imagepreview__image {
  background: url("data:image/gif;base64,R0lGODdhDAAMAIABAMzMzP///ywAAAAADAAMAAACFoQfqYeabNyDMkBQb81Uat85nxguUAEAOw==");
}

.tox .tox-image-tools .tox-spacer {
  flex: 1;
}

.tox .tox-image-tools .tox-bar {
  height: 60px;
  justify-content: center;
  align-items: center;
  display: flex;
}

.tox .tox-image-tools .tox-imagepreview, .tox .tox-image-tools .tox-imagepreview + .tox-bar {
  margin-top: 8px;
}

.tox .tox-image-tools .tox-croprect-block {
  filter: alpha(opacity= 50);
  opacity: .5;
  zoom: 1;
  background: #000;
  position: absolute;
}

.tox .tox-image-tools .tox-croprect-handle {
  height: 20px;
  width: 20px;
  border: 2px solid #fff;
  position: absolute;
  top: 0;
  left: 0;
}

.tox .tox-image-tools .tox-croprect-handle-move {
  cursor: move;
  border: none;
  position: absolute;
}

.tox .tox-image-tools .tox-croprect-handle-nw {
  cursor: nw-resize;
  border-width: 2px 0 0 2px;
  margin: -2px 0 0 -2px;
  top: 100px;
  left: 100px;
}

.tox .tox-image-tools .tox-croprect-handle-ne {
  cursor: ne-resize;
  border-width: 2px 2px 0 0;
  margin: -2px 0 0 -20px;
  top: 100px;
  left: 200px;
}

.tox .tox-image-tools .tox-croprect-handle-sw {
  cursor: sw-resize;
  border-width: 0 0 2px 2px;
  margin: -20px 2px 0 -2px;
  top: 200px;
  left: 100px;
}

.tox .tox-image-tools .tox-croprect-handle-se {
  cursor: se-resize;
  border-width: 0 2px 2px 0;
  margin: -20px 0 0 -20px;
  top: 200px;
  left: 200px;
}

.tox .tox-insert-table-picker {
  width: 170px;
  flex-wrap: wrap;
  display: flex;
}

.tox .tox-insert-table-picker > div {
  box-sizing: border-box;
  height: 17px;
  width: 17px;
  border: 1px solid #eee;
  border-width: 0 1px 1px 0;
}

.tox .tox-collection--list .tox-collection__group .tox-insert-table-picker {
  margin: -4px;
}

.tox .tox-insert-table-picker .tox-insert-table-picker__selected {
  background-color: #006ce780;
  border-color: #006ce780;
}

.tox .tox-insert-table-picker__label {
  color: #222f3eb3;
  text-align: center;
  width: 100%;
  padding: 4px;
  font-size: 14px;
  display: block;
}

.tox:not([dir="rtl"]) {
}

.tox:not([dir="rtl"]) .tox-insert-table-picker > div:nth-child(10n) {
  border-right: none;
}

.tox[dir="rtl"] {
}

.tox[dir="rtl"] .tox-insert-table-picker > div:nth-child(10n+1) {
  border-right: none;
}

.tox {
}

.tox .tox-menu {
  vertical-align: top;
  z-index: 1150;
  background-color: #fff;
  border: 1px solid #0000;
  border-radius: 6px;
  display: inline-block;
  overflow: hidden;
  box-shadow: 0 0 2px #222f3e33, 0 4px 8px #222f3e26;
}

.tox .tox-menu.tox-collection.tox-collection--list {
  padding: 0 4px;
}

.tox .tox-menu.tox-collection.tox-collection--toolbar, .tox .tox-menu.tox-collection.tox-collection--grid {
  padding: 8px;
}

.tox .tox-menu__label h1, .tox .tox-menu__label h2, .tox .tox-menu__label h3, .tox .tox-menu__label h4, .tox .tox-menu__label h5, .tox .tox-menu__label h6, .tox .tox-menu__label p, .tox .tox-menu__label blockquote, .tox .tox-menu__label code {
  margin: 0;
}

.tox .tox-menubar {
  background: #fff url("data:image/svg+xml;charset=utf8,%3Csvg height='39px' viewBox='0 0 40 39px' width='40' xmlns='http://www.w3.org/2000/svg'%3E%3Crect x='0' y='38px' width='100' height='1' fill='transparent'/%3E%3C/svg%3E") 0 0;
  flex-wrap: wrap;
  flex: none;
  padding: 0 11px 0 12px;
  display: flex;
}

.tox.tox-tinymce:not(.tox-tinymce-inline) .tox-editor-header:not(:first-child) .tox-menubar {
  border-top: 1px solid #0000;
}

.tox .tox-mbtn {
  box-shadow: none;
  color: #222f3e;
  height: 28px;
  text-transform: none;
  width: auto;
  background: none;
  border: none;
  border-radius: 3px;
  outline: none;
  flex: none;
  justify-content: center;
  align-items: center;
  margin: 5px 1px 6px 0;
  padding: 0 4px;
  font-size: 14px;
  font-style: normal;
  font-weight: normal;
  display: flex;
  overflow: hidden;
}

.tox .tox-mbtn[disabled] {
  box-shadow: none;
  color: #222f3e80;
  cursor: not-allowed;
  background-color: #0000;
  border: none;
}

.tox .tox-mbtn:focus:not(:disabled) {
  box-shadow: none;
  color: #222f3e;
  background: #cce2fa;
  border: none;
}

.tox .tox-mbtn--active {
  box-shadow: none;
  color: #222f3e;
  background: #a6ccf7;
  border: none;
}

.tox .tox-mbtn:hover:not(:disabled):not(.tox-mbtn--active) {
  box-shadow: none;
  color: #222f3e;
  background: #cce2fa;
  border: none;
}

.tox .tox-mbtn__select-label {
  cursor: default;
  margin: 0 4px;
  font-weight: normal;
}

.tox .tox-mbtn[disabled] .tox-mbtn__select-label {
  cursor: not-allowed;
}

.tox .tox-mbtn__select-chevron {
  width: 16px;
  justify-content: center;
  align-items: center;
  display: none;
}

.tox .tox-notification {
  box-shadow: none;
  box-sizing: border-box;
  opacity: 0;
  border-style: solid;
  border-width: 1px;
  border-radius: 6px;
  grid-template-columns: minmax(40px, 1fr) auto minmax(40px, 1fr);
  margin-top: 4px;
  padding: 4px;
  font-size: 14px;
  font-weight: normal;
  transition: transform .1s ease-in, opacity .15s ease-in;
  display: grid;
}

.tox .tox-notification p {
  font-size: 14px;
  font-weight: normal;
}

.tox .tox-notification a {
  cursor: pointer;
  text-decoration: underline;
}

.tox .tox-notification--in {
  opacity: 1;
}

.tox .tox-notification--success {
  color: #222f3e;
  background-color: #e4eeda;
  border-color: #d7e6c8;
}

.tox .tox-notification--success p {
  color: #222f3e;
}

.tox .tox-notification--success a {
  color: #517342;
}

.tox .tox-notification--success svg {
  fill: #222f3e;
}

.tox .tox-notification--error {
  color: #222f3e;
  background-color: #f5cccc;
  border-color: #f0b3b3;
}

.tox .tox-notification--error p {
  color: #222f3e;
}

.tox .tox-notification--error a {
  color: #77181f;
}

.tox .tox-notification--error svg {
  fill: #222f3e;
}

.tox .tox-notification--warn, .tox .tox-notification--warning {
  color: #222f3e;
  background-color: #fff5cc;
  border-color: #fff0b3;
}

.tox .tox-notification--warn p, .tox .tox-notification--warning p {
  color: #222f3e;
}

.tox .tox-notification--warn a, .tox .tox-notification--warning a {
  color: #7a6e25;
}

.tox .tox-notification--warn svg, .tox .tox-notification--warning svg {
  fill: #222f3e;
}

.tox .tox-notification--info {
  color: #222f3e;
  background-color: #d6e7fb;
  border-color: #c1dbf9;
}

.tox .tox-notification--info p {
  color: #222f3e;
}

.tox .tox-notification--info a {
  color: #2a64a6;
}

.tox .tox-notification--info svg {
  fill: #222f3e;
}

.tox .tox-notification__body {
  color: #222f3e;
  text-align: center;
  white-space: normal;
  word-break: break-all;
  word-break: break-word;
  grid-area: 1 / 2 / 2 / 3;
  align-self: center;
  font-size: 14px;
}

.tox .tox-notification__body > * {
  margin: 0;
}

.tox .tox-notification__body > * + * {
  margin-top: 1rem;
}

.tox .tox-notification__icon {
  grid-area: 1 / 1 / 2 / 2;
  place-self: center end;
}

.tox .tox-notification__icon svg {
  display: block;
}

.tox .tox-notification__dismiss {
  grid-area: 1 / 3 / 2 / 4;
  place-self: start end;
}

.tox .tox-notification .tox-progress-bar {
  grid-area: 2 / 1 / 3 / 4;
  justify-self: center;
}

.tox .tox-pop {
  display: inline-block;
  position: relative;
}

.tox .tox-pop--resizing {
  transition: width .1s;
}

.tox .tox-pop--resizing .tox-toolbar, .tox .tox-pop--resizing .tox-toolbar__group {
  flex-wrap: nowrap;
}

.tox .tox-pop--transition {
  transition: left .15s, right .15s, top .15s, bottom .15s;
}

.tox .tox-pop--transition:before, .tox .tox-pop--transition:after {
  transition: all .15s, visibility, opacity 75ms 75ms;
}

.tox .tox-pop__dialog {
  min-width: 0;
  background-color: #fff;
  border: 1px solid #eee;
  border-radius: 6px;
  overflow: hidden;
  box-shadow: 0 0 2px #222f3e33, 0 4px 8px #222f3e26;
}

.tox .tox-pop__dialog > :not(.tox-toolbar) {
  margin: 4px 4px 4px 8px;
}

.tox .tox-pop__dialog .tox-toolbar {
  background-color: #0000;
  margin-bottom: -1px;
}

.tox .tox-pop:before, .tox .tox-pop:after {
  content: "";
  height: 0;
  opacity: 1;
  width: 0;
  border-style: solid;
  display: block;
  position: absolute;
}

.tox .tox-pop.tox-pop--inset:before, .tox .tox-pop.tox-pop--inset:after {
  opacity: 0;
  transition: all 0s .15s, visibility, opacity 75ms;
}

.tox .tox-pop.tox-pop--bottom:before, .tox .tox-pop.tox-pop--bottom:after {
  top: 100%;
  left: 50%;
}

.tox .tox-pop.tox-pop--bottom:after {
  border-width: 8px;
  border-color: #fff #0000 #0000;
  margin-top: -1px;
  margin-left: -8px;
}

.tox .tox-pop.tox-pop--bottom:before {
  border-width: 9px;
  border-color: #eee #0000 #0000;
  margin-left: -9px;
}

.tox .tox-pop.tox-pop--top:before, .tox .tox-pop.tox-pop--top:after {
  top: 0;
  left: 50%;
  transform: translateY(-100%);
}

.tox .tox-pop.tox-pop--top:after {
  border-width: 8px;
  border-color: #0000 #0000 #fff;
  margin-top: 1px;
  margin-left: -8px;
}

.tox .tox-pop.tox-pop--top:before {
  border-width: 9px;
  border-color: #0000 #0000 #eee;
  margin-left: -9px;
}

.tox .tox-pop.tox-pop--left:before, .tox .tox-pop.tox-pop--left:after {
  top: calc(50% - 1px);
  left: 0;
  transform: translateY(-50%);
}

.tox .tox-pop.tox-pop--left:after {
  border-width: 8px;
  border-color: #0000 #fff #0000 #0000;
  margin-left: -15px;
}

.tox .tox-pop.tox-pop--left:before {
  border-width: 10px;
  border-color: #0000 #eee #0000 #0000;
  margin-left: -19px;
}

.tox .tox-pop.tox-pop--right:before, .tox .tox-pop.tox-pop--right:after {
  top: calc(50% + 1px);
  left: 100%;
  transform: translateY(-50%);
}

.tox .tox-pop.tox-pop--right:after {
  border-width: 8px;
  border-color: #0000 #0000 #0000 #fff;
  margin-left: -1px;
}

.tox .tox-pop.tox-pop--right:before {
  border-width: 10px;
  border-color: #0000 #0000 #0000 #eee;
  margin-left: -1px;
}

.tox .tox-pop.tox-pop--align-left:before, .tox .tox-pop.tox-pop--align-left:after {
  left: 20px;
}

.tox .tox-pop.tox-pop--align-right:before, .tox .tox-pop.tox-pop--align-right:after {
  left: calc(100% - 20px);
}

.tox .tox-sidebar-wrap {
  min-height: 0;
  flex-direction: row;
  flex-grow: 1;
  display: flex;
}

.tox .tox-sidebar {
  background-color: #fff;
  flex-direction: row;
  justify-content: flex-end;
  display: flex;
}

.tox .tox-sidebar__slider {
  display: flex;
  overflow: hidden;
}

.tox .tox-sidebar__pane-container, .tox .tox-sidebar__pane {
  display: flex;
}

.tox .tox-sidebar--sliding-closed {
  opacity: 0;
}

.tox .tox-sidebar--sliding-open {
  opacity: 1;
}

.tox .tox-sidebar--sliding-growing, .tox .tox-sidebar--sliding-shrinking {
  transition: width .5s, opacity .5s;
}

.tox .tox-selector {
  box-sizing: border-box;
  height: 10px;
  width: 10px;
  background-color: #4099ff;
  border: 1px solid #4099ff;
  display: inline-block;
  position: absolute;
}

.tox.tox-platform-touch .tox-selector {
  height: 12px;
  width: 12px;
}

.tox .tox-slider {
  height: 24px;
  flex: 1;
  justify-content: center;
  align-items: center;
  display: flex;
  position: relative;
}

.tox .tox-slider__rail {
  height: 10px;
  min-width: 120px;
  width: 100%;
  background-color: #0000;
  border: 1px solid #eee;
  border-radius: 6px;
}

.tox .tox-slider__handle {
  box-shadow: none;
  height: 24px;
  width: 14px;
  background-color: #006ce7;
  border: 2px solid #0054b4;
  border-radius: 6px;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translateX(-50%)translateY(-50%);
}

.tox .tox-form__controls-h-stack > .tox-slider:not(:first-of-type) {
  margin-inline-start: 8px;
}

.tox .tox-form__controls-h-stack > .tox-form__group + .tox-slider, .tox .tox-form__controls-h-stack > .tox-slider + .tox-form__group {
  margin-inline-start: 32px;
}

.tox .tox-source-code {
  overflow: auto;
}

.tox .tox-spinner {
  display: flex;
}

.tox .tox-spinner > div {
  height: 8px;
  width: 8px;
  background-color: #222f3eb3;
  border-radius: 100%;
  animation: tam-bouncing-dots 1.5s ease-in-out infinite both;
}

.tox .tox-spinner > div:nth-child(1) {
  animation-delay: -.32s;
}

.tox .tox-spinner > div:nth-child(2) {
  animation-delay: -.16s;
}

@keyframes tam-bouncing-dots {
  0%, 80%, 100% {
    transform: scale(0);
  }

  40% {
    transform: scale(1);
  }
}

.tox:not([dir="rtl"]) .tox-spinner > div:not(:first-child) {
  margin-left: 4px;
}

.tox[dir="rtl"] .tox-spinner > div:not(:first-child) {
  margin-right: 4px;
}

.tox .tox-statusbar {
  color: #222f3eb3;
  height: 25px;
  text-transform: none;
  background-color: #fff;
  border-top: 1px solid #e3e3e3;
  flex: none;
  align-items: center;
  padding: 0 8px;
  font-size: 14px;
  font-weight: normal;
  display: flex;
  position: relative;
  overflow: hidden;
}

.tox .tox-statusbar__text-container {
  flex: auto;
  justify-content: flex-end;
  display: flex;
  overflow: hidden;
}

.tox .tox-statusbar__path {
  text-overflow: ellipsis;
  white-space: nowrap;
  flex: auto;
  margin-right: auto;
  display: flex;
  overflow: hidden;
}

.tox .tox-statusbar__path > * {
  white-space: nowrap;
  display: inline;
}

.tox .tox-statusbar__wordcount {
  flex: none;
  margin-left: 1ch;
}

.tox .tox-statusbar a, .tox .tox-statusbar__path-item, .tox .tox-statusbar__wordcount {
  color: #222f3eb3;
  text-decoration: none;
}

.tox .tox-statusbar a:hover:not(:disabled):not([aria-disabled="true"]), .tox .tox-statusbar__path-item:hover:not(:disabled):not([aria-disabled="true"]), .tox .tox-statusbar__wordcount:hover:not(:disabled):not([aria-disabled="true"]), .tox .tox-statusbar a:focus:not(:disabled):not([aria-disabled="true"]), .tox .tox-statusbar__path-item:focus:not(:disabled):not([aria-disabled="true"]), .tox .tox-statusbar__wordcount:focus:not(:disabled):not([aria-disabled="true"]) {
  color: #222f3e;
  cursor: pointer;
}

.tox .tox-statusbar__branding svg {
  fill: #222f3ecc;
  height: 1.14em;
  vertical-align: -.28em;
  width: 3.6em;
}

.tox .tox-statusbar__branding a:hover:not(:disabled):not([aria-disabled="true"]) svg, .tox .tox-statusbar__branding a:focus:not(:disabled):not([aria-disabled="true"]) svg {
  fill: #222f3e;
}

.tox .tox-statusbar__resize-handle {
  cursor: nwse-resize;
  flex: none;
  justify-content: flex-end;
  align-self: stretch;
  align-items: flex-end;
  margin-left: auto;
  margin-right: -8px;
  padding-bottom: 3px;
  padding-left: 1ch;
  padding-right: 3px;
  display: flex;
}

.tox .tox-statusbar__resize-handle svg {
  fill: #222f3e80;
  display: block;
}

.tox .tox-statusbar__resize-handle:focus svg {
  background-color: #dee0e2;
  border-radius: 1px 1px 5px;
  box-shadow: 0 0 0 2px #dee0e2;
}

.tox:not([dir="rtl"]) .tox-statusbar__path > * {
  margin-right: 4px;
}

.tox:not([dir="rtl"]) .tox-statusbar__branding {
  margin-left: 2ch;
}

.tox[dir="rtl"] .tox-statusbar {
  flex-direction: row-reverse;
}

.tox[dir="rtl"] .tox-statusbar__path > * {
  margin-left: 4px;
}

.tox .tox-throbber {
  z-index: 1299;
}

.tox .tox-throbber__busy-spinner {
  background-color: #fff9;
  justify-content: center;
  align-items: center;
  display: flex;
  position: absolute;
  inset: 0;
}

.tox .tox-tbtn {
  box-shadow: none;
  color: #222f3e;
  height: 28px;
  text-transform: none;
  width: 34px;
  background: none;
  border: none;
  border-radius: 3px;
  outline: none;
  flex: none;
  justify-content: center;
  align-items: center;
  margin: 6px 1px 5px 0;
  padding: 0;
  font-size: 14px;
  font-style: normal;
  font-weight: normal;
  display: flex;
  overflow: hidden;
}

.tox .tox-tbtn svg {
  fill: #222f3e;
  display: block;
}

.tox .tox-tbtn.tox-tbtn-more {
  width: inherit;
  padding-left: 5px;
  padding-right: 5px;
}

.tox .tox-tbtn:focus {
  box-shadow: none;
  background: #cce2fa;
  border: none;
}

.tox .tox-tbtn:hover {
  box-shadow: none;
  color: #222f3e;
  background: #cce2fa;
  border: none;
}

.tox .tox-tbtn:hover svg {
  fill: #222f3e;
}

.tox .tox-tbtn:active {
  box-shadow: none;
  color: #222f3e;
  background: #a6ccf7;
  border: none;
}

.tox .tox-tbtn:active svg {
  fill: #222f3e;
}

.tox .tox-tbtn--disabled, .tox .tox-tbtn--disabled:hover, .tox .tox-tbtn:disabled, .tox .tox-tbtn:disabled:hover {
  box-shadow: none;
  color: #222f3e80;
  cursor: not-allowed;
  background: none;
  border: none;
}

.tox .tox-tbtn--disabled svg, .tox .tox-tbtn--disabled:hover svg, .tox .tox-tbtn:disabled svg, .tox .tox-tbtn:disabled:hover svg {
  fill: #222f3e80;
}

.tox .tox-tbtn--enabled, .tox .tox-tbtn--enabled:hover {
  box-shadow: none;
  color: #222f3e;
  background: #a6ccf7;
  border: none;
}

.tox .tox-tbtn--enabled > *, .tox .tox-tbtn--enabled:hover > * {
  transform: none;
}

.tox .tox-tbtn--enabled svg, .tox .tox-tbtn--enabled:hover svg {
  fill: #222f3e;
}

.tox .tox-tbtn:focus:not(.tox-tbtn--disabled) {
  color: #222f3e;
}

.tox .tox-tbtn:focus:not(.tox-tbtn--disabled) svg {
  fill: #222f3e;
}

.tox .tox-tbtn:active > * {
  transform: none;
}

.tox .tox-tbtn--md {
  height: 42px;
  width: 51px;
}

.tox .tox-tbtn--lg {
  height: 56px;
  width: 68px;
  flex-direction: column;
}

.tox .tox-tbtn--return {
  height: unset;
  width: 16px;
  align-self: stretch;
}

.tox .tox-tbtn--labeled {
  width: unset;
  padding: 0 4px;
}

.tox .tox-tbtn__vlabel {
  letter-spacing: -.025em;
  white-space: nowrap;
  margin-bottom: 4px;
  font-size: 10px;
  font-weight: normal;
  display: block;
}

.tox .tox-tbtn--select {
  width: auto;
  margin: 6px 1px 5px 0;
  padding: 0 4px;
}

.tox .tox-tbtn__select-label {
  cursor: default;
  margin: 0 4px;
  font-weight: normal;
}

.tox .tox-tbtn__select-chevron {
  width: 16px;
  justify-content: center;
  align-items: center;
  display: flex;
}

.tox .tox-tbtn__select-chevron svg {
  fill: #222f3e80;
}

.tox .tox-tbtn--bespoke .tox-tbtn__select-label {
  text-overflow: ellipsis;
  white-space: nowrap;
  width: 7em;
  overflow: hidden;
}

.tox .tox-split-button {
  box-sizing: border-box;
  border: none;
  border-radius: 3px;
  margin: 6px 1px 5px 0;
  display: flex;
  overflow: hidden;
}

.tox .tox-split-button:hover {
  box-shadow: inset 0 0 0 1px #cce2fa;
}

.tox .tox-split-button:focus {
  box-shadow: none;
  color: #222f3e;
  background: #cce2fa;
}

.tox .tox-split-button > * {
  border-radius: 0;
}

.tox .tox-split-button__chevron {
  width: 16px;
}

.tox .tox-split-button__chevron svg {
  fill: #222f3e80;
}

.tox .tox-split-button .tox-tbtn {
  margin: 0;
}

.tox.tox-platform-touch .tox-split-button .tox-tbtn:first-child {
  width: 30px;
}

.tox.tox-platform-touch .tox-split-button__chevron {
  width: 20px;
}

.tox .tox-split-button.tox-tbtn--disabled:hover, .tox .tox-split-button.tox-tbtn--disabled:focus, .tox .tox-split-button.tox-tbtn--disabled .tox-tbtn:hover, .tox .tox-split-button.tox-tbtn--disabled .tox-tbtn:focus {
  box-shadow: none;
  color: #222f3e80;
  background: none;
}

.tox .tox-toolbar-overlord {
  background-color: #fff;
}

.tox .tox-toolbar, .tox .tox-toolbar__primary, .tox .tox-toolbar__overflow {
  background-color: #fff;
  background-image: repeating-linear-gradient(#e3e3e3 0 1px, #0000 1px 39px);
  background-position: 50% 40px;
  background-repeat: no-repeat;
  background-size: calc(100% - 22px) calc(100% - 41px);
  flex-wrap: wrap;
  flex: none;
  padding: 0;
  display: flex;
  transform: perspective(1px);
}

.tox .tox-toolbar-overlord > .tox-toolbar, .tox .tox-toolbar-overlord > .tox-toolbar__primary, .tox .tox-toolbar-overlord > .tox-toolbar__overflow {
  background-position: 50% 0;
  background-size: calc(100% - 22px) 100%;
}

.tox .tox-toolbar__overflow.tox-toolbar__overflow--closed {
  height: 0;
  opacity: 0;
  visibility: hidden;
  padding-top: 0;
  padding-bottom: 0;
}

.tox .tox-toolbar__overflow--growing {
  transition: height .3s, opacity .2s linear .1s;
}

.tox .tox-toolbar__overflow--shrinking {
  transition: opacity .3s, height .2s linear .1s, visibility 0s linear .3s;
}

.tox .tox-menubar + .tox-toolbar, .tox .tox-menubar + .tox-toolbar-overlord {
  border-top: 1px solid #0000;
  margin-top: 0;
  padding-top: 1px;
  padding-bottom: 1px;
}

.tox .tox-toolbar--scrolling {
  flex-wrap: nowrap;
  overflow-x: auto;
}

.tox .tox-pop .tox-toolbar {
  border-width: 0;
}

.tox .tox-toolbar--no-divider {
  background-image: none;
}

.tox .tox-toolbar-overlord .tox-toolbar:not(.tox-toolbar--scrolling):first-child, .tox .tox-toolbar-overlord .tox-toolbar__primary {
  background-position: 50% 39px;
}

.tox .tox-editor-header > .tox-toolbar--scrolling, .tox .tox-toolbar-overlord .tox-toolbar--scrolling:first-child {
  background-image: none;
}

.tox.tox-tinymce-aux .tox-toolbar__overflow {
  background-color: #fff;
  background-position: 50% 43px;
  background-size: calc(100% - 16px) calc(100% - 51px);
  border: none;
  border-radius: 6px;
  padding: 4px 0;
  box-shadow: 0 0 2px #222f3e33, 0 4px 8px #222f3e26;
}

.tox-pop .tox-pop__dialog {
}

.tox-pop .tox-pop__dialog .tox-toolbar {
  background-position: 50% 43px;
  background-size: calc(100% - 22px) calc(100% - 51px);
  padding: 4px 0;
}

.tox .tox-toolbar__group {
  flex-wrap: wrap;
  align-items: center;
  margin: 0;
  padding: 0 11px 0 12px;
  display: flex;
}

.tox .tox-toolbar__group--pull-right {
  margin-left: auto;
}

.tox .tox-toolbar--scrolling .tox-toolbar__group {
  flex-wrap: nowrap;
  flex-shrink: 0;
}

.tox:not([dir="rtl"]) .tox-toolbar__group:not(:last-of-type) {
  border-right: 1px solid #0000;
}

.tox[dir="rtl"] .tox-toolbar__group:not(:last-of-type) {
  border-left: 1px solid #0000;
}

.tox .tox-tooltip {
  padding: 8px;
  display: inline-block;
  position: relative;
}

.tox .tox-tooltip__body {
  color: #ffffffbf;
  text-transform: none;
  background-color: #222f3e;
  border-radius: 6px;
  padding: 4px 8px;
  font-size: 14px;
  font-style: normal;
  font-weight: normal;
  box-shadow: 0 2px 4px #222f3e4d;
}

.tox .tox-tooltip__arrow {
  position: absolute;
}

.tox .tox-tooltip--down .tox-tooltip__arrow {
  border-top: 8px solid #222f3e;
  border-left: 8px solid #0000;
  border-right: 8px solid #0000;
  position: absolute;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
}

.tox .tox-tooltip--up .tox-tooltip__arrow {
  border-bottom: 8px solid #222f3e;
  border-left: 8px solid #0000;
  border-right: 8px solid #0000;
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
}

.tox .tox-tooltip--right .tox-tooltip__arrow {
  border-top: 8px solid #0000;
  border-bottom: 8px solid #0000;
  border-left: 8px solid #222f3e;
  position: absolute;
  top: 50%;
  right: 0;
  transform: translateY(-50%);
}

.tox .tox-tooltip--left .tox-tooltip__arrow {
  border-top: 8px solid #0000;
  border-bottom: 8px solid #0000;
  border-right: 8px solid #222f3e;
  position: absolute;
  top: 50%;
  left: 0;
  transform: translateY(-50%);
}

.tox .tox-well {
  width: 100%;
  border: 1px solid #eee;
  border-radius: 6px;
  padding: 8px;
}

.tox .tox-well > :first-child {
  margin-top: 0;
}

.tox .tox-well > :last-child {
  margin-bottom: 0;
}

.tox .tox-well > :only-child {
  margin: 0;
}

.tox .tox-custom-editor {
  border: 1px solid #eee;
  border-radius: 6px;
  flex: 1;
  display: flex;
  position: relative;
}

.tox {
}

.tox .tox-dialog-loading:before {
  content: "";
  height: 100%;
  width: 100%;
  z-index: 1000;
  background-color: #00000080;
  position: absolute;
}

.tox .tox-tab {
  cursor: pointer;
}

.tox .tox-dialog__content-js, .tox .tox-dialog__body-content .tox-collection {
  flex: 1;
  display: flex;
}



</style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous">
</script>
  <script referrerpolicy="origin">
/**
 * TinyMCE version 6.0.1 (2022-03-23)
 */ !function() {
    var e1 = function(e) {
        if (null === e) return "null";
        if (void 0 === e) return "undefined";
        var t = typeof e;
        return "object" === t && (Array.prototype.isPrototypeOf(e) || e.constructor && "Array" === e.constructor.name) ? "array" : "object" === t && (String.prototype.isPrototypeOf(e) || e.constructor && "String" === e.constructor.name) ? "string" : t;
    }, t1 = function(e) {
        return {
            eq: e
        };
    }, n1 = t1(function(e, t) {
        return e === t;
    }), o1 = function(e) {
        return t1(function(t, n) {
            if (t.length !== n.length) return !1;
            for(var o = t.length, r = 0; r < o; r++)if (!e.eq(t[r], n[r])) return !1;
            return !0;
        });
    }, r1 = function(e2) {
        return t1(function(r, s) {
            var a = Object.keys(r), i = Object.keys(s);
            if (!(function(e3, n2) {
                return function(e, n) {
                    return t1(function(t, o) {
                        return e.eq(n(t), n(o));
                    });
                }(o1(e3), function(e4) {
                    return function(e, t) {
                        return Array.prototype.slice.call(e).sort(t);
                    }(e4, n2);
                });
            })(n1).eq(a, i)) return !1;
            for(var l = a.length, d = 0; d < l; d++){
                var c = a[d];
                if (!e2.eq(r[c], s[c])) return !1;
            }
            return !0;
        });
    }, s1 = t1(function(t, n) {
        if (t === n) return !0;
        var a = e1(t);
        return a === e1(n) && (function(e) {
            return -1 !== [
                "undefined",
                "boolean",
                "number",
                "string",
                "function",
                "xml",
                "null"
            ].indexOf(e);
        }(a) ? t === n : "array" === a ? o1(s1).eq(t, n) : "object" === a && r1(s1).eq(t, n));
    });
    const a1 = Object.getPrototypeOf, i1 = (e, t, n)=>{
        var o;
        return !!n(e, t.prototype) || (null === (o = e.constructor) || void 0 === o ? void 0 : o.name) === t.name;
    }, l1 = (e5)=>(t2)=>((e6)=>{
                const t3 = typeof e6;
                return null === e6 ? "null" : "object" === t3 && Array.isArray(e6) ? "array" : "object" === t3 && i1(e6, String, (e, t)=>t.isPrototypeOf(e)
                ) ? "string" : t3;
            })(t2) === e5
    , d1 = (e)=>(t)=>typeof t === e
    , c1 = (e)=>(t)=>e === t
    , u1 = (e7, t4)=>f1(e7) && i1(e7, t4, (e, t)=>a1(e) === t
        )
    , m1 = l1("string"), f1 = l1("object"), g1 = (e)=>u1(e, Object)
    , p1 = l1("array"), h1 = c1(null), b1 = d1("boolean"), v1 = c1(void 0), y1 = (e)=>null == e
    , C1 = (e)=>!y1(e)
    , x1 = d1("function"), w1 = d1("number"), k1 = (e, t)=>{
        if (p1(e)) {
            for(let n = 0, o = e.length; n < o; ++n)if (!t(e[n])) return !1;
            return !0;
        }
        return !1;
    }, S1 = ()=>{}, _1 = (e, t)=>(...n)=>e(t.apply(null, n))
    , E1 = (e, t)=>(n)=>e(t(n))
    , N1 = (e)=>()=>e
    , R1 = (e)=>e
    , A1 = (e, t)=>e === t
    ;
    function O1(e, ...t) {
        return (...n)=>{
            const o = t.concat(n);
            return e.apply(null, o);
        };
    }
    const T1 = (e)=>(t)=>!e(t)
    , B1 = (e)=>e()
    , D1 = (e)=>{
        e();
    }, L1 = N1(!1), P1 = N1(!0);
    class M1 {
        constructor(e, t){
            this.tag = e, this.value = t;
        }
        static some(e) {
            return new M1(!0, e);
        }
        static none() {
            return M1.singletonNone;
        }
        fold(e, t) {
            return this.tag ? t(this.value) : e();
        }
        isSome() {
            return this.tag;
        }
        isNone() {
            return !this.tag;
        }
        map(e) {
            return this.tag ? M1.some(e(this.value)) : M1.none();
        }
        bind(e) {
            return this.tag ? e(this.value) : M1.none();
        }
        exists(e) {
            return this.tag && e(this.value);
        }
        forall(e) {
            return !this.tag || e(this.value);
        }
        filter(e) {
            return !this.tag || e(this.value) ? this : M1.none();
        }
        getOr(e) {
            return this.tag ? this.value : e;
        }
        or(e) {
            return this.tag ? this : e;
        }
        getOrThunk(e) {
            return this.tag ? this.value : e();
        }
        orThunk(e) {
            return this.tag ? this : e();
        }
        getOrDie(e) {
            if (this.tag) return this.value;
            throw new Error(null != e ? e : "Called getOrDie on None");
        }
        static from(e) {
            return C1(e) ? M1.some(e) : M1.none();
        }
        getOrNull() {
            return this.tag ? this.value : null;
        }
        getOrUndefined() {
            return this.value;
        }
        each(e) {
            this.tag && e(this.value);
        }
        toArray() {
            return this.tag ? [
                this.value
            ] : [];
        }
        toString() {
            return this.tag ? `some(${this.value})` : "none()";
        }
    }
    M1.singletonNone = new M1(!1);
    const I1 = Array.prototype.slice, F1 = Array.prototype.indexOf, U1 = Array.prototype.push, z1 = (e, t)=>F1.call(e, t)
    , j1 = (e, t)=>z1(e, t) > -1
    , V1 = (e, t)=>{
        for(let n = 0, o = e.length; n < o; n++)if (t(e[n], n)) return !0;
        return !1;
    }, H1 = (e, t)=>{
        const n = e.length, o = new Array(n);
        for(let r = 0; r < n; r++){
            const n = e[r];
            o[r] = t(n, r);
        }
        return o;
    }, $1 = (e, t)=>{
        for(let n = 0, o = e.length; n < o; n++)t(e[n], n);
    }, q1 = (e, t)=>{
        for(let n = e.length - 1; n >= 0; n--)t(e[n], n);
    }, W1 = (e, t)=>{
        const n = [], o = [];
        for(let r = 0, s = e.length; r < s; r++){
            const s = e[r];
            (t(s, r) ? n : o).push(s);
        }
        return {
            pass: n,
            fail: o
        };
    }, K1 = (e, t)=>{
        const n = [];
        for(let o = 0, r = e.length; o < r; o++){
            const r = e[o];
            t(r, o) && n.push(r);
        }
        return n;
    }, G1 = (e8, t, n)=>(q1(e8, (e, o)=>{
            n = t(n, e, o);
        }), n)
    , Y1 = (e9, t, n)=>($1(e9, (e, o)=>{
            n = t(n, e, o);
        }), n)
    , X1 = (e, t, n)=>{
        for(let o = 0, r = e.length; o < r; o++){
            const r = e[o];
            if (t(r, o)) return M1.some(r);
            if (n(r, o)) break;
        }
        return M1.none();
    }, Q1 = (e, t)=>X1(e, t, L1)
    , J1 = (e, t)=>{
        for(let n = 0, o = e.length; n < o; n++)if (t(e[n], n)) return M1.some(n);
        return M1.none();
    }, Z1 = (e)=>{
        const t = [];
        for(let n = 0, o = e.length; n < o; ++n){
            if (!p1(e[n])) throw new Error("Arr.flatten item " + n + " was not an array, input: " + e);
            U1.apply(t, e[n]);
        }
        return t;
    }, ee1 = (e, t)=>Z1(H1(e, t))
    , te1 = (e, t)=>{
        for(let n = 0, o = e.length; n < o; ++n)if (!0 !== t(e[n], n)) return !1;
        return !0;
    }, ne1 = (e)=>{
        const t = I1.call(e, 0);
        return t.reverse(), t;
    }, oe1 = (e10, t)=>K1(e10, (e)=>!j1(t, e)
        )
    , re1 = (e, t)=>{
        const n = {};
        for(let o = 0, r = e.length; o < r; o++){
            const r = e[o];
            n[String(r)] = t(r, o);
        }
        return n;
    }, se1 = (e, t)=>{
        const n = I1.call(e, 0);
        return n.sort(t), n;
    }, ae1 = (e, t)=>t >= 0 && t < e.length ? M1.some(e[t]) : M1.none()
    , ie1 = (e)=>ae1(e, 0)
    , le1 = (e)=>ae1(e, e.length - 1)
    , de1 = x1(Array.from) ? Array.from : (e)=>I1.call(e)
    , ce1 = (e, t)=>{
        for(let n = 0; n < e.length; n++){
            const o = t(e[n], n);
            if (o.isSome()) return o;
        }
        return M1.none();
    }, ue1 = Object.keys, me1 = Object.hasOwnProperty, fe1 = (e, t)=>{
        const n = ue1(e);
        for(let o = 0, r = n.length; o < r; o++){
            const r = n[o];
            t(e[r], r);
        }
    }, ge1 = (e11, t)=>pe1(e11, (e, n)=>({
                k: n,
                v: t(e, n)
            })
        )
    , pe1 = (e12, t)=>{
        const n = {};
        return fe1(e12, (e, o)=>{
            const r = t(e, o);
            n[r.k] = r.v;
        }), n;
    }, he1 = (e)=>(t, n)=>{
            e[n] = t;
        }
    , be1 = (e13, t, n, o)=>(fe1(e13, (e, r)=>{
            (t(e, r) ? n : o)(e, r);
        }), {})
    , ve1 = (e, t)=>{
        const n = {};
        return be1(e, t, he1(n), S1), n;
    }, ye1 = (e14, t)=>{
        const n = [];
        return fe1(e14, (e, o)=>{
            n.push(t(e, o));
        }), n;
    }, Ce1 = (e)=>ye1(e, R1)
    , xe1 = (e, t)=>we1(e, t) ? M1.from(e[t]) : M1.none()
    , we1 = (e, t)=>me1.call(e, t)
    , ke1 = (e, t)=>we1(e, t) && void 0 !== e[t] && null !== e[t]
    , Se1 = (e15)=>{
        const t = {};
        return $1(e15, (e)=>{
            t[e] = {};
        }), ue1(t);
    }, _e1 = Array.isArray, Ee1 = (e, t, n)=>{
        let o, r;
        if (!e) return !1;
        if (n = n || e, void 0 !== e.length) {
            for(o = 0, r = e.length; o < r; o++)if (!1 === t.call(n, e[o], o, e)) return !1;
        } else for(o in e)if (we1(e, o) && !1 === t.call(n, e[o], o, e)) return !1;
        return !0;
    }, Ne1 = (e, t)=>{
        const n = [];
        return Ee1(e, (o, r)=>{
            n.push(t(o, r, e));
        }), n;
    }, Re1 = (e, t)=>{
        const n = [];
        return Ee1(e, (o, r)=>{
            t && !t(o, r, e) || n.push(o);
        }), n;
    }, Ae1 = (e, t)=>{
        if (e) {
            for(let n = 0, o = e.length; n < o; n++)if (e[n] === t) return n;
        }
        return -1;
    }, Oe1 = (e, t, n, o)=>{
        let r = v1(n) ? e[0] : n;
        for(let n3 = 0; n3 < e.length; n3++)r = t.call(o, r, e[n3], n3);
        return r;
    }, Te1 = (e, t, n)=>{
        let o, r;
        for(o = 0, r = e.length; o < r; o++)if (t.call(n, e[o], o, e)) return o;
        return -1;
    }, Be1 = (e)=>e[e.length - 1]
    , De1 = (e)=>{
        let t, n = !1;
        return (...o)=>(n || (n = !0, t = e.apply(null, o)), t)
        ;
    }, Le1 = ()=>Pe1(0, 0)
    , Pe1 = (e, t)=>({
            major: e,
            minor: t
        })
    , Me1 = {
        nu: Pe1,
        detect: (e16, t5)=>{
            const n4 = String(t5).toLowerCase();
            return 0 === e16.length ? Le1() : ((e17, t6)=>{
                const n5 = ((e, t)=>{
                    for(let n = 0; n < e.length; n++){
                        const o = e[n];
                        if (o.test(t)) return o;
                    }
                })(e17, t6);
                if (!n5) return {
                    major: 0,
                    minor: 0
                };
                const o2 = (e)=>Number(t6.replace(n5, "$" + e))
                ;
                return Pe1(o2(1), o2(2));
            })(e16, n4);
        },
        unknown: Le1
    }, Ie1 = (e18, t)=>{
        const n = String(t).toLowerCase();
        return Q1(e18, (e)=>e.search(n)
        );
    }, Fe1 = (e, t, n)=>"" === t || e.length >= t.length && e.substr(n, n + t.length) === t
    , Ue1 = (e, t)=>-1 !== e.indexOf(t)
    , ze1 = (e, t)=>Fe1(e, t, 0)
    , je1 = (e, t)=>Fe1(e, t, e.length - t.length)
    , Ve = (e)=>(t)=>t.replace(e, "")
    , He = Ve(/^\s+|\s+$/g), $e = Ve(/^\s+/g), qe = Ve(/\s+$/g), We = (e)=>e.length > 0
    , Ke = (e)=>!We(e)
    , Ge = (e, t = 10)=>{
        const n = parseInt(e, t);
        return isNaN(n) ? M1.none() : M1.some(n);
    }, Ye = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, Xe = (e)=>(t)=>Ue1(t, e)
    , Qe = [
        {
            name: "Edge",
            versionRegexes: [
                /.*?edge\/ ?([0-9]+)\.([0-9]+)$/
            ],
            search: (e)=>Ue1(e, "edge/") && Ue1(e, "chrome") && Ue1(e, "safari") && Ue1(e, "applewebkit")
        },
        {
            name: "Chromium",
            brand: "Chromium",
            versionRegexes: [
                /.*?chrome\/([0-9]+)\.([0-9]+).*/,
                Ye
            ],
            search: (e)=>Ue1(e, "chrome") && !Ue1(e, "chromeframe")
        },
        {
            name: "IE",
            versionRegexes: [
                /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
                /.*?rv:([0-9]+)\.([0-9]+).*/
            ],
            search: (e)=>Ue1(e, "msie") || Ue1(e, "trident")
        },
        {
            name: "Opera",
            versionRegexes: [
                Ye,
                /.*?opera\/([0-9]+)\.([0-9]+).*/
            ],
            search: Xe("opera")
        },
        {
            name: "Firefox",
            versionRegexes: [
                /.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/
            ],
            search: Xe("firefox")
        },
        {
            name: "Safari",
            versionRegexes: [
                Ye,
                /.*?cpu os ([0-9]+)_([0-9]+).*/
            ],
            search: (e)=>(Ue1(e, "safari") || Ue1(e, "mobile/")) && Ue1(e, "applewebkit")
        }
    ], Je = [
        {
            name: "Windows",
            search: Xe("win"),
            versionRegexes: [
                /.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/
            ]
        },
        {
            name: "iOS",
            search: (e)=>Ue1(e, "iphone") || Ue1(e, "ipad")
            ,
            versionRegexes: [
                /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
                /.*cpu os ([0-9]+)_([0-9]+).*/,
                /.*cpu iphone os ([0-9]+)_([0-9]+).*/
            ]
        },
        {
            name: "Android",
            search: Xe("android"),
            versionRegexes: [
                /.*?android\ ?([0-9]+)\.([0-9]+).*/
            ]
        },
        {
            name: "macOS",
            search: Xe("mac os x"),
            versionRegexes: [
                /.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/
            ]
        },
        {
            name: "Linux",
            search: Xe("linux"),
            versionRegexes: []
        },
        {
            name: "Solaris",
            search: Xe("sunos"),
            versionRegexes: []
        },
        {
            name: "FreeBSD",
            search: Xe("freebsd"),
            versionRegexes: []
        },
        {
            name: "ChromeOS",
            search: Xe("cros"),
            versionRegexes: [
                /.*?chrome\/([0-9]+)\.([0-9]+).*/
            ]
        }
    ], Ze = {
        browsers: N1(Qe),
        oses: N1(Je)
    }, et = "Edge", tt = "Chromium", nt = "Opera", ot = "Firefox", rt = "Safari", st = (e19)=>{
        const t = e19.current, n = e19.version, o = (e)=>()=>t === e
        ;
        return {
            current: t,
            version: n,
            isEdge: o(et),
            isChromium: o(tt),
            isIE: o("IE"),
            isOpera: o(nt),
            isFirefox: o(ot),
            isSafari: o(rt)
        };
    }, at = ()=>st({
            current: void 0,
            version: Me1.unknown()
        })
    , it = st, lt = (N1(et), N1(tt), N1("IE"), N1(nt), N1(ot), N1(rt), "Windows"), dt = "Android", ct = "Linux", ut = "macOS", mt = "Solaris", ft = "FreeBSD", gt = "ChromeOS", pt = (e20)=>{
        const t = e20.current, n = e20.version, o = (e)=>()=>t === e
        ;
        return {
            current: t,
            version: n,
            isWindows: o(lt),
            isiOS: o("iOS"),
            isAndroid: o(dt),
            isMacOS: o(ut),
            isLinux: o(ct),
            isSolaris: o(mt),
            isFreeBSD: o(ft),
            isChromeOS: o(gt)
        };
    }, ht = ()=>pt({
            current: void 0,
            version: Me1.unknown()
        })
    , bt = pt, vt = (N1(lt), N1("iOS"), N1(dt), N1(ct), N1(ut), N1(mt), N1(ft), N1(gt), (e)=>window.matchMedia(e).matches
    );
    let yt = De1(()=>((e21, t7, n6)=>{
            const o3 = Ze.browsers(), r2 = Ze.oses(), s2 = t7.bind((e22)=>((e23, t8)=>ce1(t8.brands, (t9)=>{
                        const n = t9.brand.toLowerCase();
                        return Q1(e23, (e)=>{
                            var t;
                            return n === (null === (t = e.brand) || void 0 === t ? void 0 : t.toLowerCase());
                        }).map((e)=>({
                                current: e.name,
                                version: Me1.nu(parseInt(t9.version, 10), 0)
                            })
                        );
                    })
                )(o3, e22)
            ).orThunk(()=>((e24, t)=>Ie1(e24, t).map((e)=>{
                        const n = Me1.detect(e.versionRegexes, t);
                        return {
                            current: e.name,
                            version: n
                        };
                    })
                )(o3, e21)
            ).fold(at, it), a2 = ((e25, t)=>Ie1(e25, t).map((e)=>{
                    const n = Me1.detect(e.versionRegexes, t);
                    return {
                        current: e.name,
                        version: n
                    };
                })
            )(r2, e21).fold(ht, bt), i2 = ((e, t, n, o)=>{
                const r = e.isiOS() && !0 === /ipad/i.test(n), s = e.isiOS() && !r, a = e.isiOS() || e.isAndroid(), i = a || o("(pointer:coarse)"), l = r || !s && a && o("(min-device-width:768px)"), d = s || a && !l, c = t.isSafari() && e.isiOS() && !1 === /safari/i.test(n), u = !d && !l && !c;
                return {
                    isiPad: N1(r),
                    isiPhone: N1(s),
                    isTablet: N1(l),
                    isPhone: N1(d),
                    isTouch: N1(i),
                    isAndroid: e.isAndroid,
                    isiOS: e.isiOS,
                    isWebView: N1(c),
                    isDesktop: N1(u)
                };
            })(a2, s2, e21, n6);
            return {
                browser: s2,
                os: a2,
                deviceType: i2
            };
        })(navigator.userAgent, M1.from(navigator.userAgentData), vt)
    );
    const Ct = ()=>yt()
    , xt = navigator.userAgent, wt = Ct(), kt = wt.browser, St = wt.os, _t = wt.deviceType, Et = -1 !== xt.indexOf("Windows Phone"), Nt = {
        transparentSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        documentMode: kt.isIE() ? document.documentMode || 7 : 10,
        cacheSuffix: null,
        container: null,
        canHaveCSP: !kt.isIE(),
        windowsPhone: Et,
        browser: {
            current: kt.current,
            version: kt.version,
            isChromium: kt.isChromium,
            isEdge: kt.isEdge,
            isFirefox: kt.isFirefox,
            isIE: kt.isIE,
            isOpera: kt.isOpera,
            isSafari: kt.isSafari
        },
        os: {
            current: St.current,
            version: St.version,
            isAndroid: St.isAndroid,
            isChromeOS: St.isChromeOS,
            isFreeBSD: St.isFreeBSD,
            isiOS: St.isiOS,
            isLinux: St.isLinux,
            isMacOS: St.isMacOS,
            isSolaris: St.isSolaris,
            isWindows: St.isWindows
        },
        deviceType: {
            isDesktop: _t.isDesktop,
            isiPad: _t.isiPad,
            isiPhone: _t.isiPhone,
            isPhone: _t.isPhone,
            isTablet: _t.isTablet,
            isTouch: _t.isTouch,
            isWebView: _t.isWebView
        }
    }, Rt = /^\s*|\s*$/g, At = (e)=>null == e ? "" : ("" + e).replace(Rt, "")
    , Ot = (e, t)=>t ? !("array" !== t || !_e1(e)) || typeof e === t : void 0 !== e
    , Tt = function(e26, t, n, o) {
        o = o || this, e26 && (n && (e26 = e26[n]), Ee1(e26, (e, r)=>{
            if (!1 === t.call(o, e, r, n)) return !1;
            Tt(e, t, n, o);
        }));
    }, Bt = {
        trim: At,
        isArray: _e1,
        is: Ot,
        toArray: (e)=>{
            if (_e1(e)) return e;
            {
                const t = [];
                for(let n = 0, o = e.length; n < o; n++)t[n] = e[n];
                return t;
            }
        },
        makeMap: (e, t, n)=>{
            let o;
            for(t = t || ",", "string" == typeof (e = e || []) && (e = e.split(t)), n = n || {}, o = e.length; o--;)n[e[o]] = {};
            return n;
        },
        each: Ee1,
        map: Ne1,
        grep: Re1,
        inArray: Ae1,
        hasOwn: we1,
        extend: (e, ...t)=>{
            for(let n = 0; n < t.length; n++){
                const o = t[n];
                for(const t10 in o)if (we1(o, t10)) {
                    const n = o[t10];
                    void 0 !== n && (e[t10] = n);
                }
            }
            return e;
        },
        walk: Tt,
        resolve: (e, t)=>{
            let n, o;
            for(t = t || window, n = 0, o = (e = e.split(".")).length; n < o && (t = t[e[n]]); n++);
            return t;
        },
        explode: (e, t)=>!e || Ot(e, "array") ? e : Ne1(e.split(t || ","), At)
        ,
        _addCacheSuffix: (e)=>{
            const t = Nt.cacheSuffix;
            return t && (e += (-1 === e.indexOf("?") ? "?" : "&") + t), e;
        }
    }, Dt = (e27, t, n = A1)=>e27.exists((e)=>n(e, t)
        )
    , Lt = (e, t, n)=>e.isSome() && t.isSome() ? M1.some(n(e.getOrDie(), t.getOrDie())) : M1.none()
    , Pt = (e, t)=>e ? M1.some(t) : M1.none()
    ;
    "undefined" != typeof window || Function("return this;")();
    const Mt = (e)=>e.dom.nodeName.toLowerCase()
    , It = (e)=>e.dom.nodeType
    , Ft = (e)=>(t)=>It(t) === e
    , Ut = Ft(1), zt = Ft(3), jt = Ft(9), Vt = Ft(11), Ht = (e, t, n)=>{
        if (!(m1(n) || b1(n) || w1(n))) throw console.error("Invalid call to Attribute.set. Key ", t, ":: Value ", n, ":: Element ", e), new Error("Attribute value was not simple");
        e.setAttribute(t, n + "");
    }, $t = (e, t, n)=>{
        Ht(e.dom, t, n);
    }, qt = (e28, t11)=>{
        const n = e28.dom;
        fe1(t11, (e, t)=>{
            Ht(n, t, e);
        });
    }, Wt = (e, t)=>{
        const n = e.dom.getAttribute(t);
        return null === n ? void 0 : n;
    }, Kt = (e, t)=>M1.from(Wt(e, t))
    , Gt = (e, t)=>{
        const n = e.dom;
        return !(!n || !n.hasAttribute) && n.hasAttribute(t);
    }, Yt = (e, t)=>{
        e.dom.removeAttribute(t);
    }, Xt = (e29)=>Y1(e29.dom.attributes, (e, t)=>(e[t.name] = t.value, e)
        , {})
    , Qt = (e, t)=>{
        const n = Wt(e, t);
        return void 0 === n || "" === n ? [] : n.split(" ");
    }, Jt = (e)=>void 0 !== e.dom.classList
    , Zt = (e)=>Qt(e, "class")
    , en = (e30, t12)=>((e, t, n)=>{
            const o = Qt(e, t).concat([
                n
            ]);
            return $t(e, t, o.join(" ")), !0;
        })(e30, "class", t12)
    , tn = (e31, t13)=>((e32, t, n)=>{
            const o = K1(Qt(e32, t), (e)=>e !== n
            );
            return o.length > 0 ? $t(e32, t, o.join(" ")) : Yt(e32, t), !1;
        })(e31, "class", t13)
    , nn = (e, t)=>{
        Jt(e) ? e.dom.classList.add(t) : en(e, t);
    }, on = (e)=>{
        0 === (Jt(e) ? e.dom.classList : Zt(e)).length && Yt(e, "class");
    }, rn = (e, t)=>{
        Jt(e) ? e.dom.classList.remove(t) : tn(e, t), on(e);
    }, sn = (e, t)=>Jt(e) && e.dom.classList.contains(t)
    , an = (e)=>void 0 !== e.style && x1(e.style.getPropertyValue)
    , ln = (e)=>{
        if (null == e) throw new Error("Node cannot be null or undefined");
        return {
            dom: e
        };
    }, dn = (e, t)=>{
        const n = (t || document).createElement("div");
        if (n.innerHTML = e, !n.hasChildNodes() || n.childNodes.length > 1) {
            const t = "HTML does not have a single root node";
            throw console.error(t, e), new Error(t);
        }
        return ln(n.childNodes[0]);
    }, cn = (e, t)=>{
        const n = (t || document).createElement(e);
        return ln(n);
    }, un = (e, t)=>{
        const n = (t || document).createTextNode(e);
        return ln(n);
    }, mn = ln, fn = (e, t, n)=>M1.from(e.dom.elementFromPoint(t, n)).map(ln)
    , gn = (e33, t)=>{
        const n = [], o = (e)=>(n.push(e), t(e))
        ;
        let r = t(e33);
        do r = r.bind(o);
        while (r.isSome())
        return n;
    }, pn = (e, t)=>{
        const n = e.dom;
        if (1 !== n.nodeType) return !1;
        {
            const e = n;
            if (void 0 !== e.matches) return e.matches(t);
            if (void 0 !== e.msMatchesSelector) return e.msMatchesSelector(t);
            if (void 0 !== e.webkitMatchesSelector) return e.webkitMatchesSelector(t);
            if (void 0 !== e.mozMatchesSelector) return e.mozMatchesSelector(t);
            throw new Error("Browser lacks native selectors");
        }
    }, hn = (e)=>1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType || 0 === e.childElementCount
    , bn = (e, t)=>e.dom === t.dom
    , vn = (e, t)=>{
        const n = e.dom, o = t.dom;
        return n !== o && n.contains(o);
    }, yn = (e)=>mn(e.dom.ownerDocument)
    , Cn = (e)=>jt(e) ? e : yn(e)
    , xn = (e)=>mn(Cn(e).dom.defaultView)
    , wn = (e)=>M1.from(e.dom.parentNode).map(mn)
    , kn = (e)=>M1.from(e.dom.previousSibling).map(mn)
    , Sn = (e)=>M1.from(e.dom.nextSibling).map(mn)
    , _n = (e)=>ne1(gn(e, kn))
    , En = (e)=>gn(e, Sn)
    , Nn = (e)=>H1(e.dom.childNodes, mn)
    , Rn = (e, t)=>{
        const n = e.dom.childNodes;
        return M1.from(n[t]).map(mn);
    }, An = (e)=>Rn(e, 0)
    , On = (e)=>Rn(e, e.dom.childNodes.length - 1)
    , Tn = (e)=>e.dom.childNodes.length
    , Bn = (e)=>Vt(e) && C1(e.dom.host)
    , Dn = x1(Element.prototype.attachShadow) && x1(Node.prototype.getRootNode), Ln = N1(Dn), Pn = Dn ? (e)=>mn(e.dom.getRootNode())
     : Cn, Mn = (e34)=>Bn(e34) ? e34 : ((e)=>{
            const t = e.dom.head;
            if (null == t) throw new Error("Head is not available yet");
            return mn(t);
        })(Cn(e34))
    , In = (e)=>mn(e.dom.host)
    , Fn = (e)=>{
        if (Ln() && C1(e.target)) {
            const t = mn(e.target);
            if (Ut(t) && Un(t) && e.composed && e.composedPath) {
                const t = e.composedPath();
                if (t) return ie1(t);
            }
        }
        return M1.from(e.target);
    }, Un = (e)=>C1(e.dom.shadowRoot)
    , zn = (e35)=>{
        const t14 = zt(e35) ? e35.dom.parentNode : e35.dom;
        if (null == t14 || null === t14.ownerDocument) return !1;
        const n = t14.ownerDocument;
        return ((e)=>{
            const t = Pn(e);
            return Bn(t) ? M1.some(t) : M1.none();
        })(mn(t14)).fold(()=>n.body.contains(t14)
        , E1(zn, In));
    }, jn = (e, t, n)=>{
        if (!m1(n)) throw console.error("Invalid call to CSS.set. Property ", t, ":: Value ", n, ":: Element ", e), new Error("CSS value must be a string: " + n);
        an(e) && e.style.setProperty(t, n);
    }, Vn = (e, t, n)=>{
        const o = e.dom;
        jn(o, t, n);
    }, Hn = (e36, t15)=>{
        const n = e36.dom;
        fe1(t15, (e, t)=>{
            jn(n, t, e);
        });
    }, $n = (e, t)=>{
        const n = e.dom, o = window.getComputedStyle(n).getPropertyValue(t);
        return "" !== o || zn(e) ? o : qn(n, t);
    }, qn = (e, t)=>an(e) ? e.style.getPropertyValue(t) : ""
    , Wn = (e37, t)=>{
        const n = e37.dom, o = qn(n, t);
        return M1.from(o).filter((e)=>e.length > 0
        );
    }, Kn = (e)=>{
        const t = {}, n = e.dom;
        if (an(n)) for(let e38 = 0; e38 < n.style.length; e38++){
            const o = n.style.item(e38);
            t[o] = n.style[o];
        }
        return t;
    }, Gn = (e39, t16)=>{
        ((e, t)=>{
            an(e) && e.style.removeProperty(t);
        })(e39.dom, t16), Dt(Kt(e39, "style").map(He), "") && Yt(e39, "style");
    }, Yn = (e, t)=>{
        wn(e).each((n)=>{
            n.dom.insertBefore(t.dom, e.dom);
        });
    }, Xn = (e40, t)=>{
        Sn(e40).fold(()=>{
            wn(e40).each((e)=>{
                Jn(e, t);
            });
        }, (e)=>{
            Yn(e, t);
        });
    }, Qn = (e, t)=>{
        An(e).fold(()=>{
            Jn(e, t);
        }, (n)=>{
            e.dom.insertBefore(t.dom, n.dom);
        });
    }, Jn = (e, t)=>{
        e.dom.appendChild(t.dom);
    }, Zn = (e, t17)=>{
        $1(t17, (t)=>{
            Jn(e, t);
        });
    }, eo = (e41)=>{
        e41.dom.textContent = "", $1(Nn(e41), (e)=>{
            to(e);
        });
    }, to = (e)=>{
        const t = e.dom;
        null !== t.parentNode && t.parentNode.removeChild(t);
    }, no = (e42)=>{
        const t18 = Nn(e42);
        var n, o;
        t18.length > 0 && (n = e42, $1(o = t18, (e, t)=>{
            const r = 0 === t ? n : o[t - 1];
            Xn(r, e);
        })), to(e42);
    }, oo = (e)=>e.dom.innerHTML
    , ro = (e43, t19)=>{
        const n7 = yn(e43).dom, o = mn(n7.createDocumentFragment()), r = ((e, t)=>{
            const n = (t || document).createElement("div");
            return n.innerHTML = e, Nn(mn(n));
        })(t19, n7);
        Zn(o, r), eo(e43), Jn(e43, o);
    }, so = (e44, t20, n8, o4)=>((e45, t21, n9, o5, r3)=>{
            const s3 = ((e46, t22)=>(n10)=>{
                    e46(n10) && t22(((e47)=>{
                        const t23 = mn(Fn(e47).getOr(e47.target)), n11 = ()=>e47.stopPropagation()
                        , o6 = ()=>e47.preventDefault()
                        , r4 = _1(o6, n11);
                        return ((e, t, n, o, r, s, a)=>({
                                target: e,
                                x: t,
                                y: n,
                                stop: o,
                                prevent: r,
                                kill: s,
                                raw: a
                            })
                        )(t23, e47.clientX, e47.clientY, n11, o6, r4, e47);
                    })(n10));
                }
            )(n9, o5);
            return e45.dom.addEventListener(t21, s3, false), {
                unbind: O1(ao, e45, t21, s3, false)
            };
        })(e44, t20, n8, o4)
    , ao = (e, t, n, o)=>{
        e.dom.removeEventListener(t, n, o);
    }, io = (e, t)=>({
            left: e,
            top: t,
            translate: (n, o)=>io(e + n, t + o)
        })
    , lo = io, co = (e, t)=>void 0 !== e ? e : void 0 !== t ? t : 0
    , uo = (e48)=>{
        const t24 = e48.dom, n = t24.ownerDocument.body;
        return n === t24 ? lo(n.offsetLeft, n.offsetTop) : zn(e48) ? ((e)=>{
            const t = e.getBoundingClientRect();
            return lo(t.left, t.top);
        })(t24) : lo(0, 0);
    }, mo = (e)=>{
        const t = void 0 !== e ? e.dom : document, n = t.body.scrollLeft || t.documentElement.scrollLeft, o = t.body.scrollTop || t.documentElement.scrollTop;
        return lo(n, o);
    }, fo = (e, t, n)=>{
        const o = (void 0 !== n ? n.dom : document).defaultView;
        o && o.scrollTo(e, t);
    }, go = (e, t)=>{
        Ct().browser.isSafari() && x1(e.dom.scrollIntoViewIfNeeded) ? e.dom.scrollIntoViewIfNeeded(!1) : e.dom.scrollIntoView(t);
    }, po = (e, t, n, o)=>({
            x: e,
            y: t,
            width: n,
            height: o,
            right: e + n,
            bottom: t + o
        })
    , ho = (e49)=>{
        const t25 = void 0 === e49 ? window : e49, n12 = t25.document, o = mo(mn(n12));
        return ((e)=>{
            const t = void 0 === e ? window : e;
            return Ct().browser.isFirefox() ? M1.none() : M1.from(t.visualViewport);
        })(t25).fold(()=>{
            const e = t25.document.documentElement, n = e.clientWidth, r = e.clientHeight;
            return po(o.left, o.top, n, r);
        }, (e)=>po(Math.max(e.pageLeft, o.left), Math.max(e.pageTop, o.top), e.width, e.height)
        );
    }, bo = (e)=>(t)=>!!t && t.nodeType === e
    , vo = (e)=>!!e && !Object.getPrototypeOf(e)
    , yo = bo(1), Co = (e50)=>{
        const t = e50.map((e)=>e.toLowerCase()
        );
        return (e)=>{
            if (e && e.nodeName) {
                const n = e.nodeName.toLowerCase();
                return j1(t, n);
            }
            return !1;
        };
    }, xo = (e, t26)=>{
        const n = t26.toLowerCase().split(" ");
        return (t)=>{
            if (yo(t)) for(let o = 0; o < n.length; o++){
                const r = t.ownerDocument.defaultView.getComputedStyle(t, null);
                if ((r ? r.getPropertyValue(e) : null) === n[o]) return !0;
            }
            return !1;
        };
    }, wo = (e)=>(t)=>yo(t) && t.hasAttribute(e)
    , ko = (e)=>yo(e) && e.hasAttribute("data-mce-bogus")
    , So = (e)=>yo(e) && "TABLE" === e.tagName
    , _o = (e)=>(t)=>{
            if (yo(t)) {
                if (t.contentEditable === e) return !0;
                if (t.getAttribute("data-mce-contenteditable") === e) return !0;
            }
            return !1;
        }
    , Eo = Co([
        "textarea",
        "input"
    ]), No = bo(3), Ro = bo(4), Ao = bo(7), Oo = bo(8), To = bo(9), Bo = bo(11), Do = Co([
        "br"
    ]), Lo = Co([
        "img"
    ]), Po = _o("true"), Mo = _o("false"), Io = Co([
        "td",
        "th"
    ]), Fo = Co([
        "video",
        "audio",
        "object",
        "embed"
    ]), Uo = Ct().browser, zo = (e)=>Q1(e, Ut)
    , jo = (e, t)=>e.children && j1(e.children, t)
    ;
    var Vo = (e, t, n, o, r)=>e(n, o) ? M1.some(n) : x1(r) && r(n) ? M1.none() : t(n, o, r)
    ;
    const Ho = (e, t, n)=>{
        let o = e.dom;
        const r = x1(n) ? n : L1;
        for(; o.parentNode;){
            o = o.parentNode;
            const e = mn(o);
            if (t(e)) return M1.some(e);
            if (r(e)) break;
        }
        return M1.none();
    }, $o = (e51, t27, n)=>Vo((e, t)=>t(e)
        , Ho, e51, t27, n)
    , qo = (e52, t, n)=>Ho(e52, (e)=>pn(e, t)
        , n)
    , Wo = (e53, t28)=>((e, t)=>{
            const n = void 0 === t ? document : t.dom;
            return hn(n) ? M1.none() : M1.from(n.querySelector(e)).map(mn);
        })(t28, e53)
    , Ko = (e54, t29, n)=>Vo((e, t)=>pn(e, t)
        , qo, e54, t29, n)
    , Go = (e55, t30 = {})=>{
        let n13 = 0;
        const o = {}, r = mn(e55), s = Cn(r), a = t30.maxLoadTime || 5000, i3 = (i)=>new Promise((l, d)=>{
                let c;
                const u = Bt._addCacheSuffix(i), m = ((e)=>xe1(o, e).getOrThunk(()=>({
                            id: "mce-u" + n13++,
                            passed: [],
                            failed: [],
                            count: 0
                        })
                    )
                )(u);
                o[u] = m, m.count++;
                const f = (e, t)=>{
                    $1(e, D1), m.status = t, m.passed = [], m.failed = [], c && (c.onload = null, c.onerror = null, c = null);
                }, g = ()=>f(m.passed, 2)
                , p = ()=>f(m.failed, 3)
                , h = ()=>{
                    var t31;
                    t31 = h, (()=>{
                        const t = e55.styleSheets;
                        let n = t.length;
                        for(; n--;){
                            const e = t[n].ownerNode;
                            if (e && e.id === c.id) return g(), !0;
                        }
                        return !1;
                    })() || (Date.now() - v < a ? setTimeout(t31) : p());
                };
                if (l && m.passed.push(l), d && m.failed.push(d), 1 === m.status) return;
                if (2 === m.status) return void g();
                if (3 === m.status) return void p();
                m.status = 1;
                const b = cn("link", s.dom);
                qt(b, {
                    rel: "stylesheet",
                    type: "text/css",
                    id: m.id
                });
                const v = Date.now();
                var y;
                t30.contentCssCors && $t(b, "crossOrigin", "anonymous"), t30.referrerPolicy && $t(b, "referrerpolicy", t30.referrerPolicy), c = b.dom, c.onload = h, c.onerror = p, y = b, Jn(Mn(r), y), $t(b, "href", u);
            })
        , l2 = (e56)=>{
            const t32 = Bt._addCacheSuffix(e56);
            xe1(o, t32).each((e57)=>{
                0 == --e57.count && (delete o[t32], ((e)=>{
                    const t = Mn(r);
                    Wo(t, "#" + e).each(to);
                })(e57.id));
            });
        };
        return {
            load: i3,
            loadAll: (e58)=>Promise.allSettled(H1(e58, (e)=>i3(e).then(N1(e))
                )).then((e59)=>{
                    const t = W1(e59, (e)=>"fulfilled" === e.status
                    );
                    return t.fail.length > 0 ? Promise.reject(H1(t.fail, (e)=>e.reason
                    )) : H1(t.pass, (e)=>e.value
                    );
                })
            ,
            unload: l2,
            unloadAll: (e60)=>{
                $1(e60, (e)=>{
                    l2(e);
                });
            },
            _setReferrerPolicy: (e)=>{
                t30.referrerPolicy = e;
            }
        };
    }, Yo = (()=>{
        const e = new WeakMap;
        return {
            forElement: (t33, n)=>{
                const o = Pn(t33).dom;
                return M1.from(e.get(o)).getOrThunk(()=>{
                    const t = Go(o, n);
                    return e.set(o, t), t;
                });
            }
        };
    })();
    class Xo {
        constructor(e, t){
            this.node = e, this.rootNode = t, this.current = this.current.bind(this), this.next = this.next.bind(this), this.prev = this.prev.bind(this), this.prev2 = this.prev2.bind(this);
        }
        current() {
            return this.node;
        }
        next(e) {
            return this.node = this.findSibling(this.node, "firstChild", "nextSibling", e), this.node;
        }
        prev(e) {
            return this.node = this.findSibling(this.node, "lastChild", "previousSibling", e), this.node;
        }
        prev2(e) {
            return this.node = this.findPreviousNode(this.node, "lastChild", "previousSibling", e), this.node;
        }
        findSibling(e, t, n, o) {
            let r, s;
            if (e) {
                if (!o && e[t]) return e[t];
                if (e !== this.rootNode) {
                    if (r = e[n], r) return r;
                    for(s = e.parentNode; s && s !== this.rootNode; s = s.parentNode)if (r = s[n], r) return r;
                }
            }
        }
        findPreviousNode(e, t, n, o) {
            let r, s, a;
            if (e) {
                if (r = e[n], this.rootNode && r === this.rootNode) return;
                if (r) {
                    if (!o) {
                        for(a = r[t]; a; a = a[t])if (!a[t]) return a;
                    }
                    return r;
                }
                if (s = e.parentNode, s && s !== this.rootNode) return s;
            }
        }
    }
    const Qo = (e)=>{
        let t;
        return (n)=>(t = t || re1(e, P1), we1(t, Mt(n)))
        ;
    }, Jo = Qo([
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6"
    ]), Zo = Qo([
        "article",
        "aside",
        "details",
        "div",
        "dt",
        "figcaption",
        "footer",
        "form",
        "fieldset",
        "header",
        "hgroup",
        "html",
        "main",
        "nav",
        "section",
        "summary",
        "body",
        "p",
        "dl",
        "multicol",
        "dd",
        "figure",
        "address",
        "center",
        "blockquote",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "listing",
        "xmp",
        "pre",
        "plaintext",
        "menu",
        "dir",
        "ul",
        "ol",
        "li",
        "hr",
        "table",
        "tbody",
        "thead",
        "tfoot",
        "th",
        "tr",
        "td",
        "caption"
    ]), er = (e)=>Ut(e) && !Zo(e)
    , tr = (e)=>Ut(e) && "br" === Mt(e)
    , nr = Qo([
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "p",
        "div",
        "address",
        "pre",
        "form",
        "blockquote",
        "center",
        "dir",
        "fieldset",
        "header",
        "footer",
        "article",
        "section",
        "hgroup",
        "aside",
        "nav",
        "figure"
    ]), or = Qo([
        "ul",
        "ol",
        "dl"
    ]), rr = Qo([
        "li",
        "dd",
        "dt"
    ]), sr = Qo([
        "thead",
        "tbody",
        "tfoot"
    ]), ar = Qo([
        "td",
        "th"
    ]), ir = Qo([
        "pre",
        "script",
        "textarea",
        "style"
    ]), lr = "\ufeff", dr = "\xa0", cr = (e)=>e === lr
    , ur = lr, mr = cr, fr = (e)=>e.replace(/\uFEFF/g, "")
    , gr = yo, pr = No, hr = (e)=>(pr(e) && (e = e.parentNode), gr(e) && e.hasAttribute("data-mce-caret"))
    , br = (e)=>pr(e) && mr(e.data)
    , vr = (e)=>hr(e) || br(e)
    , yr = (e)=>e.firstChild !== e.lastChild || !Do(e.firstChild)
    , Cr = (e)=>{
        const t = e.container();
        return !!No(t) && (t.data.charAt(e.offset()) === ur || e.isAtStart() && br(t.previousSibling));
    }, xr = (e)=>{
        const t = e.container();
        return !!No(t) && (t.data.charAt(e.offset() - 1) === ur || e.isAtEnd() && br(t.nextSibling));
    }, wr = (e)=>pr(e) && e.data[0] === ur
    , kr = (e)=>pr(e) && e.data[e.data.length - 1] === ur
    , Sr = (e61)=>e61 && e61.hasAttribute("data-mce-caret") ? (((e)=>{
            const t = e.getElementsByTagName("br"), n = t[t.length - 1];
            ko(n) && n.parentNode.removeChild(n);
        })(e61), e61.removeAttribute("data-mce-caret"), e61.removeAttribute("data-mce-bogus"), e61.removeAttribute("style"), e61.removeAttribute("data-mce-style"), e61.removeAttribute("_moz_abspos"), e61) : null
    , _r = (e)=>hr(e.startContainer)
    , Er = Po, Nr = Mo, Rr = Do, Ar = No, Or = Co([
        "script",
        "style",
        "textarea"
    ]), Tr = Co([
        "img",
        "input",
        "textarea",
        "hr",
        "iframe",
        "video",
        "audio",
        "object",
        "embed"
    ]), Br = Co([
        "table"
    ]), Dr = vr, Lr = (e)=>!Dr(e) && (Ar(e) ? !Or(e.parentNode) : Tr(e) || Rr(e) || Br(e) || Pr(e))
    , Pr = (e62)=>!1 === ((e)=>yo(e) && "true" === e.getAttribute("unselectable")
        )(e62) && Nr(e62)
    , Mr = (e63, t34)=>Lr(e63) && ((e, t)=>{
            for(e = e.parentNode; e && e !== t; e = e.parentNode){
                if (Pr(e)) return !1;
                if (Er(e)) return !0;
            }
            return !0;
        })(e63, t34)
    , Ir = /^[ \t\r\n]*$/, Fr = (e)=>Ir.test(e)
    , Ur = (e)=>"\n" === e || "\r" === e
    , zr = (e64, t35 = 4, n = !0, o = !0)=>{
        const r = ((e, t)=>t <= 0 ? "" : new Array(t + 1).join(" ")
        )(0, t35), s = e64.replace(/\t/g, r), a = Y1(s, (e65, t36)=>((e)=>-1 !== " \f\t\v".indexOf(e)
            )(t36) || t36 === dr ? e65.pcIsSpace || "" === e65.str && n || e65.str.length === s.length - 1 && o || ((e, t)=>t < e.length && t >= 0 && Ur(e[t])
            )(s, e65.str.length + 1) ? {
                pcIsSpace: !1,
                str: e65.str + dr
            } : {
                pcIsSpace: !0,
                str: e65.str + " "
            } : {
                pcIsSpace: Ur(t36),
                str: e65.str + t36
            }
        , {
            pcIsSpace: !1,
            str: ""
        });
        return a.str;
    }, jr = (e66, t37)=>Lr(e66) && !1 === ((e67, t38)=>No(e67) && Fr(e67.data) && !1 === ((e, t)=>{
                const n = mn(t);
                var o, r;
                return o = mn(e), r = O1(bn, n), qo(o, "pre,code", r).isSome();
            })(e67, t38)
        )(e66, t37) || ((e)=>yo(e) && "A" === e.nodeName && !e.hasAttribute("href") && (e.hasAttribute("name") || e.hasAttribute("id"))
        )(e66) || Vr(e66)
    , Vr = wo("data-mce-bookmark"), Hr = wo("data-mce-bogus"), $r = (e)=>yo(e) && "all" === e.getAttribute("data-mce-bogus")
    ;
    const qr = (e68, t39 = !0)=>((e, t)=>{
            let n = 0;
            if (jr(e, e)) return !1;
            {
                let o = e.firstChild;
                if (!o) return !0;
                const r = new Xo(o, e);
                do {
                    if (t) {
                        if ($r(o)) {
                            o = r.next(!0);
                            continue;
                        }
                        if (Hr(o)) {
                            o = r.next();
                            continue;
                        }
                    }
                    if (Do(o)) n++, o = r.next();
                    else {
                        if (jr(o, e)) return !1;
                        o = r.next();
                    }
                }while (o)
                return n <= 1;
            }
        })(e68.dom, t39)
    , Wr = (e, t)=>C1(e) && (jr(e, t) || er(mn(e)))
    , Kr = (e69)=>((e)=>"span" === e.nodeName.toLowerCase()
        )(e69) && "bookmark" === e69.getAttribute("data-mce-type")
    , Gr = (e70, t41, n14)=>{
        const o7 = n14 || t41;
        if (yo(t41) && Kr(t41)) return t41;
        const r5 = t41.childNodes;
        for(let t40 = r5.length - 1; t40 >= 0; t40--)Gr(e70, r5[t40], o7);
        if (yo(t41)) {
            const e = t41.childNodes;
            1 === e.length && Kr(e[0]) && t41.parentNode.insertBefore(e[0], t41);
        }
        return ((e)=>Bo(e) || To(e)
        )(t41) || jr(t41, o7) || ((e)=>!!yo(e) && e.childNodes.length > 0
        )(t41) || ((e71, t42)=>No(e71) && e71.data.length > 0 && ((e, t)=>{
                const n = new Xo(e, t).prev(!1), o = new Xo(e, t).next(!1), r = v1(n) || Wr(n, t), s = v1(o) || Wr(o, t);
                return r && s;
            })(e71, t42)
        )(t41, o7) || e70.remove(t41), t41;
    }, Yr = Bt.makeMap, Xr = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, Qr = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, Jr = /[<>&\"\']/g, Zr = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi, es = {
        128: "\u20ac",
        130: "\u201a",
        131: "\u0192",
        132: "\u201e",
        133: "\u2026",
        134: "\u2020",
        135: "\u2021",
        136: "\u02c6",
        137: "\u2030",
        138: "\u0160",
        139: "\u2039",
        140: "\u0152",
        142: "\u017d",
        145: "\u2018",
        146: "\u2019",
        147: "\u201c",
        148: "\u201d",
        149: "\u2022",
        150: "\u2013",
        151: "\u2014",
        152: "\u02dc",
        153: "\u2122",
        154: "\u0161",
        155: "\u203a",
        156: "\u0153",
        158: "\u017e",
        159: "\u0178"
    }, ts = {
        '"': "&quot;",
        "'": "&#39;",
        "<": "&lt;",
        ">": "&gt;",
        "&": "&amp;",
        "`": "&#96;"
    }, ns = {
        "&lt;": "<",
        "&gt;": ">",
        "&amp;": "&",
        "&quot;": '"',
        "&apos;": "'"
    }, os = (e, t)=>{
        let n, o, r;
        const s = {};
        if (e) {
            for(e = e.split(","), t = t || 10, n = 0; n < e.length; n += 2)o = String.fromCharCode(parseInt(e[n], t)), ts[o] || (r = "&" + e[n + 1] + ";", s[o] = r, s[r] = o);
            return s;
        }
    }, rs = os("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32), ss = (e72, t)=>e72.replace(t ? Xr : Qr, (e)=>ts[e] || e
        )
    , as = (e73, t)=>e73.replace(t ? Xr : Qr, (e)=>e.length > 1 ? "&#" + (1024 * (e.charCodeAt(0) - 55296) + (e.charCodeAt(1) - 56320) + 65536) + ";" : ts[e] || "&#" + e.charCodeAt(0) + ";"
        )
    , is = (e74, t, n)=>(n = n || rs, e74.replace(t ? Xr : Qr, (e)=>ts[e] || n[e] || e
        ))
    , ls = {
        encodeRaw: ss,
        encodeAllRaw: (e75)=>("" + e75).replace(Jr, (e)=>ts[e] || e
            )
        ,
        encodeNumeric: as,
        encodeNamed: is,
        getEncodeFunc: (e76, t43)=>{
            const n = os(t43) || rs, o = Yr(e76.replace(/\+/g, ","));
            return o.named && o.numeric ? (e77, t)=>e77.replace(t ? Xr : Qr, (e)=>void 0 !== ts[e] ? ts[e] : void 0 !== n[e] ? n[e] : e.length > 1 ? "&#" + (1024 * (e.charCodeAt(0) - 55296) + (e.charCodeAt(1) - 56320) + 65536) + ";" : "&#" + e.charCodeAt(0) + ";"
                )
             : o.named ? t43 ? (e, t)=>is(e, t, n)
             : is : o.numeric ? as : ss;
        },
        decode: (e78)=>e78.replace(Zr, (e79, t44)=>t44 ? (t44 = "x" === t44.charAt(0).toLowerCase() ? parseInt(t44.substr(1), 16) : parseInt(t44, 10)) > 65535 ? (t44 -= 65536, String.fromCharCode(55296 + (t44 >> 10), 56320 + (1023 & t44))) : es[t44] || String.fromCharCode(t44) : ns[e79] || rs[e79] || ((e)=>{
                    const t = cn("div").dom;
                    return t.innerHTML = e, t.textContent || t.innerText || e;
                })(e79)
            )
    }, ds = {}, cs = {}, us = Bt.makeMap, ms = Bt.each, fs = Bt.extend, gs = Bt.explode, ps = Bt.inArray, hs = (e, t)=>(e = Bt.trim(e)) ? e.split(t || " ") : []
    , bs = (e80, t)=>{
        let n;
        return e80 && (n = {}, "string" == typeof e80 && (e80 = {
            "*": e80
        }), ms(e80, (e, o)=>{
            n[o] = n[o.toUpperCase()] = "map" === t ? us(e, /[, ]/) : gs(e, /[, ]/);
        })), n;
    }, vs = (e81)=>{
        var t45;
        const n15 = {}, o8 = {};
        let r6 = [];
        const s4 = {}, a3 = {}, i4 = (t, n, o)=>{
            let r = e81[t];
            return r ? r = us(r, /[, ]/, us(r.toUpperCase(), /[, ]/)) : (r = ds[t], r || (r = us(n, " ", us(n.toUpperCase(), " ")), r = fs(r, o), ds[t] = r)), r;
        }, l3 = null !== (t45 = (e81 = e81 || {}).schema) && void 0 !== t45 ? t45 : "html5", d2 = ((e82)=>{
            const t = {};
            let n16, o9, r7, s5, a4, i5;
            const l = (e, o = "", r = "")=>{
                const s = hs(r), a = hs(e);
                let i = a.length;
                for(; i--;){
                    const e = hs([
                        n16,
                        o
                    ].join(" "));
                    t[a[i]] = {
                        attributes: re1(e, ()=>({})
                        ),
                        attributesOrder: e,
                        children: re1(s, N1(cs))
                    };
                }
            }, d = (e, n)=>{
                const o = hs(e), r = hs(n);
                let s = o.length;
                for(; s--;){
                    const e = t[o[s]];
                    for(let t46 = 0, n = r.length; t46 < n; t46++)e.attributes[r[t46]] = {}, e.attributesOrder.push(r[t46]);
                }
            };
            return ds[e82] ? ds[e82] : (n16 = "id accesskey class dir lang style tabindex title role", o9 = "address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul", r7 = "a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd label map noscript object q s samp script select small span strong sub sup textarea u var #text #comment", "html4" !== e82 && (n16 += " contenteditable contextmenu draggable dropzone hidden spellcheck translate", o9 += " article aside details dialog figure main header footer hgroup section nav", r7 += " audio canvas command datalist mark meter output picture progress time wbr video ruby bdi keygen"), "html5-strict" !== e82 && (n16 += " xml:lang", i5 = "acronym applet basefont big font strike tt", r7 = [
                r7,
                i5
            ].join(" "), ms(hs(i5), (e)=>{
                l(e, "", r7);
            }), a4 = "center dir isindex noframes", o9 = [
                o9,
                a4
            ].join(" "), s5 = [
                o9,
                r7
            ].join(" "), ms(hs(a4), (e)=>{
                l(e, "", s5);
            })), s5 = s5 || [
                o9,
                r7
            ].join(" "), l("html", "manifest", "head body"), l("head", "", "base command link meta noscript script style title"), l("title hr noscript br"), l("base", "href target"), l("link", "href rel media hreflang type sizes hreflang"), l("meta", "name http-equiv content charset"), l("style", "media type scoped"), l("script", "src async defer type charset"), l("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus onhashchange onload onmessage onoffline ononline onpagehide onpageshow onpopstate onresize onscroll onstorage onunload", s5), l("address dt dd div caption", "", s5), l("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", r7), l("blockquote", "cite", s5), l("ol", "reversed start type", "li"), l("ul", "", "li"), l("li", "value", s5), l("dl", "", "dt dd"), l("a", "href target rel media hreflang type", r7), l("q", "cite", r7), l("ins del", "cite datetime", s5), l("img", "src sizes srcset alt usemap ismap width height"), l("iframe", "src name width height", s5), l("embed", "src type width height"), l("object", "data type typemustmatch name usemap form width height", [
                s5,
                "param"
            ].join(" ")), l("param", "name value"), l("map", "name", [
                s5,
                "area"
            ].join(" ")), l("area", "alt coords shape href target rel media hreflang type"), l("table", "border", "caption colgroup thead tfoot tbody tr" + ("html4" === e82 ? " col" : "")), l("colgroup", "span", "col"), l("col", "span"), l("tbody thead tfoot", "", "tr"), l("tr", "", "td th"), l("td", "colspan rowspan headers", s5), l("th", "colspan rowspan headers scope abbr", s5), l("form", "accept-charset action autocomplete enctype method name novalidate target", s5), l("fieldset", "disabled form name", [
                s5,
                "legend"
            ].join(" ")), l("label", "form for", r7), l("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate formtarget height list max maxlength min multiple name pattern readonly required size src step type value width"), l("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value", "html4" === e82 ? s5 : r7), l("select", "disabled form multiple name required size", "option optgroup"), l("optgroup", "disabled label", "option"), l("option", "disabled label selected value"), l("textarea", "cols dirname disabled form maxlength name readonly required rows wrap"), l("menu", "type label", [
                s5,
                "li"
            ].join(" ")), l("noscript", "", s5), "html4" !== e82 && (l("wbr"), l("ruby", "", [
                r7,
                "rt rp"
            ].join(" ")), l("figcaption", "", s5), l("mark rt rp summary bdi", "", r7), l("canvas", "width height", s5), l("video", "src crossorigin poster preload autoplay mediagroup loop muted controls width height buffered", [
                s5,
                "track source"
            ].join(" ")), l("audio", "src crossorigin preload autoplay mediagroup loop muted controls buffered volume", [
                s5,
                "track source"
            ].join(" ")), l("picture", "", "img source"), l("source", "src srcset type media sizes"), l("track", "kind src srclang label default"), l("datalist", "", [
                r7,
                "option"
            ].join(" ")), l("article section nav aside main header footer", "", s5), l("hgroup", "", "h1 h2 h3 h4 h5 h6"), l("figure", "", [
                s5,
                "figcaption"
            ].join(" ")), l("time", "datetime", r7), l("dialog", "open", s5), l("command", "type label icon disabled checked radiogroup command"), l("output", "for form name", r7), l("progress", "value max", r7), l("meter", "value min max low high optimum", r7), l("details", "open", [
                s5,
                "summary"
            ].join(" ")), l("keygen", "autofocus challenge disabled form keytype name")), "html5-strict" !== e82 && (d("script", "language xml:space"), d("style", "xml:space"), d("object", "declare classid code codebase codetype archive standby align border hspace vspace"), d("embed", "align name hspace vspace"), d("param", "valuetype type"), d("a", "charset name rev shape coords"), d("br", "clear"), d("applet", "codebase archive code object alt name width height align hspace vspace"), d("img", "name longdesc align border hspace vspace"), d("iframe", "longdesc frameborder marginwidth marginheight scrolling align"), d("font basefont", "size color face"), d("input", "usemap align"), d("select"), d("textarea"), d("h1 h2 h3 h4 h5 h6 div p legend caption", "align"), d("ul", "type compact"), d("li", "type"), d("ol dl menu dir", "compact"), d("pre", "width xml:space"), d("hr", "align noshade size width"), d("isindex", "prompt"), d("table", "summary width frame rules cellspacing cellpadding align bgcolor"), d("col", "width align char charoff valign"), d("colgroup", "width align char charoff valign"), d("thead", "align char charoff valign"), d("tr", "align char charoff valign bgcolor"), d("th", "axis align char charoff valign nowrap bgcolor width height"), d("form", "accept"), d("td", "abbr axis scope align char charoff valign nowrap bgcolor width height"), d("tfoot", "align char charoff valign"), d("tbody", "align char charoff valign"), d("area", "nohref"), d("body", "background bgcolor text link vlink alink")), "html4" !== e82 && (d("input button select textarea", "autofocus"), d("input textarea", "placeholder"), d("a", "download"), d("link script img", "crossorigin"), d("img", "loading"), d("iframe", "sandbox seamless allowfullscreen loading")), "html4" !== e82 && $1([
                t.video,
                t.audio
            ], (e)=>{
                delete e.children.audio, delete e.children.video;
            }), ms(hs("a form meter progress dfn"), (e)=>{
                t[e] && delete t[e].children[e];
            }), delete t.caption.children.table, delete t.script, ds[e82] = t, t);
        })(l3);
        !1 === e81.verify_html && (e81.valid_elements = "*[*]");
        const c2 = bs(e81.valid_styles), u2 = bs(e81.invalid_styles, "map"), m2 = bs(e81.valid_classes, "map"), f2 = i4("whitespace_elements", "pre script noscript style textarea video audio iframe object code"), g2 = i4("self_closing_elements", "colgroup dd dt li option p td tfoot th thead tr"), p2 = i4("void_elements", "area base basefont br col frame hr img input isindex link meta param embed source wbr track"), h2 = i4("boolean_attributes", "checked compact declare defer disabled ismap multiple nohref noresize noshade nowrap readonly selected autoplay loop controls allowfullscreen"), b2 = "td th iframe video audio object script code", v2 = i4("non_empty_elements", b2 + " pre", p2), y2 = i4("move_caret_before_on_enter_elements", b2 + " table", p2), C2 = i4("text_block_elements", "h1 h2 h3 h4 h5 h6 p div address pre form blockquote center dir fieldset header footer article section hgroup aside main nav figure"), x2 = i4("block_elements", "hr table tbody thead tfoot th tr td li ol ul caption dl dt dd noscript menu isindex option datalist select optgroup figcaption details summary", C2), w2 = i4("text_inline_elements", "span strong b em i font strike u var cite dfn code mark q sup sub samp");
        ms("script noscript iframe noframes noembed title style textarea xmp plaintext".split(" "), (e)=>{
            a3[e] = new RegExp("</" + e + "[^>]*>", "gi");
        });
        const k = (e)=>new RegExp("^" + e.replace(/([?+*])/g, ".$1") + "$")
        , S2 = (e83)=>{
            let t48, o, s, a, i, l, d, c, u, m, f, g, p, h, b, v, y, C;
            const x = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/, w = /^([!\-])?(\w+[\\:]:\w+|[^=~<]+)?(?:([=~<])(.*))?$/, S = /[*?+]/;
            if (e83) {
                const _ = hs(e83, ",");
                for(n15["@"] && (v = n15["@"].attributes, y = n15["@"].attributesOrder), t48 = 0, o = _.length; t48 < o; t48++)if (i = x.exec(_[t48]), i) {
                    if (h = i[1], u = i[2], b = i[3], c = i[5], g = {}, p = [], l = {
                        attributes: g,
                        attributesOrder: p
                    }, "#" === h && (l.paddEmpty = !0), "-" === h && (l.removeEmpty = !0), "!" === i[4] && (l.removeEmptyAttrs = !0), v && (fe1(v, (e, t)=>{
                        g[t] = e;
                    }), p.push.apply(p, y)), c) {
                        for(c = hs(c, "|"), s = 0, a = c.length; s < a; s++)if (i = w.exec(c[s]), i) {
                            if (d = {}, f = i[1], m = i[2].replace(/[\\:]:/g, ":"), h = i[3], C = i[4], "!" === f && (l.attributesRequired = l.attributesRequired || [], l.attributesRequired.push(m), d.required = !0), "-" === f) {
                                delete g[m], p.splice(ps(p, m), 1);
                                continue;
                            }
                            h && ("=" === h && (l.attributesDefault = l.attributesDefault || [], l.attributesDefault.push({
                                name: m,
                                value: C
                            }), d.defaultValue = C), "~" === h && (l.attributesForced = l.attributesForced || [], l.attributesForced.push({
                                name: m,
                                value: C
                            }), d.forcedValue = C), "<" === h && (d.validValues = us(C, "?"))), S.test(m) ? (l.attributePatterns = l.attributePatterns || [], d.pattern = k(m), l.attributePatterns.push(d)) : (g[m] || p.push(m), g[m] = d);
                        }
                    }
                    v || "@" !== u || (v = g, y = p), b && (l.outputName = u, n15[b] = l), S.test(u) ? (l.pattern = k(u), r6.push(l)) : n15[u] = l;
                }
            }
        }, _2 = (e84)=>{
            r6 = [], $1(ue1(n15), (e)=>{
                delete n15[e];
            }), S2(e84), ms(d2, (e, t)=>{
                o8[t] = e.children;
            });
        }, E = (e85)=>{
            const t49 = /^(~)?(.+)$/;
            e85 && (ds.text_block_elements = ds.block_elements = null, ms(hs(e85, ","), (e86)=>{
                const r = t49.exec(e86), a = "~" === r[1], i = a ? "span" : "div", l = r[2];
                if (o8[l] = o8[i], s4[l] = i, a || (x2[l.toUpperCase()] = {}, x2[l] = {}), !n15[l]) {
                    let e = n15[i];
                    e = fs({}, e), delete e.removeEmptyAttrs, delete e.removeEmpty, n15[l] = e;
                }
                ms(o8, (e, t)=>{
                    e[i] && (o8[t] = e = fs({}, o8[t]), e[l] = e[i]);
                });
            }));
        }, R = (e87)=>{
            const t = /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/;
            ds[l3] = null, e87 && ms(hs(e87, ","), (e88)=>{
                const n = t.exec(e88);
                let r, s;
                n && (s = n[1], r = s ? o8[n[2]] : o8[n[2]] = {
                    "#comment": {}
                }, r = o8[n[2]], ms(hs(n[3], "|"), (e)=>{
                    "-" === s ? delete r[e] : r[e] = {};
                }));
            });
        }, A = (e)=>{
            let t, o = n15[e];
            if (o) return o;
            for(t = r6.length; t--;)if (o = r6[t], o.pattern.test(e)) return o;
        };
        e81.valid_elements ? _2(e81.valid_elements) : (ms(d2, (e, t)=>{
            n15[t] = {
                attributes: e.attributes,
                attributesOrder: e.attributesOrder
            }, o8[t] = e.children;
        }), ms(hs("strong/b em/i"), (e)=>{
            const t = hs(e, "/");
            n15[t[1]].outputName = t[0];
        }), ms(hs("ol ul sub sup blockquote span font a table tbody strong em b i"), (e)=>{
            n15[e] && (n15[e].removeEmpty = !0);
        }), ms(hs("p h1 h2 h3 h4 h5 h6 th td pre div address caption li"), (e)=>{
            n15[e].paddEmpty = !0;
        }), ms(hs("span"), (e)=>{
            n15[e].removeEmptyAttrs = !0;
        })), E(e81.custom_elements), R(e81.valid_children), S2(e81.extended_valid_elements), R("+ol[ul|ol],+ul[ul|ol]"), ms({
            dd: "dl",
            dt: "dl",
            li: "ul ol",
            td: "tr",
            th: "tr",
            tr: "tbody thead tfoot",
            tbody: "table",
            thead: "table",
            tfoot: "table",
            legend: "fieldset",
            area: "map",
            param: "video audio object"
        }, (e, t)=>{
            n15[t] && (n15[t].parentsRequired = hs(e));
        }), e81.invalid_elements && ms(gs(e81.invalid_elements), (e)=>{
            n15[e] && delete n15[e];
        }), A("span") || S2("span[!data-mce-type|*]");
        const O = N1(c2), T = N1(u2), B = N1(m2), D = N1(h2), L = N1(x2), P = N1(C2), M = N1(w2), I = N1(Object.seal(p2)), F = N1(g2), U = N1(v2), z = N1(y2), j = N1(f2), V = N1(Object.seal(a3)), H = N1(s4);
        return {
            type: l3,
            children: o8,
            elements: n15,
            getValidStyles: O,
            getValidClasses: B,
            getBlockElements: L,
            getInvalidStyles: T,
            getVoidElements: I,
            getTextBlockElements: P,
            getTextInlineElements: M,
            getBoolAttrs: D,
            getElementRule: A,
            getSelfClosingElements: F,
            getNonEmptyElements: U,
            getMoveCaretBeforeOnEnterElements: z,
            getWhitespaceElements: j,
            getSpecialElements: V,
            isValidChild: (e, t)=>{
                const n = o8[e.toLowerCase()];
                return !(!n || !n[t.toLowerCase()]);
            },
            isValid: (e, t)=>{
                let n, o;
                const r = A(e);
                if (r) {
                    if (!t) return !0;
                    if (r.attributes[t]) return !0;
                    if (n = r.attributePatterns, n) {
                        for(o = n.length; o--;)if (n[o].pattern.test(t)) return !0;
                    }
                }
                return !1;
            },
            getCustomElements: H,
            addValidElements: S2,
            setValidElements: _2,
            addCustomElements: E,
            addValidChildren: R
        };
    }, ys = (e89, t50)=>{
        const n17 = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi, o10 = /\s*([^:]+):\s*([^;]+);?/g, r8 = /\s+$/;
        let s6;
        const a5 = {};
        let i6, l4;
        e89 = e89 || {}, t50 && (i6 = t50.getValidStyles(), l4 = t50.getInvalidStyles());
        const d3 = "\\\" \\' \\; \\: ; : \ufeff".split(" ");
        for(s6 = 0; s6 < d3.length; s6++)a5[d3[s6]] = "\ufeff" + s6, a5["\ufeff" + s6] = d3[s6];
        const c = {
            parse: (t51)=>{
                const i = {};
                let l5, d4, u, m;
                const f = e89.url_converter, g = e89.url_converter_scope || c, p = (e, t, n)=>{
                    const o = i[e + "-top" + t];
                    if (!o) return;
                    const r = i[e + "-right" + t];
                    if (!r) return;
                    const a = i[e + "-bottom" + t];
                    if (!a) return;
                    const l = i[e + "-left" + t];
                    if (!l) return;
                    const d = [
                        o,
                        r,
                        a,
                        l
                    ];
                    for(s6 = d.length - 1; (s6--) && d[s6] === d[s6 + 1];);
                    s6 > -1 && n || (i[e + t] = -1 === s6 ? d[0] : d.join(" "), delete i[e + "-top" + t], delete i[e + "-right" + t], delete i[e + "-bottom" + t], delete i[e + "-left" + t]);
                }, h = (e)=>{
                    let t, n = i[e];
                    if (n) {
                        for(n = n.split(" "), t = n.length; t--;)if (n[t] !== n[0]) return !1;
                        return i[e] = n[0], !0;
                    }
                }, b = (e)=>(m = !0, a5[e])
                , v = (e90, t)=>(m && (e90 = e90.replace(/\uFEFF[0-9]/g, (e)=>a5[e]
                    )), t || (e90 = e90.replace(/\\([\'\";:])/g, "$1")), e90)
                , y = (e)=>String.fromCharCode(parseInt(e.slice(1), 16))
                , C = (e)=>e.replace(/\\[0-9a-f]+/gi, y)
                , x = (t, n, o, r, s, a)=>{
                    if (s = s || a) return "'" + (s = v(s)).replace(/\'/g, "\\'") + "'";
                    if (n = v(n || o || r), !e89.allow_script_urls) {
                        const t = n.replace(/[\s\r\n]+/g, "");
                        if (/(java|vb)script:/i.test(t)) return "";
                        if (!e89.allow_svg_data_urls && /^data:image\/svg/i.test(t)) return "";
                    }
                    return f && (n = f.call(g, n, "style")), "url('" + n.replace(/\'/g, "\\'") + "')";
                };
                if (t51) {
                    for(t51 = (t51 = t51.replace(/[\u0000-\u001F]/g, "")).replace(/\\[\"\';:\uFEFF]/g, b).replace(/\"[^\"]+\"|\'[^\']+\'/g, (e)=>e.replace(/[;:]/g, b)
                    ); l5 = o10.exec(t51);)if (o10.lastIndex = l5.index + l5[0].length, d4 = l5[1].replace(r8, "").toLowerCase(), u = l5[2].replace(r8, ""), d4 && u) {
                        if (d4 = C(d4), u = C(u), -1 !== d4.indexOf("\ufeff") || -1 !== d4.indexOf('"')) continue;
                        if (!e89.allow_script_urls && ("behavior" === d4 || /expression\s*\(|\/\*|\*\//.test(u))) continue;
                        "font-weight" === d4 && "700" === u ? u = "bold" : "color" !== d4 && "background-color" !== d4 || (u = u.toLowerCase()), u = u.replace(n17, x), i[d4] = m ? v(u, !0) : u;
                    }
                    p("border", "", !0), p("border", "-width"), p("border", "-color"), p("border", "-style"), p("padding", ""), p("margin", ""), k = "border-style", S = "border-color", h(w = "border-width") && h(k) && h(S) && (i.border = i[w] + " " + i[k] + " " + i[S], delete i[w], delete i[k], delete i[S]), "medium none" === i.border && delete i.border, "none" === i["border-image"] && delete i["border-image"];
                }
                var w, k, S;
                return i;
            },
            serialize: (e91, t52)=>{
                let n18 = "";
                const o11 = (t)=>{
                    let o;
                    const r = i6[t];
                    if (r) for(let s = 0, a = r.length; s < a; s++)t = r[s], o = e91[t], o && (n18 += (n18.length > 0 ? " " : "") + t + ": " + o + ";");
                };
                return t52 && i6 ? (o11("*"), o11(t52)) : fe1(e91, (e92, o)=>{
                    !e92 || l4 && !((e, t)=>{
                        let n = l4["*"];
                        return !(n && n[e] || (n = l4[t], n && n[e]));
                    })(o, t52) || (n18 += (n18.length > 0 ? " " : "") + o + ": " + e92 + ";");
                }), n18;
            }
        };
        return c;
    }, Cs = {
        keyLocation: !0,
        layerX: !0,
        layerY: !0,
        returnValue: !0,
        webkitMovementX: !0,
        webkitMovementY: !0,
        keyIdentifier: !0,
        mozPressure: !0
    }, xs = (e, t)=>{
        const n = null != t ? t : {};
        for(const t53 in e)we1(Cs, t53) || (n[t53] = e[t53]);
        return C1(n.composedPath) && (n.composedPath = ()=>e.composedPath()
        ), n;
    }, ws = (e93, t, n, o)=>{
        var r;
        const s = xs(t, o);
        return s.type = e93, y1(s.target) && (s.target = null !== (r = s.srcElement) && void 0 !== r ? r : n), ((e94)=>y1(e94.preventDefault) || ((e)=>e instanceof Event || x1(e.initEvent)
            )(e94)
        )(t) && (s.preventDefault = ()=>{
            s.defaultPrevented = !0, s.isDefaultPrevented = P1, x1(t.preventDefault) && t.preventDefault();
        }, s.stopPropagation = ()=>{
            s.cancelBubble = !0, s.isPropagationStopped = P1, x1(t.stopPropagation) && t.stopPropagation();
        }, s.stopImmediatePropagation = ()=>{
            s.isImmediatePropagationStopped = P1, s.stopPropagation();
        }, ((e)=>e.isDefaultPrevented === P1 || e.isDefaultPrevented === L1
        )(s) || (s.isDefaultPrevented = !0 === s.defaultPrevented ? P1 : L1, s.isPropagationStopped = !0 === s.cancelBubble ? P1 : L1, s.isImmediatePropagationStopped = L1)), s;
    }, ks = /^(?:mouse|contextmenu)|click/, Ss = (e, t, n, o)=>{
        e.addEventListener ? e.addEventListener(t, n, o || !1) : e.attachEvent && e.attachEvent("on" + t, n);
    }, _s = (e, t, n, o)=>{
        e.removeEventListener ? e.removeEventListener(t, n, o || !1) : e.detachEvent && e.detachEvent("on" + t, n);
    }, Es = (e95, t)=>{
        const n = ws(e95.type, e95, document, t);
        if (((e)=>C1(e) && ks.test(e.type)
        )(e95) && v1(e95.pageX) && !v1(e95.clientX)) {
            const t = n.target.ownerDocument || document, o = t.documentElement, r = t.body, s = n;
            s.pageX = e95.clientX + (o && o.scrollLeft || r && r.scrollLeft || 0) - (o && o.clientLeft || r && r.clientLeft || 0), s.pageY = e95.clientY + (o && o.scrollTop || r && r.scrollTop || 0) - (o && o.clientTop || r && r.clientTop || 0);
        }
        return n;
    }, Ns = (e, t, n)=>{
        const o = e.document, r = {
            type: "ready"
        };
        if (n.domLoaded) return void t(r);
        const s = ()=>{
            _s(e, "DOMContentLoaded", s), _s(e, "load", s), n.domLoaded || (n.domLoaded = !0, t(r)), e = null;
        };
        "complete" === o.readyState || "interactive" === o.readyState && o.body ? s() : Ss(e, "DOMContentLoaded", s), n.domLoaded || Ss(e, "load", s);
    };
    class Rs {
        constructor(){
            this.domLoaded = !1, this.events = {}, this.count = 1, this.expando = "mce-data-" + (+new Date).toString(32), this.hasMouseEnterLeave = "onmouseenter" in document.documentElement, this.hasFocusIn = "onfocusin" in document.documentElement, this.count = 1;
        }
        bind(e96, t54, n19, o) {
            const r = this;
            let s, a, i, l, d, c, u;
            const m = window, f = (e)=>{
                r.executeHandlers(Es(e || m.event), s);
            };
            if (!e96 || 3 === e96.nodeType || 8 === e96.nodeType) return;
            e96[r.expando] ? s = e96[r.expando] : (s = r.count++, e96[r.expando] = s, r.events[s] = {}), o = o || e96;
            const g = t54.split(" ");
            for(i = g.length; i--;)l = g[i], c = f, d = u = !1, "DOMContentLoaded" === l && (l = "ready"), r.domLoaded && "ready" === l && "complete" === e96.readyState ? n19.call(o, Es({
                type: l
            })) : (r.hasMouseEnterLeave || (d = r.mouseEnterLeave[l], d && (c = (e)=>{
                const t = e.currentTarget;
                let n = e.relatedTarget;
                if (n && t.contains) n = t.contains(n);
                else for(; n && n !== t;)n = n.parentNode;
                n || ((e = Es(e || m.event)).type = "mouseout" === e.type ? "mouseleave" : "mouseenter", e.target = t, r.executeHandlers(e, s));
            })), r.hasFocusIn || "focusin" !== l && "focusout" !== l || (u = !0, d = "focusin" === l ? "focus" : "blur", c = (e)=>{
                (e = Es(e || m.event)).type = "focus" === e.type ? "focusin" : "focusout", r.executeHandlers(e, s);
            }), a = r.events[s][l], a ? "ready" === l && r.domLoaded ? n19(Es({
                type: l
            })) : a.push({
                func: n19,
                scope: o
            }) : (r.events[s][l] = a = [
                {
                    func: n19,
                    scope: o
                }
            ], a.fakeName = d, a.capture = u, a.nativeHandler = c, "ready" === l ? Ns(e96, c, r) : Ss(e96, d || l, c, u)));
            return e96 = a = null, n19;
        }
        unbind(e, t55, n20) {
            let o, r, s, a, i;
            if (!e || 3 === e.nodeType || 8 === e.nodeType) return this;
            const l = e[this.expando];
            if (l) {
                if (i = this.events[l], t55) {
                    const l = t55.split(" ");
                    for(r = l.length; r--;)if (a = l[r], o = i[a], o) {
                        if (n20) {
                            for(s = o.length; s--;)if (o[s].func === n20) {
                                const e = o.nativeHandler, t = o.fakeName, n = o.capture;
                                o = o.slice(0, s).concat(o.slice(s + 1)), o.nativeHandler = e, o.fakeName = t, o.capture = n, i[a] = o;
                            }
                        }
                        n20 && 0 !== o.length || (delete i[a], _s(e, o.fakeName || a, o.nativeHandler, o.capture));
                    }
                } else fe1(i, (t, n)=>{
                    _s(e, t.fakeName || n, t.nativeHandler, t.capture);
                }), i = {};
                for(a in i)if (we1(i, a)) return this;
                delete this.events[l];
                try {
                    delete e[this.expando];
                } catch (t) {
                    e[this.expando] = null;
                }
            }
            return this;
        }
        fire(e, t, n) {
            return this.dispatch(e, t, n);
        }
        dispatch(e, t, n) {
            let o;
            if (!e || 3 === e.nodeType || 8 === e.nodeType) return this;
            const r = Es({
                type: t,
                target: e
            }, n);
            do o = e[this.expando], o && this.executeHandlers(r, o), e = e.parentNode || e.ownerDocument || e.defaultView || e.parentWindow;
            while (e && !r.isPropagationStopped())
            return this;
        }
        clean(e) {
            let t, n;
            if (!e || 3 === e.nodeType || 8 === e.nodeType) return this;
            if (e[this.expando] && this.unbind(e), e.getElementsByTagName || (e = e.document), e && e.getElementsByTagName) for(this.unbind(e), n = e.getElementsByTagName("*"), t = n.length; t--;)(e = n[t])[this.expando] && this.unbind(e);
            return this;
        }
        destroy() {
            this.events = {};
        }
        cancel(e) {
            return e && (e.preventDefault(), e.stopImmediatePropagation()), !1;
        }
        executeHandlers(e, t) {
            const n = this.events[t], o = n && n[e.type];
            if (o) for(let t56 = 0, n21 = o.length; t56 < n21; t56++){
                const n = o[t56];
                if (n && !1 === n.func.call(n.scope, e) && e.preventDefault(), e.isImmediatePropagationStopped()) return;
            }
        }
    }
    Rs.Event = new Rs;
    const As = Bt.each, Os = Bt.grep, Ts = "data-mce-style", Bs = (e, t, n)=>{
        y1(n) || "" === n ? Yt(e, t) : $t(e, t, n);
    }, Ds = (e, t)=>{
        const n = Wt(t, "style"), o = e.serialize(e.parse(n), Mt(t));
        Bs(t, Ts, o);
    }, Ls = (e, t)=>{
        let n, o, r = 0;
        if (e) for(n = e.nodeType, e = e.previousSibling; e; e = e.previousSibling)o = e.nodeType, (!t || 3 !== o || o !== n && e.nodeValue.length) && (r++, n = o);
        return r;
    }, Ps = Bt.makeMap("fill-opacity font-weight line-height opacity orphans widows z-index zoom", " "), Ms = (e97)=>e97.replace(/[A-Z]/g, (e)=>"-" + e.toLowerCase()
        )
    , Is = (e98, t57 = {})=>{
        const n22 = {}, o12 = window, r9 = {};
        let s7 = 0;
        const a6 = Yo.forElement(mn(e98), {
            contentCssCors: t57.contentCssCors,
            referrerPolicy: t57.referrerPolicy
        }), i = [], l = t57.schema ? t57.schema : vs({}), d = ys({
            url_converter: t57.url_converter,
            url_converter_scope: t57.url_converter_scope
        }, t57.schema), c = t57.ownEvents ? new Rs : Rs.Event, u = l.getBlockElements(), g = (t)=>t && e98 && m1(t) ? e98.getElementById(t) : t
        , h = (e)=>{
            const t = g(e);
            return C1(t) ? mn(t) : null;
        }, b = (e, t, n)=>{
            let o;
            const r = h(e);
            if (C1(r) && Ut(r)) {
                const e = J[t];
                o = e && e.get ? e.get(r.dom, t) : Wt(r, t);
            }
            return C1(o) ? o : null != n ? n : "";
        }, v = (e)=>{
            const t = g(e);
            return y1(t) ? [] : t.attributes;
        }, k = (e99, n, o)=>{
            L(e99, (e)=>{
                if (yo(e)) {
                    const r = mn(e);
                    "" === o && (o = null);
                    const s = Wt(r, n), a = J[n];
                    a && a.set ? a.set(r.dom, o, n) : Bs(r, n, o), s !== o && t57.onSetAttrib && t57.onSetAttrib({
                        attrElm: r,
                        attrName: n,
                        attrValue: o
                    });
                }
            });
        }, _ = ()=>t57.root_element || e98.body
        , E = (t58, n23)=>((e100, t59, n24)=>{
                let o13 = 0, r10 = 0;
                const s = e100.ownerDocument;
                if (n24 = n24 || e100, t59) {
                    if (n24 === e100 && t59.getBoundingClientRect && "static" === $n(mn(e100), "position")) {
                        const n = t59.getBoundingClientRect();
                        return o13 = n.left + (s.documentElement.scrollLeft || e100.scrollLeft) - s.documentElement.clientLeft, r10 = n.top + (s.documentElement.scrollTop || e100.scrollTop) - s.documentElement.clientTop, {
                            x: o13,
                            y: r10
                        };
                    }
                    let a = t59;
                    for(; a && a !== n24 && a.nodeType && !jo(a, n24);){
                        const e = a;
                        o13 += e.offsetLeft || 0, r10 += e.offsetTop || 0, a = e.offsetParent;
                    }
                    for(a = t59.parentNode; a && a !== n24 && a.nodeType && !jo(a, n24);)o13 -= a.scrollLeft || 0, r10 -= a.scrollTop || 0, a = a.parentNode;
                    r10 += ((e101)=>Uo.isFirefox() && "table" === Mt(e101) ? zo(Nn(e101)).filter((e)=>"caption" === Mt(e)
                        ).bind((e)=>zo(En(e)).map((t)=>{
                                const n = t.dom.offsetTop, o = e.dom.offsetTop, r = e.dom.offsetHeight;
                                return n <= o ? -r : 0;
                            })
                        ).getOr(0) : 0
                    )(mn(t59));
                }
                return {
                    x: o13,
                    y: r10
                };
            })(e98.body, g(t58), n23)
        , R = (e102, n25, o14)=>{
            const r11 = (e, t)=>m1(e) ? e : w1(e) ? we1(Ps, t) ? e + "" : e + "px" : ge1(e, r11)
            , s = (e, t, n)=>{
                const o = Ms(t);
                y1(n) || "" === n ? Gn(e, o) : Vn(e, o, r11(n, o));
            };
            L(e102, (e103)=>{
                const r = mn(e103);
                m1(n25) ? s(r, n25, o14) : fe1(n25, (e, t)=>{
                    s(r, t, e);
                }), t57.update_styles && Ds(d, r);
            });
        }, A = (e, t60, n)=>{
            const o = g(e);
            if (!y1(o) && yo(o)) return n ? $n(mn(o), Ms(t60)) : ("float" === (t60 = t60.replace(/-(\D)/g, (e, t)=>t.toUpperCase()
            )) && (t60 = "cssFloat"), o.style ? o.style[t60] : void 0);
        }, O = (e)=>{
            let t, n;
            const o = g(e);
            return t = A(o, "width"), n = A(o, "height"), -1 === t.indexOf("px") && (t = 0), -1 === n.indexOf("px") && (n = 0), {
                w: parseInt(t, 10) || o.offsetWidth || o.clientWidth,
                h: parseInt(n, 10) || o.offsetHeight || o.clientHeight
            };
        }, T = (e104, t)=>{
            if (!e104) return !1;
            const n = p1(e104) ? e104 : [
                e104
            ];
            return V1(n, (e)=>pn(mn(e), t)
            );
        }, B = (e105, t, n, o)=>{
            const r = [];
            let s, a = g(e105);
            for(o = void 0 === o, n = n || ("BODY" !== _().nodeName ? _().parentNode : null), m1(t) && (s = t, t = "*" === t ? yo : (e)=>T(e, s)
            ); a && !(a === n || y1(a.nodeType) || To(a) || Bo(a));){
                if (!t || t(a)) {
                    if (!o) return [
                        a
                    ];
                    r.push(a);
                }
                a = a.parentNode;
            }
            return o ? r : null;
        }, D = (e106, t, n)=>{
            let o = t;
            if (e106) {
                for(m1(t) && (o = (e)=>T(e, t)
                ), e106 = e106[n]; e106; e106 = e106[n])if (x1(o) && o(e106)) return e106;
            }
            return null;
        }, L = function(e, t, n26) {
            const o = null != n26 ? n26 : this, r12 = m1(e) ? g(e) : e;
            if (!r12) return !1;
            if (p1(r12) && (r12.length || 0 === r12.length)) {
                const e = [];
                return As(r12, (n, r)=>{
                    n && e.push(t.call(o, m1(n) ? g(n) : n, r));
                }), e;
            }
            return t.call(o, r12);
        }, P = (e107, t61)=>{
            L(e107, (e)=>{
                fe1(t61, (t, n)=>{
                    k(e, n, t);
                });
            });
        }, M = (e108, t)=>{
            L(e108, (e)=>{
                const n = mn(e);
                ro(n, t);
            });
        }, I = (t62, n, o, r, s)=>L(t62, (t)=>{
                const a = m1(n) ? e98.createElement(n) : n;
                return C1(o) && P(a, o), r && (!m1(r) && r.nodeType ? a.appendChild(r) : m1(r) && M(a, r)), s ? a : t.appendChild(a);
            })
        , F = (t, n, o)=>I(e98.createElement(t), t, n, o, !0)
        , U = ls.encodeAllRaw, z = (e109, t)=>L(e109, (e110)=>{
                const n = mn(e110);
                return t && $1(Nn(n), (e)=>{
                    zt(e) && 0 === e.dom.length ? to(e) : Yn(n, e);
                }), to(n), n.dom;
            })
        , H = (e111, t63, n)=>{
            L(e111, (e112)=>{
                if (yo(e112)) {
                    const o = mn(e112), r = t63.split(" ");
                    $1(r, (e113)=>{
                        C1(n) ? (n ? nn : rn)(o, e113) : ((e114, t64)=>{
                            const n = Jt(e114) ? e114.dom.classList.toggle(t64) : ((e, t)=>j1(Zt(e), t) ? tn(e, t) : en(e, t)
                            )(e114, t64);
                            on(e114);
                        })(o, e113);
                    });
                }
            });
        }, q = (e, t65, n)=>L(t65, (t66)=>(p1(t66) && (e = e.cloneNode(!0)), n && As(Os(t66.childNodes), (t)=>{
                    e.appendChild(t);
                }), t66.parentNode.replaceChild(e, t66))
            )
        , W = (e)=>{
            if (yo(e)) {
                const t = "a" === e.nodeName.toLowerCase() && !b(e, "href") && b(e, "id");
                if (b(e, "name") || b(e, "data-mce-bookmark") || t) return !0;
            }
            return !1;
        }, K = ()=>e98.createRange()
        , G = (n, r, s, a)=>{
            if (p1(n)) {
                let e = n.length;
                const t = [];
                for(; e--;)t[e] = G(n[e], r, s, a);
                return t;
            }
            return !t57.collect || n !== e98 && n !== o12 || i.push([
                n,
                r,
                s,
                a
            ]), c.bind(n, r, s, a || Q);
        }, Y = (t, n, r)=>{
            if (p1(t)) {
                let e = t.length;
                const o = [];
                for(; e--;)o[e] = Y(t[e], n, r);
                return o;
            }
            if (i.length > 0 && (t === e98 || t === o12)) {
                let e = i.length;
                for(; e--;){
                    const o = i[e];
                    t !== o[0] || n && n !== o[1] || r && r !== o[2] || c.unbind(o[0], o[1], o[2]);
                }
            }
            return c.unbind(t, n, r);
        }, X = (e)=>{
            if (e && yo(e)) {
                const t = e.getAttribute("data-mce-contenteditable");
                return t && "inherit" !== t ? t : "inherit" !== e.contentEditable ? e.contentEditable : null;
            }
            return null;
        }, Q = {
            doc: e98,
            settings: t57,
            win: o12,
            files: r9,
            stdMode: !0,
            boxModel: !0,
            styleSheetLoader: a6,
            boundEvents: i,
            styles: d,
            schema: l,
            events: c,
            isBlock: (e)=>m1(e) ? we1(u, e) : yo(e) && we1(u, e.nodeName)
            ,
            root: null,
            clone: (e, t)=>e.cloneNode(t)
            ,
            getRoot: _,
            getViewPort: (e)=>{
                const t = ho(e);
                return {
                    x: t.x,
                    y: t.y,
                    w: t.width,
                    h: t.height
                };
            },
            getRect: (e)=>{
                const t = g(e), n = E(t), o = O(t);
                return {
                    x: n.x,
                    y: n.y,
                    w: o.w,
                    h: o.h
                };
            },
            getSize: O,
            getParent: (e, t, n)=>{
                const o = B(e, t, n, !1);
                return o && o.length > 0 ? o[0] : null;
            },
            getParents: B,
            get: g,
            getNext: (e, t)=>D(e, t, "nextSibling")
            ,
            getPrev: (e, t)=>D(e, t, "previousSibling")
            ,
            select: (n, o)=>{
                var r, s;
                const a = null !== (s = null !== (r = g(o)) && void 0 !== r ? r : t57.root_element) && void 0 !== s ? s : e98;
                return de1(a.querySelectorAll(n));
            },
            is: T,
            add: I,
            create: F,
            createHTML: (e, t, n = "")=>{
                let o, r = "";
                for(o in r += "<" + e, t)ke1(t, o) && (r += " " + o + '="' + U(t[o]) + '"');
                return Ke(n) && we1(l.getVoidElements(), e) ? r + " />" : r + ">" + n + "</" + e + ">";
            },
            createFragment: (t)=>{
                let n;
                const o = e98.createElement("div"), r = e98.createDocumentFragment();
                for(r.appendChild(o), t && (o.innerHTML = t); n = o.firstChild;)r.appendChild(n);
                return r.removeChild(o), r;
            },
            remove: z,
            setStyle: R,
            getStyle: A,
            setStyles: (e, t)=>{
                R(e, t);
            },
            removeAllAttribs: (e115)=>L(e115, (e)=>{
                    const t = e.attributes;
                    for(let n = t.length - 1; n >= 0; n--)e.removeAttributeNode(t.item(n));
                })
            ,
            setAttrib: k,
            setAttribs: P,
            getAttrib: b,
            getPos: E,
            parseStyle: (e)=>d.parse(e)
            ,
            serializeStyle: (e, t)=>d.serialize(e, t)
            ,
            addStyle: (t)=>{
                let o, r;
                if (Q !== Is.DOM && e98 === document) {
                    if (n22[t]) return;
                    n22[t] = !0;
                }
                r = e98.getElementById("mceDefaultStyles"), r || (r = e98.createElement("style"), r.id = "mceDefaultStyles", r.type = "text/css", o = e98.getElementsByTagName("head")[0], o.firstChild ? o.insertBefore(r, o.firstChild) : o.appendChild(r)), r.styleSheet ? r.styleSheet.cssText += t : r.appendChild(e98.createTextNode(t));
            },
            loadCSS: (e116)=>{
                e116 || (e116 = ""), $1(e116.split(","), (e)=>{
                    r9[e] = !0, a6.load(e).catch(S1);
                });
            },
            addClass: (e, t)=>{
                H(e, t, !0);
            },
            removeClass: (e, t)=>{
                H(e, t, !1);
            },
            hasClass: (e117, t)=>{
                const n = h(e117), o = t.split(" ");
                return te1(o, (e)=>sn(n, e)
                );
            },
            toggleClass: H,
            show: (e118)=>{
                L(e118, (e)=>Gn(mn(e), "display")
                );
            },
            hide: (e119)=>{
                L(e119, (e)=>Vn(mn(e), "display", "none")
                );
            },
            isHidden: (e)=>{
                const t = h(e);
                return Dt(Wn(t, "display"), "none");
            },
            uniqueId: (e)=>(e || "mce_") + s7++
            ,
            setHTML: M,
            getOuterHTML: (e120)=>{
                const t67 = h(e120);
                return yo(t67.dom) ? t67.dom.outerHTML : ((e)=>{
                    const t = cn("div"), n = mn(e.dom.cloneNode(!0));
                    return Jn(t, n), oo(t);
                })(t67);
            },
            setOuterHTML: (e121, t)=>{
                L(e121, (e)=>{
                    yo(e) && (e.outerHTML = t);
                });
            },
            decode: ls.decode,
            encode: U,
            insertAfter: (e122, t68)=>{
                const n = g(t68);
                return L(e122, (e)=>{
                    const t = n.parentNode, o = n.nextSibling;
                    return o ? t.insertBefore(e, o) : t.appendChild(e), e;
                });
            },
            replace: q,
            rename: (e, t69)=>{
                let n;
                return e.nodeName !== t69.toUpperCase() && (n = F(t69), As(v(e), (t)=>{
                    k(n, t.nodeName, b(e, t.nodeName));
                }), q(n, e, !0)), n || e;
            },
            findCommonAncestor: (e, t)=>{
                let n, o = e;
                for(; o;){
                    for(n = t; n && o !== n;)n = n.parentNode;
                    if (o === n) break;
                    o = o.parentNode;
                }
                return !o && e.ownerDocument ? e.ownerDocument.documentElement : o;
            },
            run: L,
            getAttribs: v,
            isEmpty: (e, t)=>{
                let n, o, r = 0;
                if (W(e)) return !1;
                if (e = e.firstChild) {
                    const s = new Xo(e, e.parentNode), a = l ? l.getWhitespaceElements() : {};
                    t = t || (l ? l.getNonEmptyElements() : null);
                    do {
                        if (n = e.nodeType, yo(e)) {
                            const n = e.getAttribute("data-mce-bogus");
                            if (n) {
                                e = s.next("all" === n);
                                continue;
                            }
                            if (o = e.nodeName.toLowerCase(), t && t[o]) {
                                if ("br" === o) {
                                    r++, e = s.next();
                                    continue;
                                }
                                return !1;
                            }
                            if (W(e)) return !1;
                        }
                        if (8 === n) return !1;
                        if (3 === n && !Fr(e.nodeValue)) return !1;
                        if (3 === n && e.parentNode && a[e.parentNode.nodeName] && Fr(e.nodeValue)) return !1;
                        e = s.next();
                    }while (e)
                }
                return r <= 1;
            },
            createRng: K,
            nodeIndex: Ls,
            split: (e, t, n)=>{
                let o, r, s, a = K();
                if (e && t) return a.setStart(e.parentNode, Ls(e)), a.setEnd(t.parentNode, Ls(t)), o = a.extractContents(), a = K(), a.setStart(t.parentNode, Ls(t) + 1), a.setEnd(e.parentNode, Ls(e) + 1), r = a.extractContents(), s = e.parentNode, s.insertBefore(Gr(Q, o), e), n ? s.insertBefore(n, e) : s.insertBefore(t, e), s.insertBefore(Gr(Q, r), e), z(e), n || t;
            },
            bind: G,
            unbind: Y,
            fire: (e, t, n)=>c.dispatch(e, t, n)
            ,
            dispatch: (e, t, n)=>c.dispatch(e, t, n)
            ,
            getContentEditable: X,
            getContentEditableParent: (e)=>{
                const t = _();
                let n = null;
                for(; e && e !== t && (n = X(e), null === n); e = e.parentNode);
                return n;
            },
            destroy: ()=>{
                if (i.length > 0) {
                    let e = i.length;
                    for(; e--;){
                        const t = i[e];
                        c.unbind(t[0], t[1], t[2]);
                    }
                }
                fe1(r9, (e, t)=>{
                    a6.unload(t), delete r9[t];
                });
            },
            isChildOf: (e, t)=>e === t || t.contains(e)
            ,
            dumpRng: (e)=>"startContainer: " + e.startContainer.nodeName + ", startOffset: " + e.startOffset + ", endContainer: " + e.endContainer.nodeName + ", endOffset: " + e.endOffset
        }, J = ((e123, t70, n27)=>{
            const o15 = t70.keep_values, r13 = {
                set: (e, o, r)=>{
                    const s = mn(e);
                    x1(t70.url_converter) && C1(o) && (o = t70.url_converter.call(t70.url_converter_scope || n27(), o, r, e[0])), Bs(s, "data-mce-" + r, o), Bs(s, r, o);
                },
                get: (e, t)=>{
                    const n = mn(e);
                    return Wt(n, "data-mce-" + t) || Wt(n, t);
                }
            }, s8 = {
                style: {
                    set: (t, n)=>{
                        const r = mn(t);
                        f1(n) ? Hn(r, n) : (o15 && Bs(r, Ts, n), Yt(r, "style"), m1(n) && Hn(r, e123.parse(n)));
                    },
                    get: (t)=>{
                        const n = mn(t), o = Wt(n, Ts) || Wt(n, "style");
                        return e123.serialize(e123.parse(o), Mt(n));
                    }
                }
            };
            return o15 && (s8.href = s8.src = r13), s8;
        })(d, t57, N1(Q));
        return Q;
    };
    Is.DOM = Is(document), Is.nodeIndex = Ls;
    const Fs = Is.DOM;
    class Us {
        constructor(e = {}){
            this.states = {}, this.queue = [], this.scriptLoadedCallbacks = {}, this.queueLoadedCallbacks = [], this.loading = !1, this.settings = e;
        }
        _setReferrerPolicy(e) {
            this.settings.referrerPolicy = e;
        }
        loadScript(e) {
            return new Promise((t, n)=>{
                const o = Fs;
                let r;
                const s = ()=>{
                    o.remove(a), r && (r.onerror = r.onload = r = null);
                }, a = o.uniqueId();
                r = document.createElement("script"), r.id = a, r.type = "text/javascript", r.src = Bt._addCacheSuffix(e), this.settings.referrerPolicy && o.setAttrib(r, "referrerpolicy", this.settings.referrerPolicy), r.onload = ()=>{
                    s(), t();
                }, r.onerror = ()=>{
                    s(), n("Failed to load script: " + e);
                }, (document.getElementsByTagName("head")[0] || document.body).appendChild(r);
            });
        }
        isDone(e) {
            return 2 === this.states[e];
        }
        markDone(e) {
            this.states[e] = 2;
        }
        add(e) {
            const t = this;
            return t.queue.push(e), void 0 === t.states[e] && (t.states[e] = 0), new Promise((n, o)=>{
                t.scriptLoadedCallbacks[e] || (t.scriptLoadedCallbacks[e] = []), t.scriptLoadedCallbacks[e].push({
                    resolve: n,
                    reject: o
                });
            });
        }
        load(e) {
            return this.add(e);
        }
        remove(e) {
            delete this.states[e], delete this.scriptLoadedCallbacks[e];
        }
        loadQueue() {
            const e = this.queue;
            return this.queue = [], this.loadScripts(e);
        }
        loadScripts(e124) {
            const t71 = this, n28 = (e, n)=>{
                xe1(t71.scriptLoadedCallbacks, n).each((t72)=>{
                    $1(t72, (t)=>t[e](n)
                    );
                }), delete t71.scriptLoadedCallbacks[n];
            }, o = (e125)=>{
                const t = K1(e125, (e)=>"rejected" === e.status
                );
                return t.length > 0 ? Promise.reject(ee1(t, ({ reason: e  })=>p1(e) ? e : [
                        e
                    ]
                )) : Promise.resolve();
            }, r = (e126)=>Promise.allSettled(H1(e126, (e)=>2 === t71.states[e] ? (n28("resolve", e), Promise.resolve()) : 3 === t71.states[e] ? (n28("reject", e), Promise.reject(e)) : (t71.states[e] = 1, t71.loadScript(e).then(()=>{
                        t71.states[e] = 2, n28("resolve", e);
                        const s = t71.queue;
                        if (s.length > 0) return t71.queue = [], r(s).then(o);
                    }, ()=>(t71.states[e] = 3, n28("reject", e), Promise.reject(e))
                    ))
                ))
            , s9 = (e127)=>(t71.loading = !0, r(e127).then((e)=>{
                    t71.loading = !1;
                    const n = t71.queueLoadedCallbacks.shift();
                    return M1.from(n).each(D1), o(e);
                }))
            , a = Se1(e124);
            return t71.loading ? new Promise((e, n)=>{
                t71.queueLoadedCallbacks.push(()=>s9(a).then(e, n)
                );
            }) : s9(a);
        }
    }
    Us.ScriptLoader = new Us;
    const zs = (e128)=>{
        let t = e128;
        return {
            get: ()=>t
            ,
            set: (e)=>{
                t = e;
            }
        };
    }, js = {}, Vs = zs("en"), Hs = ()=>xe1(js, Vs.get())
    , $s = {
        getData: ()=>ge1(js, (e)=>({
                    ...e
                })
            )
        ,
        setCode: (e)=>{
            e && Vs.set(e);
        },
        getCode: ()=>Vs.get()
        ,
        add: (e129, t73)=>{
            let n = js[e129];
            n || (js[e129] = n = {}), fe1(t73, (e, t)=>{
                n[t.toLowerCase()] = e;
            });
        },
        translate: (e130)=>{
            const t = Hs().getOr({}), n = (e)=>x1(e) ? Object.prototype.toString.call(e) : o16(e) ? "" : "" + e
            , o16 = (e)=>"" === e || null == e
            , r = (e)=>{
                const o = n(e);
                return xe1(t, o.toLowerCase()).map(n).getOr(o);
            }, s = (e)=>e.replace(/{context:\w+}$/, "")
            ;
            if (o16(e130)) return "";
            if (f1(a = e130) && we1(a, "raw")) return n(e130.raw);
            var a;
            if (((e)=>p1(e) && e.length > 1
            )(e130)) {
                const t = e130.slice(1);
                return s(r(e130[0]).replace(/\{([0-9]+)\}/g, (e, o)=>we1(t, o) ? n(t[o]) : e
                ));
            }
            return s(r(e130));
        },
        isRtl: ()=>Hs().bind((e)=>xe1(e, "_dir")
            ).exists((e)=>"rtl" === e
            )
        ,
        hasCode: (e)=>we1(js, e)
    }, qs = ()=>{
        const e131 = [], t74 = {}, n29 = {}, o17 = [], r = (e132, t)=>{
            const n30 = K1(o17, (n)=>n.name === e132 && n.state === t
            );
            $1(n30, (e)=>e.resolve()
            );
        }, s10 = (e)=>we1(t74, e)
        , a7 = (e, n)=>{
            const o = $s.getCode();
            !o || n && -1 === ("," + (n || "") + ",").indexOf("," + o + ",") || Us.ScriptLoader.add(t74[e] + "/langs/" + o + ".js");
        }, i = (e133, t = "added")=>"added" === t && ((e)=>we1(n29, e)
            )(e133) || "loaded" === t && s10(e133) ? Promise.resolve() : new Promise((n)=>{
                o17.push({
                    name: e133,
                    state: t,
                    resolve: n
                });
            })
        ;
        return {
            items: e131,
            urls: t74,
            lookup: n29,
            get: (e)=>{
                if (n29[e]) return n29[e].instance;
            },
            requireLangPack: (e, t)=>{
                !1 !== qs.languageLoad && (s10(e) ? a7(e, t) : i(e, "loaded").then(()=>a7(e, t)
                ));
            },
            add: (t, o)=>(e131.push(o), n29[t] = {
                    instance: o
                }, r(t, "added"), o)
            ,
            remove: (e)=>{
                delete t74[e], delete n29[e];
            },
            createUrl: (e, t)=>m1(t) ? m1(e) ? {
                    prefix: "",
                    resource: t,
                    suffix: ""
                } : {
                    prefix: e.prefix,
                    resource: t,
                    suffix: e.suffix
                } : t
            ,
            load: (e, o)=>{
                if (t74[e]) return Promise.resolve();
                let s = m1(o) ? o : o.prefix + o.resource + o.suffix;
                0 !== s.indexOf("/") && -1 === s.indexOf("://") && (s = qs.baseURL + "/" + s), t74[e] = s.substring(0, s.lastIndexOf("/"));
                const a = ()=>(r(e, "loaded"), Promise.resolve())
                ;
                return n29[e] ? a() : Us.ScriptLoader.add(s).then(a);
            },
            waitFor: i
        };
    };
    qs.languageLoad = !0, qs.baseURL = "", qs.PluginManager = qs(), qs.ThemeManager = qs(), qs.ModelManager = qs();
    const Ws = ()=>{
        const e134 = ((e135)=>{
            const t = zs(M1.none()), n = ()=>t.get().each(e135)
            ;
            return {
                clear: ()=>{
                    n(), t.set(M1.none());
                },
                isSet: ()=>t.get().isSome()
                ,
                get: ()=>t.get()
                ,
                set: (e)=>{
                    n(), t.set(M1.some(e));
                }
            };
        })(S1);
        return {
            ...e134,
            on: (t)=>e134.get().each(t)
        };
    }, Ks = (e, t)=>{
        let n = null;
        return {
            cancel: ()=>{
                h1(n) || (clearTimeout(n), n = null);
            },
            throttle: (...o)=>{
                h1(n) && (n = setTimeout(()=>{
                    n = null, e.apply(null, o);
                }, t));
            }
        };
    }, Gs = (e, t)=>{
        let n = null;
        const o = ()=>{
            h1(n) || (clearTimeout(n), n = null);
        };
        return {
            cancel: o,
            throttle: (...r)=>{
                o(), n = setTimeout(()=>{
                    n = null, e.apply(null, r);
                }, t);
            }
        };
    }, Ys = (e136, t)=>{
        let n = [];
        return $1(Nn(e136), (e)=>{
            t(e) && (n = n.concat([
                e
            ])), n = n.concat(Ys(e, t));
        }), n;
    }, Xs = (e137, t75)=>((e, t)=>{
            const n = void 0 === t ? document : t.dom;
            return hn(n) ? [] : H1(n.querySelectorAll(e), mn);
        })(t75, e137)
    , Qs = N1("mce-annotation"), Js = N1("data-mce-annotation"), Zs = N1("data-mce-annotation-uid"), ea = N1("data-mce-annotation-active"), ta = (e138, t76)=>{
        const n31 = e138.selection.getRng(), o18 = mn(n31.startContainer), r = mn(e138.getBody()), s = t76.fold(()=>"." + Qs()
        , (e)=>`[${Js()}="${e}"]`
        ), a = Rn(o18, n31.startOffset).getOr(o18), i = Ko(a, s, (e)=>bn(e, r)
        ), l = (e, t)=>Gt(e, t) ? M1.some(Wt(e, t)) : M1.none()
        ;
        return i.bind((t77)=>l(t77, `${Zs()}`).bind((n)=>l(t77, `${Js()}`).map((t)=>{
                    const o = na(e138, n);
                    return {
                        uid: n,
                        name: t,
                        elements: o
                    };
                })
            )
        );
    }, na = (e, t)=>{
        const n = mn(e.getBody());
        return Xs(n, `[${Zs()}="${t}"]`);
    }, oa = (e139, t78)=>{
        const n32 = mn(e139.getBody()), o = Xs(n32, `[${Js()}="${t78}"]`), r = {};
        return $1(o, (e)=>{
            const t = Wt(e, Zs()), n = xe1(r, t).getOr([]);
            r[t] = n.concat([
                e
            ]);
        }), r;
    };
    let ra = 0;
    const sa = (e)=>{
        const t = (new Date).getTime(), n = Math.floor(1000000000 * Math.random());
        return ra++, e + "_" + n + ra + String(t);
    }, aa = (e, t)=>mn(e.dom.cloneNode(t))
    , ia = (e)=>aa(e, !1)
    , la = (e)=>aa(e, !0)
    , da = (e140, t79, n = L1)=>{
        const o = new Xo(e140, t79), r = (e)=>{
            let t;
            do t = o[e]();
            while (t && !No(t) && !n(t))
            return M1.from(t).filter(No);
        };
        return {
            current: ()=>M1.from(o.current()).filter(No)
            ,
            next: ()=>r("next")
            ,
            prev: ()=>r("prev")
            ,
            prev2: ()=>r("prev2")
        };
    }, ca = (e141, t80)=>{
        const n33 = t80 || ((t)=>e141.isBlock(t) || Do(t) || Mo(t)
        ), o = (e142, t, n, r)=>{
            if (No(e142)) {
                const n = r(e142, t, e142.data);
                if (-1 !== n) return M1.some({
                    container: e142,
                    offset: n
                });
            }
            return n().bind((e)=>o(e.container, e.offset, n, r)
            );
        };
        return {
            backwards: (e143, t, r, s)=>{
                const a = da(e143, s, n33);
                return o(e143, t, ()=>a.prev().map((e)=>({
                            container: e,
                            offset: e.length
                        })
                    )
                , r).getOrNull();
            },
            forwards: (e144, t, r, s)=>{
                const a = da(e144, s, n33);
                return o(e144, t, ()=>a.next().map((e)=>({
                            container: e,
                            offset: 0
                        })
                    )
                , r).getOrNull();
            }
        };
    }, ua = Math.round, ma = (e)=>e ? {
            left: ua(e.left),
            top: ua(e.top),
            bottom: ua(e.bottom),
            right: ua(e.right),
            width: ua(e.width),
            height: ua(e.height)
        } : {
            left: 0,
            top: 0,
            bottom: 0,
            right: 0,
            width: 0,
            height: 0
        }
    , fa = (e, t)=>(e = ma(e), t || (e.left = e.left + e.width), e.right = e.left, e.width = 0, e)
    , ga = (e, t, n)=>e >= 0 && e <= Math.min(t.height, n.height) / 2
    , pa = (e, t)=>{
        const n = Math.min(t.height / 2, e.height / 2);
        return e.bottom - n < t.top || !(e.top > t.bottom) && ga(t.top - e.bottom, e, t);
    }, ha = (e, t)=>e.top > t.bottom || !(e.bottom < t.top) && ga(t.bottom - e.top, e, t)
    , ba = (e, t, n)=>{
        const o = Math.max(Math.min(t, e.left + e.width), e.left), r = Math.max(Math.min(n, e.top + e.height), e.top);
        return Math.sqrt((t - o) * (t - o) + (n - r) * (n - r));
    }, va = (e)=>{
        const t = e.startContainer, n = e.startOffset;
        return t.hasChildNodes() && e.endOffset === n + 1 ? t.childNodes[n] : null;
    }, ya = (e145, t)=>{
        if (yo(e145) && e145.hasChildNodes()) {
            const n34 = e145.childNodes, o = ((e, t, n)=>Math.min(Math.max(e, 0), n)
            )(t, 0, n34.length - 1);
            return n34[o];
        }
        return e145;
    }, Ca = new RegExp("[\u0300-\u036f\u0483-\u0487\u0488-\u0489\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u0610-\u061a\u064b-\u065f\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7-\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e3-\u0902\u093a\u093c\u0941-\u0948\u094d\u0951-\u0957\u0962-\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2-\u09e3\u0a01-\u0a02\u0a3c\u0a41-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a70-\u0a71\u0a75\u0a81-\u0a82\u0abc\u0ac1-\u0ac5\u0ac7-\u0ac8\u0acd\u0ae2-\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62-\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c00\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56\u0c62-\u0c63\u0c81\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc-\u0ccd\u0cd5-\u0cd6\u0ce2-\u0ce3\u0d01\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62-\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb-\u0ebc\u0ec8-\u0ecd\u0f18-\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039-\u103a\u103d-\u103e\u1058-\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085-\u1086\u108d\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17b4-\u17b5\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193b\u1a17-\u1a18\u1a1b\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1ab0-\u1abd\u1abe\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80-\u1b81\u1ba2-\u1ba5\u1ba8-\u1ba9\u1bab-\u1bad\u1be6\u1be8-\u1be9\u1bed\u1bef-\u1bf1\u1c2c-\u1c33\u1c36-\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1cf4\u1cf8-\u1cf9\u1dc0-\u1df5\u1dfc-\u1dff\u200c-\u200d\u20d0-\u20dc\u20dd-\u20e0\u20e1\u20e2-\u20e4\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302d\u302e-\u302f\u3099-\u309a\ua66f\ua670-\ua672\ua674-\ua67d\ua69e-\ua69f\ua6f0-\ua6f1\ua802\ua806\ua80b\ua825-\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\ua9e5\uaa29-\uaa2e\uaa31-\uaa32\uaa35-\uaa36\uaa43\uaa4c\uaa7c\uaab0\uaab2-\uaab4\uaab7-\uaab8\uaabe-\uaabf\uaac1\uaaec-\uaaed\uaaf6\uabe5\uabe8\uabed\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\uff9e-\uff9f]"), xa = (e)=>"string" == typeof e && e.charCodeAt(0) >= 768 && Ca.test(e)
    , wa = yo, ka = Lr, Sa = xo("display", "block table"), _a = xo("float", "left right"), Ea = ((...e)=>(t)=>{
            for(let n = 0; n < e.length; n++)if (!e[n](t)) return !1;
            return !0;
        }
    )(wa, ka, T1(_a)), Na = T1(xo("white-space", "pre pre-line pre-wrap")), Ra = No, Aa = Do, Oa = Is.nodeIndex, Ta = (e, t)=>t < 0 && yo(e) && e.hasChildNodes() ? void 0 : ya(e, t)
    , Ba = (e)=>"createRange" in e ? e.createRange() : Is.DOM.createRng()
    , Da = (e)=>e && /[\r\n\t ]/.test(e)
    , La = (e)=>!!e.setStart && !!e.setEnd
    , Pa = (e)=>{
        const t = e.startContainer, n = e.startOffset;
        if (Da(e.toString()) && Na(t.parentNode) && No(t)) {
            const e = t.data;
            if (Da(e[n - 1]) || Da(e[n + 1])) return !0;
        }
        return !1;
    }, Ma = (e)=>0 === e.left && 0 === e.right && 0 === e.top && 0 === e.bottom
    , Ia = (e146)=>{
        let t81;
        const n36 = e146.getClientRects();
        return t81 = n36.length > 0 ? ma(n36[0]) : ma(e146.getBoundingClientRect()), !La(e146) && Aa(e146) && Ma(t81) ? ((e)=>{
            const t = e.ownerDocument, n = Ba(t), o = t.createTextNode(dr), r = e.parentNode;
            r.insertBefore(o, e), n.setStart(o, 0), n.setEnd(o, 1);
            const s = ma(n.getBoundingClientRect());
            return r.removeChild(o), s;
        })(e146) : Ma(t81) && La(e146) ? ((e)=>{
            const t = e.startContainer, n = e.endContainer, o = e.startOffset, r = e.endOffset;
            if (t === n && No(n) && 0 === o && 1 === r) {
                const t = e.cloneRange();
                return t.setEndAfter(n), Ia(t);
            }
            return null;
        })(e146) : t81;
    }, Fa = (e, t)=>{
        const n = fa(e, t);
        return n.width = 1, n.right = n.left + 1, n;
    }, Ua = (e147, t82, n37)=>{
        const o19 = ()=>(n37 || (n37 = ((e148)=>{
                const t = [], n38 = (e)=>{
                    var n, o;
                    0 !== e.height && (t.length > 0 && (n = e, o = t[t.length - 1], n.left === o.left && n.top === o.top && n.bottom === o.bottom && n.right === o.right) || t.push(e));
                }, o20 = (e, o)=>{
                    const r = Ba(e.ownerDocument);
                    if (o < e.data.length) {
                        if (xa(e.data[o])) return t;
                        if (xa(e.data[o - 1]) && (r.setStart(e, o), r.setEnd(e, o + 1), !Pa(r))) return n38(Fa(Ia(r), !1)), t;
                    }
                    o > 0 && (r.setStart(e, o - 1), r.setEnd(e, o), Pa(r) || n38(Fa(Ia(r), !1))), o < e.data.length && (r.setStart(e, o), r.setEnd(e, o + 1), Pa(r) || n38(Fa(Ia(r), !0)));
                }, r14 = e148.container(), s = e148.offset();
                if (Ra(r14)) return o20(r14, s), t;
                if (wa(r14)) {
                    if (e148.isAtEnd()) {
                        const e = Ta(r14, s);
                        Ra(e) && o20(e, e.data.length), Ea(e) && !Aa(e) && n38(Fa(Ia(e), !1));
                    } else {
                        const a = Ta(r14, s);
                        if (Ra(a) && o20(a, 0), Ea(a) && e148.isAtEnd()) return n38(Fa(Ia(a), !1)), t;
                        const i = Ta(e148.container(), e148.offset() - 1);
                        Ea(i) && !Aa(i) && (Sa(i) || Sa(a) || !Ea(a)) && n38(Fa(Ia(i), !1)), Ea(a) && n38(Fa(Ia(a), !0));
                    }
                }
                return t;
            })(Ua(e147, t82))), n37)
        ;
        return {
            container: N1(e147),
            offset: N1(t82),
            toRange: ()=>{
                const n = Ba(e147.ownerDocument);
                return n.setStart(e147, t82), n.setEnd(e147, t82), n;
            },
            getClientRects: o19,
            isVisible: ()=>o19().length > 0
            ,
            isAtStart: ()=>(Ra(e147), 0 === t82)
            ,
            isAtEnd: ()=>Ra(e147) ? t82 >= e147.data.length : t82 >= e147.childNodes.length
            ,
            isEqual: (n)=>n && e147 === n.container() && t82 === n.offset()
            ,
            getNode: (n)=>Ta(e147, n ? t82 - 1 : t82)
        };
    };
    Ua.fromRangeStart = (e)=>Ua(e.startContainer, e.startOffset)
    , Ua.fromRangeEnd = (e)=>Ua(e.endContainer, e.endOffset)
    , Ua.after = (e)=>Ua(e.parentNode, Oa(e) + 1)
    , Ua.before = (e)=>Ua(e.parentNode, Oa(e))
    , Ua.isAbove = (e, t)=>Lt(ie1(t.getClientRects()), le1(e.getClientRects()), pa).getOr(!1)
    , Ua.isBelow = (e, t)=>Lt(le1(t.getClientRects()), ie1(e.getClientRects()), ha).getOr(!1)
    , Ua.isAtStart = (e)=>!!e && e.isAtStart()
    , Ua.isAtEnd = (e)=>!!e && e.isAtEnd()
    , Ua.isTextPosition = (e)=>!!e && No(e.container())
    , Ua.isElementPosition = (e)=>!1 === Ua.isTextPosition(e)
    ;
    const za = (e, t)=>{
        No(t) && 0 === t.data.length && e.remove(t);
    }, ja = (e149, t83, n39)=>{
        Bo(n39) ? ((e, t84, n)=>{
            const o = M1.from(n.firstChild), r = M1.from(n.lastChild);
            t84.insertNode(n), o.each((t)=>za(e, t.previousSibling)
            ), r.each((t)=>za(e, t.nextSibling)
            );
        })(e149, t83, n39) : ((e, t, n)=>{
            t.insertNode(n), za(e, n.previousSibling), za(e, n.nextSibling);
        })(e149, t83, n39);
    }, Va = No, Ha = ko, $a = Is.nodeIndex, qa = (e)=>{
        const t = e.parentNode;
        return Ha(t) ? qa(t) : t;
    }, Wa = (e150)=>e150 ? Oe1(e150.childNodes, (e, t)=>(Ha(t) && "BR" !== t.nodeName ? e = e.concat(Wa(t)) : e.push(t), e)
        , []) : []
    , Ka = (e)=>(t)=>e === t
    , Ga = (e151)=>{
        let t85;
        return t85 = Va(e151) ? "text()" : e151.nodeName.toLowerCase(), t85 + "[" + ((e152)=>{
            let t, n40;
            t = Wa(qa(e152)), n40 = Te1(t, Ka(e152), e152), t = t.slice(0, n40 + 1);
            const o21 = Oe1(t, (e, n, o)=>(Va(n) && Va(t[o - 1]) && e++, e)
            , 0);
            return t = Re1(t, Co([
                e152.nodeName
            ])), n40 = Te1(t, Ka(e152), e152), n40 - o21;
        })(e151) + "]";
    }, Ya = (e153, t86)=>{
        let n, o22, r, s, a, i = [];
        return n = t86.container(), o22 = t86.offset(), Va(n) ? r = ((e, t)=>{
            for(; (e = e.previousSibling) && Va(e);)t += e.data.length;
            return t;
        })(n, o22) : (s = n.childNodes, o22 >= s.length ? (r = "after", o22 = s.length - 1) : r = "before", n = s[o22]), i.push(Ga(n)), a = ((e, t, n)=>{
            const o = [];
            for(t = t.parentNode; t !== e; t = t.parentNode)o.push(t);
            return o;
        })(e153, n), a = Re1(a, T1(ko)), i = i.concat(Ne1(a, (e)=>Ga(e)
        )), i.reverse().join("/") + "," + r;
    }, Xa = (e154, t87)=>{
        let n41;
        if (!t87) return null;
        const o23 = t87.split(","), r15 = o23[0].split("/");
        n41 = o23.length > 1 ? o23[1] : "before";
        const s = Oe1(r15, (e155, t88)=>{
            const n42 = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(t88);
            return n42 ? ("text()" === n42[1] && (n42[1] = "#text"), ((e156, t89, n)=>{
                let o = Wa(e156);
                return o = Re1(o, (e, t)=>!Va(e) || !Va(o[t - 1])
                ), o = Re1(o, Co([
                    t89
                ])), o[n];
            })(e155, n42[1], parseInt(n42[2], 10))) : null;
        }, e154);
        return s ? Va(s) ? ((e, t)=>{
            let n, o = e, r = 0;
            for(; Va(o);){
                if (n = o.data.length, t >= r && t <= r + n) {
                    e = o, t -= r;
                    break;
                }
                if (!Va(o.nextSibling)) {
                    e = o, t = n;
                    break;
                }
                r += n, o = o.nextSibling;
            }
            return Va(e) && t > e.data.length && (t = e.data.length), Ua(e, t);
        })(s, parseInt(n41, 10)) : (n41 = "after" === n41 ? $a(s) + 1 : $a(s), Ua(s.parentNode, n41)) : null;
    }, Qa = Mo, Ja = (e157, t90, n43, o24, r16)=>{
        let s = o24[r16 ? "startContainer" : "endContainer"], a = o24[r16 ? "startOffset" : "endOffset"];
        const i = [];
        let l, d = 0;
        const c = e157.getRoot();
        for(No(s) ? i.push(n43 ? ((e, t, n)=>{
            let o, r;
            for(r = e(t.data.slice(0, n)).length, o = t.previousSibling; o && No(o); o = o.previousSibling)r += e(o.data).length;
            return r;
        })(t90, s, a) : a) : (l = s.childNodes, a >= l.length && l.length && (d = 1, a = Math.max(0, l.length - 1)), i.push(e157.nodeIndex(l[a], n43) + d)); s && s !== c; s = s.parentNode)i.push(e157.nodeIndex(s, n43));
        return i;
    }, Za = (e158, t, n)=>{
        let o = 0;
        return Bt.each(e158.select(t), (e)=>{
            if ("all" !== e.getAttribute("data-mce-bogus")) return e !== n && void o++;
        }), o;
    }, ei = (e, t)=>{
        let n, o, r;
        const s = t ? "start" : "end";
        n = e[s + "Container"], o = e[s + "Offset"], yo(n) && "TR" === n.nodeName && (r = n.childNodes, n = r[Math.min(t ? o : o - 1, r.length - 1)], n && (o = t ? 0 : n.childNodes.length, e["set" + (t ? "Start" : "End")](n, o)));
    }, ti = (e)=>(ei(e, !0), ei(e, !1), e)
    , ni = (e, t)=>{
        let n;
        if (yo(e) && (e = ya(e, t), Qa(e))) return e;
        if (vr(e)) {
            if (No(e) && hr(e) && (e = e.parentNode), n = e.previousSibling, Qa(n)) return n;
            if (n = e.nextSibling, Qa(n)) return n;
        }
    }, oi = (e159, t91, n44)=>{
        const o25 = n44.getNode();
        let r17 = o25 ? o25.nodeName : null;
        const s11 = n44.getRng();
        if (Qa(o25) || "IMG" === r17) return {
            name: r17,
            index: Za(n44.dom, r17, o25)
        };
        const a = ((e)=>ni(e.startContainer, e.startOffset) || ni(e.endContainer, e.endOffset)
        )(s11);
        return a ? (r17 = a.tagName, {
            name: r17,
            index: Za(n44.dom, r17, a)
        }) : ((e, t, n, o)=>{
            const r = t.dom, s = {};
            return s.start = Ja(r, e, n, o, !0), t.isCollapsed() || (s.end = Ja(r, e, n, o, !1)), _r(o) && (s.isFakeCaret = !0), s;
        })(e159, n44, t91, s11);
    }, ri = (e, t, n)=>{
        const o = {
            "data-mce-type": "bookmark",
            id: t,
            style: "overflow:hidden;line-height:0px"
        };
        return n ? e.create("span", o, "&#xFEFF;") : e.create("span", o);
    }, si = (e, t)=>{
        const n = e.dom;
        let o = e.getRng();
        const r = n.uniqueId(), s = e.isCollapsed(), a = e.getNode(), i = a.nodeName;
        if ("IMG" === i) return {
            name: i,
            index: Za(n, i, a)
        };
        const l = ti(o.cloneRange());
        if (!s) {
            l.collapse(!1);
            const e = ri(n, r + "_end", t);
            ja(n, l, e);
        }
        o = ti(o), o.collapse(!0);
        const d = ri(n, r + "_start", t);
        return ja(n, o, d), e.moveToBookmark({
            id: r,
            keep: !0
        }), {
            id: r
        };
    }, ai = O1(oi, R1, !0), ii = (e)=>{
        const t92 = (t)=>t(e)
        , n45 = N1(e), o = ()=>r
        , r = {
            tag: !0,
            inner: e,
            fold: (t, n)=>n(e)
            ,
            isValue: P1,
            isError: L1,
            map: (t)=>di.value(t(e))
            ,
            mapError: o,
            bind: t92,
            exists: t92,
            forall: t92,
            getOr: n45,
            or: o,
            getOrThunk: n45,
            orThunk: o,
            getOrDie: n45,
            each: (t)=>{
                t(e);
            },
            toOptional: ()=>M1.some(e)
        };
        return r;
    }, li = (e)=>{
        const t93 = ()=>n
        , n = {
            tag: !1,
            inner: e,
            fold: (t, n)=>t(e)
            ,
            isValue: L1,
            isError: P1,
            map: t93,
            mapError: (t)=>di.error(t(e))
            ,
            bind: t93,
            exists: L1,
            forall: P1,
            getOr: R1,
            or: R1,
            getOrThunk: B1,
            orThunk: B1,
            getOrDie: (o = String(e), ()=>{
                throw new Error(o);
            }),
            each: S1,
            toOptional: M1.none
        };
        var o;
        return n;
    }, di = {
        value: ii,
        error: li,
        fromOption: (e, t)=>e.fold(()=>li(t)
            , ii)
    }, ci = (e160)=>{
        if (!p1(e160)) throw new Error("cases must be an array");
        if (0 === e160.length) throw new Error("there must be at least one case");
        const t94 = [], n46 = {};
        return $1(e160, (o26, r)=>{
            const s = ue1(o26);
            if (1 !== s.length) throw new Error("one and only one name per case");
            const a = s[0], i = o26[a];
            if (void 0 !== n46[a]) throw new Error("duplicate key detected:" + a);
            if ("cata" === a) throw new Error("cannot have a case named cata (sorry)");
            if (!p1(i)) throw new Error("case arguments must be an array");
            t94.push(a), n46[a] = (...n)=>{
                const o27 = n.length;
                if (o27 !== i.length) throw new Error("Wrong number of arguments to case " + a + ". Expected " + i.length + " (" + i + "), got " + o27);
                return {
                    fold: (...t)=>{
                        if (t.length !== e160.length) throw new Error("Wrong number of arguments to fold. Expected " + e160.length + ", got " + t.length);
                        return t[r].apply(null, n);
                    },
                    match: (e161)=>{
                        const o = ue1(e161);
                        if (t94.length !== o.length) throw new Error("Wrong number of arguments to match. Expected: " + t94.join(",") + "\nActual: " + o.join(","));
                        if (!te1(t94, (e)=>j1(o, e)
                        )) throw new Error("Not all branches were specified when using match. Specified: " + o.join(", ") + "\nRequired: " + t94.join(", "));
                        return e161[a].apply(null, n);
                    },
                    log: (e)=>{
                        console.log(e, {
                            constructors: t94,
                            constructor: a,
                            params: n
                        });
                    }
                };
            };
        }), n46;
    };
    ci([
        {
            bothErrors: [
                "error1",
                "error2"
            ]
        },
        {
            firstError: [
                "error1",
                "value2"
            ]
        },
        {
            secondError: [
                "value1",
                "error2"
            ]
        },
        {
            bothValues: [
                "value1",
                "value2"
            ]
        }
    ]);
    const ui = (e)=>"inline-command" === e.type || "inline-format" === e.type
    , mi = (e)=>"block-command" === e.type || "block-format" === e.type
    , fi = (e162)=>{
        const t95 = (t)=>di.error({
                message: t,
                pattern: e162
            })
        , n47 = (n, o, r)=>{
            if (void 0 !== e162.format) {
                let r;
                if (p1(e162.format)) {
                    if (!te1(e162.format, m1)) return t95(n + " pattern has non-string items in the `format` array");
                    r = e162.format;
                } else {
                    if (!m1(e162.format)) return t95(n + " pattern has non-string `format` parameter");
                    r = [
                        e162.format
                    ];
                }
                return di.value(o(r));
            }
            return void 0 !== e162.cmd ? m1(e162.cmd) ? di.value(r(e162.cmd, e162.value)) : t95(n + " pattern has non-string `cmd` parameter") : t95(n + " pattern is missing both `format` and `cmd` parameters");
        };
        if (!f1(e162)) return t95("Raw pattern is not an object");
        if (!m1(e162.start)) return t95("Raw pattern is missing `start` parameter");
        if (void 0 !== e162.end) {
            if (!m1(e162.end)) return t95("Inline pattern has non-string `end` parameter");
            if (0 === e162.start.length && 0 === e162.end.length) return t95("Inline pattern has empty `start` and `end` parameters");
            let o = e162.start, r = e162.end;
            return 0 === r.length && (r = o, o = ""), n47("Inline", (e)=>({
                    type: "inline-format",
                    start: o,
                    end: r,
                    format: e
                })
            , (e, t)=>({
                    type: "inline-command",
                    start: o,
                    end: r,
                    cmd: e,
                    value: t
                })
            );
        }
        return void 0 !== e162.replacement ? m1(e162.replacement) ? 0 === e162.start.length ? t95("Replacement pattern has empty `start` parameter") : di.value({
            type: "inline-command",
            start: "",
            end: e162.start,
            cmd: "mceInsertContent",
            value: e162.replacement
        }) : t95("Replacement pattern has non-string `replacement` parameter") : 0 === e162.start.length ? t95("Block pattern has empty `start` parameter") : n47("Block", (t)=>({
                type: "block-format",
                start: e162.start,
                format: t[0]
            })
        , (t, n)=>({
                type: "block-command",
                start: e162.start,
                cmd: t,
                value: n
            })
        );
    }, gi = (e163)=>((e164)=>se1(e164, (e, t)=>e.start.length === t.start.length ? 0 : e.start.length > t.start.length ? -1 : 1
            )
        )(K1(e163, mi))
    , pi = (e)=>K1(e, ui)
    , hi = (e165)=>{
        const t96 = ((e166)=>{
            const t = [], n = [];
            return $1(e166, (e167)=>{
                e167.fold((e)=>{
                    t.push(e);
                }, (e)=>{
                    n.push(e);
                });
            }), {
                errors: t,
                values: n
            };
        })(H1(e165, fi));
        return $1(t96.errors, (e)=>console.error(e.message, e.pattern)
        ), t96.values;
    }, bi = Ct().deviceType, vi = bi.isTouch(), yi = Is.DOM, Ci = (e)=>u1(e, RegExp)
    , xi = (e)=>(t)=>t.options.get(e)
    , wi = (e)=>m1(e) || f1(e)
    , ki = (e168, t97 = "")=>(n48)=>{
            const o28 = m1(n48);
            if (o28) {
                if (-1 !== n48.indexOf("=")) {
                    const r18 = ((e169)=>{
                        const t98 = e169.indexOf("=") > 0 ? e169.split(/[;,](?![^=;,]*(?:[;,]|$))/) : e169.split(",");
                        return Y1(t98, (e, t)=>{
                            const n = t.split("="), o = n[0], r = n.length > 1 ? n[1] : o;
                            return e[He(o)] = He(r), e;
                        }, {});
                    })(n48);
                    return {
                        value: xe1(r18, e168.id).getOr(t97),
                        valid: o28
                    };
                }
                return {
                    value: n48,
                    valid: o28
                };
            }
            return {
                valid: !1,
                message: "Must be a string."
            };
        }
    , Si = xi("iframe_attrs"), _i = xi("doctype"), Ei = xi("document_base_url"), Ni = xi("body_id"), Ri = xi("body_class"), Ai = xi("content_security_policy"), Oi = xi("br_in_pre"), Ti = xi("forced_root_block"), Bi = xi("forced_root_block_attrs"), Di = xi("br_newline_selector"), Li = xi("no_newline_selector"), Pi = xi("keep_styles"), Mi = xi("end_container_on_empty_block"), Ii = xi("automatic_uploads"), Fi = xi("images_reuse_filename"), Ui = xi("images_replace_blob_uris"), zi = xi("icons"), ji = xi("icons_url"), Vi = xi("images_upload_url"), Hi = xi("images_upload_base_path"), $i = xi("images_upload_credentials"), qi = xi("images_upload_handler"), Wi = xi("content_css_cors"), Ki = xi("referrer_policy"), Gi = xi("language"), Yi = xi("language_url"), Xi = xi("indent_use_margin"), Qi = xi("indentation"), Ji = xi("content_css"), Zi = xi("content_style"), el = xi("font_css"), tl = xi("directionality"), nl = xi("inline_boundaries_selector"), ol = xi("object_resizing"), rl = xi("resize_img_proportional"), sl = xi("placeholder"), al = xi("event_root"), il = xi("service_message"), ll = xi("theme"), dl = xi("theme_url"), cl = xi("model"), ul = xi("model_url"), ml = xi("inline_boundaries"), fl = xi("formats"), gl = xi("preview_styles"), pl = xi("format_empty_lines"), hl = xi("custom_ui_selector"), bl = xi("inline"), vl = xi("hidden_input"), yl = xi("submit_patch"), Cl = xi("add_form_submit_trigger"), xl = xi("add_unload_trigger"), wl = xi("custom_undo_redo_levels"), kl = xi("disable_nodechange"), Sl = xi("readonly"), _l = xi("content_css_cors"), El = xi("plugins"), Nl = xi("external_plugins"), Rl = xi("block_unsupported_drop"), Al = xi("visual"), Ol = xi("visual_table_class"), Tl = xi("visual_anchor_class"), Bl = xi("iframe_aria_text"), Dl = xi("setup"), Ll = xi("init_instance_callback"), Pl = xi("urlconverter_callback"), Ml = xi("auto_focus"), Il = xi("browser_spellcheck"), Fl = xi("protect"), Ul = xi("paste_block_drop"), zl = xi("paste_data_images"), jl = xi("paste_preprocess"), Vl = xi("paste_postprocess"), Hl = xi("paste_webkit_styles"), $l = xi("paste_remove_styles_if_webkit"), ql = xi("paste_merge_formats"), Wl = xi("smart_paste"), Kl = xi("paste_as_text"), Gl = xi("paste_tab_spaces"), Yl = xi("allow_html_data_urls"), Xl = xi("text_patterns"), Ql = xi("noneditable_class"), Jl = xi("editable_class"), Zl = xi("noneditable_regexp"), ed = (e)=>Bt.explode(e.options.get("images_file_types"))
    , td = xi("table_tab_navigation"), nd = yo, od = No, rd = (e)=>{
        const t = e.parentNode;
        t && t.removeChild(e);
    }, sd = (e)=>{
        const t = fr(e);
        return {
            count: e.length - t.length,
            text: t
        };
    }, ad = (e)=>{
        let t;
        for(; -1 !== (t = e.data.lastIndexOf(ur));)e.deleteData(t, 1);
    }, id = (e, t)=>(dd(e), t)
    , ld = (e170, t99)=>Ua.isTextPosition(t99) ? ((e171, t100)=>od(e171) && t100.container() === e171 ? ((e, t)=>{
                const n = sd(e.data.substr(0, t.offset())), o = sd(e.data.substr(t.offset()));
                return (n.text + o.text).length > 0 ? (ad(e), Ua(e, t.offset() - n.count)) : t;
            })(e171, t100) : id(e171, t100)
        )(e170, t99) : ((e172, t101)=>t101.container() === e172.parentNode ? ((e173, t102)=>{
                const n49 = t102.container(), o = ((e, t)=>{
                    const n = z1(e, t);
                    return -1 === n ? M1.none() : M1.some(n);
                })(de1(n49.childNodes), e173).map((e)=>e < t102.offset() ? Ua(n49, t102.offset() - 1) : t102
                ).getOr(t102);
                return dd(e173), o;
            })(e172, t101) : id(e172, t101)
        )(e170, t99)
    , dd = (e)=>{
        nd(e) && vr(e) && (yr(e) ? e.removeAttribute("data-mce-caret") : rd(e)), od(e) && (ad(e), 0 === e.data.length && rd(e));
    }, cd = Mo, ud = Fo, md = Io, fd = (e, t, n)=>{
        const o = fa(t.getBoundingClientRect(), n);
        let r, s;
        if ("BODY" === e.tagName) {
            const t = e.ownerDocument.documentElement;
            r = e.scrollLeft || t.scrollLeft, s = e.scrollTop || t.scrollTop;
        } else {
            const t = e.getBoundingClientRect();
            r = e.scrollLeft - t.left, s = e.scrollTop - t.top;
        }
        o.left += r, o.right += r, o.top += s, o.bottom += s, o.width = 1;
        let a = t.offsetWidth - t.clientWidth;
        return a > 0 && (n && (a *= -1), o.left += a, o.right += a), o;
    }, gd = (e175, t103, n50, o29)=>{
        const r21 = Ws();
        let s, a;
        const i = Ti(e175), l = e175.dom, d5 = ()=>{
            ((e)=>{
                const t = Xs(mn(e), "*[contentEditable=false],video,audio,embed,object");
                for(let e174 = 0; e174 < t.length; e174++){
                    const n = t[e174].dom;
                    let o = n.previousSibling;
                    if (kr(o)) {
                        const e = o.data;
                        1 === e.length ? o.parentNode.removeChild(o) : o.deleteData(e.length - 1, 1);
                    }
                    o = n.nextSibling, wr(o) && (1 === o.data.length ? o.parentNode.removeChild(o) : o.deleteData(0, 1));
                }
            })(t103), a && (dd(a), a = null), r21.on((e)=>{
                l.remove(e.caret), r21.clear();
            }), s && (clearInterval(s), s = void 0);
        };
        return {
            show: (e176, c)=>{
                let u;
                if (d5(), md(c)) return null;
                if (!n50(c)) return a = ((e, t)=>{
                    const n = e.ownerDocument.createTextNode(ur), o = e.parentNode;
                    if (t) {
                        const t = e.previousSibling;
                        if (pr(t)) {
                            if (vr(t)) return t;
                            if (kr(t)) return t.splitText(t.data.length - 1);
                        }
                        o.insertBefore(n, e);
                    } else {
                        const t = e.nextSibling;
                        if (pr(t)) {
                            if (vr(t)) return t;
                            if (wr(t)) return t.splitText(1), t;
                        }
                        e.nextSibling ? o.insertBefore(n, e.nextSibling) : o.appendChild(n);
                    }
                    return n;
                })(c, e176), u = c.ownerDocument.createRange(), hd(a.nextSibling) ? (u.setStart(a, 0), u.setEnd(a, 0)) : (u.setStart(a, 1), u.setEnd(a, 1)), u;
                {
                    a = ((e177, t, n)=>{
                        const o = t.ownerDocument.createElement(e177);
                        o.setAttribute("data-mce-caret", n ? "before" : "after"), o.setAttribute("data-mce-bogus", "all"), o.appendChild((()=>{
                            const e = document.createElement("br");
                            return e.setAttribute("data-mce-bogus", "1"), e;
                        })());
                        const r = t.parentNode;
                        return n ? r.insertBefore(o, t) : t.nextSibling ? r.insertBefore(o, t.nextSibling) : r.appendChild(o), o;
                    })(i, c, e176);
                    const n51 = fd(t103, c, e176);
                    l.setStyle(a, "top", n51.top);
                    const d = l.create("div", {
                        class: "mce-visual-caret",
                        "data-mce-bogus": "all"
                    });
                    l.setStyles(d, {
                        ...n51
                    }), l.add(t103, d), r21.set({
                        caret: d,
                        element: c,
                        before: e176
                    }), e176 && l.addClass(d, "mce-visual-caret-before"), s = setInterval(()=>{
                        r21.on((e)=>{
                            o29() ? l.toggleClass(e.caret, "mce-visual-caret-hidden") : l.addClass(e.caret, "mce-visual-caret-hidden");
                        });
                    }, 500), u = c.ownerDocument.createRange(), u.setStart(a, 0), u.setEnd(a, 0);
                }
                return u;
            },
            hide: d5,
            getCss: ()=>".mce-visual-caret {position: absolute;background-color: black;background-color: currentcolor;}.mce-visual-caret-hidden {display: none;}*[data-mce-caret] {position: absolute;left: -1000px;right: auto;top: 0;margin: 0;padding: 0;}"
            ,
            reposition: ()=>{
                r21.on((e)=>{
                    const n = fd(t103, e.element, e.before);
                    l.setStyles(e.caret, {
                        ...n
                    });
                });
            },
            destroy: ()=>clearInterval(s)
        };
    }, pd = ()=>Nt.browser.isFirefox()
    , hd = (e)=>cd(e) || ud(e)
    , bd = (e)=>hd(e) || So(e) && pd()
    , vd = Po, yd = Mo, Cd = Fo, xd = xo("display", "block table table-cell table-caption list-item"), wd = vr, kd = hr, Sd = yo, _d = Lr, Ed = (e)=>e > 0
    , Nd = (e)=>e < 0
    , Rd = (e, t)=>{
        let n;
        for(; n = e(t);)if (!kd(n)) return n;
        return null;
    }, Ad = (e, t, n, o, r)=>{
        const s = new Xo(e, o), a = yd(e) || kd(e);
        if (Nd(t)) {
            if (a && n(e = Rd(s.prev.bind(s), !0))) return e;
            for(; e = Rd(s.prev.bind(s), r);)if (n(e)) return e;
        }
        if (Ed(t)) {
            if (a && n(e = Rd(s.next.bind(s), !0))) return e;
            for(; e = Rd(s.next.bind(s), r);)if (n(e)) return e;
        }
        return null;
    }, Od = (e, t)=>{
        for(; e && e !== t;){
            if (xd(e)) return e;
            e = e.parentNode;
        }
        return null;
    }, Td = (e, t, n)=>Od(e.container(), n) === Od(t.container(), n)
    , Bd = (e, t)=>{
        if (!t) return null;
        const n = t.container(), o = t.offset();
        return Sd(n) ? n.childNodes[o + e] : null;
    }, Dd = (e, t)=>{
        const n = t.ownerDocument.createRange();
        return e ? (n.setStartBefore(t), n.setEndBefore(t)) : (n.setStartAfter(t), n.setEndAfter(t)), n;
    }, Ld = (e, t, n)=>Od(t, e) === Od(n, e)
    , Pd = (e, t, n)=>{
        const o = e ? "previousSibling" : "nextSibling";
        for(; n && n !== t;){
            let e = n[o];
            if (wd(e) && (e = e[o]), yd(e) || Cd(e)) {
                if (Ld(t, e, n)) return e;
                break;
            }
            if (_d(e)) break;
            n = n.parentNode;
        }
        return null;
    }, Md = O1(Dd, !0), Id = O1(Dd, !1), Fd = (e, t, n)=>{
        let o;
        const r = O1(Pd, !0, t), s = O1(Pd, !1, t);
        let a = n.startContainer;
        const i = n.startOffset;
        if (hr(a)) {
            Sd(a) || (a = a.parentNode);
            const e = a.getAttribute("data-mce-caret");
            if ("before" === e && (o = a.nextSibling, bd(o))) return Md(o);
            if ("after" === e && (o = a.previousSibling, bd(o))) return Id(o);
        }
        if (!n.collapsed) return n;
        if (No(a)) {
            if (wd(a)) {
                if (1 === e) {
                    if (o = s(a), o) return Md(o);
                    if (o = r(a), o) return Id(o);
                }
                if (-1 === e) {
                    if (o = r(a), o) return Id(o);
                    if (o = s(a), o) return Md(o);
                }
                return n;
            }
            if (kr(a) && i >= a.data.length - 1) return 1 === e && (o = s(a), o) ? Md(o) : n;
            if (wr(a) && i <= 1) return -1 === e && (o = r(a), o) ? Id(o) : n;
            if (i === a.data.length) return o = s(a), o ? Md(o) : n;
            if (0 === i) return o = r(a), o ? Id(o) : n;
        }
        return n;
    }, Ud = (e, t)=>M1.from(Bd(e ? 0 : -1, t)).filter(yd)
    , zd = (e, t, n)=>{
        const o = Fd(e, t, n);
        return -1 === e ? Ua.fromRangeStart(o) : Ua.fromRangeEnd(o);
    }, jd = (e)=>M1.from(e.getNode()).map(mn)
    , Vd = (e, t)=>{
        for(; t = e(t);)if (t.isVisible()) return t;
        return t;
    }, Hd = (e, t)=>{
        const n = Td(e, t);
        return !(n || !Do(e.getNode())) || n;
    };
    var $d;
    !function(e) {
        e[e.Backwards = -1] = "Backwards", e[e.Forwards = 1] = "Forwards";
    }($d || ($d = {}));
    const qd = Mo, Wd = No, Kd = yo, Gd = Do, Yd = Lr, Xd = (e178)=>Tr(e178) || ((e179)=>!!Pr(e179) && !0 !== Y1(de1(e179.getElementsByTagName("*")), (e, t)=>e || Er(t)
            , !1)
        )(e178)
    , Qd = Mr, Jd = (e, t)=>e.hasChildNodes() && t < e.childNodes.length ? e.childNodes[t] : null
    , Zd = (e, t)=>{
        if (Ed(e)) {
            if (Yd(t.previousSibling) && !Wd(t.previousSibling)) return Ua.before(t);
            if (Wd(t)) return Ua(t, 0);
        }
        if (Nd(e)) {
            if (Yd(t.nextSibling) && !Wd(t.nextSibling)) return Ua.after(t);
            if (Wd(t)) return Ua(t, t.data.length);
        }
        return Nd(e) ? Gd(t) ? Ua.before(t) : Ua.after(t) : Ua.before(t);
    }, ec = (e180, t104, n53)=>{
        let o, r, s, a;
        if (!Kd(n53) || !t104) return null;
        if (t104.isEqual(Ua.after(n53)) && n53.lastChild) {
            if (a = Ua.after(n53.lastChild), Nd(e180) && Yd(n53.lastChild) && Kd(n53.lastChild)) return Gd(n53.lastChild) ? Ua.before(n53.lastChild) : a;
        } else a = t104;
        const i = a.container();
        let l = a.offset();
        if (Wd(i)) {
            if (Nd(e180) && l > 0) return Ua(i, --l);
            if (Ed(e180) && l < i.length) return Ua(i, ++l);
            o = i;
        } else {
            if (Nd(e180) && l > 0 && (r = Jd(i, l - 1), Yd(r))) return !Xd(r) && (s = Ad(r, e180, Qd, r), s) ? Wd(s) ? Ua(s, s.data.length) : Ua.after(s) : Wd(r) ? Ua(r, r.data.length) : Ua.before(r);
            if (Ed(e180) && l < i.childNodes.length && (r = Jd(i, l), Yd(r))) return Gd(r) ? ((e, t)=>{
                const n = t.nextSibling;
                return n && Yd(n) ? Wd(n) ? Ua(n, 0) : Ua.before(n) : ec($d.Forwards, Ua.after(t), e);
            })(n53, r) : !Xd(r) && (s = Ad(r, e180, Qd, r), s) ? Wd(s) ? Ua(s, 0) : Ua.before(s) : Wd(r) ? Ua(r, 0) : Ua.after(r);
            o = r || a.getNode();
        }
        if ((Ed(e180) && a.isAtEnd() || Nd(e180) && a.isAtStart()) && (o = Ad(o, e180, P1, n53, !0), Qd(o, n53))) return Zd(e180, o);
        r = Ad(o, e180, Qd, n53);
        const d = Be1(K1(((e, t)=>{
            const n = [];
            for(; e && e !== t;)n.push(e), e = e.parentNode;
            return n;
        })(i, n53), qd));
        return !d || r && d.contains(r) ? r ? Zd(e180, r) : null : (a = Ed(e180) ? Ua.after(d) : Ua.before(d), a);
    }, tc = (e)=>({
            next: (t)=>ec($d.Forwards, t, e)
            ,
            prev: (t)=>ec($d.Backwards, t, e)
        })
    , nc = (e)=>Ua.isTextPosition(e) ? 0 === e.offset() : Lr(e.getNode())
    , oc = (e)=>{
        if (Ua.isTextPosition(e)) {
            const t = e.container();
            return e.offset() === t.data.length;
        }
        return Lr(e.getNode(!0));
    }, rc = (e, t)=>!Ua.isTextPosition(e) && !Ua.isTextPosition(t) && e.getNode() === t.getNode(!0)
    , sc = (e, t, n)=>{
        const o = tc(t);
        return M1.from(e ? o.next(n) : o.prev(n));
    }, ac = (e181, t105, n54)=>sc(e181, t105, n54).bind((o30)=>Td(n54, o30, t105) && ((e, t, n)=>{
                var o;
                return e ? !rc(t, n) && (o = t, !(!Ua.isTextPosition(o) && Do(o.getNode()))) && oc(t) && nc(n) : !rc(n, t) && nc(t) && oc(n);
            })(e181, n54, o30) ? sc(e181, t105, o30) : M1.some(o30)
        )
    , ic = (e, t, n55, o)=>ac(e, t, n55).bind((n)=>o(n) ? ic(e, t, n, o) : M1.some(n)
        )
    , lc = (e182, t106)=>{
        const n56 = e182 ? t106.firstChild : t106.lastChild;
        var o31;
        return No(n56) ? M1.some(Ua(n56, e182 ? 0 : n56.data.length)) : n56 ? Lr(n56) ? M1.some(e182 ? Ua.before(n56) : Do(o31 = n56) ? Ua.before(o31) : Ua.after(o31)) : ((e, t, n)=>{
            const o = e ? Ua.before(n) : Ua.after(n);
            return sc(e, t, o);
        })(e182, t106, n56) : M1.none();
    }, dc = O1(sc, !0), cc = O1(sc, !1), uc = O1(lc, !0), mc = O1(lc, !1), fc = "_mce_caret", gc = (e)=>yo(e) && e.id === fc
    , pc = (e, t)=>{
        for(; t && t !== e;){
            if (t.id === fc) return t;
            t = t.parentNode;
        }
        return null;
    }, hc = (e)=>Bt.isArray(e.start)
    , bc = (e, t)=>(yo(t) && e.isBlock(t) && !t.innerHTML && (t.innerHTML = '<br data-mce-bogus="1" />'), t)
    , vc = (e183, t)=>mc(e183).fold(L1, (e)=>(t.setStart(e.container(), e.offset()), t.setEnd(e.container(), e.offset()), !0)
        )
    , yc = (e184, t107, n57)=>!(!((e)=>!1 === e.hasChildNodes()
        )(t107) || !pc(e184, t107) || (((e, t)=>{
            const n = e.ownerDocument.createTextNode(ur);
            e.appendChild(n), t.setStart(n, 0), t.setEnd(n, 0);
        })(t107, n57), 0))
    , Cc = (e, t, n, o)=>{
        const r = n[t ? "start" : "end"];
        let s, a, i, l;
        const d = e.getRoot();
        if (r) {
            for(i = r[0], a = d, s = r.length - 1; s >= 1; s--){
                if (l = a.childNodes, yc(d, a, o)) return !0;
                if (r[s] > l.length - 1) return !!yc(d, a, o) || vc(a, o);
                a = l[r[s]];
            }
            3 === a.nodeType && (i = Math.min(r[0], a.nodeValue.length)), 1 === a.nodeType && (i = Math.min(r[0], a.childNodes.length)), t ? o.setStart(a, i) : o.setEnd(a, i);
        }
        return !0;
    }, xc = (e)=>No(e) && e.data.length > 0
    , wc = (e185, t, n)=>{
        let o, r, s, a, i = e185.get(n.id + "_" + t);
        const l = n.keep;
        let d, c;
        if (i) {
            if (o = i.parentNode, "start" === t ? (l ? i.hasChildNodes() ? (o = i.firstChild, r = 1) : xc(i.nextSibling) ? (o = i.nextSibling, r = 0) : xc(i.previousSibling) ? (o = i.previousSibling, r = i.previousSibling.data.length) : (o = i.parentNode, r = e185.nodeIndex(i) + 1) : r = e185.nodeIndex(i), d = o, c = r) : (l ? i.hasChildNodes() ? (o = i.firstChild, r = 1) : xc(i.previousSibling) ? (o = i.previousSibling, r = i.previousSibling.data.length) : (o = i.parentNode, r = e185.nodeIndex(i)) : r = e185.nodeIndex(i), d = o, c = r), !l) {
                for(a = i.previousSibling, s = i.nextSibling, Bt.each(Bt.grep(i.childNodes), (e)=>{
                    No(e) && (e.nodeValue = e.nodeValue.replace(/\uFEFF/g, ""));
                }); i = e185.get(n.id + "_" + t);)e185.remove(i, !0);
                a && s && a.nodeType === s.nodeType && No(a) && !Nt.browser.isOpera() && (r = a.nodeValue.length, a.appendData(s.nodeValue), e185.remove(s), d = a, c = r);
            }
            return M1.some(Ua(d, c));
        }
        return M1.none();
    }, kc = (e186, t108, n58)=>((e187, t109, n)=>2 === t109 ? oi(fr, n, e187) : 3 === t109 ? ((e)=>{
                const t = e.getRng();
                return {
                    start: Ya(e.dom.getRoot(), Ua.fromRangeStart(t)),
                    end: Ya(e.dom.getRoot(), Ua.fromRangeEnd(t))
                };
            })(e187) : t109 ? ((e)=>({
                    rng: e.getRng()
                })
            )(e187) : si(e187, !1)
        )(e186, t108, n58)
    , Sc = (e188, t110)=>{
        ((e189, t111)=>{
            const n59 = e189.dom;
            if (t111) {
                if (hc(t111)) return ((e, t)=>{
                    const n = e.createRng();
                    return Cc(e, !0, t, n) && Cc(e, !1, t, n) ? M1.some(n) : M1.none();
                })(n59, t111);
                if (((e)=>m1(e.start)
                )(t111)) return M1.some(((e, t)=>{
                    let n;
                    const o = e.createRng();
                    return n = Xa(e.getRoot(), t.start), o.setStart(n.container(), n.offset()), n = Xa(e.getRoot(), t.end), o.setEnd(n.container(), n.offset()), o;
                })(n59, t111));
                if (((e)=>we1(e, "id")
                )(t111)) return ((e, t112)=>{
                    const n60 = wc(e, "start", t112), o32 = wc(e, "end", t112);
                    return Lt(n60, o32.or(n60), (t, n)=>{
                        const o = e.createRng();
                        return o.setStart(bc(e, t.container()), t.offset()), o.setEnd(bc(e, n.container()), n.offset()), o;
                    });
                })(n59, t111);
                if (((e)=>we1(e, "name")
                )(t111)) return ((e, t113)=>M1.from(e.select(t113.name)[t113.index]).map((t)=>{
                        const n = e.createRng();
                        return n.selectNode(t), n;
                    })
                )(n59, t111);
                if (((e)=>we1(e, "rng")
                )(t111)) return M1.some(t111.rng);
            }
            return M1.none();
        })(e188, t110).each((t)=>{
            e188.setRng(t);
        });
    }, _c = (e)=>yo(e) && "SPAN" === e.tagName && "bookmark" === e.getAttribute("data-mce-type")
    , Ec = (e)=>"\xa0" === e
    ;
    const Nc = (e)=>"" !== e && -1 !== " \f\n\r\t\v".indexOf(e)
    , Rc = (e)=>!Nc(e) && !Ec(e) && !cr(e)
    , Ac = (e)=>{
        const t = e.toString(16);
        return (1 === t.length ? "0" + t : t).toUpperCase();
    }, Oc = (e190)=>((e)=>({
                value: e
            })
        )(Ac(e190.red) + Ac(e190.green) + Ac(e190.blue))
    , Tc = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i, Bc = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i, Dc = (e, t, n, o)=>({
            red: e,
            green: t,
            blue: n,
            alpha: o
        })
    , Lc = (e, t, n, o)=>{
        const r = parseInt(e, 10), s = parseInt(t, 10), a = parseInt(n, 10), i = parseFloat(o);
        return Dc(r, s, a, i);
    }, Pc = (e191)=>((e)=>{
            if ("transparent" === e) return M1.some(Dc(0, 0, 0, 0));
            const t = Tc.exec(e);
            if (null !== t) return M1.some(Lc(t[1], t[2], t[3], "1"));
            const n = Bc.exec(e);
            return null !== n ? M1.some(Lc(n[1], n[2], n[3], n[4])) : M1.none();
        })(e191).map(Oc).map((e)=>"#" + e.value
        ).getOr(e191)
    , Mc = (e)=>!!e.nodeType
    , Ic = (e, t, n)=>{
        const o = n.startOffset;
        let r = n.startContainer;
        var s;
        if ((r !== n.endContainer || !(s = r.childNodes[o]) || !/^(IMG)$/.test(s.nodeName)) && yo(r)) {
            const s = r.childNodes;
            let a;
            o < s.length ? (r = s[o], a = new Xo(r, e.getParent(r, e.isBlock))) : (r = s[s.length - 1], a = new Xo(r, e.getParent(r, e.isBlock)), a.next(!0));
            for(let e192 = a.current(); e192; e192 = a.next())if (No(e192) && !jc(e192)) return n.setStart(e192, 0), void t.setRng(n);
        }
    }, Fc = (e, t, n)=>{
        if (e) {
            const o = t ? "nextSibling" : "previousSibling";
            for(e = n ? e : e[o]; e; e = e[o])if (yo(e) || !jc(e)) return e;
        }
    }, Uc = (e, t)=>(Mc(t) && (t = t.nodeName), !!e.schema.getTextBlockElements()[t.toLowerCase()])
    , zc = (e, t, n)=>e.schema.isValidChild(t, n)
    , jc = (e, t = !1)=>{
        if (C1(e) && No(e)) {
            const n = t ? e.data.replace(/ /g, "\xa0") : e.data;
            return Fr(n);
        }
        return !1;
    }, Vc = (e193, t)=>(x1(e193) ? e193 = e193(t) : C1(t) && (e193 = e193.replace(/%(\w+)/g, (e, n)=>t[n] || e
        )), e193)
    , Hc = (e, t)=>(t = t || "", e = "" + ((e = e || "").nodeName || e), t = "" + (t.nodeName || t), e.toLowerCase() === t.toLowerCase())
    , $c = (e, t)=>("color" !== t && "backgroundColor" !== t || (e = Pc(e)), "fontWeight" === t && 700 === e && (e = "bold"), "fontFamily" === t && (e = e.replace(/[\'\"]/g, "").replace(/,\s+/g, ",")), "" + e)
    , qc = (e, t, n)=>$c(e.getStyle(t, n), n)
    , Wc = (e, t114)=>{
        let n;
        return e.getParent(t114, (t)=>(n = e.getStyle(t, "text-decoration"), n && "none" !== n)
        ), n;
    }, Kc = (e, t, n)=>e.getParents(t, n, e.getRoot())
    , Gc = (e)=>ke1(e, "block")
    , Yc = (e)=>ke1(e, "selector")
    , Xc = (e)=>ke1(e, "inline")
    , Qc = (e)=>Yc(e) && !1 !== e.expand && !Xc(e)
    , Jc = _c, Zc = Kc, eu = jc, tu = Uc, nu = (e, t)=>{
        let n = t;
        for(; n;){
            if (yo(n) && e.getContentEditable(n)) return "false" === e.getContentEditable(n) ? n : t;
            n = n.parentNode;
        }
        return t;
    }, ou = (e, t, n, o)=>{
        const r = t.data;
        for(let t115 = n; e ? t115 >= 0 : t115 < r.length; e ? t115-- : t115++)if (o(r.charAt(t115))) return e ? t115 + 1 : t115;
        return -1;
    }, ru = (e194, t, n)=>ou(e194, t, n, (e)=>Ec(e) || Nc(e)
        )
    , su = (e, t, n)=>ou(e, t, n, Rc)
    , au = (e195, t116, n61, o33, r, s12)=>{
        let a;
        const i = e195.getParent(n61, e195.isBlock) || t116, l6 = (t117, n, o)=>{
            const s = ca(e195), l = r ? s.backwards : s.forwards;
            return M1.from(l(t117, n, (e, t)=>Jc(e.parentNode) ? -1 : (a = e, o(r, e, t))
            , i));
        };
        return l6(n61, o33, ru).bind((e)=>s12 ? l6(e.container, e.offset + (r ? -1 : 0), su) : M1.some(e)
        ).orThunk(()=>a ? M1.some({
                container: a,
                offset: r ? 0 : a.length
            }) : M1.none()
        );
    }, iu = (e, t, n, o, r)=>{
        No(o) && Ke(o.data) && o[r] && (o = o[r]);
        const s = Zc(e, o);
        for(let o34 = 0; o34 < s.length; o34++)for(let r22 = 0; r22 < t.length; r22++){
            const a = t[r22];
            if ((!C1(a.collapsed) || a.collapsed === n.collapsed) && Yc(a) && e.is(s[o34], a.selector)) return s[o34];
        }
        return o;
    }, lu = (e, t119, n, o)=>{
        let r = n;
        const s = e.dom, a = s.getRoot(), i = t119[0];
        if (Gc(i) && (r = i.wrapper ? null : s.getParent(n, i.block, a)), !r) {
            const t118 = s.getParent(n, "LI,TD,TH");
            r = s.getParent(No(n) ? n.parentNode : n, (t)=>t !== a && tu(e, t)
            , t118);
        }
        if (r && Gc(i) && i.wrapper && (r = Zc(s, r, "ul,ol").reverse()[0] || r), !r) for(r = n; r[o] && !s.isBlock(r[o]) && (r = r[o], !Hc(r, "br")););
        return r || n;
    }, du = (e, t, n, o)=>{
        const r = n.parentNode;
        return !C1(n[o]) && (!(r !== t && !y1(r) && !e.isBlock(r)) || du(e, t, r, o));
    }, cu = (e, t, n, o, r)=>{
        let s = n;
        const a = r ? "previousSibling" : "nextSibling", i = e.getRoot();
        if (No(n) && !eu(n) && (r ? o > 0 : o < n.data.length)) return n;
        for(;;){
            if (!t[0].block_expand && e.isBlock(s)) return s;
            for(let t120 = s[a]; t120; t120 = t120[a]){
                const n = No(t120) && !du(e, i, t120, a);
                if (!Jc(t120) && (!Do(l = t120) || !l.getAttribute("data-mce-bogus") || l.nextSibling) && !eu(t120, n)) return s;
            }
            if (s === i || s.parentNode === i) {
                n = s;
                break;
            }
            s = s.parentNode;
        }
        var l;
        return n;
    }, uu = (e)=>Jc(e.parentNode) || Jc(e)
    , mu = (e196, t121, n, o = !1)=>{
        let { startContainer: r , startOffset: s , endContainer: a , endOffset: i  } = t121;
        const l = e196.dom, d = n[0];
        return yo(r) && r.hasChildNodes() && (r = ya(r, s), No(r) && (s = 0)), yo(a) && a.hasChildNodes() && (a = ya(a, t121.collapsed ? i : i - 1), No(a) && (i = a.nodeValue.length)), r = nu(l, r), a = nu(l, a), uu(r) && (r = Jc(r) ? r : r.parentNode, r = t121.collapsed ? r.previousSibling || r : r.nextSibling || r, No(r) && (s = t121.collapsed ? r.length : 0)), uu(a) && (a = Jc(a) ? a : a.parentNode, a = t121.collapsed ? a.nextSibling || a : a.previousSibling || a, No(a) && (i = t121.collapsed ? 0 : a.length)), t121.collapsed && (au(l, e196.getBody(), r, s, !0, o).each(({ container: e , offset: t  })=>{
            r = e, s = t;
        }), au(l, e196.getBody(), a, i, !1, o).each(({ container: e , offset: t  })=>{
            a = e, i = t;
        })), (Xc(d) || d.block_expand) && (Xc(d) && No(r) && 0 !== s || (r = cu(l, n, r, s, !0)), Xc(d) && No(a) && i !== a.nodeValue.length || (a = cu(l, n, a, i, !1))), Qc(d) && (r = iu(l, n, t121, r, "previousSibling"), a = iu(l, n, t121, a, "nextSibling")), (Gc(d) || Yc(d)) && (r = lu(e196, n, r, "previousSibling"), a = lu(e196, n, a, "nextSibling"), Gc(d) && (l.isBlock(r) || (r = cu(l, n, r, s, !0)), l.isBlock(a) || (a = cu(l, n, a, i, !1)))), yo(r) && (s = l.nodeIndex(r), r = r.parentNode), yo(a) && (i = l.nodeIndex(a) + 1, a = a.parentNode), {
            startContainer: r,
            startOffset: s,
            endContainer: a,
            endOffset: i
        };
    }, fu = (e197, t122, n62)=>{
        const o35 = t122.startOffset, r23 = ya(t122.startContainer, o35), s13 = t122.endOffset, a8 = ya(t122.endContainer, s13 - 1), i = (e)=>{
            const t = e[0];
            No(t) && t === r23 && o35 >= t.data.length && e.splice(0, 1);
            const n = e[e.length - 1];
            return 0 === s13 && e.length > 0 && n === a8 && No(n) && e.splice(e.length - 1, 1), e;
        }, l = (e, t, n)=>{
            const o = [];
            for(; e && e !== n; e = e[t])o.push(e);
            return o;
        }, d = (t, n)=>e197.getParent(t, (e)=>e.parentNode === n
            , n)
        , c = (e, t, o)=>{
            const r = o ? "nextSibling" : "previousSibling";
            for(let s = e, a = s.parentNode; s && s !== t; s = a){
                a = s.parentNode;
                const t = l(s === e ? s : s[r], r);
                t.length && (o || t.reverse(), n62(i(t)));
            }
        };
        if (r23 === a8) return n62(i([
            r23
        ]));
        const u = e197.findCommonAncestor(r23, a8);
        if (e197.isChildOf(r23, a8)) return c(r23, u, !0);
        if (e197.isChildOf(a8, r23)) return c(a8, u);
        const m = d(r23, u) || r23, f = d(a8, u) || a8;
        c(r23, m, !0);
        const g = l(m === r23 ? m : m.nextSibling, "nextSibling", f === a8 ? f.nextSibling : f);
        g.length && n62(i(g)), c(a8, f);
    }, gu = (e)=>{
        const t = [];
        if (e) for(let n = 0; n < e.rangeCount; n++)t.push(e.getRangeAt(n));
        return t;
    }, pu = (e198, t123)=>{
        const n = Xs(t123, "td[data-mce-selected],th[data-mce-selected]");
        return n.length > 0 ? n : ((e199)=>K1(((e200)=>ee1(e200, (e)=>{
                    const t = va(e);
                    return t ? [
                        mn(t)
                    ] : [];
                })
            )(e199), ar)
        )(e198);
    }, hu = (e)=>pu(gu(e.selection.getSel()), mn(e.getBody()))
    , bu = (e, t)=>qo(e, "table", t)
    , vu = (e)=>An(e).fold(N1([
            e
        ]), (t)=>[
                e
            ].concat(vu(t))
        )
    , yu = (e)=>On(e).fold(N1([
            e
        ]), (t124)=>"br" === Mt(t124) ? kn(t124).map((t)=>[
                    e
                ].concat(yu(t))
            ).getOr([]) : [
                e
            ].concat(yu(t124))
        )
    , Cu = (e201, t125)=>Lt(((e)=>{
            const t = e.startContainer, n = e.startOffset;
            return No(t) ? 0 === n ? M1.some(mn(t)) : M1.none() : M1.from(t.childNodes[n]).map(mn);
        })(t125), ((e)=>{
            const t = e.endContainer, n = e.endOffset;
            return No(t) ? n === t.data.length ? M1.some(mn(t)) : M1.none() : M1.from(t.childNodes[n - 1]).map(mn);
        })(t125), (t, n)=>{
            const o = Q1(vu(e201), O1(bn, t)), r = Q1(yu(e201), O1(bn, n));
            return o.isSome() && r.isSome();
        }).getOr(!1)
    , xu = (e, t126, n, o)=>{
        const r = n, s = new Xo(n, r), a = ve1(e.schema.getMoveCaretBeforeOnEnterElements(), (e, t)=>!j1([
                "td",
                "th",
                "table"
            ], t.toLowerCase())
        );
        do {
            if (No(n) && 0 !== Bt.trim(n.nodeValue).length) return void (o ? t126.setStart(n, 0) : t126.setEnd(n, n.nodeValue.length));
            if (a[n.nodeName]) return void (o ? t126.setStartBefore(n) : "BR" === n.nodeName ? t126.setEndBefore(n) : t126.setEndAfter(n));
        }while (n = o ? s.next() : s.prev())
        "BODY" === r.nodeName && (o ? t126.setStart(r, 0) : t126.setEnd(r, r.childNodes.length));
    }, wu = (e)=>{
        const t = e.selection.getSel();
        return t && t.rangeCount > 0;
    }, ku = (e, t)=>{
        const n63 = hu(e);
        n63.length > 0 ? $1(n63, (n)=>{
            const o = n.dom, r = e.dom.createRng();
            r.setStartBefore(o), r.setEndAfter(o), t(r, !0);
        }) : t(e.selection.getRng(), !1);
    }, Su = (e, t, n)=>{
        const o = si(e, t);
        n(o), e.moveToBookmark(o);
    }, _u = ((e, t127)=>{
        const n64 = (t)=>e(t) ? M1.from(t.dom.nodeValue) : M1.none()
        ;
        return {
            get: (t)=>{
                if (!e(t)) throw new Error("Can only get text value of a text node");
                return n64(t).getOr("");
            },
            getOption: n64,
            set: (t, n)=>{
                if (!e(t)) throw new Error("Can only set raw text value of a text node");
                t.dom.nodeValue = n;
            }
        };
    })(zt), Eu = (e)=>_u.get(e)
    , Nu = (e)=>_u.getOption(e)
    , Ru = (e202, { uid: t128 = sa("mce-annotation") , ...n }, o, r)=>{
        const s = cn("span", e202);
        nn(s, Qs()), $t(s, `${Zs()}`, t128), $t(s, `${Js()}`, o);
        const { attributes: a = {} , classes: i = []  } = r(t128, n);
        return qt(s, a), ((e, t129)=>{
            $1(t129, (t)=>{
                nn(e, t);
            });
        })(s, i), s;
    }, Au = (e203, t130, n65, o36, r24)=>{
        const s = [], a = Ru(e203.getDoc(), r24, n65, o36), i = Ws(), l = ()=>{
            i.clear();
        }, d = (e)=>{
            $1(e, c);
        }, c = (t131)=>{
            switch(((e204, t, n, o)=>wn(t).fold(()=>"skipping"
                , (r)=>"br" === o || ((e)=>zt(e) && Eu(e) === ur
                    )(t) ? "valid" : ((e)=>Ut(e) && sn(e, Qs())
                    )(t) ? "existing" : gc(t.dom) ? "caret" : zc(e204, n, o) && zc(e204, Mt(r), n) ? "valid" : "invalid-child"
                )
            )(e203, t131, "span", Mt(t131))){
                case "invalid-child":
                    {
                        l();
                        const e = Nn(t131);
                        d(e), l();
                        break;
                    }
                case "valid":
                    {
                        const e205 = i.get().getOrThunk(()=>{
                            const e = ia(a);
                            return s.push(e), i.set(e), e;
                        });
                        ((e, t)=>{
                            Yn(e, t), Jn(t, e);
                        })(t131, e205);
                        break;
                    }
            }
        };
        return fu(e203.dom, t130, (e207)=>{
            l(), ((e)=>{
                const t = H1(e, mn);
                d(t);
            })(e207);
        }), s;
    }, Ou = (e208)=>{
        const t132 = (()=>{
            const e209 = {};
            return {
                register: (t, n)=>{
                    e209[t] = {
                        name: t,
                        settings: n
                    };
                },
                lookup: (t)=>xe1(e209, t).map((e)=>e.settings
                    )
                ,
                getNames: ()=>ue1(e209)
            };
        })();
        ((e210, t133)=>{
            e210.serializer.addTempAttr(ea()), e210.serializer.addNodeFilter("span", (e211)=>{
                $1(e211, (e212)=>{
                    ((e)=>M1.from(e.attr(Js())).bind(t133.lookup)
                    )(e212).each((t)=>{
                        !1 === t.persistent && e212.unwrap();
                    });
                });
            });
        })(e208, t132);
        const n66 = ((e213, t134)=>{
            const n67 = zs({}), o37 = ()=>({
                    listeners: [],
                    previous: Ws()
                })
            , r25 = (e214, t)=>{
                s14(e214, (e)=>(t(e), e)
                );
            }, s14 = (e, t)=>{
                const r = n67.get(), s = t(xe1(r, e).getOrThunk(o37));
                r[e] = s, n67.set(r);
            }, a = (t, n)=>{
                $1(na(e213, t), (e)=>{
                    n ? $t(e, ea(), "true") : Yt(e, ea());
                });
            }, i = Gs(()=>{
                const n68 = se1(t134.getNames());
                $1(n68, (t135)=>{
                    s14(t135, (n69)=>{
                        const o38 = n69.previous.get();
                        return ta(e213, M1.some(t135)).fold(()=>{
                            o38.each((e215)=>{
                                ((e)=>{
                                    r25(e, (t136)=>{
                                        $1(t136.listeners, (t)=>t(!1, e)
                                        );
                                    });
                                })(t135), n69.previous.clear(), a(e215, !1);
                            });
                        }, ({ uid: e216 , name: t137 , elements: s  })=>{
                            Dt(o38, e216) || (o38.each((e)=>a(e, !1)
                            ), ((e217, t, n)=>{
                                r25(e217, (o39)=>{
                                    $1(o39.listeners, (o)=>o(!0, e217, {
                                            uid: t,
                                            nodes: H1(n, (e)=>e.dom
                                            )
                                        })
                                    );
                                });
                            })(t137, e216, s), n69.previous.set(e216), a(e216, !0));
                        }), {
                            previous: n69.previous,
                            listeners: n69.listeners
                        };
                    });
                });
            }, 30);
            return e213.on("remove", ()=>{
                i.cancel();
            }), e213.on("NodeChange", ()=>{
                i.throttle();
            }), {
                addListener: (e218, t)=>{
                    s14(e218, (e)=>({
                            previous: e.previous,
                            listeners: e.listeners.concat([
                                t
                            ])
                        })
                    );
                }
            };
        })(e208, t132);
        return {
            register: (e, n)=>{
                t132.register(e, n);
            },
            annotate: (n70, o40)=>{
                t132.lookup(n70).each((t138)=>{
                    ((e219, t139, n71, o)=>{
                        e219.undoManager.transact(()=>{
                            const r26 = e219.selection, s = r26.getRng(), a = hu(e219).length > 0;
                            if (s.collapsed && !a && ((e, t)=>{
                                const n = mu(e, t, [
                                    {
                                        inline: "span"
                                    }
                                ]);
                                t.setStart(n.startContainer, n.startOffset), t.setEnd(n.endContainer, n.endOffset), e.selection.setRng(t);
                            })(e219, s), r26.getRng().collapsed && !a) {
                                const s = Ru(e219.getDoc(), o, t139, n71.decorate);
                                ro(s, dr), r26.getRng().insertNode(s.dom), r26.select(s.dom);
                            } else Su(r26, !1, ()=>{
                                ku(e219, (r)=>{
                                    Au(e219, r, t139, n71.decorate, o);
                                });
                            });
                        });
                    })(e208, n70, t138, o40);
                });
            },
            annotationChanged: (e, t)=>{
                n66.addListener(e, t);
            },
            remove: (t)=>{
                const n = e208.selection.getBookmark();
                ta(e208, M1.some(t)).each(({ elements: e  })=>{
                    $1(e, no);
                }), e208.selection.moveToBookmark(n);
            },
            removeAll: (t)=>{
                const n = e208.selection.getBookmark();
                fe1(oa(e208, t), (e, t)=>$1(e, no)
                ), e208.selection.moveToBookmark(n);
            },
            getAll: (t)=>{
                const n = oa(e208, t);
                return ge1(n, (e220)=>H1(e220, (e)=>e.dom
                    )
                );
            }
        };
    }, Tu = (e)=>({
            getBookmark: O1(kc, e),
            moveToBookmark: O1(Sc, e)
        })
    ;
    Tu.isBookmarkNode = _c;
    const Bu = (e221, t140, n72)=>!n72.collapsed && V1(n72.getClientRects(), (n73)=>((e, t, n)=>t >= e.left && t <= e.right && n >= e.top && n <= e.bottom
            )(n73, e221, t140)
        )
    , Du = (e, t, n)=>e.dispatch(t, n)
    , Lu = (e, t, n, o)=>e.dispatch("FormatApply", {
            format: t,
            node: n,
            vars: o
        })
    , Pu = (e, t, n, o)=>e.dispatch("FormatRemove", {
            format: t,
            node: n,
            vars: o
        })
    , Mu = (e, t)=>e.dispatch("SetContent", t)
    , Iu = (e, t)=>e.dispatch("GetContent", t)
    , Fu = (e, t)=>e.dispatch("PastePlainTextToggle", {
            state: t
        })
    , Uu = {
        BACKSPACE: 8,
        DELETE: 46,
        DOWN: 40,
        ENTER: 13,
        ESC: 27,
        LEFT: 37,
        RIGHT: 39,
        SPACEBAR: 32,
        TAB: 9,
        UP: 38,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        END: 35,
        HOME: 36,
        modifierPressed: (e)=>e.shiftKey || e.ctrlKey || e.altKey || Uu.metaKeyPressed(e)
        ,
        metaKeyPressed: (e)=>Nt.os.isMacOS() || Nt.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey
    }, zu = (e222, t141)=>{
        const n74 = "data-mce-selected", o41 = t141.dom, r27 = Bt.each;
        let s15, a9, i7, l7, d6, c, u, m, f, g, p3, h3, b;
        const v3 = t141.getDoc(), y3 = document, x3 = Math.abs, w3 = Math.round, k = t141.getBody();
        let S, _;
        const E = {
            nw: [
                0,
                0,
                -1,
                -1
            ],
            ne: [
                1,
                0,
                1,
                -1
            ],
            se: [
                1,
                1,
                1,
                1
            ],
            sw: [
                0,
                1,
                -1,
                1
            ]
        }, N2 = (e)=>C1(e) && (Lo(e) || t141.dom.is(e, "figure.image"))
        , R = (e)=>Fo(e) || o41.hasClass(e, "mce-preview-object")
        , A2 = (e223)=>{
            const n75 = e223.target;
            ((e, t)=>{
                if ("longpress" === e.type || 0 === e.type.indexOf("touch")) {
                    const n = e.touches[0];
                    return N2(e.target) && !Bu(n.clientX, n.clientY, t);
                }
                return N2(e.target) && !Bu(e.clientX, e.clientY, t);
            })(e223, t141.selection.getRng()) && !e223.isDefaultPrevented() && t141.selection.select(n75);
        }, O = (e)=>o41.is(e, "figure.image") ? [
                e.querySelector("img")
            ] : o41.hasClass(e, "mce-preview-object") && C1(e.firstElementChild) ? [
                e,
                e.firstElementChild
            ] : [
                e
            ]
        , T = (e)=>{
            const n = ol(t141);
            return !!n && "false" !== e.getAttribute("data-mce-resize") && e !== t141.getBody() && (o41.hasClass(e, "mce-preview-object") ? pn(mn(e.firstElementChild), n) : pn(mn(e), n));
        }, B2 = (e224, n, r)=>{
            if (C1(r)) {
                const s = O(e224);
                $1(s, (e)=>{
                    e.style[n] || !t141.schema.isValid(e.nodeName.toLowerCase(), n) ? o41.setStyle(e, n, r) : o41.setAttrib(e, n, "" + r);
                });
            }
        }, D = (e, t, n)=>{
            B2(e, "width", t), B2(e, "height", n);
        }, L = (e225)=>{
            let n76, r28, d, v, y;
            n76 = e225.screenX - c, r28 = e225.screenY - u, h3 = n76 * l7[2] + m, b = r28 * l7[3] + f, h3 = h3 < 5 ? 5 : h3, b = b < 5 ? 5 : b, d = (N2(s15) || R(s15)) && !1 !== rl(t141) ? !Uu.modifierPressed(e225) : Uu.modifierPressed(e225), d && (x3(n76) > x3(r28) ? (b = w3(h3 * g), h3 = w3(b / g)) : (h3 = w3(b / g), b = w3(h3 * g))), D(a9, h3, b), v = l7.startPos.x + n76, y = l7.startPos.y + r28, v = v > 0 ? v : 0, y = y > 0 ? y : 0, o41.setStyles(i7, {
                left: v,
                top: y,
                display: "block"
            }), i7.innerHTML = h3 + " &times; " + b, l7[2] < 0 && a9.clientWidth <= h3 && o41.setStyle(a9, "left", (void 0) + (m - h3)), l7[3] < 0 && a9.clientHeight <= b && o41.setStyle(a9, "top", (void 0) + (f - b)), n76 = k.scrollWidth - S, r28 = k.scrollHeight - _, n76 + r28 !== 0 && o41.setStyles(i7, {
                left: v - n76,
                top: y - r28
            }), p3 || (((e, t, n, o, r)=>{
                e.dispatch("ObjectResizeStart", {
                    target: t,
                    width: n,
                    height: o,
                    origin: r
                });
            })(t141, s15, m, f, "corner-" + l7.name), p3 = !0);
        }, P = ()=>{
            const e226 = p3;
            p3 = !1, e226 && (B2(s15, "width", h3), B2(s15, "height", b)), o41.unbind(v3, "mousemove", L), o41.unbind(v3, "mouseup", P), y3 !== v3 && (o41.unbind(y3, "mousemove", L), o41.unbind(y3, "mouseup", P)), o41.remove(a9), o41.remove(i7), o41.remove(d6), M2(s15), e226 && (((e, t, n, o, r)=>{
                e.dispatch("ObjectResized", {
                    target: t,
                    width: n,
                    height: o,
                    origin: r
                });
            })(t141, s15, h3, b, "corner-" + l7.name), o41.setAttrib(s15, "style", o41.getAttrib(s15, "style"))), t141.nodeChanged();
        }, M2 = (e227)=>{
            U();
            const p4 = o41.getPos(e227, k), C = p4.x, x = p4.y, w = e227.getBoundingClientRect(), N = w.width || w.right - w.left, A = w.height || w.bottom - w.top;
            s15 !== e227 && (I(), s15 = e227, h3 = b = 0);
            const B = t141.dispatch("ObjectSelected", {
                target: e227
            }), M = o41.getAttrib(s15, n74, "1");
            T(e227) && !B.isDefaultPrevented() ? r27(E, (e, t)=>{
                let r29;
                r29 = o41.get("mceResizeHandle" + t), r29 && o41.remove(r29), r29 = o41.add(k, "div", {
                    id: "mceResizeHandle" + t,
                    "data-mce-bogus": "all",
                    class: "mce-resizehandle",
                    unselectable: !0,
                    style: "cursor:" + t + "-resize; margin:0; padding:0"
                }), o41.bind(r29, "mousedown", (r30)=>{
                    r30.stopImmediatePropagation(), r30.preventDefault(), ((r)=>{
                        const p = O(s15)[0];
                        var h;
                        c = r.screenX, u = r.screenY, m = p.clientWidth, f = p.clientHeight, g = f / m, l7 = e, l7.name = t, l7.startPos = {
                            x: N * e[0] + C,
                            y: A * e[1] + x
                        }, S = k.scrollWidth, _ = k.scrollHeight, d6 = o41.add(k, "div", {
                            class: "mce-resize-backdrop",
                            "data-mce-bogus": "all"
                        }), o41.setStyles(d6, {
                            position: "fixed",
                            left: "0",
                            top: "0",
                            width: "100%",
                            height: "100%"
                        }), a9 = R(h = s15) ? o41.create("img", {
                            src: Nt.transparentSrc
                        }) : h.cloneNode(!0), o41.addClass(a9, "mce-clonedresizable"), o41.setAttrib(a9, "data-mce-bogus", "all"), a9.contentEditable = "false", o41.setStyles(a9, {
                            left: C,
                            top: x,
                            margin: 0
                        }), D(a9, N, A), a9.removeAttribute(n74), k.appendChild(a9), o41.bind(v3, "mousemove", L), o41.bind(v3, "mouseup", P), y3 !== v3 && (o41.bind(y3, "mousemove", L), o41.bind(y3, "mouseup", P)), i7 = o41.add(k, "div", {
                            class: "mce-resize-helper",
                            "data-mce-bogus": "all"
                        }, m + " &times; " + f);
                    })(r30);
                }), e.elm = r29, o41.setStyles(r29, {
                    left: N * e[0] + C - r29.offsetWidth / 2,
                    top: A * e[1] + x - r29.offsetHeight / 2
                });
            }) : I(), o41.getAttrib(s15, n74) || s15.setAttribute(n74, M);
        }, I = ()=>{
            U(), s15 && s15.removeAttribute(n74), fe1(E, (e, t)=>{
                const n = o41.get("mceResizeHandle" + t);
                n && (o41.unbind(n), o41.remove(n));
            });
        }, F = (s)=>{
            var a;
            let i, l;
            const d = (e, t)=>{
                if (e) do {
                    if (e === t) return !0;
                }while (e = e.parentNode)
            };
            p3 || t141.removed || (r27(o41.select("img[data-mce-selected],hr[data-mce-selected]"), (e)=>{
                e.removeAttribute(n74);
            }), l = "mousedown" === s.type ? s.target : e222.getNode(), l = null === (a = Ko(mn(l), "table,img,figure.image,hr,video,span.mce-preview-object").getOrUndefined()) || void 0 === a ? void 0 : a.dom, d(l, k) && (z(), i = e222.getStart(!0), d(i, l) && d(e222.getEnd(!0), l)) ? M2(l) : I());
        }, U = ()=>{
            fe1(E, (e)=>{
                e.elm && (o41.unbind(e.elm), delete e.elm);
            });
        }, z = ()=>{
            try {
                t141.getDoc().execCommand("enableObjectResizing", !1, "false");
            } catch (e) {}
        };
        return t141.on("init", ()=>{
            z();
            const e228 = Ks((e)=>{
                t141.composing || F(e);
            }, 0);
            t141.on("nodechange ResizeEditor ResizeWindow ResizeContent drop FullscreenStateChanged", e228.throttle), t141.on("keyup compositionend", (t)=>{
                s15 && "TABLE" === s15.nodeName && e228.throttle(t);
            }), t141.on("hide blur", I), t141.on("contextmenu longpress", A2, !0);
        }), t141.on("remove", U), {
            isResizable: T,
            showResizeRect: M2,
            hideResizeRect: I,
            updateResizeRect: F,
            destroy: ()=>{
                s15 = a9 = d6 = null;
            }
        };
    }, ju = (e229, t142, n77)=>{
        const o = e229.document.createRange();
        var r;
        return r = o, t142.fold((e)=>{
            r.setStartBefore(e.dom);
        }, (e, t)=>{
            r.setStart(e.dom, t);
        }, (e)=>{
            r.setStartAfter(e.dom);
        }), ((e, t143)=>{
            t143.fold((t)=>{
                e.setEndBefore(t.dom);
            }, (t, n)=>{
                e.setEnd(t.dom, n);
            }, (t)=>{
                e.setEndAfter(t.dom);
            });
        })(o, n77), o;
    }, Vu = (e, t, n, o, r)=>{
        const s = e.document.createRange();
        return s.setStart(t.dom, n), s.setEnd(o.dom, r), s;
    }, Hu = ci([
        {
            ltr: [
                "start",
                "soffset",
                "finish",
                "foffset"
            ]
        },
        {
            rtl: [
                "start",
                "soffset",
                "finish",
                "foffset"
            ]
        }
    ]), $u = (e, t, n)=>t(mn(n.startContainer), n.startOffset, mn(n.endContainer), n.endOffset)
    ;
    Hu.ltr, Hu.rtl;
    const qu = (e, t, n, o)=>({
            start: e,
            soffset: t,
            finish: n,
            foffset: o
        })
    , Wu = document.caretPositionFromPoint ? (e, t144, n78)=>{
        var o, r;
        return M1.from(null === (r = (o = e.dom).caretPositionFromPoint) || void 0 === r ? void 0 : r.call(o, t144, n78)).bind((t)=>{
            if (null === t.offsetNode) return M1.none();
            const n = e.dom.createRange();
            return n.setStart(t.offsetNode, t.offset), n.collapse(), M1.some(n);
        });
    } : document.caretRangeFromPoint ? (e, t, n)=>{
        var o, r;
        return M1.from(null === (r = (o = e.dom).caretRangeFromPoint) || void 0 === r ? void 0 : r.call(o, t, n));
    } : M1.none, Ku = ci([
        {
            before: [
                "element"
            ]
        },
        {
            on: [
                "element",
                "offset"
            ]
        },
        {
            after: [
                "element"
            ]
        }
    ]), Gu = {
        before: Ku.before,
        on: Ku.on,
        after: Ku.after,
        cata: (e, t, n, o)=>e.fold(t, n, o)
        ,
        getStart: (e)=>e.fold(R1, R1, R1)
    }, Yu = ci([
        {
            domRange: [
                "rng"
            ]
        },
        {
            relative: [
                "startSitu",
                "finishSitu"
            ]
        },
        {
            exact: [
                "start",
                "soffset",
                "finish",
                "foffset"
            ]
        }
    ]), Xu = {
        domRange: Yu.domRange,
        relative: Yu.relative,
        exact: Yu.exact,
        exactFromRange: (e)=>Yu.exact(e.start, e.soffset, e.finish, e.foffset)
        ,
        getWin: (e230)=>{
            const t = ((e231)=>e231.match({
                    domRange: (e)=>mn(e.startContainer)
                    ,
                    relative: (e, t)=>Gu.getStart(e)
                    ,
                    exact: (e, t, n, o)=>e
                })
            )(e230);
            return xn(t);
        },
        range: qu
    }, Qu = (e, t)=>{
        const n = Mt(e);
        return "input" === n ? Gu.after(e) : j1([
            "br",
            "img"
        ], n) ? 0 === t ? Gu.before(e) : Gu.after(e) : Gu.on(e, t);
    }, Ju = (e, t)=>{
        const n = e.fold(Gu.before, Qu, Gu.after), o = t.fold(Gu.before, Qu, Gu.after);
        return Xu.relative(n, o);
    }, Zu = (e, t, n, o)=>{
        const r = Qu(e, t), s = Qu(n, o);
        return Xu.relative(r, s);
    }, em = (e232, t)=>{
        const n = (t || document).createDocumentFragment();
        return $1(e232, (e)=>{
            n.appendChild(e.dom);
        }), mn(n);
    }, tm = (e233)=>{
        const t145 = Xu.getWin(e233).dom, n79 = (e, n, o, r)=>Vu(t145, e, n, o, r)
        , o42 = ((e234)=>e234.match({
                domRange: (e)=>{
                    const t = mn(e.startContainer), n = mn(e.endContainer);
                    return Zu(t, e.startOffset, n, e.endOffset);
                },
                relative: Ju,
                exact: Zu
            })
        )(e233);
        return ((e235, t146)=>{
            const n80 = ((e236, t147)=>t147.match({
                    domRange: (e)=>({
                            ltr: N1(e),
                            rtl: M1.none
                        })
                    ,
                    relative: (t, n)=>({
                            ltr: De1(()=>ju(e236, t, n)
                            ),
                            rtl: De1(()=>M1.some(ju(e236, n, t))
                            )
                        })
                    ,
                    exact: (t, n, o, r)=>({
                            ltr: De1(()=>Vu(e236, t, n, o, r)
                            ),
                            rtl: De1(()=>M1.some(Vu(e236, o, r, t, n))
                            )
                        })
                })
            )(e235, t146);
            return ((e237, t)=>{
                const n = t.ltr();
                return n.collapsed ? t.rtl().filter((e)=>!1 === e.collapsed
                ).map((e)=>Hu.rtl(mn(e.endContainer), e.endOffset, mn(e.startContainer), e.startOffset)
                ).getOrThunk(()=>$u(0, Hu.ltr, n)
                ) : $u(0, Hu.ltr, n);
            })(0, n80);
        })(t145, o42).match({
            ltr: n79,
            rtl: n79
        });
    }, nm = (e238, t148, n81)=>{
        var o43, r, s;
        return (o43 = n81.defaultView, r = e238, s = t148, ((e239, t, n)=>{
            const o = mn(e239.document);
            return Wu(o, t, n).map((e)=>qu(mn(e.startContainer), e.startOffset, mn(e.endContainer), e.endOffset)
            );
        })(o43, r, s)).map((e)=>{
            const t = n81.createRange();
            return t.setStart(e.start.dom, e.soffset), t.setEnd(e.finish.dom, e.foffset), t;
        }).getOrUndefined();
    }, om = (e, t)=>e && t && e.startContainer === t.startContainer && e.startOffset === t.startOffset && e.endContainer === t.endContainer && e.endOffset === t.endOffset
    , rm = (e240, t149, n82)=>null !== ((e, t, n)=>{
            for(; e && e !== t;){
                if (n(e)) return e;
                e = e.parentNode;
            }
            return null;
        })(e240, t149, n82)
    , sm = (e241, t, n)=>rm(e241, t, (e)=>e.nodeName === n
        )
    , am = (e)=>e && "TABLE" === e.nodeName
    , im = (e)=>e && /^(TD|TH|CAPTION)$/.test(e.nodeName)
    , lm = (e, t)=>vr(e) && !1 === rm(e, t, gc)
    , dm = (e, t, n)=>{
        const o = new Xo(t, e.getParent(t.parentNode, e.isBlock) || e.getRoot());
        for(; t = o[n ? "prev" : "next"]();)if (Do(t)) return !0;
    }, cm = (e, t, n, o, r)=>{
        let s;
        const a = e.getRoot();
        let i;
        const l = e.schema.getNonEmptyElements(), d = e.getParent(r.parentNode, e.isBlock) || a;
        if (o && Do(r) && t && e.isEmpty(d)) return M1.some(Ua(r.parentNode, e.nodeIndex(r)));
        const c = new Xo(r, d);
        for(; i = c[o ? "prev" : "next"]();){
            if ("false" === e.getContentEditableParent(i) || lm(i, a)) return M1.none();
            if (No(i) && i.nodeValue.length > 0) return !1 === sm(i, a, "A") ? M1.some(Ua(i, o ? i.nodeValue.length : 0)) : M1.none();
            if (e.isBlock(i) || l[i.nodeName.toLowerCase()]) return M1.none();
            s = i;
        }
        return n && s ? M1.some(Ua(s, 0)) : M1.none();
    }, um = (e242, t150, n, o)=>{
        let r, s;
        const a = e242.getRoot();
        let i, l, d = !1;
        r = o[(n ? "start" : "end") + "Container"], s = o[(n ? "start" : "end") + "Offset"];
        const c = yo(r) && s === r.childNodes.length, u = e242.schema.getNonEmptyElements();
        if (l = n, vr(r)) return M1.none();
        if (yo(r) && s > r.childNodes.length - 1 && (l = !1), To(r) && (r = a, s = 0), r === a) {
            if (l && (i = r.childNodes[s > 0 ? s - 1 : 0], i)) {
                if (vr(i)) return M1.none();
                if (u[i.nodeName] || am(i)) return M1.none();
            }
            if (r.hasChildNodes()) {
                if (s = Math.min(!l && s > 0 ? s - 1 : s, r.childNodes.length - 1), r = r.childNodes[s], s = No(r) && c ? r.data.length : 0, !t150 && r === a.lastChild && am(r)) return M1.none();
                if (((e, t)=>{
                    for(; t && t !== e;){
                        if (Mo(t)) return !0;
                        t = t.parentNode;
                    }
                    return !1;
                })(a, r) || vr(r)) return M1.none();
                if (r.hasChildNodes() && !1 === am(r)) {
                    i = r;
                    const t = new Xo(r, a);
                    do {
                        if (Mo(i) || vr(i)) {
                            d = !1;
                            break;
                        }
                        if (No(i) && i.nodeValue.length > 0) {
                            s = l ? 0 : i.nodeValue.length, r = i, d = !0;
                            break;
                        }
                        if (u[i.nodeName.toLowerCase()] && !im(i)) {
                            s = e242.nodeIndex(i), r = i.parentNode, l || s++, d = !0;
                            break;
                        }
                    }while (i = l ? t.next() : t.prev())
                }
            }
        }
        return t150 && (No(r) && 0 === s && cm(e242, c, t150, !0, r).each((e)=>{
            r = e.container(), s = e.offset(), d = !0;
        }), yo(r) && (i = r.childNodes[s], i || (i = r.childNodes[s - 1]), !i || !Do(i) || ((e, t)=>e.previousSibling && "A" === e.previousSibling.nodeName
        )(i) || dm(e242, i, !1) || dm(e242, i, !0) || cm(e242, c, t150, !0, i).each((e)=>{
            r = e.container(), s = e.offset(), d = !0;
        }))), l && !t150 && No(r) && s === r.nodeValue.length && cm(e242, c, t150, !1, r).each((e)=>{
            r = e.container(), s = e.offset(), d = !0;
        }), d ? M1.some(Ua(r, s)) : M1.none();
    }, mm = (e243, t)=>{
        const n = t.collapsed, o = t.cloneRange(), r = Ua.fromRangeStart(t);
        return um(e243, n, !0, o).each((e)=>{
            n && Ua.isAbove(r, e) || o.setStart(e.container(), e.offset());
        }), n || um(e243, n, !1, o).each((e)=>{
            o.setEnd(e.container(), e.offset());
        }), n && o.collapse(!0), om(t, o) ? M1.none() : M1.some(o);
    }, fm = (e, t)=>e.splitText(t)
    , gm = (e)=>{
        let t = e.startContainer, n = e.startOffset, o = e.endContainer, r = e.endOffset;
        return t === o && No(t) ? n > 0 && n < t.nodeValue.length && (o = fm(t, n), t = o.previousSibling, r > n ? (r -= n, t = o = fm(o, r).previousSibling, r = o.nodeValue.length, n = 0) : r = 0) : (No(t) && n > 0 && n < t.nodeValue.length && (t = fm(t, n), n = 0), No(o) && r > 0 && r < o.nodeValue.length && (o = fm(o, r).previousSibling, r = o.nodeValue.length)), {
            startContainer: t,
            startOffset: n,
            endContainer: o,
            endOffset: r
        };
    }, pm = (e244)=>({
            walk: (t, n)=>fu(e244, t, n)
            ,
            split: gm,
            normalize: (t)=>mm(e244, t).fold(L1, (e)=>(t.setStart(e.startContainer, e.startOffset), t.setEnd(e.endContainer, e.endOffset), !0)
                )
        })
    ;
    pm.compareRanges = om, pm.getCaretRangeFromPoint = nm, pm.getSelectedNode = va, pm.getNode = ya;
    const hm = ((e245, t151)=>{
        const n83 = (t152)=>{
            const n = ((e)=>{
                const t = e.dom;
                return zn(e) ? t.getBoundingClientRect().height : t.offsetHeight;
            })(t152);
            if (n <= 0 || null === n) {
                const n = $n(t152, e245);
                return parseFloat(n) || 0;
            }
            return n;
        }, o44 = (e, t153)=>Y1(t153, (t, n)=>{
                const o = $n(e, n), r = void 0 === o ? 0 : parseInt(o, 10);
                return isNaN(r) ? t : t + r;
            }, 0)
        ;
        return {
            set: (t, n)=>{
                if (!w1(n) && !n.match(/^[0-9]+$/)) throw new Error(e245 + ".set accepts only positive integer values. Value was " + n);
                const o = t.dom;
                an(o) && (o.style[e245] = n + "px");
            },
            get: n83,
            getOuter: n83,
            aggregate: o44,
            max: (e, t, n)=>{
                const r = o44(e, n);
                return t > r ? t - r : 0;
            }
        };
    })("height"), bm = ()=>mn(document)
    , vm = (e, t154)=>e.view(t154).fold(N1([]), (t)=>{
            const n = e.owner(t), o = vm(e, n);
            return [
                t
            ].concat(o);
        })
    ;
    var ym = Object.freeze({
        __proto__: null,
        view: (e)=>{
            var t;
            return (e.dom === document ? M1.none() : M1.from(null === (t = e.dom.defaultView) || void 0 === t ? void 0 : t.frameElement)).map(mn);
        },
        owner: (e)=>Cn(e)
    });
    const Cm = (e)=>"textarea" === Mt(e)
    , xm = (e246, t155)=>{
        const n84 = ((e)=>{
            const t = e.dom.ownerDocument, n = t.body, o = t.defaultView, r = t.documentElement;
            if (n === e.dom) return lo(n.offsetLeft, n.offsetTop);
            const s = co(null == o ? void 0 : o.pageYOffset, r.scrollTop), a = co(null == o ? void 0 : o.pageXOffset, r.scrollLeft), i = co(r.clientTop, n.clientTop), l = co(r.clientLeft, n.clientLeft);
            return uo(e).translate(a - l, s - i);
        })(e246), o45 = ((e)=>hm.get(e)
        )(e246);
        return {
            element: e246,
            bottom: n84.top + o45,
            height: o45,
            pos: n84,
            cleanup: t155
        };
    }, wm = (e, t, n, o)=>{
        Em(e, (r, s)=>Sm(e, t, n, o)
        , n);
    }, km = (e247, t156, n, o, r)=>{
        const s = {
            elm: o.element.dom,
            alignToTop: r
        };
        ((e, t)=>e.dispatch("ScrollIntoView", t).isDefaultPrevented()
        )(e247, s) || (n(t156, mo(t156).top, o, r), ((e, t)=>{
            e.dispatch("AfterScrollIntoView", t);
        })(e247, s));
    }, Sm = (e248, t157, n85, o46)=>{
        const r = mn(e248.getBody()), s = mn(e248.getDoc());
        r.dom.offsetWidth;
        const a = ((e249, t158)=>{
            const n86 = ((e, t)=>{
                const n = Nn(e);
                if (0 === n.length || Cm(e)) return {
                    element: e,
                    offset: t
                };
                if (t < n.length && !Cm(n[t])) return {
                    element: n[t],
                    offset: 0
                };
                {
                    const o = n[n.length - 1];
                    return Cm(o) ? {
                        element: e,
                        offset: t
                    } : "img" === Mt(o) ? {
                        element: o,
                        offset: 1
                    } : zt(o) ? {
                        element: o,
                        offset: Eu(o).length
                    } : {
                        element: o,
                        offset: Nn(o).length
                    };
                }
            })(e249, t158), o47 = dn('<span data-mce-bogus="all" style="display: inline-block;">\ufeff</span>');
            return Yn(n86.element, o47), xm(o47, ()=>to(o47)
            );
        })(mn(n85.startContainer), n85.startOffset);
        km(e248, s, t157, a, o46), a.cleanup();
    }, _m = (e250, t, n, o)=>{
        const r = mn(e250.getDoc());
        km(e250, r, n, ((e)=>xm(mn(e), S1)
        )(t), o);
    }, Em = (e, t, n)=>{
        const o = n.startContainer, r = n.startOffset, s = n.endContainer, a = n.endOffset;
        t(mn(o), mn(s));
        const i = e.dom.createRng();
        i.setStart(o, r), i.setEnd(s, a), e.selection.setRng(n);
    }, Nm = (e, t, n, o)=>{
        const r = e.pos;
        if (n) fo(r.left, r.top, o);
        else {
            const n = r.top - t + e.height;
            fo(r.left, n, o);
        }
    }, Rm = (e, t, n, o, r)=>{
        const s = n + t, a = o.pos.top, i = o.bottom, l = i - a >= n;
        a < t ? Nm(o, n, !1 !== r, e) : a > s ? Nm(o, n, l ? !1 !== r : !0 === r, e) : i > s && !l && Nm(o, n, !0 === r, e);
    }, Am = (e, t, n, o)=>{
        const r = e.dom.defaultView.innerHeight;
        Rm(e, t, r, n, o);
    }, Om = (e251, t159, n87, o48)=>{
        const r31 = e251.dom.defaultView.innerHeight;
        Rm(e251, t159, r31, n87, o48);
        const s16 = ((e252)=>{
            const t160 = bm(), n88 = mo(t160), o = ((e, t)=>{
                const n = t.owner(e);
                return vm(t, n);
            })(e252, ym), r = uo(e252), s = G1(o, (e, t)=>{
                const n = uo(t);
                return {
                    left: e.left + n.left,
                    top: e.top + n.top
                };
            }, {
                left: 0,
                top: 0
            });
            return lo(s.left + r.left + n88.left, s.top + r.top + n88.top);
        })(n87.element), a = ho(window);
        s16.top < a.y ? go(n87.element, !1 !== o48) : s16.top > a.bottom && go(n87.element, !0 === o48);
    }, Tm = (e, t, n)=>wm(e, Am, t, n)
    , Bm = (e, t, n)=>_m(e, t, Am, n)
    , Dm = (e, t, n)=>wm(e, Om, t, n)
    , Lm = (e, t, n)=>_m(e, t, Om, n)
    , Pm = (e, t, n)=>{
        (e.inline ? Tm : Dm)(e, t, n);
    }, Mm = (e)=>e.dom.focus()
    , Im = (e)=>{
        const t = Pn(e).dom;
        return e.dom === t.activeElement;
    }, Fm = (e = bm())=>M1.from(e.dom.activeElement).map(mn)
    , Um = (e, t)=>{
        const n = zt(t) ? Eu(t).length : Nn(t).length + 1;
        return e > n ? n : e < 0 ? 0 : e;
    }, zm = (e)=>Xu.range(e.start, Um(e.soffset, e.start), e.finish, Um(e.foffset, e.finish))
    , jm = (e, t)=>!vo(t.dom) && (vn(e, t) || bn(e, t))
    , Vm = (e)=>(t)=>jm(e, t.start) && jm(e, t.finish)
    , Hm = (e)=>Xu.range(mn(e.startContainer), e.startOffset, mn(e.endContainer), e.endOffset)
    , $m = (e)=>{
        const t = document.createRange();
        try {
            return t.setStart(e.start.dom, e.soffset), t.setEnd(e.finish.dom, e.foffset), M1.some(t);
        } catch (e253) {
            return M1.none();
        }
    }, qm = (e254)=>{
        const t161 = ((e)=>e.inline
        )(e254) ? (n = mn(e254.getBody()), ((e)=>{
            const t = e.getSelection();
            return (t && 0 !== t.rangeCount ? M1.from(t.getRangeAt(0)) : M1.none()).map(Hm);
        })(xn(n).dom).filter(Vm(n))) : M1.none();
        var n;
        e254.bookmark = t161.isSome() ? t161 : e254.bookmark;
    }, Wm = (e)=>(e.bookmark ? e.bookmark : M1.none()).bind((t)=>{
            var n, o;
            return n = mn(e.getBody()), o = t, M1.from(o).filter(Vm(n)).map(zm);
        }).bind($m)
    , Km = {
        isEditorUIElement: (e)=>{
            const t = e.className.toString();
            return -1 !== t.indexOf("tox-") || -1 !== t.indexOf("mce-");
        }
    }, Gm = {
        setEditorTimeout: (e255, t162, n)=>((e, t)=>(w1(t) || (t = 0), setTimeout(e, t))
            )(()=>{
                e255.removed || t162();
            }, n)
        ,
        setEditorInterval: (e256, t163, n)=>{
            const o = ((e, t)=>(w1(t) || (t = 0), setInterval(e, t))
            )(()=>{
                e256.removed ? clearInterval(o) : t163();
            }, n);
            return o;
        }
    };
    let Ym;
    const Xm = Is.DOM, Qm = (e257, t164)=>{
        const n = hl(e257), o = Xm.getParent(t164, (t)=>((e)=>Km.isEditorUIElement(e)
            )(t) || !!n && e257.dom.is(t, n)
        );
        return null !== o;
    }, Jm = (e258, t165)=>{
        const n89 = t165.editor;
        ((e259)=>{
            const t166 = Ks(()=>{
                qm(e259);
            }, 0);
            e259.on("init", ()=>{
                e259.inline && ((e, t)=>{
                    const n = ()=>{
                        t.throttle();
                    };
                    Is.DOM.bind(document, "mouseup", n), e.on("remove", ()=>{
                        Is.DOM.unbind(document, "mouseup", n);
                    });
                })(e259, t166), ((e260, t167)=>{
                    ((e, t)=>{
                        e.on("mouseup touchend", (e)=>{
                            t.throttle();
                        });
                    })(e260, t167), e260.on("keyup NodeChange AfterSetSelectionRange", (t)=>{
                        ((e)=>"nodechange" === e.type && e.selectionChange
                        )(t) || qm(e260);
                    });
                })(e259, t166);
            }), e259.on("remove", ()=>{
                t166.cancel();
            });
        })(n89), n89.on("focusin", ()=>{
            const t = e258.focusedEditor;
            t !== n89 && (t && t.dispatch("blur", {
                focusedEditor: n89
            }), e258.setActive(n89), e258.focusedEditor = n89, n89.dispatch("focus", {
                blurredEditor: t
            }), n89.focus(!0));
        }), n89.on("focusout", ()=>{
            Gm.setEditorTimeout(n89, ()=>{
                const t168 = e258.focusedEditor;
                Qm(n89, ((e261)=>{
                    try {
                        const t = Pn(mn(e261.getElement()));
                        return Fm(t).fold(()=>document.body
                        , (e)=>e.dom
                        );
                    } catch (e) {
                        return document.body;
                    }
                })(n89)) || t168 !== n89 || (n89.dispatch("blur", {
                    focusedEditor: null
                }), e258.focusedEditor = null);
            });
        }), Ym || (Ym = (t169)=>{
            const n = e258.activeEditor;
            n && Fn(t169).each((t)=>{
                t.ownerDocument === document && (t === document.body || Qm(n, t) || e258.focusedEditor !== n || (n.dispatch("blur", {
                    focusedEditor: null
                }), e258.focusedEditor = null));
            });
        }, Xm.bind(document, "focusin", Ym));
    }, Zm = (e, t)=>{
        e.focusedEditor === t.editor && (e.focusedEditor = null), e.activeEditor || (Xm.unbind(document, "focusin", Ym), Ym = null);
    }, ef = (e262, t170)=>{
        ((e263, t171)=>((e)=>e.collapsed ? M1.from(ya(e.startContainer, e.startOffset)).map(mn) : M1.none()
            )(t171).bind((t)=>sr(t) ? M1.some(t) : !1 === vn(e263, t) ? M1.some(e263) : M1.none()
            )
        )(mn(e262.getBody()), t170).bind((e)=>uc(e.dom)
        ).fold(()=>{
            e262.selection.normalize();
        }, (t)=>e262.selection.setRng(t.toRange())
        );
    }, tf = (e)=>{
        if (e.setActive) try {
            e.setActive();
        } catch (t) {
            e.focus();
        }
        else e.focus();
    }, nf = (e264)=>e264.inline ? ((e265)=>{
            const t = e265.getBody();
            var n, o;
            return t && (n = mn(t), Im(n) || (o = n, Fm(Pn(o)).filter((e)=>o.dom.contains(e.dom)
            )).isSome());
        })(e264) : ((e)=>e.iframeElement && Im(mn(e.iframeElement))
        )(e264)
    , of = (e)=>e.editorManager.setActive(e)
    , rf = (e266, t, n, o, r)=>{
        const s = n ? t.startContainer : t.endContainer, a = n ? t.startOffset : t.endOffset;
        return M1.from(s).map(mn).map((e)=>o && t.collapsed ? e : Rn(e, r(e, a)).getOr(e)
        ).bind((e)=>Ut(e) ? M1.some(e) : wn(e).filter(Ut)
        ).map((e)=>e.dom
        ).getOr(e266);
    }, sf = (e267, t172, n)=>rf(e267, t172, !0, n, (e, t)=>Math.min(Tn(e), t)
        )
    , af = (e, t173, n)=>rf(e, t173, !1, n, (e, t)=>t > 0 ? t - 1 : t
        )
    , lf = (e, t)=>{
        const n = e;
        for(; e && No(e) && 0 === e.length;)e = t ? e.nextSibling : e.previousSibling;
        return e || n;
    }, df = (e, t174)=>H1(t174, (t)=>{
            const n = e.dispatch("GetSelectionRange", {
                range: t
            });
            return n.range !== t ? n.range : t;
        })
    , cf = [
        "img",
        "br"
    ], uf = (e268)=>{
        const t = Nu(e268).filter((e)=>0 !== e.trim().length || e.indexOf(dr) > -1
        ).isSome();
        return t || j1(cf, Mt(e268));
    }, mf = "[data-mce-autocompleter]", ff = (e269, t175)=>{
        if (gf(mn(e269.getBody())).isNone()) {
            const o49 = dn('<span data-mce-autocompleter="1" data-mce-bogus="1"></span>', e269.getDoc());
            Jn(o49, mn(t175.extractContents())), t175.insertNode(o49.dom), wn(o49).each((e)=>e.dom.normalize()
            ), (n90 = o49, ((e271, t)=>{
                const n = (e)=>{
                    const o = Nn(e);
                    for(let e270 = o.length - 1; e270 >= 0; e270--){
                        const r = o[e270];
                        if (t(r)) return M1.some(r);
                        const s = n(r);
                        if (s.isSome()) return s;
                    }
                    return M1.none();
                };
                return n(e271);
            })(n90, uf)).map((t)=>{
                e269.selection.setCursorLocation(t.dom, ((e272)=>"img" === Mt(e272) ? 1 : Nu(e272).fold(()=>Nn(e272).length
                    , (e)=>e.length
                    )
                )(t));
            });
        }
        var n90;
    }, gf = (e)=>Wo(e, mf)
    , pf = {
        "#text": 3,
        "#comment": 8,
        "#cdata": 4,
        "#pi": 7,
        "#doctype": 10,
        "#document-fragment": 11
    }, hf = (e, t, n)=>{
        const o = n ? "lastChild" : "firstChild", r = n ? "prev" : "next";
        if (e[o]) return e[o];
        if (e !== t) {
            let n = e[r];
            if (n) return n;
            for(let o = e.parent; o && o !== t; o = o.parent)if (n = o[r], n) return n;
        }
    }, bf = (e)=>{
        if (!Fr(e.value)) return !1;
        const t = e.parent;
        return !t || "span" === t.name && !t.attr("style") || !/^[ ]+$/.test(e.value);
    }, vf = (e)=>{
        const t = "a" === e.name && !e.attr("href") && e.attr("id");
        return e.attr("name") || e.attr("id") && !e.firstChild || e.attr("data-mce-bookmark") || t;
    };
    class yf {
        constructor(e, t){
            this.name = e, this.type = t, 1 === t && (this.attributes = [], this.attributes.map = {});
        }
        static create(e273, t176) {
            const n = new yf(e273, pf[e273] || 1);
            return t176 && fe1(t176, (e, t)=>{
                n.attr(t, e);
            }), n;
        }
        replace(e) {
            const t = this;
            return e.parent && e.remove(), t.insert(e, t), t.remove(), t;
        }
        attr(e274, t177) {
            const n = this;
            let o;
            if ("string" != typeof e274) return null != e274 && fe1(e274, (e, t)=>{
                n.attr(t, e);
            }), n;
            if (o = n.attributes) {
                if (void 0 !== t177) {
                    if (null === t177) {
                        if (e274 in o.map) {
                            delete o.map[e274];
                            let t = o.length;
                            for(; t--;)if (o[t].name === e274) return o.splice(t, 1), n;
                        }
                        return n;
                    }
                    if (e274 in o.map) {
                        let n = o.length;
                        for(; n--;)if (o[n].name === e274) {
                            o[n].value = t177;
                            break;
                        }
                    } else o.push({
                        name: e274,
                        value: t177
                    });
                    return o.map[e274] = t177, n;
                }
                return o.map[e274];
            }
        }
        clone() {
            const e = this, t = new yf(e.name, e.type);
            let n;
            if (n = e.attributes) {
                const e = [];
                e.map = {};
                for(let t178 = 0, o = n.length; t178 < o; t178++){
                    const o = n[t178];
                    "id" !== o.name && (e[e.length] = {
                        name: o.name,
                        value: o.value
                    }, e.map[o.name] = o.value);
                }
                t.attributes = e;
            }
            return t.value = e.value, t;
        }
        wrap(e) {
            const t = this;
            return t.parent.insert(e, t), e.append(t), t;
        }
        unwrap() {
            const e = this;
            for(let t = e.firstChild; t;){
                const n = t.next;
                e.insert(t, e, !0), t = n;
            }
            e.remove();
        }
        remove() {
            const e = this, t = e.parent, n = e.next, o = e.prev;
            return t && (t.firstChild === e ? (t.firstChild = n, n && (n.prev = null)) : o.next = n, t.lastChild === e ? (t.lastChild = o, o && (o.next = null)) : n.prev = o, e.parent = e.next = e.prev = null), e;
        }
        append(e) {
            const t = this;
            e.parent && e.remove();
            const n = t.lastChild;
            return n ? (n.next = e, e.prev = n, t.lastChild = e) : t.lastChild = t.firstChild = e, e.parent = t, e;
        }
        insert(e, t, n) {
            e.parent && e.remove();
            const o = t.parent || this;
            return n ? (t === o.firstChild ? o.firstChild = e : t.prev.next = e, e.prev = t.prev, e.next = t, t.prev = e) : (t === o.lastChild ? o.lastChild = e : t.next.prev = e, e.next = t.next, e.prev = t, t.next = e), e.parent = o, e;
        }
        getAll(e) {
            const t = this, n = [];
            for(let o = t.firstChild; o; o = hf(o, t))o.name === e && n.push(o);
            return n;
        }
        children() {
            const e = [];
            for(let t = this.firstChild; t; t = t.next)e.push(t);
            return e;
        }
        empty() {
            const e = this;
            if (e.firstChild) {
                const t = [];
                for(let n = e.firstChild; n; n = hf(n, e))t.push(n);
                let n91 = t.length;
                for(; n91--;){
                    const e = t[n91];
                    e.parent = e.firstChild = e.lastChild = e.next = e.prev = null;
                }
            }
            return e.firstChild = e.lastChild = null, e;
        }
        isEmpty(e, t = {}, n) {
            const o = this;
            let r = o.firstChild;
            if (vf(o)) return !1;
            if (r) do {
                if (1 === r.type) {
                    if (r.attr("data-mce-bogus")) continue;
                    if (e[r.name]) return !1;
                    if (vf(r)) return !1;
                }
                if (8 === r.type) return !1;
                if (3 === r.type && !bf(r)) return !1;
                if (3 === r.type && r.parent && t[r.parent.name] && Fr(r.value)) return !1;
                if (n && n(r)) return !1;
            }while (r = hf(r, o))
            return !0;
        }
        walk(e) {
            return hf(this, null, e);
        }
    }
    const Cf = (e275, t179, n = 0)=>{
        const o = e275.toLowerCase();
        if (-1 !== o.indexOf("[if ", n) && ((e, t)=>/^\s*\[if [\w\W]+\]>.*<!\[endif\](--!?)?>/.test(e.substr(t))
        )(o, n)) {
            const e = o.indexOf("[endif]", n);
            return o.indexOf(">", e);
        }
        if (t179) {
            const e = o.indexOf(">", n);
            return -1 !== e ? e : o.length;
        }
        {
            const t = /--!?>/g;
            t.lastIndex = n;
            const r = t.exec(e275);
            return r ? r.index + r[0].length : o.length;
        }
    }, xf = (e, t, n)=>{
        const o = /<([!?\/])?([A-Za-z0-9\-_:.]+)/g, r = /(?:\s(?:[^'">]+(?:"[^"]*"|'[^']*'))*[^"'>]*(?:"[^">]*|'[^'>]*)?|\s*|\/)>/g, s = e.getVoidElements();
        let a = 1, i = n;
        for(; 0 !== a;)for(o.lastIndex = i;;){
            const e = o.exec(t);
            if (null === e) return i;
            if ("!" === e[1]) {
                i = ze1(e[2], "--") ? Cf(t, !1, e.index + 3) : Cf(t, !0, e.index + 1);
                break;
            }
            {
                r.lastIndex = o.lastIndex;
                const n = r.exec(t);
                if (h1(n) || n.index !== o.lastIndex) continue;
                "/" === e[1] ? a -= 1 : we1(s, e[2]) || (a += 1), i = o.lastIndex + n[0].length;
                break;
            }
        }
        return i;
    }, wf = (e276, t180)=>{
        const n92 = /<(\w+) [^>]*data-mce-bogus="all"[^>]*>/g, o = e276.schema;
        let r = ((e, t)=>{
            const n = new RegExp([
                "\\s?(" + e.join("|") + ')="[^"]+"'
            ].join("|"), "gi");
            return t.replace(n, "");
        })(e276.getTempAttrs(), t180);
        const s = o.getVoidElements();
        let a;
        for(; a = n92.exec(r);){
            const e = n92.lastIndex, t = a[0].length;
            let i;
            i = s[a[1]] ? e : xf(o, r, e), r = r.substring(0, e - t) + r.substring(i), n92.lastIndex = e - t;
        }
        return fr(r);
    }, kf = wf, Sf = Bt.each, _f = (e277)=>({
            compare: (t181, n93)=>{
                if (t181.nodeName !== n93.nodeName) return !1;
                const o51 = (t)=>{
                    const n = {};
                    return Sf(e277.getAttribs(t), (o)=>{
                        const r = o.nodeName.toLowerCase();
                        0 !== r.indexOf("_") && "style" !== r && 0 !== r.indexOf("data-") && (n[r] = e277.getAttrib(t, r));
                    }), n;
                }, r32 = (e, t)=>{
                    let n, o;
                    for(o in e)if (we1(e, o)) {
                        if (n = t[o], void 0 === n) return !1;
                        if (e[o] !== n) return !1;
                        delete t[o];
                    }
                    for(o in t)if (we1(t, o)) return !1;
                    return !0;
                };
                return !(!r32(o51(t181), o51(n93)) || !r32(e277.parseStyle(e277.getAttrib(t181, "style")), e277.parseStyle(e277.getAttrib(n93, "style"))) || _c(t181) || _c(n93));
            }
        })
    , Ef = Bt.makeMap, Nf = (e278)=>{
        const t = [], n94 = (e278 = e278 || {}).indent, o52 = Ef(e278.indent_before || ""), r = Ef(e278.indent_after || ""), s = ls.getEncodeFunc(e278.entity_encoding || "raw", e278.entities), a = "xhtml" !== e278.element_format;
        return {
            start: (e, i, l)=>{
                let d, c, u, m;
                if (n94 && o52[e] && t.length > 0 && (m = t[t.length - 1], m.length > 0 && "\n" !== m && t.push("\n")), t.push("<", e), i) for(d = 0, c = i.length; d < c; d++)u = i[d], t.push(" ", u.name, '="', s(u.value, !0), '"');
                t[t.length] = !l || a ? ">" : " />", l && n94 && r[e] && t.length > 0 && (m = t[t.length - 1], m.length > 0 && "\n" !== m && t.push("\n"));
            },
            end: (e)=>{
                let o;
                t.push("</", e, ">"), n94 && r[e] && t.length > 0 && (o = t[t.length - 1], o.length > 0 && "\n" !== o && t.push("\n"));
            },
            text: (e, n)=>{
                e.length > 0 && (t[t.length] = n ? e : s(e));
            },
            cdata: (e)=>{
                t.push("<![CDATA[", e, "]]>");
            },
            comment: (e)=>{
                t.push("\x3c!--", e, "--\x3e");
            },
            pi: (e, o)=>{
                o ? t.push("<?", e, " ", s(o), "?>") : t.push("<?", e, "?>"), n94 && t.push("\n");
            },
            doctype: (e)=>{
                t.push("<!DOCTYPE", e, ">", n94 ? "\n" : "");
            },
            reset: ()=>{
                t.length = 0;
            },
            getContent: ()=>t.join("").replace(/\n$/, "")
        };
    }, Rf = (e279, t183 = vs())=>{
        const n95 = Nf(e279);
        return (e279 = e279 || {}).validate = !("validate" in e279) || e279.validate, {
            serialize: (o53)=>{
                const r = e279.validate, s17 = {
                    3: (e)=>{
                        n95.text(e.value, e.raw);
                    },
                    8: (e)=>{
                        n95.comment(e.value);
                    },
                    7: (e)=>{
                        n95.pi(e.name, e.value);
                    },
                    10: (e)=>{
                        n95.doctype(e.value);
                    },
                    4: (e)=>{
                        n95.cdata(e.value);
                    },
                    11: (e)=>{
                        if (e = e.firstChild) do a(e);
                        while (e = e.next)
                    }
                };
                n95.reset();
                const a = (e)=>{
                    const o = s17[e.type];
                    if (o) o(e);
                    else {
                        const o = e.name, s = o in t183.getVoidElements();
                        let i = e.attributes;
                        if (r && i && i.length > 1) {
                            const n = [];
                            n.map = {};
                            const o = t183.getElementRule(e.name);
                            if (o) {
                                for(let e = 0, t = o.attributesOrder.length; e < t; e++){
                                    const t = o.attributesOrder[e];
                                    if (t in i.map) {
                                        const e = i.map[t];
                                        n.map[t] = e, n.push({
                                            name: t,
                                            value: e
                                        });
                                    }
                                }
                                for(let e280 = 0, t182 = i.length; e280 < t182; e280++){
                                    const t = i[e280].name;
                                    if (!(t in n.map)) {
                                        const e = i.map[t];
                                        n.map[t] = e, n.push({
                                            name: t,
                                            value: e
                                        });
                                    }
                                }
                                i = n;
                            }
                        }
                        if (n95.start(o, i, s), !s) {
                            let t = e.firstChild;
                            if (t) {
                                "pre" !== o && "textarea" !== o || 3 !== t.type || "\n" !== t.value[0] || n95.text("\n", !0);
                                do a(t);
                                while (t = t.next)
                            }
                            n95.end(o);
                        }
                    }
                };
                return 1 !== o53.type || e279.inner ? 3 === o53.type ? s17[3](o53) : s17[11](o53) : a(o53), n95.getContent();
            }
        };
    }, Af = new Set;
    $1([
        "margin",
        "margin-left",
        "margin-right",
        "margin-top",
        "margin-bottom",
        "padding",
        "padding-left",
        "padding-right",
        "padding-top",
        "padding-bottom",
        "border",
        "border-width",
        "border-style",
        "border-color",
        "background",
        "background-attachment",
        "background-clip",
        "background-color",
        "background-image",
        "background-origin",
        "background-position",
        "background-repeat",
        "background-size",
        "float",
        "position",
        "left",
        "right",
        "top",
        "bottom",
        "z-index",
        "display",
        "transform",
        "width",
        "max-width",
        "min-width",
        "height",
        "max-height",
        "min-height",
        "overflow",
        "overflow-x",
        "overflow-y",
        "text-overflow",
        "vertical-align",
        "transition",
        "transition-delay",
        "transition-duration",
        "transition-property",
        "transition-timing-function"
    ], (e)=>{
        Af.add(e);
    });
    const Of = [
        "font",
        "text-decoration",
        "text-emphasis"
    ], Tf = (e, t)=>ue1(e.parseStyle(e.getAttrib(t, "style")))
    , Bf = (e281, t184, n)=>{
        const o54 = Tf(e281, t184), r33 = Tf(e281, n), s18 = (o)=>{
            var r, s;
            const a = null !== (r = e281.getStyle(t184, o)) && void 0 !== r ? r : "", i = null !== (s = e281.getStyle(n, o)) && void 0 !== s ? s : "";
            return We(a) && We(i) && a !== i;
        };
        return V1(o54, (e)=>{
            const t185 = (t186)=>V1(t186, (t)=>t === e
                )
            ;
            if (!t185(r33) && t185(Of)) {
                const e282 = K1(r33, (e)=>V1(Of, (t)=>ze1(e, t)
                    )
                );
                return V1(e282, s18);
            }
            return s18(e);
        });
    }, Df = (e, t, n)=>M1.from(n.container()).filter(No).exists((o)=>{
            const r = e ? 0 : -1;
            return t(o.data.charAt(n.offset() + r));
        })
    , Lf = O1(Df, !0, Nc), Pf = O1(Df, !1, Nc), Mf = (e)=>{
        const t = e.container();
        return No(t) && (0 === t.data.length || mr(t.data) && Tu.isBookmarkNode(t.parentNode));
    }, If = (e, t)=>(n)=>M1.from(Bd(e ? 0 : -1, n)).filter(t).isSome()
    , Ff = (e)=>Lo(e) && "block" === $n(mn(e), "display")
    , Uf = (e283)=>Mo(e283) && !((e)=>yo(e) && "all" === e.getAttribute("data-mce-bogus")
        )(e283)
    , zf = If(!0, Ff), jf = If(!1, Ff), Vf = If(!0, Fo), Hf = If(!1, Fo), $f = If(!0, So), qf = If(!1, So), Wf = If(!0, Uf), Kf = If(!1, Uf), Gf = (e)=>{
        eo(e), Jn(e, dn('<br data-mce-bogus="1">'));
    }, Yf = (e)=>{
        On(e).each((t)=>{
            kn(t).each((n)=>{
                Zo(e) && tr(t) && Zo(n) && to(t);
            });
        });
    }, Xf = (e284, t187)=>((e285, t188, n96)=>{
            var o55;
            return vn(t188, e285) ? (o55 = ((e, t)=>{
                const n = x1(t) ? t : L1;
                let o = e.dom;
                const r = [];
                for(; null !== o.parentNode && void 0 !== o.parentNode;){
                    const e = o.parentNode, t = mn(e);
                    if (r.push(t), !0 === n(t)) break;
                    o = e;
                }
                return r;
            })(e285, (e)=>n96(e) || bn(e, t188)
            ), o55.slice(0, -1)) : [];
        })(e284, t187, L1)
    , Qf = (e, t)=>[
            e
        ].concat(Xf(e, t))
    , Jf = (e, t, n)=>ic(e, t, n, Mf)
    , Zf = (e, t)=>Q1(Qf(mn(t.container()), e), Zo)
    , eg = (e286, t, n)=>Jf(e286, t.dom, n).forall((e)=>Zf(t, n).fold(()=>!1 === Td(e, n, t.dom)
            , (o)=>!1 === Td(e, n, t.dom) && vn(o, mn(e.container()))
            )
        )
    , tg = (e287, t189, n)=>Zf(t189, n).fold(()=>Jf(e287, t189.dom, n).forall((e)=>!1 === Td(e, n, t189.dom)
            )
        , (t)=>Jf(e287, t.dom, n).isNone()
        )
    , ng = O1(tg, !1), og = O1(tg, !0), rg = O1(eg, !1), sg = O1(eg, !0), ag = (e)=>jd(e).exists(tr)
    , ig = (e, t, n)=>{
        const o = K1(Qf(mn(n.container()), t), Zo), r = ie1(o).getOr(t);
        return sc(e, r.dom, n).filter(ag);
    }, lg = (e, t)=>jd(t).exists(tr) || ig(!0, e, t).isSome()
    , dg = (e288, t)=>((e)=>M1.from(e.getNode(!0)).map(mn)
        )(t).exists(tr) || ig(!1, e288, t).isSome()
    , cg = O1(ig, !1), ug = O1(ig, !0), mg = (e)=>Ua.isTextPosition(e) && !e.isAtStart() && !e.isAtEnd()
    , fg = (e, t)=>{
        const n = K1(Qf(mn(t.container()), e), Zo);
        return ie1(n).getOr(e);
    }, gg = (e, t)=>mg(t) ? Pf(t) : Pf(t) || cc(fg(e, t).dom, t).exists(Pf)
    , pg = (e, t)=>mg(t) ? Lf(t) : Lf(t) || dc(fg(e, t).dom, t).exists(Lf)
    , hg = (e289)=>jd(e289).bind((e)=>$o(e, Ut)
        ).exists((e290)=>((e)=>j1([
                    "pre",
                    "pre-wrap"
                ], e)
            )($n(e290, "white-space"))
        )
    , bg = (e, t)=>!hg(t) && (ng(e, t) || rg(e, t) || dg(e, t) || gg(e, t))
    , vg = (e, t)=>!hg(t) && (og(e, t) || sg(e, t) || lg(e, t) || pg(e, t))
    , yg = (e291, t190)=>bg(e291, t190) || vg(e291, ((e)=>{
            const t = e.container(), n = e.offset();
            return No(t) && n < t.data.length ? Ua(t, n + 1) : e;
        })(t190))
    , Cg = (e, t)=>Ec(e.charAt(t))
    , xg = (e)=>{
        const t = e.container();
        return No(t) && Ue1(t.data, dr);
    }, wg = (e292, t191)=>M1.some(t191).filter(xg).bind((t192)=>{
            const n97 = t192.container(), o56 = ((e, t)=>{
                const n = t.data, o = Ua(t, 0);
                return !(!Cg(n, 0) || yg(e, o) || (t.data = " " + n.slice(1), 0));
            })(e292, n97) || ((e293)=>{
                const t193 = e293.data, n98 = ((e294)=>{
                    const t = e294.split("");
                    return H1(t, (e, n)=>Ec(e) && n > 0 && n < t.length - 1 && Rc(t[n - 1]) && Rc(t[n + 1]) ? " " : e
                    ).join("");
                })(t193);
                return n98 !== t193 && (e293.data = n98, !0);
            })(n97) || ((e, t)=>{
                const n = t.data, o = Ua(t, n.length - 1);
                return !(!Cg(n, n.length - 1) || yg(e, o) || (t.data = n.slice(0, -1) + " ", 0));
            })(e292, n97);
            return o56 ? M1.some(t192) : M1.none();
        })
    , kg = (e, t, n)=>{
        if (0 === n) return;
        const o = mn(e), r = Ho(o, Zo).getOr(o), s = e.data.slice(t, t + n), a = t + n >= e.data.length && vg(r, Ua(e, e.data.length)), i = 0 === t && bg(r, Ua(e, 0));
        e.replaceData(t, n, zr(s, 4, i, a));
    }, Sg = (e, t)=>{
        const n = e.data.slice(t), o = n.length - $e(n).length;
        kg(e, t, o);
    }, _g = (e, t)=>{
        const n = e.data.slice(0, t), o = n.length - qe(n).length;
        kg(e, t - o, o);
    }, Eg = (e, t, n, o = !0)=>{
        const r = qe(e.data).length, s = o ? e : t, a = o ? t : e;
        return o ? s.appendData(a.data) : s.insertData(0, a.data), to(mn(a)), n && Sg(s, r), s;
    }, Ng = (e295, t194)=>((e, t)=>{
            const n = e.container(), o = e.offset();
            return !1 === Ua.isTextPosition(e) && n === t.parentNode && o > Ua.before(t).offset();
        })(t194, e295) ? Ua(t194.container(), t194.offset() - 1) : t194
    , Rg = (e)=>{
        var t;
        return Lr(e.previousSibling) ? M1.some((t = e.previousSibling, No(t) ? Ua(t, t.data.length) : Ua.after(t))) : e.previousSibling ? mc(e.previousSibling) : M1.none();
    }, Ag = (e)=>{
        var t;
        return Lr(e.nextSibling) ? M1.some((t = e.nextSibling, No(t) ? Ua(t, 0) : Ua.before(t))) : e.nextSibling ? uc(e.nextSibling) : M1.none();
    }, Og = (e296, t195, n99)=>((e297, t196, n100)=>e297 ? ((e298, t197)=>Ag(t197).orThunk(()=>Rg(t197)
                ).orThunk(()=>((e, t)=>dc(e, Ua.after(t)).fold(()=>cc(e, Ua.before(t))
                        , M1.some)
                    )(e298, t197)
                )
            )(t196, n100) : ((e299, t198)=>Rg(t198).orThunk(()=>Ag(t198)
                ).orThunk(()=>((e, t)=>{
                        const n = Ua.before(t.previousSibling ? t.previousSibling : t.parentNode);
                        return cc(e, n).fold(()=>dc(e, Ua.after(t))
                        , M1.some);
                    })(e299, t198)
                )
            )(t196, n100)
        )(e296, t195, n99).map(O1(Ng, n99))
    , Tg = (e, t, n101)=>{
        n101.fold(()=>{
            e.focus();
        }, (n)=>{
            e.selection.setRng(n.toRange(), t);
        });
    }, Bg = (e, t)=>t && we1(e.schema.getBlockElements(), Mt(t))
    , Dg = (e)=>{
        if (qr(e)) {
            const t = dn('<br data-mce-bogus="1">');
            return eo(e), Jn(e, t), M1.some(Ua.before(t.dom));
        }
        return M1.none();
    }, Lg = (e300, t199, n102, o57 = !0)=>{
        const r34 = Og(t199, e300.getBody(), n102.dom), s19 = Ho(n102, O1(Bg, e300), (a10 = e300.getBody(), (e)=>e.dom === a10
        ));
        var a10;
        const i8 = ((e301, t200, n)=>{
            const o58 = kn(e301).filter(zt), r35 = Sn(e301).filter(zt);
            var s20, a11, i, l;
            return to(e301), (s20 = o58, a11 = r35, i = t200, l = (e, t, o)=>{
                const r = e.dom, s = t.dom, a = r.data.length;
                return Eg(r, s, n), o.container() === s ? Ua(r, a) : o;
            }, s20.isSome() && a11.isSome() && i.isSome() ? M1.some(l(s20.getOrDie(), a11.getOrDie(), i.getOrDie())) : M1.none()).orThunk(()=>(n && (o58.each((e)=>_g(e.dom, e.dom.length)
                ), r35.each((e)=>Sg(e.dom, 0)
                )), t200)
            );
        })(n102, r34, ((e, t)=>we1(e.schema.getTextInlineElements(), Mt(t))
        )(e300, n102));
        e300.dom.isEmpty(e300.getBody()) ? (e300.setContent(""), e300.selection.setCursorLocation()) : s19.bind(Dg).fold(()=>{
            o57 && Tg(e300, t199, i8);
        }, (n)=>{
            o57 && Tg(e300, t199, M1.some(n));
        });
    }, Pg = (e)=>Xs(e, "td,th")
    , Mg = (e, t)=>({
            start: e,
            end: t
        })
    , Ig = ci([
        {
            singleCellTable: [
                "rng",
                "cell"
            ]
        },
        {
            fullTable: [
                "table"
            ]
        },
        {
            partialTable: [
                "cells",
                "outsideDetails"
            ]
        },
        {
            multiTable: [
                "startTableCells",
                "endTableCells",
                "betweenRng"
            ]
        }
    ]), Fg = (e, t)=>Ko(mn(e), "td,th", t)
    , Ug = (e)=>!bn(e.start, e.end)
    , zg = (e302, t)=>bu(e302.start, t).bind((n)=>bu(e302.end, t).bind((e)=>Pt(bn(n, e), n)
            )
        )
    , jg = (e303)=>(t201)=>zg(t201, e303).map((e304)=>((e, t, n)=>({
                        rng: e,
                        table: t,
                        cells: n
                    })
                )(t201, e304, Pg(e304))
            )
    , Vg = (e306, t203, n, o)=>{
        if (n.collapsed || !e306.forall(Ug)) return M1.none();
        if (t203.isSameTable) {
            const t = e306.bind(jg(o));
            return M1.some({
                start: t,
                end: t
            });
        }
        {
            const e305 = Fg(n.startContainer, o), t202 = Fg(n.endContainer, o), r = e305.bind(((e307)=>(t)=>bu(t, e307).bind((e308)=>le1(Pg(e308)).map((e)=>Mg(t, e)
                        )
                    )
            )(o)).bind(jg(o)), s = t202.bind(((e309)=>(t)=>bu(t, e309).bind((e310)=>ie1(Pg(e310)).map((e)=>Mg(e, t)
                        )
                    )
            )(o)).bind(jg(o));
            return M1.some({
                start: r,
                end: s
            });
        }
    }, Hg = (e311, t)=>J1(e311, (e)=>bn(e, t)
        )
    , $g = (e)=>Lt(Hg(e.cells, e.rng.start), Hg(e.cells, e.rng.end), (t, n)=>e.cells.slice(t, n + 1)
        )
    , qg = (e312, t)=>{
        const { startTable: n , endTable: o  } = t, r = e312.cloneRange();
        return n.each((e)=>r.setStartAfter(e.dom)
        ), o.each((e)=>r.setEndBefore(e.dom)
        ), r;
    }, Wg = (e313, t204)=>{
        const n103 = ((e)=>(t)=>bn(e, t)
        )(e313), o59 = ((e, t)=>{
            const n = Fg(e.startContainer, t), o = Fg(e.endContainer, t);
            return Lt(n, o, Mg);
        })(t204, n103), r36 = ((e314, t)=>{
            const n = (e)=>bu(mn(e), t)
            , o = n(e314.startContainer), r = n(e314.endContainer), s = o.isSome(), a = r.isSome(), i = Lt(o, r, bn).getOr(!1);
            return {
                startTable: o,
                endTable: r,
                isStartInTable: s,
                isEndInTable: a,
                isSameTable: i,
                isMultiTable: !i && s && a
            };
        })(t204, n103);
        return ((e315, t205, n)=>e315.exists((e316)=>((e317, t206)=>!Ug(e317) && zg(e317, t206).exists((e)=>{
                        const t = e.dom.rows;
                        return 1 === t.length && 1 === t[0].cells.length;
                    })
                )(e316, n) && Cu(e316.start, t205)
            )
        )(o59, t204, n103) ? o59.map((e)=>Ig.singleCellTable(t204, e.start)
        ) : r36.isMultiTable ? ((e318, t, n, o60)=>Vg(e318, t, n, o60).bind(({ start: e , end: o  })=>{
                const r = e.bind($g).getOr([]), s = o.bind($g).getOr([]);
                if (r.length > 0 && s.length > 0) {
                    const e = qg(n, t);
                    return M1.some(Ig.multiTable(r, s, e));
                }
                return M1.none();
            })
        )(o59, r36, t204, n103) : ((e319, t207, n, o61)=>Vg(e319, t207, n, o61).bind(({ start: e , end: t  })=>e.or(t)
            ).bind((e)=>{
                const { isSameTable: o  } = t207, r = $g(e).getOr([]);
                if (o && e.cells.length === r.length) return M1.some(Ig.fullTable(e.table));
                if (r.length > 0) {
                    if (o) return M1.some(Ig.partialTable(r, M1.none()));
                    {
                        const e = qg(n, t207);
                        return M1.some(Ig.partialTable(r, M1.some({
                            ...t207,
                            rng: e
                        })));
                    }
                }
                return M1.none();
            })
        )(o59, r36, t204, n103);
    }, Kg = (e)=>{
        var t;
        return (8 === It(t = e) || "#comment" === Mt(t) ? kn(e) : On(e)).bind(Kg).orThunk(()=>M1.some(e)
        );
    }, Gg = (e320)=>$1(e320, (e)=>{
            Yt(e, "contenteditable"), Gf(e);
        })
    , Yg = (e321, t, n, o)=>{
        const r = n.cloneRange();
        o ? (r.setStart(n.startContainer, n.startOffset), r.setEndAfter(t.dom.lastChild)) : (r.setStartBefore(t.dom.firstChild), r.setEnd(n.endContainer, n.endOffset)), Zg(e321, r, t, !1).each((e)=>e()
        );
    }, Xg = (e322)=>{
        const t = hu(e322), n = mn(e322.selection.getNode());
        Io(n.dom) && qr(n) ? e322.selection.setCursorLocation(n.dom, 0) : e322.selection.collapse(!0), t.length > 1 && V1(t, (e)=>bn(e, n)
        ) && $t(n, "data-mce-selected", "1");
    }, Qg = (e323, t208, n104)=>M1.some(()=>{
            const o = e323.selection.getRng(), r37 = n104.bind(({ rng: n105 , isStartInTable: r  })=>{
                const s = ((e, t)=>M1.from(e.dom.getParent(t, e.dom.isBlock)).map(mn)
                )(e323, r ? n105.endContainer : n105.startContainer);
                n105.deleteContents(), ((e, t, n106)=>{
                    n106.each((n)=>{
                        t ? to(n) : (Gf(n), e.selection.setCursorLocation(n.dom, 0));
                    });
                })(e323, r, s.filter(qr));
                const a = r ? t208[0] : t208[t208.length - 1];
                return Yg(e323, a, o, r), qr(a) ? M1.none() : M1.some(r ? t208.slice(1) : t208.slice(0, -1));
            }).getOr(t208);
            Gg(r37), Xg(e323);
        })
    , Jg = (e, t, n, o)=>M1.some(()=>{
            const r = e.selection.getRng(), s = t[0], a = n[n.length - 1];
            Yg(e, s, r, !0), Yg(e, a, r, !1);
            const i = qr(s) ? t : t.slice(1), l = qr(a) ? n : n.slice(0, -1);
            Gg(i.concat(l)), o.deleteContents(), Xg(e);
        })
    , Zg = (e324, t, n, o = !0)=>M1.some(()=>{
            t.deleteContents();
            const r = Kg(n).getOr(n), s = mn(e324.dom.getParent(r.dom, e324.dom.isBlock));
            if (qr(s) && (Gf(s), o && e324.selection.setCursorLocation(s.dom, 0)), !bn(n, s)) {
                const e325 = Dt(wn(s), n) ? [] : wn(a = s).map(Nn).map((e327)=>K1(e327, (e)=>!bn(a, e)
                    )
                ).getOr([]);
                $1(e325.concat(Nn(n)), (e)=>{
                    bn(e, s) || vn(e, s) || !qr(e) || to(e);
                });
            }
            var a;
        })
    , ep = (e, t)=>M1.some(()=>Lg(e, !1, t)
        )
    , tp = (e, t)=>Q1(Qf(t, e), ar)
    , np = (e328, t)=>Q1(Qf(t, e328), (e)=>Ut(e) && "caption" === Mt(e)
        )
    , op = (e, t)=>M1.some(()=>{
            Gf(t), e.selection.setCursorLocation(t.dom, 0);
        })
    , rp = (e, t)=>e ? $f(t) : qf(t)
    , sp = (e329, t209, n107)=>{
        const o62 = mn(e329.getBody());
        return np(o62, n107).fold(()=>((e330, t210, n108, o63)=>{
                const r38 = Ua.fromRangeStart(e330.selection.getRng());
                return tp(n108, o63).bind((o64)=>qr(o64) ? op(e330, o64) : ((e331, t, n, o, r)=>ac(n, e331.getBody(), r).bind((e332)=>tp(t, mn(e332.getNode())).bind((e)=>bn(e, o) ? M1.none() : M1.some(S1)
                            )
                        )
                    )(e330, n108, t210, o64, r38)
                );
            })(e329, t209, o62, n107).orThunk(()=>Pt(((e333, t)=>{
                    const n = Ua.fromRangeStart(e333.selection.getRng());
                    return rp(t, n) || sc(t, e333.getBody(), n).exists((e)=>rp(t, e)
                    );
                })(e329, t209), S1)
            )
        , (n109)=>((e334, t211, n110, o65)=>{
                const r39 = Ua.fromRangeStart(e334.selection.getRng());
                return qr(o65) ? op(e334, o65) : ((e335, t212, n111, o66, r40)=>ac(n111, e335.getBody(), r40).fold(()=>M1.some(S1)
                    , (s)=>((e336, t, n, o)=>uc(e336.dom).bind((r)=>mc(e336.dom).map((e)=>t ? n.isEqual(r) && o.isEqual(e) : n.isEqual(e) && o.isEqual(r)
                                )
                            ).getOr(!0)
                        )(o66, n111, r40, s) ? ((e, t)=>op(e, t)
                        )(e335, o66) : ((e337, t, n)=>np(e337, mn(n.getNode())).fold(()=>M1.some(S1)
                            , (e)=>Pt(!bn(e, t), S1)
                            )
                        )(t212, o66, s)
                    )
                )(e334, n110, t211, o65, r39);
            })(e329, t209, o62, n109)
        );
    }, ap = (e338, t213)=>{
        const n112 = mn(e338.selection.getStart(!0)), o67 = hu(e338);
        return e338.selection.isCollapsed() && 0 === o67.length ? sp(e338, t213, n112) : ((e339, t214, n113)=>{
            const o68 = mn(e339.getBody()), r = e339.selection.getRng();
            return 0 !== n113.length ? Qg(e339, n113, M1.none()) : ((e340, t215, n114, o)=>np(t215, o).fold(()=>((e, t216, n)=>Wg(t216, n).bind((t)=>t.fold(O1(Zg, e), O1(ep, e), O1(Qg, e), O1(Jg, e))
                        )
                    )(e340, t215, n114)
                , (t217)=>((e, t)=>op(e, t)
                    )(e340, t217)
                )
            )(e339, o68, r, t214);
        })(e338, n112, o67);
    }, ip = (e, t)=>{
        for(; t && t !== e;){
            if (Po(t) || Mo(t)) return t;
            t = t.parentNode;
        }
        return null;
    }, lp = (e, t)=>{
        t(e), e.firstChild && lp(e.firstChild, t), e.next && lp(e.next, t);
    }, dp = (e, t, n, o)=>{
        const r = n.name;
        for(let t218 = 0, s = e.length; t218 < s; t218++){
            const s = e[t218];
            if (s.name === r) {
                const e = o.nodes[r];
                e ? e.nodes.push(n) : o.nodes[r] = {
                    filter: s,
                    nodes: [
                        n
                    ]
                };
            }
        }
        if (n.attributes) for(let e341 = 0, r41 = t.length; e341 < r41; e341++){
            const r = t[e341], s = r.name;
            if (s in n.attributes.map) {
                const e = o.attributes[s];
                e ? e.nodes.push(n) : o.attributes[s] = {
                    filter: r,
                    nodes: [
                        n
                    ]
                };
            }
        }
    }, cp = (e342, t)=>{
        const n115 = (e343)=>{
            fe1(e343, (e344)=>{
                const n = K1(e344.nodes, (e)=>C1(e.parent)
                );
                $1(e344.filter.callbacks, (o)=>{
                    o(n, e344.filter.name, t);
                });
            });
        };
        n115(e342.nodes), n115(e342.attributes);
    }, up = (e345, t219, n116, o69 = {})=>{
        const r = ((e, t, n117)=>{
            const o = {
                nodes: {},
                attributes: {}
            };
            return n117.firstChild && lp(n117.firstChild, (n)=>{
                dp(e, t, n, o);
            }), o;
        })(e345, t219, n116);
        cp(r, o69);
    }, mp = (e, t, n, o)=>{
        t.insert && n[o.name] ? o.empty().append(new yf("br", 1)) : o.empty().append(new yf("#text", 3)).value = dr;
    }, fp = (e, t)=>e && e.firstChild && e.firstChild === e.lastChild && e.firstChild.name === t
    , gp = (e346, t220, n118, o)=>o.isEmpty(t220, n118, (t221)=>((e, t)=>{
                const n = e.getElementRule(t.name);
                return n && n.paddEmpty;
            })(e346, t221)
        )
    , pp = (e, t, n = e.parent)=>{
        if (t.getSpecialElements()[e.name]) e.empty().remove();
        else {
            const o = e.children();
            for (const e347 of o)t.isValidChild(n.name, e347.name) || pp(e347, t, n);
            e.unwrap();
        }
    }, hp = (e, t, n = S1)=>{
        const o = t.getTextBlockElements(), r = t.getNonEmptyElements(), s = t.getWhitespaceElements(), a = Bt.makeMap("tr,td,th,tbody,thead,tfoot,table"), i = new Set;
        for(let l = 0; l < e.length; l++){
            const d = e[l];
            let c, u, m;
            if (!d.parent || i.has(d)) continue;
            if (o[d.name] && "li" === d.parent.name) {
                let e = d.next;
                for(; e && o[e.name];)e.name = "li", i.add(e), d.parent.insert(e, d.parent), e = e.next;
                d.unwrap();
                continue;
            }
            const f = [
                d
            ];
            for(c = d.parent; c && !t.isValidChild(c.name, d.name) && !a[c.name]; c = c.parent)f.push(c);
            if (c && f.length > 1) {
                if (t.isValidChild(c.name, d.name)) {
                    f.reverse(), u = f[0].clone(), n(u);
                    let e = u;
                    for(let o = 0; o < f.length - 1; o++){
                        t.isValidChild(e.name, f[o].name) ? (m = f[o].clone(), n(m), e.append(m)) : m = e;
                        for(let e348 = f[o].firstChild; e348 && e348 !== f[o + 1];){
                            const t = e348.next;
                            m.append(e348), e348 = t;
                        }
                        e = m;
                    }
                    gp(t, r, s, u) ? c.insert(d, f[0], !0) : (c.insert(u, f[0], !0), c.insert(d, u)), c = f[0], (gp(t, r, s, c) || fp(c, "br")) && c.empty().remove();
                } else pp(d, t);
            } else if (d.parent) {
                if ("li" === d.name) {
                    let e = d.prev;
                    if (e && ("ul" === e.name || "ol" === e.name)) {
                        e.append(d);
                        continue;
                    }
                    if (e = d.next, e && ("ul" === e.name || "ol" === e.name)) {
                        e.insert(d, e.firstChild, !0);
                        continue;
                    }
                    const t = new yf("ul", 1);
                    n(t), d.wrap(t);
                    continue;
                }
                if (t.isValidChild(d.parent.name, "div") && t.isValidChild("div", d.name)) {
                    const e = new yf("div", 1);
                    n(e), d.wrap(e);
                } else pp(d, t);
            }
        }
    }, bp = (e349)=>e349.collapsed ? e349 : ((e350)=>{
            const t222 = Ua.fromRangeStart(e350), n119 = Ua.fromRangeEnd(e350), o70 = e350.commonAncestorContainer;
            return sc(!1, o70, n119).map((r42)=>!Td(t222, n119, o70) && Td(t222, r42, o70) ? ((e, t, n, o)=>{
                    const r = document.createRange();
                    return r.setStart(e, t), r.setEnd(n, o), r;
                })(t222.container(), t222.offset(), r42.container(), r42.offset()) : e350
            ).getOr(e350);
        })(e349)
    , vp = (e351, t223)=>{
        let n120 = t223.firstChild, o = t223.lastChild;
        return n120 && "meta" === n120.name && (n120 = n120.next), o && "mce_marker" === o.attr("id") && (o = o.prev), ((e352, t224)=>{
            const n = e352.getNonEmptyElements();
            return t224 && (t224.isEmpty(n) || ((e353, t)=>e353.getBlockElements()[t.name] && ((e)=>e.firstChild && e.firstChild === e.lastChild
                )(t) && ((e)=>"br" === e.name || e.value === dr
                )(t.firstChild)
            )(e352, t224));
        })(e351, o) && (o = o.prev), !(!n120 || n120 !== o || "ul" !== n120.name && "ol" !== n120.name);
    }, yp = (e354)=>{
        var t, n;
        return e354.length > 0 && (!(n = e354[e354.length - 1]).firstChild || (t = n) && t.firstChild && t.firstChild === t.lastChild && ((e)=>e.data === dr || Do(e)
        )(t.firstChild)) ? e354.slice(0, -1) : e354;
    }, Cp = (e, t)=>{
        const n = e.getParent(t, e.isBlock);
        return n && "LI" === n.nodeName ? n : null;
    }, xp = (e, t)=>{
        const n = Ua.after(e), o = tc(t).prev(n);
        return o ? o.toRange() : null;
    }, wp = (e355, t225, n121, o71)=>{
        const r43 = ((e356, t226, n122)=>{
            const o = t226.serialize(n122);
            return ((e)=>{
                const t = e.firstChild, n = e.lastChild;
                return t && "META" === t.nodeName && t.parentNode.removeChild(t), n && "mce_marker" === n.id && n.parentNode.removeChild(n), e;
            })(e356.createFragment(o));
        })(t225, e355, o71), s21 = Cp(t225, n121.startContainer), a12 = yp((i = r43.firstChild, K1(i.childNodes, (e)=>"LI" === e.nodeName
        )));
        var i;
        const l = t225.getRoot(), d = (e)=>{
            const o = Ua.fromRangeStart(n121), r = tc(t225.getRoot()), a = 1 === e ? r.prev(o) : r.next(o);
            return !a || Cp(t225, a.getNode()) !== s21;
        };
        return d(1) ? ((e357, t227, n123)=>{
            const o72 = e357.parentNode;
            return Bt.each(t227, (t)=>{
                o72.insertBefore(t, e357);
            }), ((e, t)=>{
                const n = Ua.before(e), o = tc(t).next(n);
                return o ? o.toRange() : null;
            })(e357, n123);
        })(s21, a12, l) : d(2) ? ((e, t, n, o)=>(o.insertAfter(t.reverse(), e), xp(t[0], n))
        )(s21, a12, l, t225) : ((e358, t228, n124, o73)=>{
            const r = ((e, t)=>{
                const n = t.cloneRange(), o = t.cloneRange();
                return n.setStartBefore(e), o.setEndAfter(e), [
                    n.cloneContents(),
                    o.cloneContents()
                ];
            })(e358, o73), s = e358.parentNode;
            return s.insertBefore(r[0], e358), Bt.each(t228, (t)=>{
                s.insertBefore(t, e358);
            }), s.insertBefore(r[1], e358), s.removeChild(e358), xp(t228[t228.length - 1], n124);
        })(s21, a12, l, n121);
    }, kp = Io, Sp = (e359, t229, n125)=>{
        let o74, r44, s22;
        const a13 = e359.selection, i9 = e359.dom, l8 = e359.parser, d = n125.merge, c = Rf({
            validate: !0
        }, e359.schema), u = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;</span>';
        -1 === t229.indexOf("{$caret}") && (t229 += "{$caret}"), t229 = t229.replace(/\{\$caret\}/, u), r44 = a13.getRng();
        const m = r44.startContainer || (r44.parentElement ? r44.parentElement() : null), f = e359.getBody();
        m === f && a13.isCollapsed() && i9.isBlock(f.firstChild) && ((e, t)=>t && !e.schema.getVoidElements()[t.nodeName]
        )(e359, f.firstChild) && i9.isEmpty(f.firstChild) && (r44 = i9.createRng(), r44.setStart(f.firstChild, 0), r44.setEnd(f.firstChild, 0), a13.setRng(r44)), a13.isCollapsed() || ((e360)=>{
            const t230 = e360.dom, n126 = bp(e360.selection.getRng());
            e360.selection.setRng(n126);
            const o = t230.getParent(n126.startContainer, kp);
            ((e, t, n)=>null !== n && n === e.getParent(t.endContainer, kp) && Cu(mn(n), t)
            )(t230, n126, o) ? Zg(e360, n126, mn(o)) : e360.getDoc().execCommand("Delete", !1, null);
        })(e359), o74 = a13.getNode();
        const g = {
            context: o74.nodeName.toLowerCase(),
            data: n125.data,
            insert: !0
        }, p = l8.parse(t229, g);
        if (!0 === n125.paste && vp(e359.schema, p) && ((e, t)=>!!Cp(e, t)
        )(i9, o74)) return r44 = wp(c, i9, a13.getRng(), p), a13.setRng(r44), t229;
        if (((e)=>{
            let t = e;
            for(; t = t.walk();)1 === t.type && t.attr("data-mce-fragment", "1");
        })(p), s22 = p.lastChild, "mce_marker" === s22.attr("id")) {
            const t = s22;
            for(s22 = s22.prev; s22; s22 = s22.walk(!0))if (3 === s22.type || !i9.isBlock(s22.name)) {
                e359.schema.isValidChild(s22.parent.name, "span") && s22.parent.insert(t, s22, "br" === s22.name);
                break;
            }
        }
        if (e359._selectionOverrides.showBlockCaretContainer(o74), g.invalid) {
            e359.selection.setContent(u), o74 = a13.getNode();
            const n = e359.getBody();
            for(9 === o74.nodeType ? o74 = s22 = n : s22 = o74; s22 !== n;)o74 = s22, s22 = s22.parentNode;
            t229 = o74 === n ? n.innerHTML : i9.getOuterHTML(o74);
            const r = l8.parse(t229);
            for(let e = r; e; e = e.walk())if ("mce_marker" === e.attr("id")) {
                e.replace(p);
                break;
            }
            const d = p.children(), m = p.parent.name;
            p.unwrap();
            const f = K1(d, (t)=>!e359.schema.isValidChild(m, t.name)
            );
            hp(f, e359.schema), up(l8.getNodeFilters(), l8.getAttributeFilters(), r), t229 = c.serialize(r), o74 === n ? i9.setHTML(n, t229) : i9.setOuterHTML(o74, t229);
        } else t229 = c.serialize(p), ((e, t, n)=>{
            if ("all" === n.getAttribute("data-mce-bogus")) n.parentNode.insertBefore(e.dom.createFragment(t), n);
            else {
                const o = n.firstChild, r = n.lastChild;
                !o || o === r && "BR" === o.nodeName ? e.dom.setHTML(n, t) : e.selection.setContent(t, {
                    no_events: !0
                });
            }
        })(e359, t229, o74);
        var h;
        return ((e361, t)=>{
            const n127 = e361.schema.getTextInlineElements(), o = e361.dom;
            if (t) {
                const t231 = e361.getBody(), r = _f(o);
                Bt.each(o.select("*[data-mce-fragment]"), (e362)=>{
                    if (C1(n127[e362.nodeName.toLowerCase()]) && ((e363, t)=>te1(Tf(e363, t), (e364)=>!((e)=>Af.has(e)
                            )(e364)
                        )
                    )(o, e362)) {
                        for(let n = e362.parentNode; C1(n) && n !== t231 && !Bf(o, e362, n); n = n.parentNode)if (r.compare(n, e362)) {
                            o.remove(e362, !0);
                            break;
                        }
                    }
                });
            }
        })(e359, d), ((e365, t232)=>{
            let n128;
            const o = e365.dom, r = e365.selection;
            if (!t232) return;
            r.scrollIntoView(t232);
            const s = ip(e365.getBody(), t232);
            if ("false" === o.getContentEditable(s)) return o.remove(t232), void r.select(s);
            let a = o.createRng();
            const i = t232.previousSibling;
            if (No(i)) {
                a.setStart(i, i.nodeValue.length);
                const e = t232.nextSibling;
                No(e) && (i.appendData(e.data), e.parentNode.removeChild(e));
            } else a.setStartBefore(t232), a.setEndBefore(t232);
            const l = o.getParent(t232, o.isBlock);
            o.remove(t232), l && o.isEmpty(l) && (eo(mn(l)), a.setStart(l, 0), a.setEnd(l, 0), kp(l) || ((e)=>!!e.getAttribute("data-mce-fragment")
            )(l) || !(n128 = ((t)=>{
                let n = Ua.fromRangeStart(t);
                if (n = tc(e365.getBody()).next(n), n) return n.toRange();
            })(a)) ? o.add(l, o.create("br", {
                "data-mce-bogus": "1"
            })) : (a = n128, o.remove(l))), r.setRng(a);
        })(e359, i9.get("mce_marker")), h = e359.getBody(), Bt.each(h.getElementsByTagName("*"), (e)=>{
            e.removeAttribute("data-mce-fragment");
        }), ((e, t)=>{
            M1.from(e.getParent(t, "td,th")).map(mn).each(Yf);
        })(i9, a13.getStart()), t229;
    }, _p = (e)=>e instanceof yf
    , Ep = (e366, t233, n129)=>{
        e366.dom.setHTML(e366.getBody(), t233), !0 !== n129 && ((e)=>{
            nf(e) && uc(e.getBody()).each((t)=>{
                const n = t.getNode(), o = So(n) ? uc(n).getOr(t) : t;
                e.selection.setRng(o.toRange());
            });
        })(e366);
    }, Np = (e367, t234)=>((e368, t235)=>{
            const n130 = e368.dom;
            return n130.parentNode ? ((e369, t)=>Q1(e369.dom.childNodes, (e)=>t(mn(e))
                ).map(mn)
            )(mn(n130.parentNode), (n)=>!bn(e368, n) && t235(n)
            ) : M1.none();
        })(e367, t234).isSome()
    , Rp = (e)=>x1(e) ? e : L1
    , Ap = (e370, t236, n131)=>{
        const o75 = t236(e370), r45 = Rp(n131);
        return o75.orThunk(()=>r45(e370) ? M1.none() : ((e, t, n)=>{
                let o = e.dom;
                const r = Rp(n);
                for(; o.parentNode;){
                    o = o.parentNode;
                    const e = mn(o), n = t(e);
                    if (n.isSome()) return n;
                    if (r(e)) break;
                }
                return M1.none();
            })(e370, t236, r45)
        );
    }, Op = Hc, Tp = (e, t, n)=>{
        const o = e.formatter.get(n);
        if (o) for(let n132 = 0; n132 < o.length; n132++){
            const r = o[n132];
            if (Yc(r) && !1 === r.inherit && e.dom.is(t, r.selector)) return !0;
        }
        return !1;
    }, Bp = (e, t237, n, o, r)=>{
        const s = e.dom.getRoot();
        return t237 !== s && (t237 = e.dom.getParent(t237, (t)=>!!Tp(e, t, n) || t.parentNode === s || !!Pp(e, t, n, o, !0)
        ), !!Pp(e, t237, n, o, r));
    }, Dp = (e, t, n)=>!(!Xc(n) || !Op(t, n.inline)) || !(!Gc(n) || !Op(t, n.block)) || !!Yc(n) && yo(t) && e.is(t, n.selector)
    , Lp = (e, t, n, o, r, s)=>{
        const a = n[o];
        if (x1(n.onmatch)) return n.onmatch(t, n, o);
        if (a) {
            if (v1(a.length)) {
                for(const i in a)if (we1(a, i)) {
                    const l = "attributes" === o ? e.getAttrib(t, i) : qc(e, t, i), d = Vc(a[i], s), c = y1(l) || Ke(l);
                    if (c && y1(d)) continue;
                    if (r && c && !n.exact) return !1;
                    if ((!r || n.exact) && !Op(l, $c(d, i))) return !1;
                }
            } else for(let n133 = 0; n133 < a.length; n133++)if ("attributes" === o ? e.getAttrib(t, a[n133]) : qc(e, t, a[n133])) return !0;
        }
        return !0;
    }, Pp = (e, t, n, o, r)=>{
        const s = e.formatter.get(n), a = e.dom;
        if (s && t) for(let n134 = 0; n134 < s.length; n134++){
            const i = s[n134];
            if (Dp(e.dom, t, i) && Lp(a, t, i, "attributes", r, o) && Lp(a, t, i, "styles", r, o)) {
                const n = i.classes;
                if (n) {
                    for(let r = 0; r < n.length; r++)if (!e.dom.hasClass(t, Vc(n[r], o))) return;
                }
                return i;
            }
        }
    }, Mp = (e, t, n, o, r)=>{
        if (o) return Bp(e, o, t, n, r);
        if (o = e.selection.getNode(), Bp(e, o, t, n, r)) return !0;
        const s = e.selection.getStart();
        return !(s === o || !Bp(e, s, t, n, r));
    }, Ip = ur, Fp = "_mce_caret", Up = (e371)=>((e)=>{
            const t = [];
            for(; e;){
                if (3 === e.nodeType && e.nodeValue !== Ip || e.childNodes.length > 1) return [];
                1 === e.nodeType && t.push(e), e = e.firstChild;
            }
            return t;
        })(e371).length > 0
    , zp = (e)=>{
        if (e) {
            const t = new Xo(e, e);
            for(e = t.current(); e; e = t.next())if (No(e)) return e;
        }
        return null;
    }, jp = (e)=>{
        const t = cn("span");
        return qt(t, {
            id: Fp,
            "data-mce-bogus": "1",
            "data-mce-type": "format-caret"
        }), e && Jn(t, un(Ip)), t;
    }, Vp = (e, t238, n = !0)=>{
        const o = e.dom, r = e.selection;
        if (Up(t238)) Lg(e, !1, mn(t238), n);
        else {
            const e372 = r.getRng(), n = o.getParent(t238, o.isBlock), s = e372.startContainer, a = e372.startOffset, i = e372.endContainer, l = e372.endOffset, d = ((e)=>{
                const t = zp(e);
                return t && t.nodeValue.charAt(0) === Ip && t.deleteData(0, 1), t;
            })(t238);
            o.remove(t238, !0), s === d && a > 0 && e372.setStart(d, a - 1), i === d && l > 0 && e372.setEnd(d, l - 1), n && o.isEmpty(n) && Gf(mn(n)), r.setRng(e372);
        }
    }, Hp = (e, t, n = !0)=>{
        const o = e.dom, r = e.selection;
        if (t) Vp(e, t, n);
        else if (!(t = pc(e.getBody(), r.getStart()))) for(; t = o.get(Fp);)Vp(e, t, !1);
    }, $p = (e, t)=>(e.appendChild(t), t)
    , qp = (e373, t239)=>{
        const n = G1(e373, (e, t)=>$p(e, t.cloneNode(!1))
        , t239);
        return $p(n, n.ownerDocument.createTextNode(Ip));
    }, Wp = (e374, t240, n135, o76)=>{
        const a14 = e374.dom, i10 = e374.selection;
        let l11, d9, c3;
        const u3 = [], m = i10.getRng(), f = m.startContainer, g = m.startOffset;
        for(d9 = f, 3 === f.nodeType && (g !== f.nodeValue.length && (l11 = !0), d9 = d9.parentNode); d9;){
            if (Pp(e374, d9, t240, n135, o76)) {
                c3 = d9;
                break;
            }
            d9.nextSibling && (l11 = !0), u3.push(d9), d9 = d9.parentNode;
        }
        if (c3) {
            if (l11) {
                const r = i10.getBookmark();
                m.collapse(!0);
                let s = mu(e374, m, e374.formatter.get(t240), !0);
                s = gm(s), e374.formatter.remove(t240, n135, s, o76), i10.moveToBookmark(r);
            } else {
                const l9 = pc(e374.getBody(), c3), d7 = jp(!1).dom;
                ((e375, t241, n136)=>{
                    const o = e375.dom, r = o.getParent(n136, O1(Uc, e375));
                    r && o.isEmpty(r) ? n136.parentNode.replaceChild(t241, n136) : (((e376)=>{
                        const t242 = Xs(e376, "br"), n137 = K1(((e)=>{
                            const t = [];
                            let n = e.dom;
                            for(; n;)t.push(mn(n)), n = n.lastChild;
                            return t;
                        })(e376).slice(-1), tr);
                        t242.length === n137.length && $1(n137, to);
                    })(mn(n136)), o.isEmpty(n136) ? n136.parentNode.replaceChild(t241, n136) : o.insertAfter(t241, n136));
                })(e374, d7, null !== l9 ? l9 : c3);
                const m = ((e377, t243, n138, o77, a15, i)=>{
                    const l = e377.formatter, d = e377.dom, c = K1(ue1(l.get()), (e)=>e !== o77 && !Ue1(e, "removeformat")
                    ), u = ((e378, t244, n139)=>Y1(n139, (n140, o)=>{
                            const r = ((e379, t245)=>V1(e379.formatter.get(t245), (e380)=>{
                                    const t = (e)=>e.length > 1 && "%" === e.charAt(0)
                                    ;
                                    return V1([
                                        "styles",
                                        "attributes"
                                    ], (n141)=>xe1(e380, n141).exists((e)=>{
                                            const n = p1(e) ? e : Ce1(e);
                                            return V1(n, t);
                                        })
                                    );
                                })
                            )(e378, o);
                            return e378.formatter.matchNode(t244, o, {}, r) ? n140.concat([
                                o
                            ]) : n140;
                        }, [])
                    )(e377, n138, c);
                    if (K1(u, (t246)=>!((e381, t247, n142)=>{
                            const o78 = [
                                "inline",
                                "block",
                                "selector",
                                "attributes",
                                "styles",
                                "classes"
                            ], a = (e382)=>ve1(e382, (e383, t)=>V1(o78, (e)=>e === t
                                    )
                                )
                            ;
                            return V1(e381.formatter.get(t247), (t248)=>{
                                const o = a(t248);
                                return V1(e381.formatter.get(n142), (e384)=>{
                                    const t249 = a(e384);
                                    return ((e, t, n = s1)=>r1(n).eq(e, t)
                                    )(o, t249);
                                });
                            });
                        })(e377, t246, o77)
                    ).length > 0) {
                        const e = n138.cloneNode(!1);
                        return d.add(t243, e), l.remove(o77, a15, e, i), d.remove(e), M1.some(e);
                    }
                    return M1.none();
                })(e374, d7, c3, t240, n135, o76), f = qp(u3.concat(m.toArray()), d7);
                Vp(e374, l9, !1), i10.setCursorLocation(f, 1), a14.isEmpty(c3) && a14.remove(c3);
            }
        }
    }, Kp = (e, t)=>{
        const n = e.schema.getTextInlineElements();
        return we1(n, Mt(t)) && !gc(t.dom) && !ko(t.dom);
    }, Gp = {}, Yp = Re1, Xp = Ee1;
    Gp.pre || (Gp.pre = []), Gp.pre.push((e385)=>{
        const t250 = e385.selection.getRng();
        let n143;
        const o79 = (e)=>r(e.previousSibling) && -1 !== Ae1(n143, e.previousSibling)
        , r = Co([
            "pre"
        ]);
        t250.collapsed || (n143 = e385.selection.getSelectedBlocks(), Xp(Yp(Yp(n143, r), o79), (e386)=>{
            ((e, t)=>{
                const n = mn(t), o = Cn(n).dom;
                to(n), Zn(mn(e), [
                    cn("br", o),
                    cn("br", o),
                    ...Nn(n)
                ]);
            })(e386.previousSibling, e386);
        }));
    });
    const Qp = Bt.each, Jp = (e)=>yo(e) && !_c(e) && !gc(e) && !ko(e)
    , Zp = (e, t)=>{
        for(let n = e; n; n = n[t]){
            if (No(n) && We(n.data)) return e;
            if (yo(n) && !_c(n)) return n;
        }
        return e;
    }, eh = (e388, t, n)=>{
        const o = _f(e388);
        if (t && n && (t = Zp(t, "previousSibling"), n = Zp(n, "nextSibling"), o.compare(t, n))) {
            for(let e387 = t.nextSibling; e387 && e387 !== n;){
                const n = e387;
                e387 = e387.nextSibling, t.appendChild(n);
            }
            return e388.remove(n), Bt.each(Bt.grep(n.childNodes), (e)=>{
                t.appendChild(e);
            }), t;
        }
        return n;
    }, th = (e, t, n, o)=>{
        if (o && !1 !== t.merge_siblings) {
            const t = eh(e, Fc(o), o);
            eh(e, t, Fc(t, !0));
        }
    }, nh = (e389, t, n)=>{
        Qp(e389.childNodes, (e)=>{
            Jp(e) && (t(e) && n(e), e.hasChildNodes() && nh(e, t, n));
        });
    }, oh = (e, t)=>(n)=>!(!n || !qc(e, n, t))
    , rh = (e390, t251, n)=>(o)=>{
            e390.setStyle(o, t251, n), "" === o.getAttribute("style") && o.removeAttribute("style"), ((e, t)=>{
                "SPAN" === t.nodeName && 0 === e.getAttribs(t).length && e.remove(t, !0);
            })(e390, o);
        }
    , sh = ci([
        {
            keep: []
        },
        {
            rename: [
                "name"
            ]
        },
        {
            removed: []
        }
    ]), ah = /^(src|href|style)$/, ih = Bt.each, lh = Hc, dh = (e, t, n)=>e.isChildOf(t, n) && t !== n && !e.isBlock(n)
    , ch = (e, t, n)=>{
        let o = t[n ? "startContainer" : "endContainer"], r = t[n ? "startOffset" : "endOffset"];
        if (yo(o)) {
            const e = o.childNodes.length - 1;
            !n && r && r--, o = o.childNodes[r > e ? e : r];
        }
        return No(o) && n && r >= o.nodeValue.length && (o = new Xo(o, e.getBody()).next() || o), No(o) && !n && 0 === r && (o = new Xo(o, e.getBody()).prev() || o), o;
    }, uh = (e391, t)=>{
        const n = t ? "firstChild" : "lastChild";
        if (((e)=>/^(TR|TH|TD)$/.test(e.nodeName)
        )(e391) && e391[n]) {
            const t = e391[n];
            return "TR" === e391.nodeName && t[n] || t;
        }
        return e391;
    }, mh = (e, t, n, o)=>{
        const r = e.create(n, o);
        return t.parentNode.insertBefore(r, t), r.appendChild(t), r;
    }, fh = (e, t, n, o, r)=>{
        const s = mn(t), a = mn(e.create(o, r)), i = n ? En(s) : _n(s);
        return Zn(a, i), n ? (Yn(s, a), Qn(a, s)) : (Xn(s, a), Jn(a, s)), a.dom;
    }, gh = (e392, t252, n144, o80, r46)=>{
        let s23;
        const a16 = e392.dom;
        if (!Dp(a16, o80, t252) && !((e, t)=>t.links && "A" === e.nodeName
        )(o80, t252)) return sh.keep();
        const i = o80;
        if (Xc(t252) && "all" === t252.remove && p1(t252.preserve_attributes)) {
            const e393 = K1(a16.getAttribs(i), (e)=>j1(t252.preserve_attributes, e.name.toLowerCase())
            );
            if (a16.removeAllAttribs(i), $1(e393, (e)=>a16.setAttrib(i, e.name, e.value)
            ), e393.length > 0) return sh.rename("span");
        }
        if ("all" !== t252.remove) {
            ih(t252.styles, (e, o)=>{
                e = $c(Vc(e, n144), o + ""), w1(o) && (o = e, r46 = null), (t252.remove_similar || !r46 || lh(qc(a16, r46, o), e)) && a16.setStyle(i, o, ""), s23 = !0;
            }), s23 && "" === a16.getAttrib(i, "style") && (i.removeAttribute("style"), i.removeAttribute("data-mce-style")), ih(t252.attributes, (e397, o)=>{
                let s;
                if (e397 = Vc(e397, n144), w1(o) && (o = e397, r46 = null), t252.remove_similar || !r46 || lh(a16.getAttrib(r46, o), e397)) {
                    if ("class" === o && (e397 = a16.getAttrib(i, o)) && (s = "", $1(e397.split(/\s+/), (e)=>{
                        /mce\-\w+/.test(e) && (s += (s ? " " : "") + e);
                    }), s)) return void a16.setAttrib(i, o, s);
                    if (ah.test(o) && i.removeAttribute("data-mce-" + o), "style" === o && Co([
                        "li"
                    ])(i) && "none" === a16.getStyle(i, "list-style-type")) return i.removeAttribute(o), void a16.setStyle(i, "list-style-type", "none");
                    "class" === o && i.removeAttribute("className"), i.removeAttribute(o);
                }
            }), ih(t252.classes, (e)=>{
                e = Vc(e, n144), r46 && !a16.hasClass(r46, e) || a16.removeClass(i, e);
            });
            const e395 = a16.getAttribs(i);
            for(let t = 0; t < e395.length; t++){
                const n = e395[t].nodeName;
                if (0 !== n.indexOf("_") && 0 !== n.indexOf("data-")) return sh.keep();
            }
        }
        return "none" !== t252.remove ? (((e398, t253, n)=>{
            const o = t253.parentNode;
            let r;
            const s = e398.dom, a = Ti(e398);
            Gc(n) && o === s.getRoot() && (n.list_block && lh(t253, n.list_block) || $1(de1(t253.childNodes), (t)=>{
                zc(e398, a, t.nodeName.toLowerCase()) ? r ? r.appendChild(t) : (r = mh(s, t, a), s.setAttribs(r, Bi(e398))) : r = null;
            })), ((e)=>Yc(e) && Xc(e) && Dt(xe1(e, "mixed"), !0)
            )(n) && !lh(n.inline, t253) || s.remove(t253, !0);
        })(e392, i, t252), sh.removed()) : sh.keep();
    }, ph = (e, t254, n, o, r)=>gh(e, t254, n, o, r).fold(L1, (t)=>(e.dom.rename(o, t), !0)
        , P1)
    , hh = (e, t255, n, o)=>gh(e, t255, n, o, o).fold(N1(o), (t)=>(e.dom.createFragment().appendChild(o), e.dom.rename(o, t))
        , N1(null))
    , bh = (e399, t256, n145, o81, r47)=>{
        const s24 = e399.formatter.get(t256), a17 = s24[0];
        let i11 = !0;
        const l12 = e399.dom, d10 = e399.selection, c4 = (o82)=>{
            const i12 = ((e, t257, n, o, r)=>{
                let s;
                return $1(Kc(e.dom, t257.parentNode).reverse(), (t)=>{
                    if (!s && "_start" !== t.id && "_end" !== t.id) {
                        const a = Pp(e, t, n, o, r);
                        a && !1 !== a.split && (s = t);
                    }
                }), s;
            })(e399, o82, t256, n145, r47);
            return ((e, t, n, o, r, s, a, i)=>{
                let l, d, c;
                const u = e.dom;
                if (n) {
                    const s = n.parentNode;
                    for(let n146 = o.parentNode; n146 && n146 !== s; n146 = n146.parentNode){
                        l = u.clone(n146, !1);
                        for(let n = 0; n < t.length && (l = hh(e, t[n], i, l), null !== l); n++);
                        l && (d && l.appendChild(d), c || (c = l), d = l);
                    }
                    a.mixed && u.isBlock(n) || (o = u.split(n, o)), d && (r.parentNode.insertBefore(d, r), c.appendChild(r), Xc(a) && th(u, a, 0, d));
                }
                return o;
            })(e399, s24, i12, o82, o82, 0, a17, n145);
        }, u4 = (t)=>V1(s24, (o)=>ph(e399, o, n145, t, t)
            )
        , m = (t)=>{
            let n147 = !0, o = !1;
            yo(t) && l12.getContentEditable(t) && (n147 = i11, i11 = "true" === l12.getContentEditable(t), o = !0);
            const r = de1(t.childNodes);
            if (i11 && !o) {
                const e400 = u4(t) || V1(s24, (e)=>Dp(l12, t, e)
                ), n = t.parentNode;
                !e400 && C1(n) && Qc(a17) && u4(n);
            }
            if (a17.deep && r.length) {
                for(let e = 0; e < r.length; e++)m(r[e]);
                o && (i11 = n147);
            }
            $1([
                "underline",
                "line-through",
                "overline"
            ], (n)=>{
                yo(t) && e399.dom.getStyle(t, "text-decoration") === n && t.parentNode && Wc(l12, t.parentNode) === n && ph(e399, {
                    deep: !1,
                    exact: !0,
                    inline: "span",
                    styles: {
                        textDecoration: n
                    }
                }, null, t);
            });
        }, f = (e402)=>{
            const t = l12.get(e402 ? "_start" : "_end");
            let n = t[e402 ? "firstChild" : "lastChild"];
            return ((e)=>_c(e) && yo(e) && ("_start" === e.id || "_end" === e.id)
            )(n) && (n = n[e402 ? "firstChild" : "lastChild"]), No(n) && 0 === n.data.length && (n = e402 ? t.previousSibling || t.nextSibling : t.nextSibling || t.previousSibling), l12.remove(t, !0), n;
        }, g = (t)=>{
            let n, o, r = mu(e399, t, s24, t.collapsed);
            if (a17.split) {
                if (r = gm(r), n = ch(e399, r, !0), o = ch(e399, r), n !== o) {
                    if (n = uh(n, !0), o = uh(o, !1), dh(l12, n, o)) {
                        const e = M1.from(n.firstChild).getOr(n);
                        return c4(fh(l12, e, !0, "span", {
                            id: "_start",
                            "data-mce-type": "bookmark"
                        })), void f(!0);
                    }
                    if (dh(l12, o, n)) {
                        const e = M1.from(o.lastChild).getOr(o);
                        return c4(fh(l12, e, !1, "span", {
                            id: "_end",
                            "data-mce-type": "bookmark"
                        })), void f(!1);
                    }
                    n = mh(l12, n, "span", {
                        id: "_start",
                        "data-mce-type": "bookmark"
                    }), o = mh(l12, o, "span", {
                        id: "_end",
                        "data-mce-type": "bookmark"
                    });
                    const e403 = l12.createRng();
                    e403.setStartAfter(n), e403.setEndBefore(o), fu(l12, e403, (e406)=>{
                        $1(e406, (e)=>{
                            _c(e) || _c(e.parentNode) || c4(e);
                        });
                    }), c4(n), c4(o), n = f(!0), o = f();
                } else n = o = c4(n);
                r.startContainer = n.parentNode ? n.parentNode : n, r.startOffset = l12.nodeIndex(n), r.endContainer = o.parentNode ? o.parentNode : o, r.endOffset = l12.nodeIndex(o) + 1;
            }
            fu(l12, r, (e)=>{
                $1(e, m);
            });
        };
        if (o81) {
            if (Mc(o81)) {
                const e = l12.createRng();
                e.setStartBefore(o81), e.setEndAfter(o81), g(e);
            } else g(o81);
            Pu(e399, t256, o81, n145);
        } else if ("false" !== l12.getContentEditable(d10.getNode())) d10.isCollapsed() && Xc(a17) && !hu(e399).length ? Wp(e399, t256, n145, r47) : (Su(d10, !0, ()=>{
            ku(e399, g);
        }), Xc(a17) && Mp(e399, t256, n145, d10.getStart()) && Ic(l12, d10, d10.getRng()), e399.nodeChanged()), Pu(e399, t256, o81, n145);
        else {
            o81 = d10.getNode();
            for(let t = 0; t < s24.length && (!s24[t].ceFalseOverride || !ph(e399, s24[t], n145, o81, o81)); t++);
            Pu(e399, t256, o81, n145);
        }
    }, vh = Bt.each, yh = Bt.each, Ch = (e)=>yo(e) && !_c(e) && !gc(e) && !ko(e)
    , xh = (e407, t258, n148, o83)=>{
        const r48 = e407.formatter.get(t258), s25 = r48[0], a18 = !o83 && e407.selection.isCollapsed(), i13 = e407.dom, l13 = e407.selection, d11 = (e, t259 = s25)=>{
            if (x1(t259.onformat) && t259.onformat(e, t259, n148, o83), yh(t259.styles, (t, o)=>{
                i13.setStyle(e, o, Vc(t, n148));
            }), t259.styles) {
                const t = i13.getAttrib(e, "style");
                t && i13.setAttrib(e, "data-mce-style", t);
            }
            yh(t259.attributes, (t, o)=>{
                i13.setAttrib(e, o, Vc(t, n148));
            }), yh(t259.classes, (t)=>{
                t = Vc(t, n148), i13.hasClass(e, t) || i13.addClass(e, t);
            });
        }, c5 = (e408, t)=>{
            let n = !1;
            return yh(e408, (e)=>!!Yc(e) && (C1(e.collapsed) && e.collapsed !== a18 ? void 0 : i13.is(t, e.selector) && !gc(t) ? (d11(t, e), n = !0, !1) : void 0)
            ), n;
        }, u5 = (e)=>{
            if (m1(e)) {
                const t = i13.create(e);
                return d11(t), t;
            }
            return null;
        }, f3 = (o84, a19, i14)=>{
            const l = [];
            let m = !0;
            const f = s25.inline || s25.block, g = u5(f);
            fu(o84, a19, (a20)=>{
                let u;
                const p = (a)=>{
                    let h = !1, b = m;
                    const v = a.nodeName.toLowerCase(), y = a.parentNode, x = y.nodeName.toLowerCase();
                    if (yo(a) && o84.getContentEditable(a) && (b = m, m = "true" === o84.getContentEditable(a), h = !0), Do(a) && !((e409, t, n, o)=>{
                        if (pl(e409) && Xc(t)) {
                            const t = {
                                ...e409.schema.getTextBlockElements(),
                                td: {},
                                th: {},
                                li: {},
                                dt: {},
                                dd: {},
                                figcaption: {},
                                caption: {},
                                details: {},
                                summary: {}
                            }, r = Np(mn(n), (e)=>gc(e.dom)
                            );
                            return ke1(t, o) && qr(mn(n.parentNode), !1) && !r;
                        }
                        return !1;
                    })(e407, s25, a, x)) return u = null, void (Gc(s25) && o84.remove(a));
                    if (Gc(s25) && s25.wrapper && Pp(e407, a, t258, n148)) u = null;
                    else {
                        if (m && !h && Gc(s25) && !s25.wrapper && Uc(e407, v) && zc(e407, x, f)) {
                            const e = o84.rename(a, f);
                            return d11(e), l.push(e), void (u = null);
                        }
                        if (Yc(s25)) {
                            let e = c5(r48, a);
                            if (!e && C1(y) && Qc(s25) && (e = c5(r48, y)), !Xc(s25) || e) return void (u = null);
                        }
                        !m || h || !zc(e407, f, v) || !zc(e407, x, f) || !i14 && No(a) && mr(a.data) || gc(a) || Xc(s25) && o84.isBlock(a) ? (u = null, $1(de1(a.childNodes), p), h && (m = b), u = null) : (u || (u = o84.clone(g, !1), a.parentNode.insertBefore(u, a), l.push(u)), u.appendChild(a));
                    }
                };
                $1(a20, p);
            }), !0 === s25.links && $1(l, (e410)=>{
                const t = (e)=>{
                    "A" === e.nodeName && d11(e, s25), $1(de1(e.childNodes), t);
                };
                t(e410);
            }), $1(l, (a)=>{
                const i = ((e411)=>{
                    let t = 0;
                    return $1(e411.childNodes, (e412)=>{
                        ((e)=>C1(e) && No(e) && 0 === e.length
                        )(e412) || _c(e412) || t++;
                    }), t;
                })(a);
                !(l.length > 1) && o84.isBlock(a) || 0 !== i ? (Xc(s25) || Gc(s25) && s25.wrapper) && (s25.exact || 1 !== i || (a = ((e413)=>{
                    const t260 = Q1(e413.childNodes, Ch).filter((e)=>Dp(o84, e, s25)
                    );
                    return t260.map((t)=>{
                        const n = o84.clone(t, !1);
                        return d11(n), o84.replace(n, e413, !0), o84.remove(t, !0), n;
                    }).getOr(e413);
                })(a)), ((e414, t261, n149, o85)=>{
                    vh(t261, (t262)=>{
                        Xc(t262) && vh(e414.dom.select(t262.inline, o85), (o)=>{
                            Jp(o) && ph(e414, t262, n149, o, t262.exact ? o : null);
                        }), ((e, t, n150)=>{
                            if (t.clear_child_styles) {
                                const o86 = t.links ? "*:not(a)" : "*";
                                Qp(e.select(o86, n150), (n)=>{
                                    Jp(n) && Qp(t.styles, (t, o)=>{
                                        e.setStyle(n, o, "");
                                    });
                                });
                            }
                        })(e414.dom, t262, o85);
                    });
                })(e407, r48, n148, a), ((e, t, n, o, r)=>{
                    Pp(e, r.parentNode, n, o) && ph(e, t, o, r) || t.merge_with_parents && e.dom.getParent(r.parentNode, (s)=>{
                        if (Pp(e, s, n, o)) return ph(e, t, o, r), !0;
                    });
                })(e407, s25, t258, n148, a), ((e, t, n, o)=>{
                    t.styles && t.styles.backgroundColor && nh(o, oh(e, "fontSize"), rh(e, "backgroundColor", Vc(t.styles.backgroundColor, n)));
                })(o84, s25, n148, a), ((e, t263, n151, o)=>{
                    const r = (t)=>{
                        if (1 === t.nodeType && t.parentNode && 1 === t.parentNode.nodeType) {
                            const n = Wc(e, t.parentNode);
                            e.getStyle(t, "color") && n ? e.setStyle(t, "text-decoration", n) : e.getStyle(t, "text-decoration") === n && e.setStyle(t, "text-decoration", null);
                        }
                    };
                    t263.styles && (t263.styles.color || t263.styles.textDecoration) && (Bt.walk(o, r, "childNodes"), r(o));
                })(o84, s25, 0, a), ((e, t, n, o)=>{
                    !Xc(t) || "sub" !== t.inline && "sup" !== t.inline || (nh(o, oh(e, "fontSize"), rh(e, "fontSize", "")), e.remove(e.select("sup" === t.inline ? "sub" : "sup", o), !0));
                })(o84, s25, 0, a), th(o84, s25, 0, a)) : o84.remove(a, !0);
            });
        };
        if ("false" !== i13.getContentEditable(l13.getNode())) {
            if (s25) {
                if (o83) {
                    if (Mc(o83)) {
                        if (!c5(r48, o83)) {
                            const t = i13.createRng();
                            t.setStartBefore(o83), t.setEndAfter(o83), f3(i13, mu(e407, t, r48), !0);
                        }
                    } else f3(i13, o83, !0);
                } else a18 && Xc(s25) && !hu(e407).length ? ((e, t, n)=>{
                    let o, r;
                    const s = e.selection, a = s.getRng();
                    let i = a.startOffset;
                    const l = a.startContainer.nodeValue;
                    o = pc(e.getBody(), s.getStart()), o && (r = zp(o));
                    const d = /[^\s\u00a0\u00ad\u200b\ufeff]/;
                    if (l && i > 0 && i < l.length && d.test(l.charAt(i)) && d.test(l.charAt(i - 1))) {
                        const o = s.getBookmark();
                        a.collapse(!0);
                        let r = mu(e, a, e.formatter.get(t));
                        r = gm(r), e.formatter.apply(t, n, r), s.moveToBookmark(o);
                    } else o && r.nodeValue === Ip || (c = e.getDoc(), u = jp(!0).dom, o = c.importNode(u, !0), r = o.firstChild, a.insertNode(o), i = 1), e.formatter.apply(t, n, o), s.setCursorLocation(r, i);
                    var c, u;
                })(e407, t258, n148) : (l13.setRng(bp(l13.getRng())), Su(l13, !0, ()=>{
                    ku(e407, (t, n)=>{
                        const o = n ? t : mu(e407, t, r48);
                        f3(i13, o, !1);
                    });
                }), Ic(i13, l13, l13.getRng()), e407.nodeChanged());
                ((e415, t)=>{
                    Xp(Gp[e415], (e)=>{
                        e(t);
                    });
                })(t258, e407);
            }
            Lu(e407, t258, o83, n148);
        } else {
            o83 = l13.getNode();
            for(let e = 0, t = r48.length; e < t; e++){
                const t = r48[e];
                if (t.ceFalseOverride && Yc(t) && i13.is(o83, t.selector)) {
                    d11(o83, t);
                    break;
                }
            }
            Lu(e407, t258, o83, n148);
        }
    }, wh = (e)=>we1(e, "vars")
    , kh = (e)=>e.selection.getStart()
    , Sh = (e, t264, n, o, r)=>X1(t264, (t)=>{
            const s = e.formatter.matchNode(t, n, null != r ? r : {}, o);
            return !v1(s);
        }, (t)=>!!Tp(e, t, n) || !o && C1(e.formatter.matchNode(t, n, r, !0))
        )
    , _h = (e416, t)=>{
        const n = null != t ? t : kh(e416);
        return K1(Kc(e416.dom, n), (e)=>yo(e) && !ko(e)
        );
    }, Eh = (e417, t265, n152)=>{
        const o = _h(e417, t265);
        fe1(n152, (n153, r)=>{
            const s26 = (n)=>{
                const s = Sh(e417, o, r, n.similar, wh(n) ? n.vars : void 0), a = s.isSome();
                if (n.state.get() !== a) {
                    n.state.set(a);
                    const e = s.getOr(t265);
                    wh(n) ? n.callback(a, {
                        node: e,
                        format: r,
                        parents: o
                    }) : $1(n.callbacks, (t)=>t(a, {
                            node: e,
                            format: r,
                            parents: o
                        })
                    );
                }
            };
            $1([
                n153.withSimilar,
                n153.withoutSimilar
            ], s26), $1(n153.withVars, s26);
        });
    };
    var Nh = Object.hasOwnProperty, Rh = Object.setPrototypeOf, Ah = Object.isFrozen, Oh = Object.getPrototypeOf, Th = Object.getOwnPropertyDescriptor, Bh = Object.freeze, Dh = Object.seal, Lh = Object.create, Ph = "undefined" != typeof Reflect && Reflect, Mh = Ph.apply, Ih = Ph.construct;
    Mh || (Mh = function(e, t, n) {
        return e.apply(t, n);
    }), Bh || (Bh = function(e) {
        return e;
    }), Dh || (Dh = function(e) {
        return e;
    }), Ih || (Ih = function(e418, t266) {
        return new (Function.prototype.bind.apply(e418, [
            null
        ].concat(function(e) {
            if (Array.isArray(e)) {
                for(var t = 0, n = Array(e.length); t < e.length; t++)n[t] = e[t];
                return n;
            }
            return Array.from(e);
        }(t266))));
    });
    var Fh, Uh = Yh(Array.prototype.forEach), zh = Yh(Array.prototype.pop), jh = Yh(Array.prototype.push), Vh = Yh(String.prototype.toLowerCase), Hh = Yh(String.prototype.match), $h = Yh(String.prototype.replace), qh = Yh(String.prototype.indexOf), Wh = Yh(String.prototype.trim), Kh = Yh(RegExp.prototype.test), Gh = (Fh = TypeError, function() {
        for(var e = arguments.length, t = Array(e), n = 0; n < e; n++)t[n] = arguments[n];
        return Ih(Fh, t);
    });
    function Yh(e) {
        return function(t) {
            for(var n = arguments.length, o = Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++)o[r - 1] = arguments[r];
            return Mh(e, t, o);
        };
    }
    function Xh(e, t) {
        Rh && Rh(e, null);
        for(var n = t.length; n--;){
            var o = t[n];
            if ("string" == typeof o) {
                var r = Vh(o);
                r !== o && (Ah(t) || (t[n] = r), o = r);
            }
            e[o] = !0;
        }
        return e;
    }
    function Qh(e) {
        var t = Lh(null), n = void 0;
        for(n in e)Mh(Nh, e, [
            n
        ]) && (t[n] = e[n]);
        return t;
    }
    function Jh(e419, t) {
        for(; null !== e419;){
            var n = Th(e419, t);
            if (n) {
                if (n.get) return Yh(n.get);
                if ("function" == typeof n.value) return Yh(n.value);
            }
            e419 = Oh(e419);
        }
        return function(e) {
            return console.warn("fallback value for", e), null;
        };
    }
    var Zh = Bh([
        "a",
        "abbr",
        "acronym",
        "address",
        "area",
        "article",
        "aside",
        "audio",
        "b",
        "bdi",
        "bdo",
        "big",
        "blink",
        "blockquote",
        "body",
        "br",
        "button",
        "canvas",
        "caption",
        "center",
        "cite",
        "code",
        "col",
        "colgroup",
        "content",
        "data",
        "datalist",
        "dd",
        "decorator",
        "del",
        "details",
        "dfn",
        "dialog",
        "dir",
        "div",
        "dl",
        "dt",
        "element",
        "em",
        "fieldset",
        "figcaption",
        "figure",
        "font",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "head",
        "header",
        "hgroup",
        "hr",
        "html",
        "i",
        "img",
        "input",
        "ins",
        "kbd",
        "label",
        "legend",
        "li",
        "main",
        "map",
        "mark",
        "marquee",
        "menu",
        "menuitem",
        "meter",
        "nav",
        "nobr",
        "ol",
        "optgroup",
        "option",
        "output",
        "p",
        "picture",
        "pre",
        "progress",
        "q",
        "rp",
        "rt",
        "ruby",
        "s",
        "samp",
        "section",
        "select",
        "shadow",
        "small",
        "source",
        "spacer",
        "span",
        "strike",
        "strong",
        "style",
        "sub",
        "summary",
        "sup",
        "table",
        "tbody",
        "td",
        "template",
        "textarea",
        "tfoot",
        "th",
        "thead",
        "time",
        "tr",
        "track",
        "tt",
        "u",
        "ul",
        "var",
        "video",
        "wbr"
    ]), eb = Bh([
        "svg",
        "a",
        "altglyph",
        "altglyphdef",
        "altglyphitem",
        "animatecolor",
        "animatemotion",
        "animatetransform",
        "circle",
        "clippath",
        "defs",
        "desc",
        "ellipse",
        "filter",
        "font",
        "g",
        "glyph",
        "glyphref",
        "hkern",
        "image",
        "line",
        "lineargradient",
        "marker",
        "mask",
        "metadata",
        "mpath",
        "path",
        "pattern",
        "polygon",
        "polyline",
        "radialgradient",
        "rect",
        "stop",
        "style",
        "switch",
        "symbol",
        "text",
        "textpath",
        "title",
        "tref",
        "tspan",
        "view",
        "vkern"
    ]), tb = Bh([
        "feBlend",
        "feColorMatrix",
        "feComponentTransfer",
        "feComposite",
        "feConvolveMatrix",
        "feDiffuseLighting",
        "feDisplacementMap",
        "feDistantLight",
        "feFlood",
        "feFuncA",
        "feFuncB",
        "feFuncG",
        "feFuncR",
        "feGaussianBlur",
        "feImage",
        "feMerge",
        "feMergeNode",
        "feMorphology",
        "feOffset",
        "fePointLight",
        "feSpecularLighting",
        "feSpotLight",
        "feTile",
        "feTurbulence"
    ]), nb = Bh([
        "animate",
        "color-profile",
        "cursor",
        "discard",
        "fedropshadow",
        "font-face",
        "font-face-format",
        "font-face-name",
        "font-face-src",
        "font-face-uri",
        "foreignobject",
        "hatch",
        "hatchpath",
        "mesh",
        "meshgradient",
        "meshpatch",
        "meshrow",
        "missing-glyph",
        "script",
        "set",
        "solidcolor",
        "unknown",
        "use"
    ]), ob = Bh([
        "math",
        "menclose",
        "merror",
        "mfenced",
        "mfrac",
        "mglyph",
        "mi",
        "mlabeledtr",
        "mmultiscripts",
        "mn",
        "mo",
        "mover",
        "mpadded",
        "mphantom",
        "mroot",
        "mrow",
        "ms",
        "mspace",
        "msqrt",
        "mstyle",
        "msub",
        "msup",
        "msubsup",
        "mtable",
        "mtd",
        "mtext",
        "mtr",
        "munder",
        "munderover"
    ]), rb = Bh([
        "maction",
        "maligngroup",
        "malignmark",
        "mlongdiv",
        "mscarries",
        "mscarry",
        "msgroup",
        "mstack",
        "msline",
        "msrow",
        "semantics",
        "annotation",
        "annotation-xml",
        "mprescripts",
        "none"
    ]), sb = Bh([
        "#text"
    ]), ab = Bh([
        "accept",
        "action",
        "align",
        "alt",
        "autocapitalize",
        "autocomplete",
        "autopictureinpicture",
        "autoplay",
        "background",
        "bgcolor",
        "border",
        "capture",
        "cellpadding",
        "cellspacing",
        "checked",
        "cite",
        "class",
        "clear",
        "color",
        "cols",
        "colspan",
        "controls",
        "controlslist",
        "coords",
        "crossorigin",
        "datetime",
        "decoding",
        "default",
        "dir",
        "disabled",
        "disablepictureinpicture",
        "disableremoteplayback",
        "download",
        "draggable",
        "enctype",
        "enterkeyhint",
        "face",
        "for",
        "headers",
        "height",
        "hidden",
        "high",
        "href",
        "hreflang",
        "id",
        "inputmode",
        "integrity",
        "ismap",
        "kind",
        "label",
        "lang",
        "list",
        "loading",
        "loop",
        "low",
        "max",
        "maxlength",
        "media",
        "method",
        "min",
        "minlength",
        "multiple",
        "muted",
        "name",
        "nonce",
        "noshade",
        "novalidate",
        "nowrap",
        "open",
        "optimum",
        "pattern",
        "placeholder",
        "playsinline",
        "poster",
        "preload",
        "pubdate",
        "radiogroup",
        "readonly",
        "rel",
        "required",
        "rev",
        "reversed",
        "role",
        "rows",
        "rowspan",
        "spellcheck",
        "scope",
        "selected",
        "shape",
        "size",
        "sizes",
        "span",
        "srclang",
        "start",
        "src",
        "srcset",
        "step",
        "style",
        "summary",
        "tabindex",
        "title",
        "translate",
        "type",
        "usemap",
        "valign",
        "value",
        "width",
        "xmlns",
        "slot"
    ]), ib = Bh([
        "accent-height",
        "accumulate",
        "additive",
        "alignment-baseline",
        "ascent",
        "attributename",
        "attributetype",
        "azimuth",
        "basefrequency",
        "baseline-shift",
        "begin",
        "bias",
        "by",
        "class",
        "clip",
        "clippathunits",
        "clip-path",
        "clip-rule",
        "color",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "cx",
        "cy",
        "d",
        "dx",
        "dy",
        "diffuseconstant",
        "direction",
        "display",
        "divisor",
        "dur",
        "edgemode",
        "elevation",
        "end",
        "fill",
        "fill-opacity",
        "fill-rule",
        "filter",
        "filterunits",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "fx",
        "fy",
        "g1",
        "g2",
        "glyph-name",
        "glyphref",
        "gradientunits",
        "gradienttransform",
        "height",
        "href",
        "id",
        "image-rendering",
        "in",
        "in2",
        "k",
        "k1",
        "k2",
        "k3",
        "k4",
        "kerning",
        "keypoints",
        "keysplines",
        "keytimes",
        "lang",
        "lengthadjust",
        "letter-spacing",
        "kernelmatrix",
        "kernelunitlength",
        "lighting-color",
        "local",
        "marker-end",
        "marker-mid",
        "marker-start",
        "markerheight",
        "markerunits",
        "markerwidth",
        "maskcontentunits",
        "maskunits",
        "max",
        "mask",
        "media",
        "method",
        "mode",
        "min",
        "name",
        "numoctaves",
        "offset",
        "operator",
        "opacity",
        "order",
        "orient",
        "orientation",
        "origin",
        "overflow",
        "paint-order",
        "path",
        "pathlength",
        "patterncontentunits",
        "patterntransform",
        "patternunits",
        "points",
        "preservealpha",
        "preserveaspectratio",
        "primitiveunits",
        "r",
        "rx",
        "ry",
        "radius",
        "refx",
        "refy",
        "repeatcount",
        "repeatdur",
        "restart",
        "result",
        "rotate",
        "scale",
        "seed",
        "shape-rendering",
        "specularconstant",
        "specularexponent",
        "spreadmethod",
        "startoffset",
        "stddeviation",
        "stitchtiles",
        "stop-color",
        "stop-opacity",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke",
        "stroke-width",
        "style",
        "surfacescale",
        "systemlanguage",
        "tabindex",
        "targetx",
        "targety",
        "transform",
        "transform-origin",
        "text-anchor",
        "text-decoration",
        "text-rendering",
        "textlength",
        "type",
        "u1",
        "u2",
        "unicode",
        "values",
        "viewbox",
        "visibility",
        "version",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
        "width",
        "word-spacing",
        "wrap",
        "writing-mode",
        "xchannelselector",
        "ychannelselector",
        "x",
        "x1",
        "x2",
        "xmlns",
        "y",
        "y1",
        "y2",
        "z",
        "zoomandpan"
    ]), lb = Bh([
        "accent",
        "accentunder",
        "align",
        "bevelled",
        "close",
        "columnsalign",
        "columnlines",
        "columnspan",
        "denomalign",
        "depth",
        "dir",
        "display",
        "displaystyle",
        "encoding",
        "fence",
        "frame",
        "height",
        "href",
        "id",
        "largeop",
        "length",
        "linethickness",
        "lspace",
        "lquote",
        "mathbackground",
        "mathcolor",
        "mathsize",
        "mathvariant",
        "maxsize",
        "minsize",
        "movablelimits",
        "notation",
        "numalign",
        "open",
        "rowalign",
        "rowlines",
        "rowspacing",
        "rowspan",
        "rspace",
        "rquote",
        "scriptlevel",
        "scriptminsize",
        "scriptsizemultiplier",
        "selection",
        "separator",
        "separators",
        "stretchy",
        "subscriptshift",
        "supscriptshift",
        "symmetric",
        "voffset",
        "width",
        "xmlns"
    ]), db = Bh([
        "xlink:href",
        "xml:id",
        "xlink:title",
        "xml:space",
        "xmlns:xlink"
    ]), cb = Dh(/\{\{[\s\S]*|[\s\S]*\}\}/gm), ub = Dh(/<%[\s\S]*|[\s\S]*%>/gm), mb = Dh(/^data-[\-\w.\u00B7-\uFFFF]/), fb = Dh(/^aria-[\-\w]+$/), gb = Dh(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), pb = Dh(/^(?:\w+script|data):/i), hb = Dh(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), bb = Dh(/^html$/i), vb = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e;
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    };
    function yb(e) {
        if (Array.isArray(e)) {
            for(var t = 0, n = Array(e.length); t < e.length; t++)n[t] = e[t];
            return n;
        }
        return Array.from(e);
    }
    var Cb = function() {
        return "undefined" == typeof window ? null : window;
    }, xb = function(e420, t) {
        if ("object" !== (void 0 === e420 ? "undefined" : vb(e420)) || "function" != typeof e420.createPolicy) return null;
        var n = null, o = "data-tt-policy-suffix";
        t.currentScript && t.currentScript.hasAttribute(o) && (n = t.currentScript.getAttribute(o));
        var r = "dompurify" + (n ? "#" + n : "");
        try {
            return e420.createPolicy(r, {
                createHTML: function(e) {
                    return e;
                }
            });
        } catch (e) {
            return console.warn("TrustedTypes policy " + r + " could not be created."), null;
        }
    }, wb = function e422() {
        var t267 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Cb(), n154 = function(t) {
            return e422(t);
        };
        if (n154.version = "2.3.6", n154.removed = [], !t267 || !t267.document || 9 !== t267.document.nodeType) return n154.isSupported = !1, n154;
        var o88 = t267.document, r49 = t267.document, s27 = t267.DocumentFragment, a21 = t267.HTMLTemplateElement, i15 = t267.Node, l14 = t267.Element, d12 = t267.NodeFilter, c6 = t267.NamedNodeMap, u6 = void 0 === c6 ? t267.NamedNodeMap || t267.MozNamedAttrMap : c6, m3 = t267.HTMLFormElement, f4 = t267.DOMParser, g3 = t267.trustedTypes, p = l14.prototype, h = Jh(p, "cloneNode"), b = Jh(p, "nextSibling"), v = Jh(p, "childNodes"), y = Jh(p, "parentNode");
        if ("function" == typeof a21) {
            var C = r49.createElement("template");
            C.content && C.content.ownerDocument && (r49 = C.content.ownerDocument);
        }
        var x = xb(g3, o88), w = x ? x.createHTML("") : "", k = r49, S = k.implementation, _ = k.createNodeIterator, E = k.createDocumentFragment, N = k.getElementsByTagName, R = o88.importNode, A = {};
        try {
            A = Qh(r49).documentMode ? r49.documentMode : {};
        } catch (e421) {}
        var O = {};
        n154.isSupported = "function" == typeof y && S && void 0 !== S.createHTMLDocument && 9 !== A;
        var T = cb, B = ub, D = mb, L = fb, P = pb, M = hb, I = gb, F = null, U = Xh({}, [].concat(yb(Zh), yb(eb), yb(tb), yb(ob), yb(sb))), z = null, j = Xh({}, [].concat(yb(ab), yb(ib), yb(lb), yb(db))), V = Object.seal(Object.create(null, {
            tagNameCheck: {
                writable: !0,
                configurable: !1,
                enumerable: !0,
                value: null
            },
            attributeNameCheck: {
                writable: !0,
                configurable: !1,
                enumerable: !0,
                value: null
            },
            allowCustomizedBuiltInElements: {
                writable: !0,
                configurable: !1,
                enumerable: !0,
                value: !1
            }
        })), H = null, $ = null, q = !0, W = !0, K = !1, G = !1, Y = !1, X = !1, Q = !1, J = !1, Z = !1, ee = !1, te = !0, ne = !0, oe = !1, re = {}, se = null, ae = Xh({}, [
            "annotation-xml",
            "audio",
            "colgroup",
            "desc",
            "foreignobject",
            "head",
            "iframe",
            "math",
            "mi",
            "mn",
            "mo",
            "ms",
            "mtext",
            "noembed",
            "noframes",
            "noscript",
            "plaintext",
            "script",
            "style",
            "svg",
            "template",
            "thead",
            "title",
            "video",
            "xmp"
        ]), ie = null, le = Xh({}, [
            "audio",
            "video",
            "img",
            "source",
            "image",
            "track"
        ]), de = null, ce = Xh({}, [
            "alt",
            "class",
            "for",
            "id",
            "label",
            "name",
            "pattern",
            "placeholder",
            "role",
            "summary",
            "title",
            "value",
            "style",
            "xmlns"
        ]), ue = "http://www.w3.org/1998/Math/MathML", me = "http://www.w3.org/2000/svg", fe = "http://www.w3.org/1999/xhtml", ge = fe, pe = !1, he = void 0, be = [
            "application/xhtml+xml",
            "text/html"
        ], ve = "text/html", ye = void 0, Ce = null, xe = r49.createElement("form"), we = function(e) {
            return e instanceof RegExp || e instanceof Function;
        }, ke = function(e423) {
            Ce && Ce === e423 || (e423 && "object" === (void 0 === e423 ? "undefined" : vb(e423)) || (e423 = {}), e423 = Qh(e423), F = "ALLOWED_TAGS" in e423 ? Xh({}, e423.ALLOWED_TAGS) : U, z = "ALLOWED_ATTR" in e423 ? Xh({}, e423.ALLOWED_ATTR) : j, de = "ADD_URI_SAFE_ATTR" in e423 ? Xh(Qh(ce), e423.ADD_URI_SAFE_ATTR) : ce, ie = "ADD_DATA_URI_TAGS" in e423 ? Xh(Qh(le), e423.ADD_DATA_URI_TAGS) : le, se = "FORBID_CONTENTS" in e423 ? Xh({}, e423.FORBID_CONTENTS) : ae, H = "FORBID_TAGS" in e423 ? Xh({}, e423.FORBID_TAGS) : {}, $ = "FORBID_ATTR" in e423 ? Xh({}, e423.FORBID_ATTR) : {}, re = "USE_PROFILES" in e423 && e423.USE_PROFILES, q = !1 !== e423.ALLOW_ARIA_ATTR, W = !1 !== e423.ALLOW_DATA_ATTR, K = e423.ALLOW_UNKNOWN_PROTOCOLS || !1, G = e423.SAFE_FOR_TEMPLATES || !1, Y = e423.WHOLE_DOCUMENT || !1, J = e423.RETURN_DOM || !1, Z = e423.RETURN_DOM_FRAGMENT || !1, ee = e423.RETURN_TRUSTED_TYPE || !1, Q = e423.FORCE_BODY || !1, te = !1 !== e423.SANITIZE_DOM, ne = !1 !== e423.KEEP_CONTENT, oe = e423.IN_PLACE || !1, I = e423.ALLOWED_URI_REGEXP || I, ge = e423.NAMESPACE || fe, e423.CUSTOM_ELEMENT_HANDLING && we(e423.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (V.tagNameCheck = e423.CUSTOM_ELEMENT_HANDLING.tagNameCheck), e423.CUSTOM_ELEMENT_HANDLING && we(e423.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (V.attributeNameCheck = e423.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), e423.CUSTOM_ELEMENT_HANDLING && "boolean" == typeof e423.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (V.allowCustomizedBuiltInElements = e423.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), he = he = -1 === be.indexOf(e423.PARSER_MEDIA_TYPE) ? ve : e423.PARSER_MEDIA_TYPE, ye = "application/xhtml+xml" === he ? function(e) {
                return e;
            } : Vh, G && (W = !1), Z && (J = !0), re && (F = Xh({}, [].concat(yb(sb))), z = [], !0 === re.html && (Xh(F, Zh), Xh(z, ab)), !0 === re.svg && (Xh(F, eb), Xh(z, ib), Xh(z, db)), !0 === re.svgFilters && (Xh(F, tb), Xh(z, ib), Xh(z, db)), !0 === re.mathMl && (Xh(F, ob), Xh(z, lb), Xh(z, db))), e423.ADD_TAGS && (F === U && (F = Qh(F)), Xh(F, e423.ADD_TAGS)), e423.ADD_ATTR && (z === j && (z = Qh(z)), Xh(z, e423.ADD_ATTR)), e423.ADD_URI_SAFE_ATTR && Xh(de, e423.ADD_URI_SAFE_ATTR), e423.FORBID_CONTENTS && (se === ae && (se = Qh(se)), Xh(se, e423.FORBID_CONTENTS)), ne && (F["#text"] = !0), Y && Xh(F, [
                "html",
                "head",
                "body"
            ]), F.table && (Xh(F, [
                "tbody"
            ]), delete H.tbody), Bh && Bh(e423), Ce = e423);
        }, Se = Xh({}, [
            "mi",
            "mo",
            "mn",
            "ms",
            "mtext"
        ]), _e = Xh({}, [
            "foreignobject",
            "desc",
            "title",
            "annotation-xml"
        ]), Ee = Xh({}, [
            "title",
            "style",
            "font",
            "a",
            "script"
        ]), Ne = Xh({}, eb);
        Xh(Ne, tb), Xh(Ne, nb);
        var Re = Xh({}, ob);
        Xh(Re, rb);
        var Ae = function(e) {
            var t = y(e);
            t && t.tagName || (t = {
                namespaceURI: fe,
                tagName: "template"
            });
            var n = Vh(e.tagName), o = Vh(t.tagName);
            return e.namespaceURI === me ? t.namespaceURI === fe ? "svg" === n : t.namespaceURI === ue ? "svg" === n && ("annotation-xml" === o || Se[o]) : Boolean(Ne[n]) : e.namespaceURI === ue ? t.namespaceURI === fe ? "math" === n : t.namespaceURI === me ? "math" === n && _e[o] : Boolean(Re[n]) : e.namespaceURI === fe && !(t.namespaceURI === me && !_e[o]) && !(t.namespaceURI === ue && !Se[o]) && !Re[n] && (Ee[n] || !Ne[n]);
        }, Oe = function(e) {
            jh(n154.removed, {
                element: e
            });
            try {
                e.parentNode.removeChild(e);
            } catch (t) {
                try {
                    e.outerHTML = w;
                } catch (t) {
                    e.remove();
                }
            }
        }, Te = function(e, t) {
            try {
                jh(n154.removed, {
                    attribute: t.getAttributeNode(e),
                    from: t
                });
            } catch (e424) {
                jh(n154.removed, {
                    attribute: null,
                    from: t
                });
            }
            if (t.removeAttribute(e), "is" === e && !z[e]) {
                if (J || Z) try {
                    Oe(t);
                } catch (e425) {}
                else try {
                    t.setAttribute(e, "");
                } catch (e) {}
            }
        }, Be = function(e) {
            var t = void 0, n = void 0;
            if (Q) e = "<remove></remove>" + e;
            else {
                var o = Hh(e, /^[\r\n\t ]+/);
                n = o && o[0];
            }
            "application/xhtml+xml" === he && (e = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + e + "</body></html>");
            var s = x ? x.createHTML(e) : e;
            if (ge === fe) try {
                t = (new f4).parseFromString(s, he);
            } catch (e426) {}
            if (!t || !t.documentElement) {
                t = S.createDocument(ge, "template", null);
                try {
                    t.documentElement.innerHTML = pe ? "" : s;
                } catch (e) {}
            }
            var a = t.body || t.documentElement;
            return e && n && a.insertBefore(r49.createTextNode(n), a.childNodes[0] || null), ge === fe ? N.call(t, Y ? "html" : "body")[0] : Y ? t.documentElement : a;
        }, De = function(e) {
            return _.call(e.ownerDocument || e, e, d12.SHOW_ELEMENT | d12.SHOW_COMMENT | d12.SHOW_TEXT, null, !1);
        }, Le = function(e) {
            return e instanceof m3 && ("string" != typeof e.nodeName || "string" != typeof e.textContent || "function" != typeof e.removeChild || !(e.attributes instanceof u6) || "function" != typeof e.removeAttribute || "function" != typeof e.setAttribute || "string" != typeof e.namespaceURI || "function" != typeof e.insertBefore);
        }, Pe = function(e) {
            return "object" === (void 0 === i15 ? "undefined" : vb(i15)) ? e instanceof i15 : e && "object" === (void 0 === e ? "undefined" : vb(e)) && "number" == typeof e.nodeType && "string" == typeof e.nodeName;
        }, Me = function(e427, t, o) {
            O[e427] && Uh(O[e427], function(e) {
                e.call(n154, t, o, Ce);
            });
        }, Ie = function(e) {
            var t = void 0;
            if (Me("beforeSanitizeElements", e, null), Le(e)) return Oe(e), !0;
            if (Kh(/[\u0080-\uFFFF]/, e.nodeName)) return Oe(e), !0;
            var o = ye(e.nodeName);
            if (Me("uponSanitizeElement", e, {
                tagName: o,
                allowedTags: F
            }), e.hasChildNodes() && !Pe(e.firstElementChild) && (!Pe(e.content) || !Pe(e.content.firstElementChild)) && Kh(/<[/\w]/g, e.innerHTML) && Kh(/<[/\w]/g, e.textContent)) return Oe(e), !0;
            if ("select" === o && Kh(/<template/i, e.innerHTML)) return Oe(e), !0;
            if (!F[o] || H[o]) {
                if (!H[o] && Ue(o)) {
                    if (V.tagNameCheck instanceof RegExp && Kh(V.tagNameCheck, o)) return !1;
                    if (V.tagNameCheck instanceof Function && V.tagNameCheck(o)) return !1;
                }
                if (ne && !se[o]) {
                    var r = y(e) || e.parentNode, s = v(e) || e.childNodes;
                    if (s && r) for(var a = s.length - 1; a >= 0; --a)r.insertBefore(h(s[a], !0), b(e));
                }
                return Oe(e), !0;
            }
            return e instanceof l14 && !Ae(e) ? (Oe(e), !0) : "noscript" !== o && "noembed" !== o || !Kh(/<\/no(script|embed)/i, e.innerHTML) ? (G && 3 === e.nodeType && (t = e.textContent, t = $h(t, T, " "), t = $h(t, B, " "), e.textContent !== t && (jh(n154.removed, {
                element: e.cloneNode()
            }), e.textContent = t)), Me("afterSanitizeElements", e, null), !1) : (Oe(e), !0);
        }, Fe = function(e, t, n) {
            if (te && ("id" === t || "name" === t) && (n in r49 || n in xe)) return !1;
            if (W && !$[t] && Kh(D, t)) ;
            else if (q && Kh(L, t)) ;
            else if (!z[t] || $[t]) {
                if (!(Ue(e) && (V.tagNameCheck instanceof RegExp && Kh(V.tagNameCheck, e) || V.tagNameCheck instanceof Function && V.tagNameCheck(e)) && (V.attributeNameCheck instanceof RegExp && Kh(V.attributeNameCheck, t) || V.attributeNameCheck instanceof Function && V.attributeNameCheck(t)) || "is" === t && V.allowCustomizedBuiltInElements && (V.tagNameCheck instanceof RegExp && Kh(V.tagNameCheck, n) || V.tagNameCheck instanceof Function && V.tagNameCheck(n)))) return !1;
            } else if (de[t]) ;
            else if (Kh(I, $h(n, M, ""))) ;
            else if ("src" !== t && "xlink:href" !== t && "href" !== t || "script" === e || 0 !== qh(n, "data:") || !ie[e]) {
                if (K && !Kh(P, $h(n, M, ""))) ;
                else if (n) return !1;
            }
            return !0;
        }, Ue = function(e) {
            return e.indexOf("-") > 0;
        }, ze = function(e) {
            var t = void 0, n = void 0, o = void 0, r = void 0;
            Me("beforeSanitizeAttributes", e, null);
            var s = e.attributes;
            if (s) {
                var a = {
                    attrName: "",
                    attrValue: "",
                    keepAttr: !0,
                    allowedAttributes: z
                };
                for(r = s.length; r--;){
                    var i = t = s[r], l = i.name, d = i.namespaceURI;
                    n = Wh(t.value), o = ye(l);
                    var c = n;
                    if (a.attrName = o, a.attrValue = n, a.keepAttr = !0, a.forceKeepAttr = void 0, Me("uponSanitizeAttribute", e, a), n = a.attrValue, !a.forceKeepAttr) {
                        if (a.keepAttr) {
                            if (Kh(/\/>/i, n)) Te(l, e);
                            else {
                                G && (n = $h(n, T, " "), n = $h(n, B, " "));
                                var u = ye(e.nodeName);
                                if (Fe(u, o, n)) {
                                    if (n !== c) try {
                                        d ? e.setAttributeNS(d, l, n) : e.setAttribute(l, n);
                                    } catch (t) {
                                        Te(l, e);
                                    }
                                } else Te(l, e);
                            }
                        } else Te(l, e);
                    }
                }
                Me("afterSanitizeAttributes", e, null);
            }
        }, je = function e(t) {
            var n = void 0, o = De(t);
            for(Me("beforeSanitizeShadowDOM", t, null); n = o.nextNode();)Me("uponSanitizeShadowNode", n, null), Ie(n) || (n.content instanceof s27 && e(n.content), ze(n));
            Me("afterSanitizeShadowDOM", t, null);
        };
        return n154.sanitize = function(e, r) {
            var a = void 0, l = void 0, d = void 0, c = void 0, u = void 0;
            if ((pe = !e) && (e = "\x3c!--\x3e"), "string" != typeof e && !Pe(e)) {
                if ("function" != typeof e.toString) throw Gh("toString is not a function");
                if ("string" != typeof (e = e.toString())) throw Gh("dirty is not a string, aborting");
            }
            if (!n154.isSupported) {
                if ("object" === vb(t267.toStaticHTML) || "function" == typeof t267.toStaticHTML) {
                    if ("string" == typeof e) return t267.toStaticHTML(e);
                    if (Pe(e)) return t267.toStaticHTML(e.outerHTML);
                }
                return e;
            }
            if (X || ke(r), n154.removed = [], "string" == typeof e && (oe = !1), oe) {
                if (e.nodeName) {
                    var m = ye(e.nodeName);
                    if (!F[m] || H[m]) throw Gh("root node is forbidden and cannot be sanitized in-place");
                }
            } else if (e instanceof i15) 1 === (l = (a = Be("\x3c!----\x3e")).ownerDocument.importNode(e, !0)).nodeType && "BODY" === l.nodeName || "HTML" === l.nodeName ? a = l : a.appendChild(l);
            else {
                if (!J && !G && !Y && -1 === e.indexOf("<")) return x && ee ? x.createHTML(e) : e;
                if (!(a = Be(e))) return J ? null : ee ? w : "";
            }
            a && Q && Oe(a.firstChild);
            for(var f = De(oe ? e : a); d = f.nextNode();)3 === d.nodeType && d === c || Ie(d) || (d.content instanceof s27 && je(d.content), ze(d), c = d);
            if (c = null, oe) return e;
            if (J) {
                if (Z) for(u = E.call(a.ownerDocument); a.firstChild;)u.appendChild(a.firstChild);
                else u = a;
                return z.shadowroot && (u = R.call(o88, u, !0)), u;
            }
            var g = Y ? a.outerHTML : a.innerHTML;
            return Y && F["!doctype"] && a.ownerDocument && a.ownerDocument.doctype && a.ownerDocument.doctype.name && Kh(bb, a.ownerDocument.doctype.name) && (g = "<!DOCTYPE " + a.ownerDocument.doctype.name + ">\n" + g), G && (g = $h(g, T, " "), g = $h(g, B, " ")), x && ee ? x.createHTML(g) : g;
        }, n154.setConfig = function(e) {
            ke(e), X = !0;
        }, n154.clearConfig = function() {
            Ce = null, X = !1;
        }, n154.isValidAttribute = function(e, t, n) {
            Ce || ke({});
            var o = ye(e), r = ye(t);
            return Fe(o, r, n);
        }, n154.addHook = function(e, t) {
            "function" == typeof t && (O[e] = O[e] || [], jh(O[e], t));
        }, n154.removeHook = function(e) {
            O[e] && zh(O[e]);
        }, n154.removeHooks = function(e) {
            O[e] && (O[e] = []);
        }, n154.removeAllHooks = function() {
            O = {};
        }, n154;
    }();
    const kb = (e428, t268, n155)=>{
        const o89 = ys();
        t268.convert_fonts_to_spans && ((e429, t269, n)=>{
            e429.addNodeFilter("font", (e430)=>{
                $1(e430, (e431)=>{
                    const o = t269.parse(e431.attr("style")), r = e431.attr("color"), s = e431.attr("face"), a = e431.attr("size");
                    r && (o.color = r), s && (o["font-family"] = s), a && (o["font-size"] = n[parseInt(e431.attr("size"), 10) - 1]), e431.name = "span", e431.attr("style", t269.serialize(o)), ((e, t270)=>{
                        $1([
                            "color",
                            "face",
                            "size"
                        ], (t)=>{
                            e.attr(t, null);
                        });
                    })(e431);
                });
            });
        })(e428, o89, Bt.explode(t268.font_size_legacy_values)), ((e432, t271, n)=>{
            e432.addNodeFilter("strike", (e433)=>{
                const o = "html4" !== t271.type;
                $1(e433, (e)=>{
                    if (o) e.name = "s";
                    else {
                        const t = n.parse(e.attr("style"));
                        t["text-decoration"] = "line-through", e.name = "span", e.attr("style", n.serialize(t));
                    }
                });
            });
        })(e428, n155, o89);
    }, Sb = (e)=>{
        let t;
        const n = decodeURIComponent(e).split(","), o = /data:([^;]+)/.exec(n[0]);
        return o && (t = o[1]), {
            type: t,
            data: n[1]
        };
    }, _b = (e, t)=>{
        let n;
        try {
            n = atob(t);
        } catch (e435) {
            return M1.none();
        }
        const o = new Uint8Array(n.length);
        for(let e434 = 0; e434 < o.length; e434++)o[e434] = n.charCodeAt(e434);
        return M1.some(new Blob([
            o
        ], {
            type: e
        }));
    }, Eb = (e436)=>{
        var t272;
        return 0 === e436.indexOf("blob:") ? ((e)=>new Promise((t, n)=>{
                const o = ()=>{
                    n("Cannot convert " + e + " to Blob. Resource might not exist or is inaccessible.");
                };
                try {
                    const n = new XMLHttpRequest;
                    n.open("GET", e, !0), n.responseType = "blob", n.onload = ()=>{
                        200 === n.status ? t(n.response) : o();
                    }, n.onerror = o, n.send();
                } catch (e) {
                    o();
                }
            })
        )(e436) : 0 === e436.indexOf("data:") ? (t272 = e436, new Promise((e)=>{
            const { type: n , data: o  } = Sb(t272);
            _b(n, o).fold(()=>e(new Blob([]))
            , e);
        })) : null;
    }, Nb = (e)=>new Promise((t)=>{
            const n = new FileReader;
            n.onloadend = ()=>{
                t(n.result);
            }, n.readAsDataURL(e);
        })
    ;
    let Rb = 0;
    const Ab = (e)=>(e || "blobid") + Rb++
    , Ob = Bt.each, Tb = Bt.trim, Bb = "source protocol authority userInfo user password host port relative path directory file query anchor".split(" "), Db = {
        ftp: 21,
        http: 80,
        https: 443,
        mailto: 25
    }, Lb = [
        "img",
        "video"
    ], Pb = (e437, t273, n)=>{
        const o = ((e)=>{
            try {
                return decodeURIComponent(e);
            } catch (t) {
                return unescape(e);
            }
        })(t273);
        return !e437.allow_script_urls && (!!/((java|vb)script|mhtml):/i.test(o) || !e437.allow_html_data_urls && (/^data:image\//i.test(o) ? ((e, t)=>C1(e) ? !e : !C1(t) || !j1(Lb, t)
        )(e437.allow_svg_data_urls, n) && /^data:image\/svg\+xml/i.test(o) : /^data:/i.test(o)));
    };
    class Mb {
        constructor(e438, t274){
            e438 = Tb(e438), this.settings = t274 || {};
            const n156 = this.settings.base_uri, o = this;
            if (/^([\w\-]+):([^\/]{2})/i.test(e438) || /^\s*#/.test(e438)) return void (o.source = e438);
            const r = 0 === e438.indexOf("//");
            if (0 !== e438.indexOf("/") || r || (e438 = (n156 && n156.protocol || "http") + "://mce_host" + e438), !/^[\w\-]*:?\/\//.test(e438)) {
                const t = this.settings.base_uri ? this.settings.base_uri.path : new Mb(document.location.href).directory;
                if (this.settings.base_uri && "" == this.settings.base_uri.protocol) e438 = "//mce_host" + o.toAbsPath(t, e438);
                else {
                    const r = /([^#?]*)([#?]?.*)/.exec(e438);
                    e438 = (n156 && n156.protocol || "http") + "://mce_host" + o.toAbsPath(t, r[1]) + r[2];
                }
            }
            e438 = e438.replace(/@@/g, "(mce_at)");
            const s = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?(\[[a-zA-Z0-9:.%]+\]|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(e438);
            Ob(Bb, (e, t)=>{
                let n = s[t];
                n && (n = n.replace(/\(mce_at\)/g, "@@")), o[e] = n;
            }), n156 && (o.protocol || (o.protocol = n156.protocol), o.userInfo || (o.userInfo = n156.userInfo), o.port || "mce_host" !== o.host || (o.port = n156.port), o.host && "mce_host" !== o.host || (o.host = n156.host), o.source = ""), r && (o.protocol = "");
        }
        static parseDataUri(e) {
            let t;
            const n = decodeURIComponent(e).split(","), o = /data:([^;]+)/.exec(n[0]);
            return o && (t = o[1]), {
                type: t,
                data: n[1]
            };
        }
        static isDomSafe(e, t, n = {}) {
            if (n.allow_script_urls) return !0;
            {
                const o = ls.decode(e).replace(/[\s\u0000-\u001F]+/g, "");
                return !Pb(n, o, t);
            }
        }
        static getDocumentBaseUrl(e) {
            let t;
            return t = 0 !== e.protocol.indexOf("http") && "file:" !== e.protocol ? e.href : e.protocol + "//" + e.host + e.pathname, /^[^:]+:\/\/\/?[^\/]+\//.test(t) && (t = t.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(t) || (t += "/")), t;
        }
        setPath(e) {
            const t = /^(.*?)\/?(\w+)?$/.exec(e);
            this.path = t[0], this.directory = t[1], this.file = t[2], this.source = "", this.getURI();
        }
        toRelative(e) {
            let t;
            if ("./" === e) return e;
            const n = new Mb(e, {
                base_uri: this
            });
            if ("mce_host" !== n.host && this.host !== n.host && n.host || this.port !== n.port || this.protocol !== n.protocol && "" !== n.protocol) return n.getURI();
            const o = this.getURI(), r = n.getURI();
            return o === r || "/" === o.charAt(o.length - 1) && o.substr(0, o.length - 1) === r ? o : (t = this.toRelPath(this.path, n.path), n.query && (t += "?" + n.query), n.anchor && (t += "#" + n.anchor), t);
        }
        toAbsolute(e, t) {
            const n = new Mb(e, {
                base_uri: this
            });
            return n.getURI(t && this.isSameOrigin(n));
        }
        isSameOrigin(e) {
            if (this.host == e.host && this.protocol == e.protocol) {
                if (this.port == e.port) return !0;
                const t = Db[this.protocol];
                if (t && (this.port || t) == (e.port || t)) return !0;
            }
            return !1;
        }
        toRelPath(e, t) {
            let n, o, r = 0, s = "";
            const a = e.substring(0, e.lastIndexOf("/")).split("/"), i = t.split("/");
            if (a.length >= i.length) {
                for(n = 0, o = a.length; n < o; n++)if (n >= i.length || a[n] !== i[n]) {
                    r = n + 1;
                    break;
                }
            }
            if (a.length < i.length) {
                for(n = 0, o = i.length; n < o; n++)if (n >= a.length || a[n] !== i[n]) {
                    r = n + 1;
                    break;
                }
            }
            if (1 === r) return t;
            for(n = 0, o = a.length - (r - 1); n < o; n++)s += "../";
            for(n = r - 1, o = i.length; n < o; n++)s += n !== r - 1 ? "/" + i[n] : i[n];
            return s;
        }
        toAbsPath(e439, t) {
            let n, o, r = 0, s = [];
            const a = /\/$/.test(t) ? "/" : "";
            let i = e439.split("/");
            const l = t.split("/");
            for(Ob(i, (e)=>{
                e && s.push(e);
            }), i = s, n = l.length - 1, s = []; n >= 0; n--)0 !== l[n].length && "." !== l[n] && (".." !== l[n] ? r > 0 ? r-- : s.push(l[n]) : r++);
            return n = i.length - r, o = n <= 0 ? ne1(s).join("/") : i.slice(0, n).join("/") + "/" + ne1(s).join("/"), 0 !== o.indexOf("/") && (o = "/" + o), a && o.lastIndexOf("/") !== o.length - 1 && (o += a), o;
        }
        getURI(e = !1) {
            let t;
            return this.source && !e || (t = "", e || (this.protocol ? t += this.protocol + "://" : t += "//", this.userInfo && (t += this.userInfo + "@"), this.host && (t += this.host), this.port && (t += ":" + this.port)), this.path && (t += this.path), this.query && (t += "?" + this.query), this.anchor && (t += "#" + this.anchor), this.source = t), this.source;
        }
    }
    const Ib = Bt.makeMap, Fb = Bt.each, Ub = Bt.explode, zb = Bt.extend, jb = {
        IN_PLACE: !0,
        ALLOW_UNKNOWN_PROTOCOLS: !0,
        ALLOWED_TAGS: [
            "#comment",
            "#cdata-section",
            "body"
        ],
        ALLOWED_ATTR: []
    }, Vb = Bt.makeMap("src,href,data,background,action,formaction,poster,xlink:href"), Hb = "data-mce-type", $b = (e440, t275)=>{
        const n157 = wb(), o90 = e440.validate;
        let r50 = 0;
        return n157.addHook("uponSanitizeElement", (n158, s)=>{
            var a, i;
            8 === n158.nodeType && !e440.allow_conditional_comments && /^\[if/i.test(n158.nodeValue) && (n158.nodeValue = " " + n158.nodeValue);
            const l = s.tagName;
            if (1 !== n158.nodeType || "body" === l) return;
            const d = mn(n158), c = Gt(d, Hb), u = Wt(d, "data-mce-bogus");
            if (!c && m1(u)) return void ("all" === u ? to(d) : no(d));
            const f = t275.getElementRule(l.toLowerCase());
            if (!o90 || f) {
                if (s.allowedTags[l] = !0, o90 && !c) {
                    if ($1(null !== (a = f.attributesForced) && void 0 !== a ? a : [], (e)=>{
                        $t(d, e.name, "{$uid}" === e.value ? "mce_" + r50++ : e.value);
                    }), $1(null !== (i = f.attributesDefault) && void 0 !== i ? i : [], (e)=>{
                        Gt(d, e.name) || $t(d, e.name, "{$uid}" === e.value ? "mce_" + r50++ : e.value);
                    }), f.attributesRequired && !V1(f.attributesRequired, (e)=>Gt(d, e)
                    )) return void no(d);
                    if (f.removeEmptyAttrs && ((e)=>{
                        const t = e.dom.attributes;
                        return null == t || 0 === t.length;
                    })(d)) return void no(d);
                    f.outputName && f.outputName !== l.toLowerCase() && ((e441, t276)=>{
                        const n159 = ((e, t)=>{
                            const n = cn(t), o = Xt(e);
                            return qt(n, o), n;
                        })(e441, t276);
                        Xn(e441, n159);
                        const o91 = Nn(e441);
                        Zn(n159, o91), to(e441);
                    })(d, f.outputName);
                }
            } else no(d);
        }), n157.addHook("uponSanitizeAttribute", (n, r)=>{
            const s = n.tagName.toLowerCase(), { attrName: a , attrValue: i  } = r;
            r.keepAttr = !o90 || t275.isValid(s, a) || ze1(a, "data-") || ze1(a, "aria-"), a in Vb && Pb(e440, i, s) && (r.keepAttr = !1), r.keepAttr ? (r.allowedAttributes[a] = !0, a in t275.getBoolAttrs() && (r.attrValue = a), e440.allow_svg_data_urls && ze1(i, "data:image/svg+xml") && (r.forceKeepAttr = !0)) : !n.hasAttribute(Hb) || "id" !== a && "class" !== a && "style" !== a || (r.forceKeepAttr = !0);
        }), n157;
    }, qb = (e, t, n)=>{
        const o = e.name, r = o in n && "title" !== o && "textarea" !== o, s = t.childNodes;
        for(let t277 = 0, o92 = s.length; t277 < o92; t277++){
            const o = s[t277], a = new yf(o.nodeName.toLowerCase(), o.nodeType);
            if (yo(o)) {
                const e = o.attributes;
                for(let t = 0, n = e.length; t < n; t++){
                    const n = e[t];
                    a.attr(n.name, n.value);
                }
            } else No(o) ? (a.value = o.data, r && (a.raw = !0)) : (Oo(o) || Ro(o) || Ao(o)) && (a.value = o.data);
            qb(a, o, n), e.append(a);
        }
    }, Wb = (e442 = {}, t278 = vs())=>{
        const n160 = {}, o93 = [], r51 = {
            validate: !0,
            root_name: "body",
            ...e442
        }, s28 = new DOMParser, a22 = $b(r51, t278), i16 = ()=>{
            const e = [];
            for(const t in n160)we1(n160, t) && e.push({
                name: t,
                callbacks: n160[t]
            });
            return e;
        }, l15 = {
            schema: t278,
            addAttributeFilter: (e443, t)=>{
                Fb(Ub(e443), (e)=>{
                    let n;
                    for(n = 0; n < o93.length; n++)if (o93[n].name === e) return void o93[n].callbacks.push(t);
                    o93.push({
                        name: e,
                        callbacks: [
                            t
                        ]
                    });
                });
            },
            getAttributeFilters: ()=>[].concat(o93)
            ,
            addNodeFilter: (e444, t)=>{
                Fb(Ub(e444), (e)=>{
                    let o = n160[e];
                    o || (n160[e] = o = []), o.push(t);
                });
            },
            getNodeFilters: i16,
            parse: (e445, n161 = {})=>{
                var l16;
                const d13 = r51.validate, c7 = null !== (l16 = n161.context) && void 0 !== l16 ? l16 : r51.root_name, u7 = ((e446, n162, o = "html")=>{
                    const i = "xhtml" === o ? "application/xhtml+xml" : "text/html", l = we1(t278.getSpecialElements(), n162.toLowerCase()), d = l ? `<${n162}>${e446}</${n162}>` : e446, c = "xhtml" === o ? `<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>${d}</body></html>` : `<body>${d}</body>`, u = s28.parseFromString(c, i).body;
                    return a22.sanitize(u, ((e, t)=>{
                        const n = {
                            ...jb
                        };
                        return n.PARSER_MEDIA_TYPE = t, e.allow_script_urls ? n.ALLOWED_URI_REGEXP = /.*/ : e.allow_html_data_urls && (n.ALLOWED_URI_REGEXP = /^(?!(\w+script|mhtml):)/i), n;
                    })(r51, i)), a22.removed = [], l ? u.firstChild : u;
                })(e445, c7, n161.format), m4 = new yf(c7, 11);
                qb(m4, u7, t278.getSpecialElements());
                const [f, g] = ((e447, t279, n163, o)=>{
                    const r52 = n163.validate, s = t279.getNonEmptyElements(), a = t279.getWhitespaceElements(), i = zb(Ib("script,style,head,html,body,title,meta,param"), t279.getBlockElements()), l = /[ \t\r\n]+/g, d = /^[ \t\r\n]+/, c = /[ \t\r\n]+$/, u = (e)=>{
                        for(e = e.parent; C1(e);){
                            if (e.name in a) return !0;
                            e = e.parent;
                        }
                        return !1;
                    }, m = (t, n)=>{
                        const r = n ? t.prev : t.next;
                        return !C1(r) && t.parent.name in i && (t.parent !== e447 || o.isRootContent);
                    };
                    return [
                        (e448)=>{
                            if (3 === e448.type && !u(e448)) {
                                let t280 = e448.value;
                                t280 = t280.replace(l, " "), (((e, t)=>e && (e.name in t || "br" === e.name)
                                )(e448.prev, i) || m(e448, !0)) && (t280 = t280.replace(d, "")), 0 === t280.length ? e448.remove() : e448.value = t280;
                            }
                        },
                        (e449)=>{
                            var n;
                            if (1 === e449.type) {
                                const n = t279.getElementRule(e449.name);
                                if (r52 && n) {
                                    const r = gp(t279, s, a, e449);
                                    n.removeEmpty && r ? i[e449.name] ? e449.remove() : e449.unwrap() : n.paddEmpty && (r || ((e)=>fp(e, "#text") && e.firstChild.value === dr
                                    )(e449)) && mp(0, o, i, e449);
                                }
                            } else if (3 === e449.type && !u(e449)) {
                                let t = e449.value;
                                (i[null === (n = e449.next) || void 0 === n ? void 0 : n.name] || m(e449, !1)) && (t = t.replace(c, "")), 0 === t.length ? e449.remove() : e449.value = t;
                            }
                        }
                    ];
                })(m4, t278, r51, n161), p = [], h = d13 ? (e450)=>((e, n)=>{
                        const o = e.parent;
                        o && t278.children[e.name] && !t278.isValidChild(o.name, e.name) && n.push(e);
                    })(e450, p)
                 : S1, b = i16(), v = {
                    nodes: {},
                    attributes: {}
                }, x = (e)=>dp(b, o93, e, v)
                ;
                if (((e452, t, n)=>{
                    const o = [];
                    for(let n164 = e452, r = n164; C1(n164); r = n164, n164 = n164.walk())$1(t, (e)=>e(n164)
                    ), y1(n164.parent) && n164 !== e452 ? n164 = r : o.push(n164);
                    for(let e451 = o.length - 1; e451 >= 0; e451--){
                        const t = o[e451];
                        $1(n, (e)=>e(t)
                        );
                    }
                })(m4, [
                    f,
                    x
                ], [
                    g,
                    h
                ]), p.reverse(), d13 && p.length > 0) {
                    if (n161.context) {
                        const { pass: e453 , fail: o  } = W1(p, (e)=>e.parent === m4
                        );
                        hp(o, t278, x), n161.invalid = e453.length > 0;
                    } else hp(p, t278, x);
                }
                const w = ((e, t)=>{
                    var n;
                    const o = null !== (n = t.forced_root_block) && void 0 !== n ? n : e.forced_root_block;
                    return !1 === o ? "" : !0 === o ? "p" : o;
                })(r51, n161);
                return w && ("body" === m4.name || n161.isRootContent) && ((e456, n)=>{
                    const o = zb(Ib("script,style,head,html,body,title,meta,param"), t278.getBlockElements()), s = /^[ \t\r\n]+/, a = /[ \t\r\n]+$/;
                    let i = e456.firstChild, l = null;
                    const d = (e)=>{
                        e && (i = e.firstChild, i && 3 === i.type && (i.value = i.value.replace(s, "")), i = e.lastChild, i && 3 === i.type && (i.value = i.value.replace(a, "")));
                    };
                    if (t278.isValidChild(e456.name, n.toLowerCase())) {
                        for(; i;){
                            const t = i.next;
                            3 === i.type || 1 === i.type && "p" !== i.name && !o[i.name] && !i.attr(Hb) ? (l || (l = new yf(n, 1), l.attr(r51.forced_root_block_attrs), e456.insert(l, i)), l.append(i)) : (d(l), l = null), i = t;
                        }
                        d(l);
                    }
                })(m4, w), n161.invalid || cp(v, n161), m4;
            }
        };
        return ((e457, t283)=>{
            const n165 = e457.schema;
            t283.remove_trailing_brs && e457.addNodeFilter("br", (e, t, o)=>{
                const r = Bt.extend({}, n165.getBlockElements()), s = n165.getNonEmptyElements(), a = n165.getWhitespaceElements();
                r.body = 1;
                for(let t282 = 0, i = e.length; t282 < i; t282++){
                    let i = e[t282], l = i.parent;
                    if (r[i.parent.name] && i === l.lastChild) {
                        let e = i.prev;
                        for(; e;){
                            const t = e.name;
                            if ("span" !== t || "bookmark" !== e.attr("data-mce-type")) {
                                "br" === t && (i = null);
                                break;
                            }
                            e = e.prev;
                        }
                        if (i && (i.remove(), gp(n165, s, a, l))) {
                            const e = n165.getElementRule(l.name);
                            e && (e.removeEmpty ? l.remove() : e.paddEmpty && mp(0, o, r, l));
                        }
                    } else {
                        let e = i;
                        for(; l && l.firstChild === e && l.lastChild === e && (e = l, !r[l.name]);)l = l.parent;
                        if (e === l) {
                            const e = new yf("#text", 3);
                            e.value = dr, i.replace(e);
                        }
                    }
                }
            }), e457.addAttributeFilter("href", (e458)=>{
                let n = e458.length;
                const o = (e459)=>{
                    const t = e459 ? Bt.trim(e459) : "";
                    return /\b(noopener)\b/g.test(t) ? t : ((e460)=>e460.split(" ").filter((e)=>e.length > 0
                        ).concat([
                            "noopener"
                        ]).sort().join(" ")
                    )(t);
                };
                if (!t283.allow_unsafe_link_target) for(; n--;){
                    const t = e458[n];
                    "a" === t.name && "_blank" === t.attr("target") && t.attr("rel", o(t.attr("rel")));
                }
            }), t283.allow_html_in_named_anchor || e457.addAttributeFilter("id,name", (e)=>{
                let t, n, o, r, s = e.length;
                for(; s--;)if (r = e[s], "a" === r.name && r.firstChild && !r.attr("href")) {
                    o = r.parent, t = r.lastChild;
                    do n = t.prev, o.insert(t, r), t = n;
                    while (t)
                }
            }), t283.fix_list_elements && e457.addNodeFilter("ul,ol", (e)=>{
                let t, n, o = e.length;
                for(; o--;)if (t = e[o], n = t.parent, "ul" === n.name || "ol" === n.name) {
                    if (t.prev && "li" === t.prev.name) t.prev.append(t);
                    else {
                        const e = new yf("li", 1);
                        e.attr("style", "list-style-type: none"), t.wrap(e);
                    }
                }
            }), t283.validate && n165.getValidClasses() && e457.addAttributeFilter("class", (e)=>{
                const t = n165.getValidClasses();
                let o = e.length;
                for(; o--;){
                    const n = e[o], r = n.attr("class").split(" ");
                    let s = "";
                    for(let e461 = 0; e461 < r.length; e461++){
                        const o = r[e461];
                        let a = !1, i = t["*"];
                        i && i[o] && (a = !0), i = t[n.name], !a && i && i[o] && (a = !0), a && (s && (s += " "), s += o);
                    }
                    s.length || (s = null), n.attr("class", s);
                }
            }), ((e462, t284)=>{
                const { blob_cache: n  } = t284, o94 = (e463)=>{
                    const t285 = e463.attr("src");
                    ((e)=>e.attr("src") === Nt.transparentSrc || C1(e.attr("data-mce-placeholder"))
                    )(e463) || ((e)=>C1(e.attr("data-mce-bogus"))
                    )(e463) || ((e)=>{
                        const t = /data:([^;]+);base64,([a-z0-9\+\/=\s]+)/i.exec(e);
                        return t ? M1.some({
                            type: t[1],
                            data: decodeURIComponent(t[2])
                        }) : M1.none();
                    })(t285).bind(({ type: e464 , data: t  })=>M1.from(n.getByData(t, e464)).orThunk(()=>_b(e464, t).map((e)=>{
                                const o = n.create(Ab(), e, t);
                                return n.add(o), o;
                            })
                        )
                    ).each((t)=>{
                        e463.attr("src", t.blobUri());
                    });
                };
                n && e462.addAttributeFilter("src", (e)=>$1(e, o94)
                );
            })(e457, t283);
        })(l15, r51), ((e, t, n)=>{
            t.inline_styles && kb(e, t, n);
        })(l15, r51, t278), l15;
    }, Kb = (e465, t)=>{
        const n = ((e)=>_p(e) ? Rf({
                validate: !1
            }).serialize(e) : e
        )(e465), o = t(n);
        if (o.isDefaultPrevented()) return o;
        if (_p(e465)) {
            if (o.content !== n) {
                const t = Wb({
                    validate: !1,
                    forced_root_block: !1
                }).parse(o.content, {
                    context: e465.name
                });
                return {
                    ...o,
                    content: t
                };
            }
            return {
                ...o,
                content: e465
            };
        }
        return o;
    }, Gb = (e466, t286)=>{
        if (t286.no_events) return di.value(t286);
        {
            const n = ((e, t)=>e.dispatch("BeforeGetContent", t)
            )(e466, t286);
            return n.isDefaultPrevented() ? di.error(Iu(e466, {
                content: "",
                ...n
            }).content) : di.value(n);
        }
    }, Yb = (e, t287, n)=>n.no_events ? t287 : Kb(t287, (t)=>Iu(e, {
                ...n,
                content: t
            })
        ).content
    , Xb = (e467, t288)=>{
        if (t288.no_events) return di.value(t288);
        {
            const n166 = Kb(t288.content, (n)=>((e, t)=>e.dispatch("BeforeSetContent", t)
                )(e467, {
                    ...t288,
                    content: n
                })
            );
            return n166.isDefaultPrevented() ? (Mu(e467, n166), di.error(void 0)) : di.value(n166);
        }
    }, Qb = (e, t, n)=>{
        n.no_events || Mu(e, {
            ...n,
            content: t
        });
    }, Jb = (e, t, n)=>({
            element: e,
            width: t,
            rows: n
        })
    , Zb = (e, t)=>({
            element: e,
            cells: t
        })
    , ev = (e, t)=>({
            x: e,
            y: t
        })
    , tv = (e, t)=>{
        const n = parseInt(Wt(e, t), 10);
        return isNaN(n) ? 1 : n;
    }, nv = (e, t, n)=>{
        const o = e.rows;
        return !!(o[n] ? o[n].cells : [])[t];
    }, ov = (e468)=>Y1(e468, (e, t)=>t.cells.length > e ? t.cells.length : e
        , 0)
    , rv = (e, t)=>{
        const n = e.rows;
        for(let e469 = 0; e469 < n.length; e469++){
            const o = n[e469].cells;
            for(let n168 = 0; n168 < o.length; n168++)if (bn(o[n168], t)) return M1.some(ev(n168, e469));
        }
        return M1.none();
    }, sv = (e, t, n, o, r)=>{
        const s = [], a = e.rows;
        for(let e470 = n; e470 <= r; e470++){
            const n = a[e470].cells, r = t < o ? n.slice(t, o + 1) : n.slice(o, t + 1);
            s.push(Zb(a[e470].element, r));
        }
        return s;
    }, av = (e471)=>((e, t)=>{
            const n = ia(e.element), o = cn("tbody");
            return Zn(o, t), Jn(n, o), n;
        })(e471, ((e472)=>H1(e472.rows, (e473)=>{
                const t289 = H1(e473.cells, (e)=>{
                    const t = la(e);
                    return Yt(t, "colspan"), Yt(t, "rowspan"), t;
                }), n = ia(e473.element);
                return Zn(n, t289), n;
            })
        )(e471))
    , iv = (e474, t290)=>{
        const n169 = mn(t290.commonAncestorContainer), o = Qf(n169, e474), r = K1(o, (e)=>er(e) || Jo(e)
        ), s = ((e475, t291)=>Q1(e475, (e)=>"li" === Mt(e) && Cu(e, t291)
            ).fold(N1([]), (t292)=>((e476)=>Q1(e476, (e)=>"ul" === Mt(e) || "ol" === Mt(e)
                    )
                )(e475).map((e)=>{
                    const t293 = cn(Mt(e)), n = ve1(Kn(e), (e, t)=>ze1(t, "list-style")
                    );
                    return Hn(t293, n), [
                        cn("li"),
                        t293
                    ];
                }).getOr([])
            )
        )(o, t290), a = r.concat(s.length ? s : ((e)=>rr(e) ? wn(e).filter(or).fold(N1([]), (t)=>[
                    e,
                    t
                ]
            ) : or(e) ? [
                e
            ] : []
        )(n169));
        return H1(a, ia);
    }, lv = ()=>em([])
    , dv = (e477, t294)=>((e, t)=>qo(t, "table", O1(bn, e))
        )(e477, t294[0]).bind((e478)=>{
            const n170 = t294[0], o95 = t294[t294.length - 1], r53 = ((e479)=>{
                const t295 = Jb(ia(e479), 0, []);
                return $1(Xs(e479, "tr"), (e481, n171)=>{
                    $1(Xs(e481, "td,th"), (o96, r54)=>{
                        ((e, t, n, o, r)=>{
                            const s = tv(r, "rowspan"), a = tv(r, "colspan"), i = e.rows;
                            for(let e480 = n; e480 < n + s; e480++){
                                i[e480] || (i[e480] = Zb(la(o), []));
                                for(let o97 = t; o97 < t + a; o97++)i[e480].cells[o97] = e480 === n && o97 === t ? r : ia(r);
                            }
                        })(t295, ((e, t, n)=>{
                            for(; nv(e, t, n);)t++;
                            return t;
                        })(t295, r54, n171), n171, e481, o96);
                    });
                }), Jb(t295.element, ov(t295.rows), t295.rows);
            })(e478);
            return ((e482, t296, n172)=>rv(e482, t296).bind((t297)=>rv(e482, n172).map((n173)=>((e, t, n)=>{
                            const o = t.x, r = t.y, s = n.x, a = n.y, i = r < a ? sv(e, o, r, s, a) : sv(e, o, a, s, r);
                            return Jb(e.element, ov(i), i);
                        })(e482, t297, n173)
                    )
                )
            )(r53, n170, o95).map((e)=>em([
                    av(e)
                ])
            );
        }).getOrThunk(lv)
    , cv = (e483, t298)=>{
        const n174 = pu(t298, e483);
        return n174.length > 0 ? dv(e483, n174) : ((e484, t299)=>t299.length > 0 && t299[0].collapsed ? lv() : ((e485, t300)=>((e486, t301)=>{
                    const n = Y1(t301, (e, t)=>(Jn(t, e), t)
                    , e486);
                    return t301.length > 0 ? em([
                        n
                    ]) : n;
                })(mn(t300.cloneContents()), iv(e485, t300))
            )(e484, t299[0])
        )(e483, t298);
    }, uv = (e, t)=>t >= 0 && t < e.length && Nc(e.charAt(t))
    , mv = (e)=>fr(e.innerText)
    , fv = (e)=>yo(e) ? e.outerHTML : No(e) ? ls.encodeRaw(e.data, !1) : Oo(e) ? "\x3c!--" + e.data + "--\x3e" : ""
    , gv = (e487, t302)=>(((e488, t303)=>{
            let n175 = 0;
            $1(e488, (e489)=>{
                0 === e489[0] ? n175++ : 1 === e489[0] ? (((e490, t304, n176)=>{
                    const o98 = ((e)=>{
                        let t;
                        const n = document.createElement("div"), o = document.createDocumentFragment();
                        for(e && (n.innerHTML = e); t = n.firstChild;)o.appendChild(t);
                        return o;
                    })(t304);
                    if (e490.hasChildNodes() && n176 < e490.childNodes.length) {
                        const t = e490.childNodes[n176];
                        t.parentNode.insertBefore(o98, t);
                    } else e490.appendChild(o98);
                })(t303, e489[1], n175), n175++) : 2 === e489[0] && ((e, t)=>{
                    if (e.hasChildNodes() && t < e.childNodes.length) {
                        const n = e.childNodes[t];
                        n.parentNode.removeChild(n);
                    }
                })(t303, n175);
            });
        })(((e491, t305)=>{
            const n177 = e491.length + t305.length + 2, o99 = new Array(n177), r55 = new Array(n177), s29 = (n, o, r, a, l)=>{
                const d = i17(n, o, r, a);
                if (null === d || d.start === o && d.diag === o - a || d.end === n && d.diag === n - r) {
                    let s = n, i = r;
                    for(; s < o || i < a;)s < o && i < a && e491[s] === t305[i] ? (l.push([
                        0,
                        e491[s]
                    ]), ++s, ++i) : o - n > a - r ? (l.push([
                        2,
                        e491[s]
                    ]), ++s) : (l.push([
                        1,
                        t305[i]
                    ]), ++i);
                } else {
                    s29(n, d.start, r, d.start - d.diag, l);
                    for(let t = d.start; t < d.end; ++t)l.push([
                        0,
                        e491[t]
                    ]);
                    s29(d.end, o, d.end - d.diag, a, l);
                }
            }, a23 = (n178, o, r, s)=>{
                let a = n178;
                for(; a - o < s && a < r && e491[a] === t305[a - o];)++a;
                return ((e, t, n)=>({
                        start: e,
                        end: t,
                        diag: n
                    })
                )(n178, a, o);
            }, i17 = (n, s, i, l)=>{
                const d = s - n, c = l - i;
                if (0 === d || 0 === c) return null;
                const u = d - c, m = c + d, f = (m % 2 == 0 ? m : m + 1) / 2;
                let g, p, h, b, v;
                for(o99[1 + f] = n, r55[1 + f] = s + 1, g = 0; g <= f; ++g){
                    for(p = -g; p <= g; p += 2){
                        for(h = p + f, p === -g || p !== g && o99[h - 1] < o99[h + 1] ? o99[h] = o99[h + 1] : o99[h] = o99[h - 1] + 1, b = o99[h], v = b - n + i - p; b < s && v < l && e491[b] === t305[v];)o99[h] = ++b, ++v;
                        if (u % 2 != 0 && u - g <= p && p <= u + g && r55[h - u] <= o99[h]) return a23(r55[h - u], p + n - i, s, l);
                    }
                    for(p = u - g; p <= u + g; p += 2){
                        for(h = p + f - u, p === u - g || p !== u + g && r55[h + 1] <= r55[h - 1] ? r55[h] = r55[h + 1] - 1 : r55[h] = r55[h - 1], b = r55[h] - 1, v = b - n + i - p; b >= n && v >= i && e491[b] === t305[v];)r55[h] = b--, v--;
                        if (u % 2 == 0 && -g <= p && p <= g && r55[h] <= o99[h + u]) return a23(r55[h], p + n - i, s, l);
                    }
                }
            }, l17 = [];
            return s29(0, e491.length, 0, t305.length, l17), l17;
        })(H1(de1(t302.childNodes), fv), e487), t302), t302)
    , pv = De1(()=>document.implementation.createHTMLDocument("undo")
    ), hv = (e492)=>{
        const t306 = (n179 = e492.getBody(), K1(H1(de1(n179.childNodes), fv), (e)=>e.length > 0
        ));
        var n179;
        const o = ee1(t306, (t)=>{
            const n = wf(e492.serializer, t);
            return n.length > 0 ? [
                n
            ] : [];
        }), r = o.join("");
        return ((e)=>-1 !== e.indexOf("</iframe>")
        )(r) ? ((e)=>({
                type: "fragmented",
                fragments: e,
                content: "",
                bookmark: null,
                beforeBookmark: null
            })
        )(o) : ((e)=>({
                type: "complete",
                fragments: null,
                content: e,
                bookmark: null,
                beforeBookmark: null
            })
        )(r);
    }, bv = (e, t, n)=>{
        const o = n ? t.beforeBookmark : t.bookmark;
        "fragmented" === t.type ? gv(t.fragments, e.getBody()) : e.setContent(t.content, {
            format: "raw",
            no_selection: !C1(o) || !hc(o) || !o.isFakeCaret
        }), e.selection.moveToBookmark(o);
    }, vv = (e)=>"fragmented" === e.type ? e.fragments.join("") : e.content
    , yv = (e)=>{
        const t = cn("body", pv());
        return ro(t, vv(e)), $1(Xs(t, "*[data-mce-bogus]"), no), oo(t);
    }, Cv = (e493, t307)=>!(!e493 || !t307) && (!!((e, t)=>vv(e) === vv(t)
        )(e493, t307) || ((e, t)=>yv(e) === yv(t)
        )(e493, t307))
    , xv = (e)=>0 === e.get()
    , wv = (e, t, n)=>{
        xv(n) && (e.typing = t);
    }, kv = (e, t)=>{
        e.typing && (wv(e, !1, t), e.add());
    }, Sv = (e494)=>({
            init: {
                bindEvents: S1
            },
            undoManager: {
                beforeChange: (t308, n180)=>((e, t, n)=>{
                        xv(t) && n.set(ai(e.selection));
                    })(e494, t308, n180)
                ,
                add: (t309, n181, o100, r56, s30, a24)=>((e495, t, n, o, r, s, a)=>{
                        const i = hv(e495);
                        if (s = s || {}, s = Bt.extend(s, i), !1 === xv(o) || e495.removed) return null;
                        const l = t.data[n.get()];
                        if (e495.dispatch("BeforeAddUndo", {
                            level: s,
                            lastLevel: l,
                            originalEvent: a
                        }).isDefaultPrevented()) return null;
                        if (l && Cv(l, s)) return null;
                        t.data[n.get()] && r.get().each((e)=>{
                            t.data[n.get()].beforeBookmark = e;
                        });
                        const d = wl(e495);
                        if (d && t.data.length > d) {
                            for(let e = 0; e < t.data.length - 1; e++)t.data[e] = t.data[e + 1];
                            t.data.length--, n.set(t.data.length);
                        }
                        s.bookmark = ai(e495.selection), n.get() < t.data.length - 1 && (t.data.length = n.get() + 1), t.data.push(s), n.set(t.data.length - 1);
                        const c = {
                            level: s,
                            lastLevel: l,
                            originalEvent: a
                        };
                        return n.get() > 0 ? (e495.setDirty(!0), e495.dispatch("AddUndo", c), e495.dispatch("change", c)) : e495.dispatch("AddUndo", c), s;
                    })(e494, t309, n181, o100, r56, s30, a24)
                ,
                undo: (t310, n182, o101)=>((e, t, n, o)=>{
                        let r;
                        return t.typing && (t.add(), t.typing = !1, wv(t, !1, n)), o.get() > 0 && (o.set(o.get() - 1), r = t.data[o.get()], bv(e, r, !0), e.setDirty(!0), e.dispatch("Undo", {
                            level: r
                        })), r;
                    })(e494, t310, n182, o101)
                ,
                redo: (t311, n183)=>((e, t, n)=>{
                        let o;
                        return t.get() < n.length - 1 && (t.set(t.get() + 1), o = n[t.get()], bv(e, o, !1), e.setDirty(!0), e.dispatch("Redo", {
                            level: o
                        })), o;
                    })(e494, t311, n183)
                ,
                clear: (t312, n184)=>((e, t, n)=>{
                        t.data = [], n.set(0), t.typing = !1, e.dispatch("ClearUndos");
                    })(e494, t312, n184)
                ,
                reset: (e496)=>((e)=>{
                        e.clear(), e.add();
                    })(e496)
                ,
                hasUndo: (t313, n185)=>((e, t, n)=>n.get() > 0 || t.typing && t.data[0] && !Cv(hv(e), t.data[0])
                    )(e494, t313, n185)
                ,
                hasRedo: (e497, t314)=>((e, t)=>t.get() < e.data.length - 1 && !e.typing
                    )(e497, t314)
                ,
                transact: (e498, t315, n186)=>((e, t, n)=>(kv(e, t), e.beforeChange(), e.ignore(n), e.add())
                    )(e498, t315, n186)
                ,
                ignore: (e499, t316)=>((e, t)=>{
                        try {
                            e.set(e.get() + 1), t();
                        } finally{
                            e.set(e.get() - 1);
                        }
                    })(e499, t316)
                ,
                extra: (t317, n187, o102, r57)=>((e, t, n, o, r)=>{
                        if (t.transact(o)) {
                            const o = t.data[n.get()].bookmark, s = t.data[n.get() - 1];
                            bv(e, s, !0), t.transact(r) && (t.data[n.get() - 1].beforeBookmark = o);
                        }
                    })(e494, t317, n187, o102, r57)
            },
            formatter: {
                match: (t, n, o, r)=>Mp(e494, t, n, o, r)
                ,
                matchAll: (t318, n188)=>((e, t, n)=>{
                        const o = [], r = {}, s31 = e.selection.getStart();
                        return e.dom.getParent(s31, (s)=>{
                            for(let a = 0; a < t.length; a++){
                                const i = t[a];
                                !r[i] && Pp(e, s, i, n) && (r[i] = !0, o.push(i));
                            }
                        }, e.dom.getRoot()), o;
                    })(e494, t318, n188)
                ,
                matchNode: (t, n, o, r)=>Pp(e494, t, n, o, r)
                ,
                canApply: (t319)=>((e, t)=>{
                        const n = e.formatter.get(t), o = e.dom;
                        if (n) {
                            const t = e.selection.getStart(), r = Kc(o, t);
                            for(let e500 = n.length - 1; e500 >= 0; e500--){
                                const t = n[e500];
                                if (!Yc(t)) return !0;
                                for(let e = r.length - 1; e >= 0; e--)if (o.is(r[e], t.selector)) return !0;
                            }
                        }
                        return !1;
                    })(e494, t319)
                ,
                closest: (t320)=>((e, t321)=>{
                        const n189 = (t)=>bn(t, mn(e.getBody()))
                        ;
                        return M1.from(e.selection.getStart(!0)).bind((o)=>Ap(mn(o), (n190)=>ce1(t321, (t322)=>((t, n)=>Pp(e, t.dom, n) ? M1.some(n) : M1.none()
                                    )(n190, t322)
                                )
                            , n189)
                        ).getOrNull();
                    })(e494, t320)
                ,
                apply: (t, n, o)=>xh(e494, t, n, o)
                ,
                remove: (t, n, o, r)=>bh(e494, t, n, o, r)
                ,
                toggle: (t323, n191, o103)=>((e, t, n, o)=>{
                        const r = e.formatter.get(t);
                        !Mp(e, t, n, o) || "toggle" in r[0] && !r[0].toggle ? xh(e, t, n, o) : bh(e, t, n, o);
                    })(e494, t323, n191, o103)
                ,
                formatChanged: (t324, n192, o104, r58, s32)=>((e501, t325, n193, o105, r59, s33)=>(null === t325.get() && ((e502, t)=>{
                            e502.set({}), t.on("NodeChange", (n)=>{
                                Eh(t, n.element, e502.get());
                            }), t.on("FormatApply FormatRemove", (n)=>{
                                const o = M1.from(n.node).map((e)=>Mc(e) ? e : e.startContainer
                                ).bind((e)=>yo(e) ? M1.some(e) : M1.from(e.parentElement)
                                ).getOrThunk(()=>kh(t)
                                );
                                Eh(t, o, e502.get());
                            });
                        })(t325, e501), ((e503, t326, n194, o, r, s)=>{
                            const a = t326.get();
                            $1(n194.split(","), (t)=>{
                                const n195 = xe1(a, t).getOrThunk(()=>{
                                    const e = {
                                        withSimilar: {
                                            state: zs(!1),
                                            similar: !0,
                                            callbacks: []
                                        },
                                        withoutSimilar: {
                                            state: zs(!1),
                                            similar: !1,
                                            callbacks: []
                                        },
                                        withVars: []
                                    };
                                    return a[t] = e, e;
                                }), i = ()=>{
                                    const n = _h(e503);
                                    return Sh(e503, n, t, r, s).isSome();
                                };
                                if (v1(s)) {
                                    const e = r ? n195.withSimilar : n195.withoutSimilar;
                                    e.callbacks.push(o), 1 === e.callbacks.length && e.state.set(i());
                                } else n195.withVars.push({
                                    state: zs(i()),
                                    similar: r,
                                    vars: s,
                                    callback: o
                                });
                            }), t326.set(a);
                        })(e501, t325, n193, o105, r59, s33), {
                            unbind: ()=>((e504, t327, n)=>{
                                    const o = e504.get();
                                    $1(t327.split(","), (e505)=>xe1(o, e505).each((t)=>{
                                            o[e505] = {
                                                withSimilar: {
                                                    ...t.withSimilar,
                                                    callbacks: K1(t.withSimilar.callbacks, (e)=>e !== n
                                                    )
                                                },
                                                withoutSimilar: {
                                                    ...t.withoutSimilar,
                                                    callbacks: K1(t.withoutSimilar.callbacks, (e)=>e !== n
                                                    )
                                                },
                                                withVars: K1(t.withVars, (e)=>e.callback !== n
                                                )
                                            };
                                        })
                                    ), e504.set(o);
                                })(t325, n193, o105)
                        })
                    )(e494, t324, n192, o104, r58, s32)
            },
            editor: {
                getContent: (t328)=>((e506, t329)=>M1.from(e506.getBody()).fold(N1("tree" === t329.format ? new yf("body", 11) : ""), (n196)=>((e507, t330, n197)=>{
                                let o106;
                                return o106 = "raw" === t330.format ? Bt.trim(kf(e507.serializer, n197.innerHTML)) : "text" === t330.format ? e507.dom.isEmpty(n197) ? "" : fr(n197.innerText || n197.textContent) : "tree" === t330.format ? e507.serializer.serialize(n197, t330) : ((e, t)=>{
                                    const n = Ti(e), o = new RegExp(`^(<${n}[^>]*>(&nbsp;|&#160;|\\s|\xa0|<br \\/>|)<\\/${n}>[\r\n]*|<br \\/>[\r\n]*)$`);
                                    return t.replace(o, "");
                                })(e507, e507.serializer.serialize(n197, t330)), "text" !== t330.format && !ir(mn(n197)) && m1(o106) ? Bt.trim(o106) : o106;
                            })(e506, t329, n196)
                        )
                    )(e494, t328)
                ,
                setContent: (t331, n198)=>((e508, t332, n199)=>M1.from(e508.getBody()).map((o107)=>_p(t332) ? ((e, t, n, o)=>{
                                up(e.parser.getNodeFilters(), e.parser.getAttributeFilters(), n);
                                const r = Rf({
                                    validate: !1
                                }, e.schema).serialize(n), s = ir(mn(t)) ? r : Bt.trim(r);
                                return Ep(e, s, o.no_selection), {
                                    content: n,
                                    html: s
                                };
                            })(e508, o107, t332, n199) : ((e, t, n, o)=>{
                                if (0 === n.length || /^\s+$/.test(n)) {
                                    const r = '<br data-mce-bogus="1">';
                                    "TABLE" === t.nodeName ? n = "<tr><td>" + r + "</td></tr>" : /^(UL|OL)$/.test(t.nodeName) && (n = "<li>" + r + "</li>");
                                    const s = Ti(e);
                                    return e.schema.isValidChild(t.nodeName.toLowerCase(), s.toLowerCase()) ? (n = r, n = e.dom.createHTML(s, Bi(e), n)) : n || (n = r), Ep(e, n, o.no_selection), {
                                        content: n,
                                        html: n
                                    };
                                }
                                {
                                    "raw" !== o.format && (n = Rf({
                                        validate: !1
                                    }, e.schema).serialize(e.parser.parse(n, {
                                        isRootContent: !0,
                                        insert: !0
                                    })));
                                    const r = ir(mn(t)) ? n : Bt.trim(n);
                                    return Ep(e, r, o.no_selection), {
                                        content: r,
                                        html: r
                                    };
                                }
                            })(e508, o107, t332, n199)
                        ).getOr({
                            content: t332,
                            html: _p(n199.content) ? "" : n199.content
                        })
                    )(e494, t331, n198)
                ,
                insertContent: (t, n)=>Sp(e494, t, n)
                ,
                addVisual: (t333)=>((e, t334)=>{
                        const n = e.dom, o108 = C1(t334) ? t334 : e.getBody();
                        v1(e.hasVisual) && (e.hasVisual = Al(e)), $1(n.select("table,a", o108), (t)=>{
                            switch(t.nodeName){
                                case "TABLE":
                                    const o = Ol(e), r = n.getAttrib(t, "border");
                                    r && "0" !== r || !e.hasVisual ? n.removeClass(t, o) : n.addClass(t, o);
                                    break;
                                case "A":
                                    if (!n.getAttrib(t, "href")) {
                                        const o = n.getAttrib(t, "name") || t.id, r = Tl(e);
                                        o && e.hasVisual ? n.addClass(t, r) : n.removeClass(t, r);
                                    }
                            }
                        }), e.dispatch("VisualAid", {
                            element: t334,
                            hasVisual: e.hasVisual
                        });
                    })(e494, t333)
            },
            selection: {
                getContent: (t335, n200)=>((e509, t336, n201 = {})=>{
                        const o109 = ((e, t)=>({
                                ...e,
                                format: t,
                                get: !0,
                                selection: !0,
                                getInner: !0
                            })
                        )(n201, t336);
                        return Gb(e509, o109).fold(R1, (t337)=>{
                            const n202 = ((e510, t338)=>{
                                if ("text" === t338.format) return ((e511)=>M1.from(e511.selection.getRng()).map((t)=>{
                                        const n = M1.from(e511.dom.getParent(t.commonAncestorContainer, e511.dom.isBlock)), o = e511.getBody(), r = ((e512)=>e512.map((e)=>e.nodeName
                                            ).getOr("div").toLowerCase()
                                        )(n), s = e511.dom.add(o, r, {
                                            "data-mce-bogus": "all",
                                            style: "overflow: hidden; opacity: 0;"
                                        }, t.cloneContents()), a = mv(s), i = fr(s.textContent);
                                        if (e511.dom.remove(s), uv(i, 0) || uv(i, i.length - 1)) {
                                            const e = n.getOr(o), t = mv(e), r = t.indexOf(a);
                                            return -1 === r ? a : (uv(t, r - 1) ? " " : "") + a + (uv(t, r + a.length) ? " " : "");
                                        }
                                        return a;
                                    }).getOr("")
                                )(e510);
                                {
                                    const n203 = ((e, t)=>{
                                        const n = e.selection.getRng(), o = e.dom.create("body"), r = e.selection.getSel(), s = df(e, gu(r)), a = t.contextual ? cv(mn(e.getBody()), s).dom : n.cloneContents();
                                        return a && o.appendChild(a), e.selection.serializer.serialize(o, t);
                                    })(e510, t338);
                                    return "tree" === t338.format ? n203 : e510.selection.isCollapsed() ? "" : n203;
                                }
                            })(e509, t337);
                            return Yb(e509, n202, t337);
                        });
                    })(e494, t335, n200)
            },
            autocompleter: {
                addDecoration: (t)=>ff(e494, t)
                ,
                removeDecoration: ()=>((e, t339)=>gf(t339).each((t)=>{
                            const n = e.selection.getBookmark();
                            no(t), e.selection.moveToBookmark(n);
                        })
                    )(e494, mn(e494.getBody()))
            },
            raw: {
                getModel: ()=>M1.none()
            }
        })
    , _v = (e)=>we1(e.plugins, "rtc")
    , Ev = (e)=>e.rtcInstance ? e.rtcInstance : Sv(e)
    , Nv = (e)=>{
        const t = e.rtcInstance;
        if (t) return t;
        throw new Error("Failed to get RTC instance not yet initialized.");
    }, Rv = (e)=>Nv(e).init.bindEvents()
    , Av = (e)=>0 === e.dom.length ? (to(e), M1.none()) : M1.some(e)
    , Ov = (e513, t340, n205, o110)=>{
        e513.bind((e514)=>((o110 ? _g : Sg)(e514.dom, o110 ? e514.dom.length : 0), t340.filter(zt).map((t341)=>((e, t, n, o)=>{
                    const r = e.dom, s = t.dom, a = o ? r.length : s.length;
                    o ? (Eg(r, s, !1, !o), n.setStart(s, a)) : (Eg(s, r, !1, !o), n.setEnd(s, a));
                })(e514, t341, n205, o110)
            ))
        ).orThunk(()=>{
            const e515 = ((e516, t)=>e516.filter((e)=>Tu.isBookmarkNode(e.dom)
                ).bind(t ? Sn : kn)
            )(t340, o110).or(t340).filter(zt);
            return e515.map((e517)=>((e, t)=>{
                    wn(e).each((n)=>{
                        const o = e.dom;
                        t && bg(n, Ua(o, 0)) ? Sg(o, 0) : !t && vg(n, Ua(o, o.length)) && _g(o, o.length);
                    });
                })(e517, o110)
            );
        });
    }, Tv = (e518, t, n)=>{
        if (e518 && we1(e518, t)) {
            const o = K1(e518[t], (e)=>e !== n
            );
            0 === o.length ? delete e518[t] : e518[t] = o;
        }
    }, Bv = (e)=>!(!e || !e.ownerDocument) && vn(mn(e.ownerDocument), mn(e))
    , Dv = (e519, t342, n206, o111)=>{
        let r60, s34;
        const { selectorChangedWithUnbind: a25  } = ((e520, t343)=>{
            let n207, o;
            const r = (t, n208)=>Q1(n208, (n)=>e520.is(n, t)
                )
            , s = (t)=>e520.getParents(t, null, e520.getRoot())
            ;
            return {
                selectorChangedWithUnbind: (e521, a26)=>(n207 || (n207 = {}, o = {}, t343.on("NodeChange", (e522)=>{
                        const t344 = e522.element, a = s(t344), i = {};
                        Bt.each(n207, (e523, t)=>{
                            r(t, a).each((n)=>{
                                o[t] || ($1(e523, (e)=>{
                                    e(!0, {
                                        node: n,
                                        selector: t,
                                        parents: a
                                    });
                                }), o[t] = e523), i[t] = e523;
                            });
                        }), Bt.each(o, (e524, n)=>{
                            i[n] || (delete o[n], Bt.each(e524, (e)=>{
                                e(!1, {
                                    node: t344,
                                    selector: n,
                                    parents: a
                                });
                            }));
                        });
                    })), n207[e521] || (n207[e521] = []), n207[e521].push(a26), r(e521, s(t343.selection.getStart())).each(()=>{
                        o[e521] = n207[e521];
                    }), {
                        unbind: ()=>{
                            Tv(n207, e521, a26), Tv(o, e521, a26);
                        }
                    })
            };
        })(e519, o111), i18 = (e525, t345)=>((e526, t346, n209 = {})=>{
                const o112 = ((e, t)=>({
                        format: "html",
                        ...e,
                        set: !0,
                        selection: !0,
                        content: t
                    })
                )(n209, t346);
                Xb(e526, o112).each((t347)=>{
                    const n210 = ((e, t)=>{
                        if ("raw" !== t.format) {
                            const n = e.selection.getRng(), o = e.dom.getParent(n.commonAncestorContainer, e.dom.isBlock), r = o ? {
                                context: o.nodeName.toLowerCase()
                            } : {}, s = e.parser.parse(t.content, {
                                forced_root_block: !1,
                                ...r,
                                ...t
                            });
                            return Rf({
                                validate: !1
                            }, e.schema).serialize(s);
                        }
                        return t.content;
                    })(e526, t347), o113 = e526.selection.getRng();
                    ((e, t)=>{
                        const n = M1.from(t.firstChild).map(mn), o = M1.from(t.lastChild).map(mn);
                        e.deleteContents(), e.insertNode(t);
                        const r = n.bind(kn).filter(zt).bind(Av), s = o.bind(Sn).filter(zt).bind(Av);
                        Ov(r, n, e, !0), Ov(s, o, e, !1), e.collapse(!1);
                    })(o113, o113.createContextualFragment(n210)), e526.selection.setRng(o113), Pm(e526, o113), Qb(e526, n210, t347);
                });
            })(o111, e525, t345)
        , l18 = (e)=>{
            const t = c8();
            t.collapse(!!e), u(t);
        }, d = ()=>t342.getSelection ? t342.getSelection() : t342.document.selection
        , c8 = ()=>{
            let n211, a, i;
            const l = (e, t, n)=>{
                try {
                    return t.compareBoundaryPoints(e, n);
                } catch (e527) {
                    return -1;
                }
            }, c = t342.document;
            if (void 0 !== o111.bookmark && !1 === nf(o111)) {
                const e528 = Wm(o111);
                if (e528.isSome()) return e528.map((e)=>df(o111, [
                        e
                    ])[0]
                ).getOr(c.createRange());
            }
            try {
                (n211 = d()) && !vo(n211.anchorNode) && (a = n211.rangeCount > 0 ? n211.getRangeAt(0) : n211.createRange ? n211.createRange() : c.createRange(), a = df(o111, [
                    a
                ])[0]);
            } catch (e) {}
            return a || (a = c.createRange()), a.setStart && 9 === a.startContainer.nodeType && a.collapsed && (i = e519.getRoot(), a.setStart(i, 0), a.setEnd(i, 0)), r60 && s34 && (0 === l(a.START_TO_START, a, r60) && 0 === l(a.END_TO_END, a, r60) ? a = s34 : (r60 = null, s34 = null)), a;
        }, u = (e530, t)=>{
            let n;
            if (!((e)=>!!e && Bv(e.startContainer) && Bv(e.endContainer)
            )(e530)) return;
            const a = d();
            if (e530 = o111.dispatch("SetSelectionRange", {
                range: e530,
                forward: t
            }).range, a) {
                s34 = e530;
                try {
                    a.removeAllRanges(), a.addRange(e530);
                } catch (e) {}
                !1 === t && a.extend && (a.collapse(e530.endContainer, e530.endOffset), a.extend(e530.startContainer, e530.startOffset)), r60 = a.rangeCount > 0 ? a.getRangeAt(0) : null;
            }
            !e530.collapsed && e530.startContainer === e530.endContainer && a.setBaseAndExtent && e530.endOffset - e530.startOffset < 2 && e530.startContainer.hasChildNodes() && (n = e530.startContainer.childNodes[e530.startOffset], n && "IMG" === n.tagName && (a.setBaseAndExtent(e530.startContainer, e530.startOffset, e530.endContainer, e530.endOffset), a.anchorNode === e530.startContainer && a.focusNode === e530.endContainer || a.setBaseAndExtent(n, 0, n, 1))), o111.dispatch("AfterSetSelectionRange", {
                range: e530,
                forward: t
            });
        }, m = ()=>{
            const t = d(), n = null == t ? void 0 : t.anchorNode, o = null == t ? void 0 : t.focusNode;
            if (!t || !n || !o || vo(n) || vo(o)) return !0;
            const r = e519.createRng();
            r.setStart(n, t.anchorOffset), r.collapse(!0);
            const s = e519.createRng();
            return s.setStart(o, t.focusOffset), s.collapse(!0), r.compareBoundaryPoints(r.START_TO_START, s) <= 0;
        }, f = {
            bookmarkManager: null,
            controlSelection: null,
            dom: e519,
            win: t342,
            serializer: n206,
            editor: o111,
            collapse: l18,
            setCursorLocation: (t, n)=>{
                const r = e519.createRng();
                C1(t) && C1(n) ? (r.setStart(t, n), r.setEnd(t, n), u(r), l18(!1)) : (xu(e519, r, o111.getBody(), !0), u(r));
            },
            getContent: (e531)=>((e532, t348 = {})=>((e, t, n)=>Nv(e).selection.getContent(t, n)
                    )(e532, t348.format ? t348.format : "html", t348)
                )(o111, e531)
            ,
            setContent: i18,
            getBookmark: (e, t)=>g.getBookmark(e, t)
            ,
            moveToBookmark: (e)=>g.moveToBookmark(e)
            ,
            select: (t349, n212)=>(((e, t350, n)=>M1.from(t350).map((t)=>{
                        const o = e.nodeIndex(t), r = e.createRng();
                        return r.setStart(t.parentNode, o), r.setEnd(t.parentNode, o + 1), n && (xu(e, r, t, !0), xu(e, r, t, !1)), r;
                    })
                )(e519, t349, n212).each(u), t349)
            ,
            isCollapsed: ()=>{
                const e = c8(), t = d();
                return !(!e || e.item) && (e.compareEndPoints ? 0 === e.compareEndPoints("StartToEnd", e) : !t || e.collapsed);
            },
            isForward: m,
            setNode: (t)=>(i18(e519.getOuterHTML(t)), t)
            ,
            getNode: ()=>((e, t)=>{
                    let n, o, r;
                    if (!t) return e;
                    o = t.startContainer, r = t.endContainer;
                    const s = t.startOffset, a = t.endOffset;
                    return n = t.commonAncestorContainer, !t.collapsed && (o === r && a - s < 2 && o.hasChildNodes() && (n = o.childNodes[s]), 3 === o.nodeType && 3 === r.nodeType && (o = o.length === s ? lf(o.nextSibling, !0) : o.parentNode, r = 0 === a ? lf(r.previousSibling, !1) : r.parentNode, o && o === r)) ? o : n && 3 === n.nodeType ? n.parentNode : n;
                })(o111.getBody(), c8())
            ,
            getSel: d,
            setRng: u,
            getRng: c8,
            getStart: (e)=>sf(o111.getBody(), c8(), e)
            ,
            getEnd: (e)=>af(o111.getBody(), c8(), e)
            ,
            getSelectedBlocks: (t351, n213)=>((e, t, n, o)=>{
                    let r;
                    const s = [], a = e.getRoot();
                    if (n = e.getParent(n || sf(a, t, t.collapsed), e.isBlock), o = e.getParent(o || af(a, t, t.collapsed), e.isBlock), n && n !== a && s.push(n), n && o && n !== o) {
                        r = n;
                        const t = new Xo(n, a);
                        for(; (r = t.next()) && r !== o;)e.isBlock(r) && s.push(r);
                    }
                    return o && n !== o && o !== a && s.push(o), s;
                })(e519, c8(), t351, n213)
            ,
            normalize: ()=>{
                const t = c8(), n = d();
                if (!(gu(n).length > 1) && wu(o111)) {
                    const n = mm(e519, t);
                    return n.each((e)=>{
                        u(e, m());
                    }), n.getOr(t);
                }
                return t;
            },
            selectorChanged: (e, t)=>(a25(e, t), f)
            ,
            selectorChangedWithUnbind: a25,
            getScrollContainer: ()=>{
                let t, n = e519.getRoot();
                for(; n && "BODY" !== n.nodeName;){
                    if (n.scrollHeight > n.clientHeight) {
                        t = n;
                        break;
                    }
                    n = n.parentNode;
                }
                return t;
            },
            scrollIntoView: (e533, t352)=>{
                C1(e533) ? ((e, t, n)=>{
                    (e.inline ? Bm : Lm)(e, t, n);
                })(o111, e533, t352) : Pm(o111, c8(), t352);
            },
            placeCaretAt: (e, t)=>u(nm(e, t, o111.getDoc()))
            ,
            getBoundingClientRect: ()=>{
                const e = c8();
                return e.collapsed ? Ua.fromRangeStart(e).getClientRects()[0] : e.getBoundingClientRect();
            },
            destroy: ()=>{
                t342 = r60 = s34 = null, p.destroy();
            }
        }, g = Tu(f), p = zu(f, o111);
        return f.bookmarkManager = g, f.controlSelection = p, f;
    }, Lv = (e534, t353, n214)=>{
        -1 === Bt.inArray(t353, n214) && (e534.addAttributeFilter(n214, (e, t)=>{
            let n = e.length;
            for(; n--;)e[n].attr(t, null);
        }), t353.push(n214));
    }, Pv = (e535, t354)=>{
        const n215 = [
            "data-mce-selected"
        ], o114 = t354 && t354.dom ? t354.dom : Is.DOM, r61 = t354 && t354.schema ? t354.schema : vs(e535);
        e535.entity_encoding = e535.entity_encoding || "named", e535.remove_trailing_brs = !("remove_trailing_brs" in e535) || e535.remove_trailing_brs;
        const s35 = Wb(e535, r61);
        return ((e536, t355, n216)=>{
            e536.addAttributeFilter("data-mce-tabindex", (e, t)=>{
                let n = e.length;
                for(; n--;){
                    const o = e[n];
                    o.attr("tabindex", o.attr("data-mce-tabindex")), o.attr(t, null);
                }
            }), e536.addAttributeFilter("src,href,style", (e, o)=>{
                const r = "data-mce-" + o, s = t355.url_converter, a = t355.url_converter_scope;
                let i = e.length;
                for(; i--;){
                    const t = e[i];
                    let l = t.attr(r);
                    void 0 !== l ? (t.attr(o, l.length > 0 ? l : null), t.attr(r, null)) : (l = t.attr(o), "style" === o ? l = n216.serializeStyle(n216.parseStyle(l), t.name) : s && (l = s.call(a, l, o, t.name)), t.attr(o, l.length > 0 ? l : null));
                }
            }), e536.addAttributeFilter("class", (e)=>{
                let t = e.length;
                for(; t--;){
                    const n = e[t];
                    let o = n.attr("class");
                    o && (o = n.attr("class").replace(/(?:^|\s)mce-item-\w+(?!\S)/g, ""), n.attr("class", o.length > 0 ? o : null));
                }
            }), e536.addAttributeFilter("data-mce-type", (e, t, n)=>{
                let o = e.length;
                for(; o--;){
                    const t = e[o];
                    if ("bookmark" === t.attr("data-mce-type") && !n.cleanup) {
                        const e537 = M1.from(t.firstChild).exists((e)=>!mr(e.value)
                        );
                        e537 ? t.unwrap() : t.remove();
                    }
                }
            }), e536.addNodeFilter("noscript", (e)=>{
                let t = e.length;
                for(; t--;){
                    const n = e[t].firstChild;
                    n && (n.value = ls.decode(n.value));
                }
            }), e536.addNodeFilter("script,style", (e539, n)=>{
                const o = (e)=>e.replace(/(<!--\[CDATA\[|\]\]-->)/g, "\n").replace(/^[\r\n]*|[\r\n]*$/g, "").replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, "").replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, "")
                ;
                let r = e539.length;
                for(; r--;){
                    const s = e539[r], a = s.firstChild ? s.firstChild.value : "";
                    if ("script" === n) {
                        const e = s.attr("type");
                        e && s.attr("type", "mce-no/type" === e ? null : e.replace(/^mce\-/, "")), "xhtml" === t355.element_format && a.length > 0 && (s.firstChild.value = "// <![CDATA[\n" + o(a) + "\n// ]]>");
                    } else "xhtml" === t355.element_format && a.length > 0 && (s.firstChild.value = "\x3c!--\n" + o(a) + "\n--\x3e");
                }
            }), e536.addNodeFilter("#comment", (e)=>{
                let o = e.length;
                for(; o--;){
                    const r = e[o];
                    t355.preserve_cdata && 0 === r.value.indexOf("[CDATA[") ? (r.name = "#cdata", r.type = 4, r.value = n216.decode(r.value.replace(/^\[CDATA\[|\]\]$/g, ""))) : 0 === r.value.indexOf("mce:protected ") && (r.name = "#text", r.type = 3, r.raw = !0, r.value = unescape(r.value).substr(14));
                }
            }), e536.addNodeFilter("xml:namespace,input", (e, t)=>{
                let n = e.length;
                for(; n--;){
                    const o = e[n];
                    7 === o.type ? o.remove() : 1 === o.type && ("input" !== t || o.attr("type") || o.attr("type", "text"));
                }
            }), e536.addAttributeFilter("data-mce-type", (t356)=>{
                $1(t356, (t)=>{
                    "format-caret" === t.attr("data-mce-type") && (t.isEmpty(e536.schema.getNonEmptyElements()) ? t.remove() : t.unwrap());
                });
            }), e536.addAttributeFilter("data-mce-src,data-mce-href,data-mce-style,data-mce-selected,data-mce-expando,data-mce-type,data-mce-resize,data-mce-placeholder", (e, t)=>{
                let n = e.length;
                for(; n--;)e[n].attr(t, null);
            });
        })(s35, e535, o114), {
            schema: r61,
            addNodeFilter: s35.addNodeFilter,
            addAttributeFilter: s35.addAttributeFilter,
            serialize: (n217, a27 = {})=>{
                const i = {
                    format: "html",
                    ...a27
                }, l = ((e540, t357, n218)=>((e, t)=>e && e.hasEventListeners("PreProcess") && !t.no_events
                    )(e540, n218) ? ((e541, t358, n)=>{
                        let o;
                        const r = e541.dom;
                        let s = t358.cloneNode(!0);
                        const a = document.implementation;
                        if (a.createHTMLDocument) {
                            const e = a.createHTMLDocument("");
                            Bt.each("BODY" === s.nodeName ? s.childNodes : [
                                s
                            ], (t)=>{
                                e.body.appendChild(e.importNode(t, !0));
                            }), s = "BODY" !== s.nodeName ? e.body.firstChild : e.body, o = r.doc, r.doc = e;
                        }
                        return ((e, t)=>{
                            e.dispatch("PreProcess", t);
                        })(e541, {
                            ...n,
                            node: s
                        }), o && (r.doc = o), s;
                    })(e540, t357, n218) : t357
                )(t354, n217, i), d = ((e, t, n)=>{
                    const o = fr(n.getInner ? t.innerHTML : e.getOuterHTML(t));
                    return n.selection || ir(mn(t)) ? o : Bt.trim(o);
                })(o114, l, i), c = ((e542, t359, n219)=>{
                    const o = n219.selection ? {
                        forced_root_block: !1,
                        ...n219
                    } : n219, r = e542.parse(t359, o);
                    return ((e543)=>{
                        const t = (e)=>e && "br" === e.name
                        , n = e543.lastChild;
                        if (t(n)) {
                            const e = n.prev;
                            t(e) && (n.remove(), e.remove());
                        }
                    })(r), r;
                })(s35, d, i);
                return "tree" === i.format ? c : ((e544, t360, n220, o115, r)=>{
                    const s = ((e, t, n)=>Rf(e, t).serialize(n)
                    )(t360, n220, o115);
                    return ((e545, t361, n)=>{
                        if (!t361.no_events && e545) {
                            const o = ((e, t)=>e.dispatch("PostProcess", t)
                            )(e545, {
                                ...t361,
                                content: n
                            });
                            return o.content;
                        }
                        return n;
                    })(e544, r, s);
                })(t354, e535, r61, c, i);
            },
            addRules: r61.addValidElements,
            setRules: r61.setValidElements,
            addTempAttr: O1(Lv, s35, n215),
            getTempAttrs: N1(n215),
            getNodeFilters: s35.getNodeFilters,
            getAttributeFilters: s35.getAttributeFilters
        };
    }, Mv = (e, t)=>{
        const n = Pv(e, t);
        return {
            schema: n.schema,
            addNodeFilter: n.addNodeFilter,
            addAttributeFilter: n.addAttributeFilter,
            serialize: n.serialize,
            addRules: n.addRules,
            setRules: n.setRules,
            addTempAttr: n.addTempAttr,
            getTempAttrs: n.getTempAttrs,
            getNodeFilters: n.getNodeFilters,
            getAttributeFilters: n.getAttributeFilters
        };
    }, Iv = (e546, t362, n221 = {})=>{
        const o = ((e, t)=>({
                format: "html",
                ...e,
                set: !0,
                content: t
            })
        )(n221, t362);
        return Xb(e546, o).map((t363)=>{
            const n222 = ((e, t, n)=>Ev(e).editor.setContent(t, n)
            )(e546, t363.content, t363);
            return Qb(e546, n222.html, t363), n222.content;
        }).getOr(t362);
    }, Fv = "autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists".split(","), Uv = "bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor".split(","), zv = (e)=>{
        const t364 = K1(Fv, (t)=>we1(e, t)
        ), n = e.forced_root_block;
        return !1 !== n && "" !== n || t364.push("forced_root_block (false only)"), se1(t364);
    }, jv = (e547)=>{
        const t = Bt.makeMap(e547.plugins, " "), n = K1(Uv, (e)=>we1(t, e)
        );
        return se1(n);
    }, Vv = Is.DOM, Hv = (e548)=>M1.from(e548).each((e)=>e.destroy()
        )
    , $v = (()=>{
        const e = {};
        return {
            add: (t, n)=>{
                e[t] = n;
            },
            get: (t)=>e[t] ? e[t] : {
                    icons: {}
                }
            ,
            has: (t)=>we1(e, t)
        };
    })(), qv = qs.ModelManager, Wv = (e, t)=>t.dom[e]
    , Kv = (e, t)=>parseInt($n(t, e), 10)
    , Gv = O1(Wv, "clientWidth"), Yv = O1(Wv, "clientHeight"), Xv = O1(Kv, "margin-top"), Qv = O1(Kv, "margin-left"), Jv = (e549)=>{
        const t365 = [], n = ()=>{
            const t = e549.theme;
            return t && t.getNotificationManagerImpl ? t.getNotificationManagerImpl() : (()=>{
                const e = ()=>{
                    throw new Error("Theme did not provide a NotificationManager implementation.");
                };
                return {
                    open: e,
                    close: e,
                    getArgs: e
                };
            })();
        }, o116 = ()=>M1.from(t365[0])
        , r = ()=>{
            $1(t365, (e)=>{
                e.reposition();
            });
        }, s = (e550)=>{
            J1(t365, (t)=>t === e550
            ).each((e)=>{
                t365.splice(e, 1);
            });
        }, a28 = (a, i20 = !0)=>{
            if (!e549.removed && ((e)=>{
                var t;
                return (t = e.inline ? e.getBody() : e.getContentAreaContainer(), M1.from(t).map(mn)).map(zn).getOr(!1);
            })(e549)) return i20 && e549.dispatch("BeforeOpenNotification", {
                notification: a
            }), Q1(t365, (e)=>{
                var t, o;
                return t = n().getArgs(e), o = a, !(t.type !== o.type || t.text !== o.text || t.progressBar || t.timeout || o.progressBar || o.timeout);
            }).getOrThunk(()=>{
                e549.editorManager.setActive(e549);
                const i = n().open(a, ()=>{
                    s(i), r(), o116().fold(()=>e549.focus()
                    , (e)=>Mm(mn(e.getEl()))
                    );
                });
                return ((e)=>{
                    t365.push(e);
                })(i), r(), e549.dispatch("OpenNotification", {
                    notification: {
                        ...i
                    }
                }), i;
            });
        }, i19 = N1(t365);
        return ((e551)=>{
            e551.on("SkinLoaded", ()=>{
                const t = il(e551);
                t && a28({
                    text: t,
                    type: "warning",
                    timeout: 0
                }, !1), r();
            }), e551.on("show ResizeEditor ResizeWindow NodeChange", ()=>{
                requestAnimationFrame(r);
            }), e551.on("remove", ()=>{
                $1(t365.slice(), (e)=>{
                    n().close(e);
                });
            });
        })(e549), {
            open: a28,
            close: ()=>{
                o116().each((e)=>{
                    n().close(e), s(e), r();
                });
            },
            getNotifications: i19
        };
    }, Zv = qs.PluginManager, ey = qs.ThemeManager, ty = (e552)=>{
        let t366 = [];
        const n223 = ()=>{
            const t = e552.theme;
            return t && t.getWindowManagerImpl ? t.getWindowManagerImpl() : (()=>{
                const e = ()=>{
                    throw new Error("Theme did not provide a WindowManager implementation.");
                };
                return {
                    open: e,
                    openUrl: e,
                    alert: e,
                    confirm: e,
                    close: e,
                    getParams: e,
                    setParams: e
                };
            })();
        }, o117 = (e, t)=>(...n)=>t ? t.apply(e, n) : void 0
        , r62 = (n)=>{
            ((t)=>{
                e552.dispatch("CloseWindow", {
                    dialog: t
                });
            })(n), t366 = K1(t366, (e)=>e !== n
            ), 0 === t366.length && e552.focus();
        }, s36 = (n224)=>{
            e552.editorManager.setActive(e552), qm(e552), e552.ui.show();
            const o = n224();
            return ((n)=>{
                t366.push(n), ((t)=>{
                    e552.dispatch("OpenWindow", {
                        dialog: t
                    });
                })(n);
            })(o), o;
        };
        return e552.on("remove", ()=>{
            $1(t366, (e)=>{
                n223().close(e);
            });
        }), {
            open: (e, t)=>s36(()=>n223().open(e, t, r62)
                )
            ,
            openUrl: (e)=>s36(()=>n223().openUrl(e, r62)
                )
            ,
            alert: (e, t, r)=>{
                const s = n223();
                s.alert(e, o117(r || s, t));
            },
            confirm: (e, t, r)=>{
                const s = n223();
                s.confirm(e, o117(r || s, t));
            },
            close: ()=>{
                M1.from(t366[t366.length - 1]).each((e)=>{
                    n223().close(e), r62(e);
                });
            }
        };
    }, ny = (e, t)=>{
        e.notificationManager.open({
            type: "error",
            text: t
        });
    }, oy = (e, t)=>{
        e._skinLoaded ? ny(e, t) : e.on("SkinLoaded", ()=>{
            ny(e, t);
        });
    }, ry = (e, t, n)=>{
        Du(e, t, {
            message: n
        }), console.error(n);
    }, sy = (e, t, n)=>n ? `Failed to load ${e}: ${n} from url ${t}` : `Failed to load ${e} url: ${t}`
    , ay = (e, ...t)=>{
        const n = window.console;
        n && (n.error ? n.error(e, ...t) : n.log(e, ...t));
    }, iy = (e553, t367)=>{
        const n = e553.editorManager.baseURL + "/skins/content", o = `content${e553.editorManager.suffix}.css`, r = !0 === e553.inline;
        return H1(t367, (t)=>((e)=>/^[a-z0-9\-]+$/i.test(e)
            )(t) && !r ? `${n}/${t}/${o}` : e553.documentBaseURI.toAbsolute(t)
        );
    }, ly = P1, dy = ()=>{
        let e554 = {};
        const t368 = (e, t)=>({
                status: e,
                resultUri: t
            })
        , n225 = (t)=>t in e554
        ;
        return {
            hasBlobUri: n225,
            getResultUri: (t)=>{
                const n = e554[t];
                return n ? n.resultUri : null;
            },
            isPending: (t)=>!!n225(t) && 1 === e554[t].status
            ,
            isUploaded: (t)=>!!n225(t) && 2 === e554[t].status
            ,
            markPending: (n)=>{
                e554[n] = t368(1, null);
            },
            markUploaded: (n, o)=>{
                e554[n] = t368(2, o);
            },
            removeFailed: (t)=>{
                delete e554[t];
            },
            destroy: ()=>{
                e554 = {};
            }
        };
    };
    let cy = 0;
    const uy = (e555, t369)=>{
        const n226 = {}, o118 = (e556, n227)=>new Promise((o, r)=>{
                const s = new XMLHttpRequest;
                s.open("POST", t369.url), s.withCredentials = t369.credentials, s.upload.onprogress = (e)=>{
                    n227(e.loaded / e.total * 100);
                }, s.onerror = ()=>{
                    r("Image upload failed due to a XHR Transport error. Code: " + s.status);
                }, s.onload = ()=>{
                    if (s.status < 200 || s.status >= 300) return void r("HTTP Error: " + s.status);
                    const e = JSON.parse(s.responseText);
                    var n, a;
                    e && m1(e.location) ? o((n = t369.basePath, a = e.location, n ? n.replace(/\/$/, "") + "/" + a.replace(/^\//, "") : a)) : r("Invalid JSON: " + s.responseText);
                };
                const a30 = new FormData;
                a30.append("file", e556.blob(), e556.filename()), s.send(a30);
            })
        , r63 = (e, t)=>({
                url: t,
                blobInfo: e,
                status: !0
            })
        , s37 = (e, t)=>({
                url: "",
                blobInfo: e,
                status: !1,
                error: t
            })
        , a29 = (e557, t)=>{
            Bt.each(n226[e557], (e)=>{
                e(t);
            }), delete n226[e557];
        };
        return !1 === x1(t369.handler) && (t369.handler = o118), {
            upload: (i21, l19)=>t369.url || t369.handler !== o118 ? ((o119, i22)=>(o119 = Bt.grep(o119, (t)=>!e555.isUploaded(t.blobUri())
                    ), Promise.all(Bt.map(o119, (o120)=>e555.isPending(o120.blobUri()) ? ((e558)=>{
                            const t = e558.blobUri();
                            return new Promise((e)=>{
                                n226[t] = n226[t] || [], n226[t].push(e);
                            });
                        })(o120) : ((t370, n228, o)=>(e555.markPending(t370.blobUri()), new Promise((i)=>{
                                let l, d;
                                try {
                                    const c = ()=>{
                                        l && (l.close(), d = S1);
                                    }, u = (n)=>{
                                        c(), e555.markUploaded(t370.blobUri(), n), a29(t370.blobUri(), r63(t370, n)), i(r63(t370, n));
                                    }, f = (n)=>{
                                        c(), e555.removeFailed(t370.blobUri()), a29(t370.blobUri(), s37(t370, n)), i(s37(t370, n));
                                    };
                                    d = (e)=>{
                                        e < 0 || e > 100 || M1.from(l).orThunk(()=>M1.from(o).map(B1)
                                        ).each((t)=>{
                                            l = t, t.progressBar.value(e);
                                        });
                                    }, n228(t370, d).then(u, (e)=>{
                                        f(m1(e) ? {
                                            message: e
                                        } : e);
                                    });
                                } catch (e) {
                                    i(s37(t370, e));
                                }
                            }))
                        )(o120, t369.handler, i22)
                    )))
                )(i21, l19) : new Promise((e)=>{
                    e([]);
                })
        };
    }, my = (e)=>()=>e.notificationManager.open({
                text: e.translate("Image uploading..."),
                type: "info",
                timeout: -1,
                progressBar: !0
            })
    , fy = (e, t)=>uy(t, {
            url: Vi(e),
            basePath: Hi(e),
            credentials: $i(e),
            handler: qi(e)
        })
    , gy = (e559)=>{
        const t371 = (()=>{
            let e560 = [];
            const t372 = (e561)=>{
                if (!e561.blob || !e561.base64) throw new Error("blob and base64 representations of the image are required for BlobInfo to be created");
                const t = e561.id || "blobid" + cy++ + (()=>{
                    const e = ()=>Math.round(4294967295 * Math.random()).toString(36)
                    ;
                    return "s" + (new Date).getTime().toString(36) + e() + e() + e();
                })(), n = e561.name || t, o = e561.blob;
                var r;
                return {
                    id: N1(t),
                    name: N1(n),
                    filename: N1(e561.filename || n + "." + (r = o.type, ({
                        "image/jpeg": "jpg",
                        "image/jpg": "jpg",
                        "image/gif": "gif",
                        "image/png": "png",
                        "image/apng": "apng",
                        "image/avif": "avif",
                        "image/svg+xml": "svg",
                        "image/webp": "webp",
                        "image/bmp": "bmp",
                        "image/tiff": "tiff"
                    })[r.toLowerCase()] || "dat")),
                    blob: N1(o),
                    base64: N1(e561.base64),
                    blobUri: N1(e561.blobUri || URL.createObjectURL(o)),
                    uri: N1(e561.uri)
                };
            }, n230 = (t)=>Q1(e560, t).getOrUndefined()
            , o122 = (e)=>n230((t)=>t.id() === e
                )
            ;
            return {
                create: (e, n, o, r, s)=>{
                    if (m1(e)) return t372({
                        id: e,
                        name: r,
                        filename: s,
                        blob: n,
                        base64: o
                    });
                    if (f1(e)) return t372(e);
                    throw new Error("Unknown input type");
                },
                add: (t)=>{
                    o122(t.id()) || e560.push(t);
                },
                get: o122,
                getByUri: (e)=>n230((t)=>t.blobUri() === e
                    )
                ,
                getByData: (e, t)=>n230((n)=>n.base64() === e && n.blob().type === t
                    )
                ,
                findFirst: n230,
                removeByUri: (t)=>{
                    e560 = K1(e560, (e)=>e.blobUri() !== t || (URL.revokeObjectURL(e.blobUri()), !1)
                    );
                },
                destroy: ()=>{
                    $1(e560, (e)=>{
                        URL.revokeObjectURL(e.blobUri());
                    }), e560 = [];
                }
            };
        })();
        let n229, o121;
        const r64 = dy(), s38 = [], a31 = ((e562)=>{
            const t373 = zs(null);
            return e562.on("change AddUndo", (e)=>{
                t373.set({
                    ...e.level
                });
            }), {
                fireIfChanged: ()=>{
                    const n = e562.undoManager.data;
                    le1(n).filter((e)=>!Cv(t373.get(), e)
                    ).each((t)=>{
                        e562.setDirty(!0), e562.dispatch("change", {
                            level: t,
                            lastLevel: ae1(n, n.length - 2).getOrNull()
                        });
                    });
                }
            };
        })(e559), i23 = (t)=>(n)=>e559.selection ? t(n) : []
        , l20 = (e, t, n)=>{
            let o = 0;
            do o = e.indexOf(t, o), -1 !== o && (e = e.substring(0, o) + n + e.substr(o + t.length), o += n.length - t.length + 1);
            while (-1 !== o)
            return e;
        }, d = (e, t, n)=>{
            const o = `src="${n}"${n === Nt.transparentSrc ? ' data-mce-placeholder="1"' : ""}`;
            return e = l20(e, `src="${t}"`, o), l20(e, 'data-mce-src="' + t + '"', 'data-mce-src="' + n + '"');
        }, c = (t, n)=>{
            $1(e559.undoManager.data, (e563)=>{
                "fragmented" === e563.type ? e563.fragments = H1(e563.fragments, (e)=>d(e, t, n)
                ) : e563.content = d(e563.content, t, n);
            });
        }, u = ()=>(n229 || (n229 = fy(e559, r64)), h().then(i23((o123)=>{
                const r65 = H1(o123, (e)=>e.blobInfo
                );
                return n229.upload(r65, my(e559)).then(i23((n231)=>{
                    const r66 = [], s39 = H1(n231, (n232, s)=>{
                        const a = o123[s].blobInfo, i = o123[s].image;
                        let l = !1;
                        return n232.status && Ui(e559) ? (t371.removeByUri(i.src), _v(e559) || ((t, n)=>{
                            const o = e559.convertURL(n, "src");
                            var r;
                            c(t.src, n), qt(mn(t), {
                                src: Fi(e559) ? (r = n, r + (-1 === r.indexOf("?") ? "?" : "&") + (new Date).getTime()) : n,
                                "data-mce-src": o
                            });
                        })(i, n232.url)) : n232.error && (n232.error.remove && (c(i.getAttribute("src"), Nt.transparentSrc), r66.push(i), l = !0), ((e, t)=>{
                            oy(e, $s.translate([
                                "Failed to upload image: {0}",
                                t
                            ]));
                        })(e559, n232.error.message)), {
                            element: i,
                            status: n232.status,
                            uploadUri: n232.url,
                            blobInfo: a,
                            removed: l
                        };
                    });
                    return s39.length > 0 && a31.fireIfChanged(), r66.length > 0 && !_v(e559) && e559.undoManager.transact(()=>{
                        $1(r66, (n)=>{
                            e559.dom.remove(n), t371.removeByUri(n.src);
                        });
                    }), s39;
                }));
            })))
        , g = ()=>Ii(e559) ? u() : Promise.resolve([])
        , p = (e)=>te1(s38, (t)=>t(e)
            )
        , h = ()=>(o121 || (o121 = ((e564, t374)=>{
                const n233 = {};
                return {
                    findAll: (o124, r67)=>{
                        r67 || (r67 = P1);
                        const s40 = K1(((e)=>e ? de1(e.getElementsByTagName("img")) : []
                        )(o124), (t)=>{
                            const n = t.src;
                            return !t.hasAttribute("data-mce-bogus") && !t.hasAttribute("data-mce-placeholder") && !(!n || n === Nt.transparentSrc) && (0 === n.indexOf("blob:") ? !e564.isUploaded(n) && r67(t) : 0 === n.indexOf("data:") && r67(t));
                        }), a32 = H1(s40, (e565)=>{
                            if (void 0 !== n233[e565.src]) return new Promise((t)=>{
                                n233[e565.src].then((n)=>{
                                    if ("string" == typeof n) return n;
                                    t({
                                        image: e565,
                                        blobInfo: n.blobInfo
                                    });
                                });
                            });
                            const o125 = new Promise((n234, o126)=>{
                                ((e566, t, n, o127)=>{
                                    let r, s;
                                    if (0 === t.src.indexOf("blob:")) return s = e566.getByUri(t.src), void (s ? n({
                                        image: t,
                                        blobInfo: s
                                    }) : Eb(t.src).then((o)=>{
                                        Nb(o).then((a)=>{
                                            r = Sb(a).data, s = e566.create(Ab(), o, r), e566.add(s), n({
                                                image: t,
                                                blobInfo: s
                                            });
                                        });
                                    }, (e)=>{
                                        o127(e);
                                    }));
                                    const { data: a33 , type: i  } = Sb(t.src);
                                    r = a33, s = e566.getByData(r, i), s ? n({
                                        image: t,
                                        blobInfo: s
                                    }) : Eb(t.src).then((o)=>{
                                        s = e566.create(Ab(), o, r), e566.add(s), n({
                                            image: t,
                                            blobInfo: s
                                        });
                                    }, (e)=>{
                                        o127(e);
                                    });
                                })(t374, e565, n234, o126);
                            }).then((e)=>(delete n233[e.image.src], e)
                            ).catch((t)=>(delete n233[e565.src], t)
                            );
                            return n233[e565.src] = o125, o125;
                        });
                        return Promise.all(a32);
                    }
                };
            })(r64, t371)), o121.findAll(e559.getBody(), p).then(i23((t375)=>(t375 = K1(t375, (t)=>"string" != typeof t || (oy(e559, t), !1)
                ), _v(e559) || $1(t375, (e)=>{
                    c(e.image.src, e.blobInfo.blobUri()), e.image.src = e.blobInfo.blobUri(), e.image.removeAttribute("data-mce-src");
                }), t375)
            )))
        , b = (n235)=>n235.replace(/src="(blob:[^"]+)"/g, (n, o)=>{
                const s = r64.getResultUri(o);
                if (s) return 'src="' + s + '"';
                let a = t371.getByUri(o);
                return a || (a = Y1(e559.editorManager.get(), (e, t)=>e || t.editorUpload && t.editorUpload.blobCache.getByUri(o)
                , null)), a ? 'src="data:' + a.blob().type + ";base64," + a.base64() + '"' : n;
            })
        ;
        return e559.on("SetContent", ()=>{
            Ii(e559) ? g() : h();
        }), e559.on("RawSaveContent", (e)=>{
            e.content = b(e.content);
        }), e559.on("GetContent", (e)=>{
            e.source_view || "raw" === e.format || "tree" === e.format || (e.content = b(e.content));
        }), e559.on("PostRender", ()=>{
            e559.parser.addNodeFilter("img", (e567)=>{
                $1(e567, (e)=>{
                    const n = e.attr("src");
                    if (t371.getByUri(n)) return;
                    const o = r64.getResultUri(n);
                    o && e.attr("src", o);
                });
            });
        }), {
            blobCache: t371,
            addFilter: (e)=>{
                s38.push(e);
            },
            uploadImages: u,
            uploadImagesAuto: g,
            scanForImages: h,
            destroy: ()=>{
                t371.destroy(), r64.destroy(), o121 = n229 = null;
            }
        };
    }, py = {
        remove_similar: !0,
        inherit: !1
    }, hy = {
        selector: "td,th",
        ...py
    }, by = {
        tablecellbackgroundcolor: {
            styles: {
                backgroundColor: "%value"
            },
            ...hy
        },
        tablecellverticalalign: {
            styles: {
                "vertical-align": "%value"
            },
            ...hy
        },
        tablecellbordercolor: {
            styles: {
                borderColor: "%value"
            },
            ...hy
        },
        tablecellclass: {
            classes: [
                "%value"
            ],
            ...hy
        },
        tableclass: {
            selector: "table",
            classes: [
                "%value"
            ],
            ...py
        },
        tablecellborderstyle: {
            styles: {
                borderStyle: "%value"
            },
            ...hy
        },
        tablecellborderwidth: {
            styles: {
                borderWidth: "%value"
            },
            ...hy
        }
    }, vy = N1(by), yy = Bt.each, Cy = Is.DOM, xy = (e568, t376)=>{
        let n236, o128, r68;
        const s = t376 && t376.schema || vs({}), a = (e569)=>{
            o128 = "string" == typeof e569 ? {
                name: e569,
                classes: [],
                attrs: {}
            } : e569;
            const t377 = Cy.create(o128.name);
            return ((e, t)=>{
                t.classes.length && Cy.addClass(e, t.classes.join(" ")), Cy.setAttribs(e, t.attrs);
            })(t377, o128), t377;
        }, i = (e570, t378, n237)=>{
            let o129, r69;
            const l = t378.length > 0 && t378[0], d = l && l.name, c = ((e, t)=>{
                const n = "string" != typeof e ? e.nodeName.toLowerCase() : e, o = s.getElementRule(n), r = o && o.parentsRequired;
                return !(!r || !r.length) && (t && -1 !== Bt.inArray(r, t) ? t : r[0]);
            })(e570, d);
            if (c) d === c ? (r69 = t378[0], t378 = t378.slice(1)) : r69 = c;
            else if (l) r69 = t378[0], t378 = t378.slice(1);
            else if (!n237) return e570;
            return r69 && (o129 = a(r69), o129.appendChild(e570)), n237 && (o129 || (o129 = Cy.create("div"), o129.appendChild(e570)), Bt.each(n237, (t)=>{
                const n = a(t);
                o129.insertBefore(n, e570);
            })), i(o129, t378, r69 && r69.siblings);
        };
        return e568 && e568.length ? (o128 = e568[0], n236 = a(o128), r68 = Cy.create("div"), r68.appendChild(i(n236, e568.slice(1), o128.siblings)), r68) : "";
    }, wy = (e571)=>{
        let t379;
        const n = {
            classes: [],
            attrs: {}
        };
        return "*" !== (e571 = n.selector = Bt.trim(e571)) && (t379 = e571.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, (e, t, o, r, s)=>{
            switch(t){
                case "#":
                    n.attrs.id = o;
                    break;
                case ".":
                    n.classes.push(o);
                    break;
                case ":":
                    -1 !== Bt.inArray("checked disabled enabled read-only required".split(" "), o) && (n.attrs[o] = o);
            }
            if ("[" === r) {
                const e = s.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
                e && (n.attrs[e[1]] = e[2]);
            }
            return "";
        })), n.name = t379 || "div", n;
    }, ky = (e572, t380)=>{
        let n238, o, r, s = "", a = gl(e572);
        if ("" === a) return "";
        const i = (e)=>e.replace(/%(\w+)/g, "")
        ;
        if ("string" == typeof t380) {
            if (!(t380 = e572.formatter.get(t380))) return;
            t380 = t380[0];
        }
        if ("preview" in t380) {
            const e = xe1(t380, "preview");
            if (Dt(e, !1)) return "";
            a = e.getOr(a);
        }
        n238 = t380.block || t380.inline || "span";
        const l = (d = t380.selector) && "string" == typeof d ? (d = (d = d.split(/\s*,\s*/)[0]).replace(/\s*(~\+|~|\+|>)\s*/g, "$1"), Bt.map(d.split(/(?:>|\s+(?![^\[\]]+\]))/), (e)=>{
            const t = Bt.map(e.split(/(?:~\+|~|\+)/), wy), n = t.pop();
            return t.length && (n.siblings = t), n;
        }).reverse()) : [];
        var d;
        l.length ? (l[0].name || (l[0].name = n238), n238 = t380.selector, o = xy(l, e572)) : o = xy([
            n238
        ], e572);
        const c = Cy.select(n238, o)[0] || o.firstChild;
        return yy(t380.styles, (e, t)=>{
            const n = i(e);
            n && Cy.setStyle(c, t, n);
        }), yy(t380.attributes, (e, t)=>{
            const n = i(e);
            n && Cy.setAttrib(c, t, n);
        }), yy(t380.classes, (e)=>{
            const t = i(e);
            Cy.hasClass(c, t) || Cy.addClass(c, t);
        }), e572.dispatch("PreviewFormats"), Cy.setStyles(o, {
            position: "absolute",
            left: -65535
        }), e572.getBody().appendChild(o), r = Cy.getStyle(e572.getBody(), "fontSize", !0), r = /px$/.test(r) ? parseInt(r, 10) : 0, yy(a.split(" "), (t)=>{
            let n = Cy.getStyle(c, t, !0);
            if (!("background-color" === t && /transparent|rgba\s*\([^)]+,\s*0\)/.test(n) && (n = Cy.getStyle(e572.getBody(), t, !0), "#ffffff" === Pc(n).toLowerCase()) || "color" === t && "#000000" === Pc(n).toLowerCase())) {
                if ("font-size" === t && /em|%$/.test(n)) {
                    if (0 === r) return;
                    n = parseFloat(n) / (/%$/.test(n) ? 100 : 1) * r + "px";
                }
                "border" === t && n && (s += "padding:0 2px;"), s += t + ":" + n + ";";
            }
        }), e572.dispatch("AfterPreviewFormats"), Cy.remove(o), s;
    }, Sy = (e573)=>{
        const t381 = ((e574)=>{
            const t382 = {}, n240 = (e575, o)=>{
                e575 && (m1(e575) ? (p1(o) || (o = [
                    o
                ]), $1(o, (e)=>{
                    v1(e.deep) && (e.deep = !Yc(e)), v1(e.split) && (e.split = !Yc(e) || Xc(e)), v1(e.remove) && Yc(e) && !Xc(e) && (e.remove = "none"), Yc(e) && Xc(e) && (e.mixed = !0, e.block_expand = !0), m1(e.classes) && (e.classes = e.classes.split(/\s+/));
                }), t382[e575] = o) : fe1(e575, (e, t)=>{
                    n240(t, e);
                }));
            };
            return n240(((e576)=>{
                const t383 = e576.dom, n241 = e576.schema.type, o130 = {
                    valigntop: [
                        {
                            selector: "td,th",
                            styles: {
                                verticalAlign: "top"
                            }
                        }
                    ],
                    valignmiddle: [
                        {
                            selector: "td,th",
                            styles: {
                                verticalAlign: "middle"
                            }
                        }
                    ],
                    valignbottom: [
                        {
                            selector: "td,th",
                            styles: {
                                verticalAlign: "bottom"
                            }
                        }
                    ],
                    alignleft: [
                        {
                            selector: "figure.image",
                            collapsed: !1,
                            classes: "align-left",
                            ceFalseOverride: !0,
                            preview: "font-family font-size"
                        },
                        {
                            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
                            styles: {
                                textAlign: "left"
                            },
                            inherit: !1,
                            preview: !1
                        },
                        {
                            selector: "img,audio,video",
                            collapsed: !1,
                            styles: {
                                float: "left"
                            },
                            preview: "font-family font-size"
                        },
                        {
                            selector: "table",
                            collapsed: !1,
                            styles: {
                                marginLeft: "0px",
                                marginRight: "auto"
                            },
                            onformat: (e)=>{
                                t383.setStyle(e, "float", null);
                            },
                            preview: "font-family font-size"
                        }
                    ],
                    aligncenter: [
                        {
                            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
                            styles: {
                                textAlign: "center"
                            },
                            inherit: !1,
                            preview: "font-family font-size"
                        },
                        {
                            selector: "figure.image",
                            collapsed: !1,
                            classes: "align-center",
                            ceFalseOverride: !0,
                            preview: "font-family font-size"
                        },
                        {
                            selector: "img,audio,video",
                            collapsed: !1,
                            styles: {
                                display: "block",
                                marginLeft: "auto",
                                marginRight: "auto"
                            },
                            preview: !1
                        },
                        {
                            selector: "table",
                            collapsed: !1,
                            styles: {
                                marginLeft: "auto",
                                marginRight: "auto"
                            },
                            preview: "font-family font-size"
                        }
                    ],
                    alignright: [
                        {
                            selector: "figure.image",
                            collapsed: !1,
                            classes: "align-right",
                            ceFalseOverride: !0,
                            preview: "font-family font-size"
                        },
                        {
                            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
                            styles: {
                                textAlign: "right"
                            },
                            inherit: !1,
                            preview: "font-family font-size"
                        },
                        {
                            selector: "img,audio,video",
                            collapsed: !1,
                            styles: {
                                float: "right"
                            },
                            preview: "font-family font-size"
                        },
                        {
                            selector: "table",
                            collapsed: !1,
                            styles: {
                                marginRight: "0px",
                                marginLeft: "auto"
                            },
                            onformat: (e)=>{
                                t383.setStyle(e, "float", null);
                            },
                            preview: "font-family font-size"
                        }
                    ],
                    alignjustify: [
                        {
                            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
                            styles: {
                                textAlign: "justify"
                            },
                            inherit: !1,
                            preview: "font-family font-size"
                        }
                    ],
                    bold: [
                        {
                            inline: "strong",
                            remove: "all",
                            preserve_attributes: [
                                "class",
                                "style"
                            ]
                        },
                        {
                            inline: "span",
                            styles: {
                                fontWeight: "bold"
                            }
                        },
                        {
                            inline: "b",
                            remove: "all",
                            preserve_attributes: [
                                "class",
                                "style"
                            ]
                        }
                    ],
                    italic: [
                        {
                            inline: "em",
                            remove: "all",
                            preserve_attributes: [
                                "class",
                                "style"
                            ]
                        },
                        {
                            inline: "span",
                            styles: {
                                fontStyle: "italic"
                            }
                        },
                        {
                            inline: "i",
                            remove: "all",
                            preserve_attributes: [
                                "class",
                                "style"
                            ]
                        }
                    ],
                    underline: [
                        {
                            inline: "span",
                            styles: {
                                textDecoration: "underline"
                            },
                            exact: !0
                        },
                        {
                            inline: "u",
                            remove: "all",
                            preserve_attributes: [
                                "class",
                                "style"
                            ]
                        }
                    ],
                    strikethrough: (()=>{
                        const e = {
                            inline: "span",
                            styles: {
                                textDecoration: "line-through"
                            },
                            exact: !0
                        }, t = {
                            inline: "strike",
                            remove: "all",
                            preserve_attributes: [
                                "class",
                                "style"
                            ]
                        }, o = {
                            inline: "s",
                            remove: "all",
                            preserve_attributes: [
                                "class",
                                "style"
                            ]
                        };
                        return "html4" !== n241 ? [
                            o,
                            e,
                            t
                        ] : [
                            e,
                            o,
                            t
                        ];
                    })(),
                    forecolor: {
                        inline: "span",
                        styles: {
                            color: "%value"
                        },
                        links: !0,
                        remove_similar: !0,
                        clear_child_styles: !0
                    },
                    hilitecolor: {
                        inline: "span",
                        styles: {
                            backgroundColor: "%value"
                        },
                        links: !0,
                        remove_similar: !0,
                        clear_child_styles: !0
                    },
                    fontname: {
                        inline: "span",
                        toggle: !1,
                        styles: {
                            fontFamily: "%value"
                        },
                        clear_child_styles: !0
                    },
                    fontsize: {
                        inline: "span",
                        toggle: !1,
                        styles: {
                            fontSize: "%value"
                        },
                        clear_child_styles: !0
                    },
                    lineheight: {
                        selector: "h1,h2,h3,h4,h5,h6,p,li,td,th,div",
                        styles: {
                            lineHeight: "%value"
                        }
                    },
                    fontsize_class: {
                        inline: "span",
                        attributes: {
                            class: "%value"
                        }
                    },
                    blockquote: {
                        block: "blockquote",
                        wrapper: !0,
                        remove: "all"
                    },
                    subscript: {
                        inline: "sub"
                    },
                    superscript: {
                        inline: "sup"
                    },
                    code: {
                        inline: "code"
                    },
                    link: {
                        inline: "a",
                        selector: "a",
                        remove: "all",
                        split: !0,
                        deep: !0,
                        onmatch: (e, t, n)=>yo(e) && e.hasAttribute("href")
                        ,
                        onformat: (e, n242, o131)=>{
                            Bt.each(o131, (n, o)=>{
                                t383.setAttrib(e, o, n);
                            });
                        }
                    },
                    lang: {
                        inline: "span",
                        clear_child_styles: !0,
                        remove_similar: !0,
                        attributes: {
                            lang: "%value",
                            "data-mce-lang": (e)=>{
                                var t;
                                return null !== (t = null == e ? void 0 : e.customValue) && void 0 !== t ? t : null;
                            }
                        }
                    },
                    removeformat: [
                        {
                            selector: "b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small",
                            remove: "all",
                            split: !0,
                            expand: !1,
                            block_expand: !0,
                            deep: !0
                        },
                        {
                            selector: "span",
                            attributes: [
                                "style",
                                "class"
                            ],
                            remove: "empty",
                            split: !0,
                            expand: !1,
                            deep: !0
                        },
                        {
                            selector: "*",
                            attributes: [
                                "style",
                                "class"
                            ],
                            split: !1,
                            expand: !1,
                            deep: !0
                        }
                    ]
                };
                return Bt.each("p h1 h2 h3 h4 h5 h6 div address pre dt dd samp".split(/\s/), (e)=>{
                    o130[e] = {
                        block: e,
                        remove: "all"
                    };
                }), o130;
            })(e574)), n240(vy()), n240(fl(e574)), {
                get: (e)=>C1(e) ? t382[e] : t382
                ,
                has: (e)=>we1(t382, e)
                ,
                register: n240,
                unregister: (e)=>(e && t382[e] && delete t382[e], t382)
            };
        })(e573), n239 = zs(null);
        return ((e)=>{
            e.addShortcut("meta+b", "", "Bold"), e.addShortcut("meta+i", "", "Italic"), e.addShortcut("meta+u", "", "Underline");
            for(let t = 1; t <= 6; t++)e.addShortcut("access+" + t, "", [
                "FormatBlock",
                !1,
                "h" + t
            ]);
            e.addShortcut("access+7", "", [
                "FormatBlock",
                !1,
                "p"
            ]), e.addShortcut("access+8", "", [
                "FormatBlock",
                !1,
                "div"
            ]), e.addShortcut("access+9", "", [
                "FormatBlock",
                !1,
                "address"
            ]);
        })(e573), ((e577)=>{
            e577.on("mouseup keydown", (t384)=>{
                ((e, t)=>{
                    const n = e.selection, o = e.getBody();
                    Hp(e, null, !1), 8 !== t && 46 !== t || !n.isCollapsed() || n.getStart().innerHTML !== Ip || Hp(e, pc(o, n.getStart())), 37 !== t && 39 !== t || Hp(e, pc(o, n.getStart()));
                })(e577, t384.keyCode);
            });
        })(e573), {
            get: t381.get,
            has: t381.has,
            register: t381.register,
            unregister: t381.unregister,
            apply: (t385, n243, o132)=>{
                ((e, t, n, o)=>{
                    Nv(e).formatter.apply(t, n, o);
                })(e573, t385, n243, o132);
            },
            remove: (t386, n244, o133, r70)=>{
                ((e, t, n, o, r)=>{
                    Nv(e).formatter.remove(t, n, o, r);
                })(e573, t386, n244, o133, r70);
            },
            toggle: (t387, n245, o134)=>{
                ((e, t, n, o)=>{
                    Nv(e).formatter.toggle(t, n, o);
                })(e573, t387, n245, o134);
            },
            match: (t388, n246, o135, r71)=>((e, t, n, o, r)=>Nv(e).formatter.match(t, n, o, r)
                )(e573, t388, n246, o135, r71)
            ,
            closest: (t389)=>((e, t)=>Nv(e).formatter.closest(t)
                )(e573, t389)
            ,
            matchAll: (t390, n247)=>((e, t, n)=>Nv(e).formatter.matchAll(t, n)
                )(e573, t390, n247)
            ,
            matchNode: (t391, n248, o136, r72)=>((e, t, n, o, r)=>Nv(e).formatter.matchNode(t, n, o, r)
                )(e573, t391, n248, o136, r72)
            ,
            canApply: (t392)=>((e, t)=>Nv(e).formatter.canApply(t)
                )(e573, t392)
            ,
            formatChanged: (t393, o137, r73, s41)=>((e, t, n, o, r, s)=>Nv(e).formatter.formatChanged(t, n, o, r, s)
                )(e573, n239, t393, o137, r73, s41)
            ,
            getCssText: O1(ky, e573)
        };
    }, _y = (e)=>{
        switch(e.toLowerCase()){
            case "undo":
            case "redo":
            case "mcefocus":
                return !0;
            default:
                return !1;
        }
    }, Ey = (e578)=>{
        const t394 = Ws(), n249 = zs(0), o138 = zs(0), r74 = {
            data: [],
            typing: !1,
            beforeChange: ()=>{
                ((e, t, n)=>{
                    Nv(e).undoManager.beforeChange(t, n);
                })(e578, n249, t394);
            },
            add: (s42, a34)=>((e, t, n, o, r, s, a)=>Nv(e).undoManager.add(t, n, o, r, s, a)
                )(e578, r74, o138, n249, t394, s42, a34)
            ,
            undo: ()=>((e, t, n, o)=>Nv(e).undoManager.undo(t, n, o)
                )(e578, r74, n249, o138)
            ,
            redo: ()=>((e, t, n)=>Nv(e).undoManager.redo(t, n)
                )(e578, o138, r74.data)
            ,
            clear: ()=>{
                ((e, t, n)=>{
                    Nv(e).undoManager.clear(t, n);
                })(e578, r74, o138);
            },
            reset: ()=>{
                ((e, t)=>{
                    Nv(e).undoManager.reset(t);
                })(e578, r74);
            },
            hasUndo: ()=>((e, t, n)=>Nv(e).undoManager.hasUndo(t, n)
                )(e578, r74, o138)
            ,
            hasRedo: ()=>((e, t, n)=>Nv(e).undoManager.hasRedo(t, n)
                )(e578, r74, o138)
            ,
            transact: (t395)=>((e, t, n, o)=>Nv(e).undoManager.transact(t, n, o)
                )(e578, r74, n249, t395)
            ,
            ignore: (t396)=>{
                ((e, t, n)=>{
                    Nv(e).undoManager.ignore(t, n);
                })(e578, n249, t396);
            },
            extra: (t397, n250)=>{
                ((e, t, n, o, r)=>{
                    Nv(e).undoManager.extra(t, n, o, r);
                })(e578, r74, o138, t397, n250);
            }
        };
        return _v(e578) || ((e579, t398, n251)=>{
            const o139 = zs(!1), r = (e)=>{
                wv(t398, !1, n251), t398.add({}, e);
            };
            e579.on("init", ()=>{
                t398.add();
            }), e579.on("BeforeExecCommand", (e)=>{
                const o = e.command;
                _y(o) || (kv(t398, n251), t398.beforeChange());
            }), e579.on("ExecCommand", (e)=>{
                const t = e.command;
                _y(t) || r(e);
            }), e579.on("ObjectResizeStart cut", ()=>{
                t398.beforeChange();
            }), e579.on("SaveContent ObjectResized blur", r), e579.on("dragend", r), e579.on("keyup", (n)=>{
                const s = n.keyCode;
                n.isDefaultPrevented() || ((s >= 33 && s <= 36 || s >= 37 && s <= 40 || 45 === s || n.ctrlKey) && (r(), e579.nodeChanged()), 46 !== s && 8 !== s || e579.nodeChanged(), o139.get() && t398.typing && !1 === Cv(hv(e579), t398.data[0]) && (!1 === e579.isDirty() && e579.setDirty(!0), e579.dispatch("TypingUndo"), o139.set(!1), e579.nodeChanged()));
            }), e579.on("keydown", (e)=>{
                const s = e.keyCode;
                if (e.isDefaultPrevented()) return;
                if (s >= 33 && s <= 36 || s >= 37 && s <= 40 || 45 === s) return void (t398.typing && r(e));
                const a = e.ctrlKey && !e.altKey || e.metaKey;
                !(s < 16 || s > 20) || 224 === s || 91 === s || t398.typing || a || (t398.beforeChange(), wv(t398, !0, n251), t398.add({}, e), o139.set(!0));
            }), e579.on("mousedown", (e)=>{
                t398.typing && r(e);
            }), e579.on("input", (e580)=>{
                var t;
                e580.inputType && ("insertReplacementText" === e580.inputType || "insertText" === (t = e580).inputType && null === t.data || ((e)=>"insertFromPaste" === e.inputType || "insertFromDrop" === e.inputType
                )(e580)) && r(e580);
            }), e579.on("AddUndo Undo Redo ClearUndos", (t)=>{
                t.isDefaultPrevented() || e579.nodeChanged();
            });
        })(e578, r74, n249), ((e)=>{
            e.addShortcut("meta+z", "", "Undo"), e.addShortcut("meta+y,meta+shift+z", "", "Redo");
        })(e578), r74;
    }, Ny = [
        9,
        27,
        Uu.HOME,
        Uu.END,
        19,
        20,
        44,
        144,
        145,
        33,
        34,
        45,
        16,
        17,
        18,
        91,
        92,
        93,
        Uu.DOWN,
        Uu.UP,
        Uu.LEFT,
        Uu.RIGHT
    ].concat(Nt.browser.isFirefox() ? [
        224
    ] : []), Ry = "data-mce-placeholder", Ay = (e)=>"keydown" === e.type || "keyup" === e.type
    , Oy = (e)=>{
        const t = e.keyCode;
        return t === Uu.BACKSPACE || t === Uu.DELETE;
    }, Ty = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/, By = (e, t)=>pn(mn(t), nl(e))
    , Dy = (e581, t399, n252)=>{
        const o = ((e, t, n)=>K1(Is.DOM.getParents(n.container(), "*", t), e)
        )(e581, t399, n252);
        return M1.from(o[o.length - 1]);
    }, Ly = (e, t)=>{
        if (!t) return t;
        const n = t.container(), o = t.offset();
        return e ? br(n) ? No(n.nextSibling) ? Ua(n.nextSibling, 0) : Ua.after(n) : Cr(t) ? Ua(n, o + 1) : t : br(n) ? No(n.previousSibling) ? Ua(n.previousSibling, n.previousSibling.data.length) : Ua.before(n) : xr(t) ? Ua(n, o - 1) : t;
    }, Py = O1(Ly, !0), My = O1(Ly, !1), Iy = (e582, t)=>{
        const n = (e)=>e.stopImmediatePropagation()
        ;
        e582.on("beforeinput input", n, !0), e582.getDoc().execCommand(t), e582.off("beforeinput input", n);
    }, Fy = (e)=>Iy(e, "Delete")
    , Uy = (e)=>nr(e) || rr(e)
    , zy = (e583, t400)=>vn(e583, t400) ? $o(t400, Uy, ((e)=>(t)=>bn(e, mn(t.dom.parentNode))
        )(e583)) : M1.none()
    , jy = (e584)=>{
        e584.dom.isEmpty(e584.getBody()) && (e584.setContent(""), ((e)=>{
            const t = e.getBody(), n = t.firstChild && e.dom.isBlock(t.firstChild) ? t.firstChild : t;
            e.selection.setCursorLocation(n, 0);
        })(e584));
    }, Vy = (e, t)=>({
            from: e,
            to: t
        })
    , Hy = (e585, t401)=>{
        const n = mn(e585), o = mn(t401.container());
        return zy(n, o).map((e586)=>((e, t)=>({
                    block: e,
                    position: t
                })
            )(e586, t401)
        );
    }, $y = (e587)=>{
        const t = Nn(e587);
        return J1(t, Zo).fold(N1(t), (e)=>t.slice(0, e)
        );
    }, qy = (e)=>{
        const t = $y(e);
        return $1(t, to), t;
    }, Wy = (e588, t)=>{
        const n = Qf(t, e588);
        return Q1(n.reverse(), (e)=>qr(e)
        ).each(to);
    }, Ky = (e589, t, n, o)=>{
        if (qr(n)) return Gf(n), uc(n.dom);
        0 === K1(_n(o), (e)=>!qr(e)
        ).length && qr(t) && Yn(o, cn("br"));
        const r = cc(n.dom, Ua.before(o.dom));
        return $1(qy(t), (e)=>{
            Yn(o, e);
        }), Wy(e589, t), r;
    }, Gy = (e590, t, n)=>{
        if (qr(n)) return to(n), qr(t) && Gf(t), uc(t.dom);
        const o = mc(n.dom);
        return $1(qy(t), (e)=>{
            Jn(n, e);
        }), Wy(e590, t), o;
    }, Yy = (e591, t)=>{
        lc(e591, t.dom).map((e)=>e.getNode()
        ).map(mn).filter(tr).each(to);
    }, Xy = (e592, t402, n253)=>(Yy(!0, t402), Yy(!1, n253), ((e593, t403)=>vn(t403, e593) ? ((e, t)=>{
                const n = Qf(t, e);
                return M1.from(n[n.length - 1]);
            })(t403, e593) : M1.none()
        )(t402, n253).fold(O1(Gy, e592, t402, n253), O1(Ky, e592, t402, n253)))
    , Qy = (e, t, n, o)=>t ? Xy(e, o, n) : Xy(e, n, o)
    , Jy = (e594, t404)=>{
        const n254 = mn(e594.getBody()), o140 = ((e595, t405, n255)=>n255.collapsed ? ((e596, t406, n256)=>{
                const o141 = Hy(e596, Ua.fromRangeStart(n256)), r = o141.bind((n257)=>sc(t406, e596, n257.position).bind((n258)=>Hy(e596, n258).map((n259)=>((e, t407, n)=>Do(n.position.getNode()) && !1 === qr(n.block) ? lc(!1, n.block.dom).bind((o)=>o.isEqual(n.position) ? sc(t407, e, o).bind((t)=>Hy(e, t)
                                    ) : M1.some(n)
                                ).getOr(n) : n
                            )(e596, t406, n259)
                        )
                    )
                );
                return Lt(o141, r, Vy).filter((e597)=>((e)=>!1 === bn(e.from.block, e.to.block)
                    )(e597) && ((e598)=>wn(e598.from.block).bind((t)=>wn(e598.to.block).filter((e)=>bn(t, e)
                            )
                        ).isSome()
                    )(e597) && ((e)=>!1 === Mo(e.from.block.dom) && !1 === Mo(e.to.block.dom)
                    )(e597)
                );
            })(e595, t405, n255) : M1.none()
        )(n254.dom, t404, e594.selection.getRng()).map((o)=>()=>{
                Qy(n254, t404, o.from.block, o.to.block).each((t)=>{
                    e594.selection.setRng(t.toRange());
                });
            }
        );
        return o140;
    }, Zy = (e, t)=>{
        const n = mn(t), o = O1(bn, e);
        return Ho(n, ar, o).isSome();
    }, eC = (e599)=>{
        const t408 = mn(e599.getBody());
        return ((e600, t409)=>{
            const n = cc(e600.dom, Ua.fromRangeStart(t409)).isNone(), o = dc(e600.dom, Ua.fromRangeEnd(t409)).isNone();
            return !((e, t)=>Zy(e, t.startContainer) || Zy(e, t.endContainer)
            )(e600, t409) && n && o;
        })(t408, e599.selection.getRng()) ? ((e)=>M1.some(()=>{
                e.setContent(""), e.selection.setCursorLocation();
            })
        )(e599) : ((e601, t)=>{
            const n = t.getRng();
            return Lt(zy(e601, mn(n.startContainer)), zy(e601, mn(n.endContainer)), (o, r)=>!1 === bn(o, r) ? M1.some(()=>{
                    n.deleteContents(), Qy(e601, !0, o, r).each((e)=>{
                        t.setRng(e.toRange());
                    });
                }) : M1.none()
            ).getOr(M1.none());
        })(t408, e599.selection);
    }, tC = (e, t)=>e.selection.isCollapsed() ? M1.none() : eC(e)
    , nC = Po, oC = Mo, rC = (e, t, n, o, r)=>M1.from(t._selectionOverrides.showCaret(e, n, o, r))
    , sC = (e602, t410)=>e602.dispatch("BeforeObjectSelected", {
            target: t410
        }).isDefaultPrevented() ? M1.none() : M1.some(((e)=>{
            const t = e.ownerDocument.createRange();
            return t.selectNode(e), t;
        })(t410))
    , aC = (e603, t411, n260)=>t411.collapsed ? ((e604, t, n)=>{
            const o = Fd(1, e604.getBody(), t), r = Ua.fromRangeStart(o), s = r.getNode();
            if (hd(s)) return rC(1, e604, s, !r.isAtEnd(), !1);
            const a = r.getNode(!0);
            if (hd(a)) return rC(1, e604, a, !1, !1);
            const i = e604.dom.getParent(r.getNode(), (e)=>oC(e) || nC(e)
            );
            return hd(i) ? rC(1, e604, i, !1, n) : M1.none();
        })(e603, t411, n260).getOr(t411) : t411
    , iC = (e)=>Wf(e) || Vf(e)
    , lC = (e)=>Kf(e) || Hf(e)
    , dC = (e605, t412, n261, o, r, s)=>{
        rC(o, e605, s.getNode(!r), r, !0).each((n)=>{
            if (t412.collapsed) {
                const e = t412.cloneRange();
                r ? e.setEnd(n.startContainer, n.startOffset) : e.setStart(n.endContainer, n.endOffset), e.deleteContents();
            } else t412.deleteContents();
            e605.selection.setRng(n);
        }), ((e, t)=>{
            No(t) && 0 === t.data.length && e.remove(t);
        })(e605.dom, n261);
    }, cC = (e606, t413)=>((e, t)=>{
            const n = e.selection.getRng();
            if (!No(n.commonAncestorContainer)) return M1.none();
            const o = t ? $d.Forwards : $d.Backwards, r = tc(e.getBody()), s = O1(Vd, t ? r.next : r.prev), a = t ? iC : lC, i = zd(o, e.getBody(), n), l = Ly(t, s(i));
            if (!l || !Hd(i, l)) return M1.none();
            if (a(l)) return M1.some(()=>dC(e, n, i.getNode(), o, t, l)
            );
            const d = s(l);
            return d && a(d) && Hd(l, d) ? M1.some(()=>dC(e, n, i.getNode(), o, t, d)
            ) : M1.none();
        })(e606, t413)
    , uC = ci([
        {
            remove: [
                "element"
            ]
        },
        {
            moveToElement: [
                "element"
            ]
        },
        {
            moveToPosition: [
                "position"
            ]
        }
    ]), mC = (e607, t414, n262)=>sc(t414, e607, n262).bind((o142)=>{
            var r75;
            return r75 = o142.getNode(), ar(mn(r75)) || rr(mn(r75)) || ((e, t415, n, o)=>{
                const r = (t)=>er(mn(t)) && !Td(n, o, e)
                ;
                return Ud(!t415, n).fold(()=>Ud(t415, o).fold(L1, r)
                , r);
            })(e607, t414, n262, o142) ? M1.none() : t414 && Mo(o142.getNode()) || !1 === t414 && Mo(o142.getNode(!0)) ? ((e608, t, n, o)=>{
                const r = o.getNode(!1 === t);
                return zy(mn(e608), mn(n.getNode())).map((e)=>qr(e) ? uC.remove(e.dom) : uC.moveToElement(r)
                ).orThunk(()=>M1.some(uC.moveToElement(r))
                );
            })(e607, t414, n262, o142) : t414 && Kf(n262) || !1 === t414 && Wf(n262) ? M1.some(uC.moveToPosition(o142)) : M1.none();
        })
    , fC = (e, t)=>M1.from(ip(e.getBody(), t))
    , gC = (e609, t416)=>{
        const n263 = e609.selection.getNode();
        return fC(e609, n263).filter(Mo).fold(()=>((e610, t417, n264)=>{
                const o143 = Fd(t417 ? 1 : -1, e610, n264), r = Ua.fromRangeStart(o143), s = mn(e610);
                return !1 === t417 && Kf(r) ? M1.some(uC.remove(r.getNode(!0))) : t417 && Wf(r) ? M1.some(uC.remove(r.getNode())) : !1 === t417 && Wf(r) && dg(s, r) ? cg(s, r).map((e)=>uC.remove(e.getNode())
                ) : t417 && Kf(r) && lg(s, r) ? ug(s, r).map((e)=>uC.remove(e.getNode())
                ) : ((e611, t418, n265)=>((e, t)=>{
                        const n = t.getNode(!1 === e), o = e ? "after" : "before";
                        return yo(n) && n.getAttribute("data-mce-caret") === o;
                    })(t418, n265) ? ((e, t)=>e && Mo(t.nextSibling) ? M1.some(uC.moveToElement(t.nextSibling)) : !1 === e && Mo(t.previousSibling) ? M1.some(uC.moveToElement(t.previousSibling)) : M1.none()
                    )(t418, n265.getNode(!1 === t418)).fold(()=>mC(e611, t418, n265)
                    , M1.some) : mC(e611, t418, n265).bind((t419)=>((e612, t, n266)=>n266.fold((e)=>M1.some(uC.remove(e))
                            , (e)=>M1.some(uC.moveToElement(e))
                            , (n)=>Td(t, n, e612) ? M1.none() : M1.some(uC.moveToPosition(n))
                            )
                        )(e611, n265, t419)
                    )
                )(e610, t417, r);
            })(e609.getBody(), t416, e609.selection.getRng()).map((n267)=>()=>n267.fold(((e, t)=>(n)=>(e._selectionOverrides.hideFakeCaret(), Lg(e, t, mn(n)), !0)
                    )(e609, t416), ((e, t)=>(n)=>{
                            const o = t ? Ua.before(n) : Ua.after(n);
                            return e.selection.setRng(o.toRange()), !0;
                        }
                    )(e609, t416), ((e)=>(t)=>(e.selection.setRng(t.toRange()), !0)
                    )(e609))
            )
        , ()=>M1.some(S1)
        );
    }, pC = (e)=>{
        const t = e.dom, n = e.selection, o = ip(e.getBody(), n.getNode());
        if (Po(o) && t.isBlock(o) && t.isEmpty(o)) {
            const e = t.create("br", {
                "data-mce-bogus": "1"
            });
            t.setHTML(o, ""), o.appendChild(e), n.setRng(Ua.before(e).toRange());
        }
        return !0;
    }, hC = (e613, t420)=>e613.selection.isCollapsed() ? gC(e613, t420) : ((e, t)=>{
            const n268 = e.selection.getNode();
            return Mo(n268) && !Io(n268) ? fC(e, n268.parentNode).filter(Mo).fold(()=>M1.some(()=>{
                    var n;
                    n = mn(e.getBody()), $1(Xs(n, ".mce-offscreen-selection"), to), Lg(e, t, mn(e.selection.getNode())), jy(e);
                })
            , ()=>M1.some(S1)
            ) : M1.none();
        })(e613, t420)
    , bC = (e614, t421)=>e614.selection.isCollapsed() ? ((e615, t422)=>{
            const n = Ua.fromRangeStart(e615.selection.getRng());
            return sc(t422, e615.getBody(), n).filter((e)=>t422 ? zf(e) : jf(e)
            ).bind((e)=>M1.from(Bd(t422 ? 0 : -1, e))
            ).map((t)=>()=>e615.selection.select(t)
            );
        })(e614, t421) : M1.none()
    , vC = No, yC = (e)=>vC(e) && e.data[0] === ur
    , CC = (e)=>vC(e) && e.data[e.data.length - 1] === ur
    , xC = (e)=>e.ownerDocument.createTextNode(ur)
    , wC = (e616, t423)=>e616 ? ((e)=>{
            if (vC(e.previousSibling)) return CC(e.previousSibling) || e.previousSibling.appendData(ur), e.previousSibling;
            if (vC(e)) return yC(e) || e.insertData(0, ur), e;
            {
                const t = xC(e);
                return e.parentNode.insertBefore(t, e), t;
            }
        })(t423) : ((e)=>{
            if (vC(e.nextSibling)) return yC(e.nextSibling) || e.nextSibling.insertData(0, ur), e.nextSibling;
            if (vC(e)) return CC(e) || e.appendData(ur), e;
            {
                const t = xC(e);
                return e.nextSibling ? e.parentNode.insertBefore(t, e.nextSibling) : e.parentNode.appendChild(t), t;
            }
        })(t423)
    , kC = O1(wC, !0), SC = O1(wC, !1), _C = (e, t)=>No(e.container()) ? wC(t, e.container()) : wC(t, e.getNode())
    , EC = (e, t)=>{
        const n = t.get();
        return n && e.container() === n && br(n);
    }, NC = (e, t424)=>t424.fold((t)=>{
            dd(e.get());
            const n = kC(t);
            return e.set(n), M1.some(Ua(n, n.length - 1));
        }, (t425)=>uc(t425).map((t)=>{
                if (EC(t, e)) return Ua(e.get(), 1);
                {
                    dd(e.get());
                    const n = _C(t, !0);
                    return e.set(n), Ua(n, 1);
                }
            })
        , (t426)=>mc(t426).map((t)=>{
                if (EC(t, e)) return Ua(e.get(), e.get().length - 1);
                {
                    dd(e.get());
                    const n = _C(t, !1);
                    return e.set(n), Ua(n, n.length - 1);
                }
            })
        , (t)=>{
            dd(e.get());
            const n = SC(t);
            return e.set(n), M1.some(Ua(n, 1));
        })
    , RC = (e, t)=>{
        for(let n = 0; n < e.length; n++){
            const o = e[n].apply(null, t);
            if (o.isSome()) return o;
        }
        return M1.none();
    }, AC = ci([
        {
            before: [
                "element"
            ]
        },
        {
            start: [
                "element"
            ]
        },
        {
            end: [
                "element"
            ]
        },
        {
            after: [
                "element"
            ]
        }
    ]), OC = (e, t)=>Od(t, e) || e
    , TC = (e617, t, n)=>{
        const o = Py(n), r = OC(t, o.container());
        return Dy(e617, r, o).fold(()=>dc(r, o).bind(O1(Dy, e617, r)).map((e)=>AC.before(e)
            )
        , M1.none);
    }, BC = (e, t)=>null === pc(e, t)
    , DC = (e, t, n)=>Dy(e, t, n).filter(O1(BC, t))
    , LC = (e618, t, n)=>{
        const o = My(n);
        return DC(e618, t, o).bind((e)=>cc(e, o).isNone() ? M1.some(AC.start(e)) : M1.none()
        );
    }, PC = (e619, t, n)=>{
        const o = Py(n);
        return DC(e619, t, o).bind((e)=>dc(e, o).isNone() ? M1.some(AC.end(e)) : M1.none()
        );
    }, MC = (e620, t, n)=>{
        const o = My(n), r = OC(t, o.container());
        return Dy(e620, r, o).fold(()=>cc(r, o).bind(O1(Dy, e620, r)).map((e)=>AC.after(e)
            )
        , M1.none);
    }, IC = (e621)=>{
        var t;
        return !1 === (t = UC(e621), "rtl" === Is.DOM.getStyle(t, "direction", !0) || ((e)=>Ty.test(e)
        )(t.textContent));
    }, FC = (e, t, n)=>RC([
            TC,
            LC,
            PC,
            MC
        ], [
            e,
            t,
            n
        ]).filter(IC)
    , UC = (e)=>e.fold(R1, R1, R1, R1)
    , zC = (e)=>e.fold(N1("before"), N1("start"), N1("end"), N1("after"))
    , jC = (e)=>e.fold(AC.before, AC.before, AC.after, AC.after)
    , VC = (e)=>e.fold(AC.start, AC.start, AC.end, AC.end)
    , HC = (e622, t427, n269, o144, r76, s)=>Lt(Dy(t427, n269, o144), Dy(t427, n269, r76), (t428, o145)=>t428 !== o145 && ((e, t, n)=>{
                const o = Od(t, e), r = Od(n, e);
                return o && o === r;
            })(n269, t428, o145) ? AC.after(e622 ? t428 : o145) : s
        ).getOr(s)
    , $C = (e623, t)=>e623.fold(P1, (e)=>{
            var n, o;
            return o = t, !(zC(n = e) === zC(o) && UC(n) === UC(o));
        })
    , qC = (e, t)=>e ? t.fold(_1(M1.some, AC.start), M1.none, _1(M1.some, AC.after), M1.none) : t.fold(M1.none, _1(M1.some, AC.before), M1.none, _1(M1.some, AC.end))
    , WC = (e, t, n)=>{
        const o = e ? 1 : -1;
        return t.setRng(Ua(n.container(), n.offset() + o).toRange()), t.getSel().modify("move", e ? "forward" : "backward", "word"), !0;
    };
    var KC;
    !function(e) {
        e[e.Br = 0] = "Br", e[e.Block = 1] = "Block", e[e.Wrap = 2] = "Wrap", e[e.Eol = 3] = "Eol";
    }(KC || (KC = {}));
    const GC = (e, t)=>e === $d.Backwards ? ne1(t) : t
    , YC = (e, t, n)=>e === $d.Forwards ? t.next(n) : t.prev(n)
    , XC = (e, t, n, o)=>Do(o.getNode(t === $d.Forwards)) ? KC.Br : !1 === Td(n, o) ? KC.Block : KC.Wrap
    , QC = (e, t, n, o)=>{
        const r = tc(n);
        let s = o;
        const a = [];
        for(; s;){
            const n = YC(t, r, s);
            if (!n) break;
            if (Do(n.getNode(!1))) return t === $d.Forwards ? {
                positions: GC(t, a).concat([
                    n
                ]),
                breakType: KC.Br,
                breakAt: M1.some(n)
            } : {
                positions: GC(t, a),
                breakType: KC.Br,
                breakAt: M1.some(n)
            };
            if (n.isVisible()) {
                if (e(s, n)) {
                    const e = XC(0, t, s, n);
                    return {
                        positions: GC(t, a),
                        breakType: e,
                        breakAt: M1.some(n)
                    };
                }
                a.push(n), s = n;
            } else s = n;
        }
        return {
            positions: GC(t, a),
            breakType: KC.Eol,
            breakAt: M1.none()
        };
    }, JC = (e, t, n, o146)=>t(n, o146).breakAt.map((o)=>{
            const r = t(n, o).positions;
            return e === $d.Backwards ? r.concat(o) : [
                o
            ].concat(r);
        }).getOr([])
    , ZC = (e624, t)=>Y1(e624, (e625, n)=>e625.fold(()=>M1.some(n)
            , (o)=>Lt(ie1(o.getClientRects()), ie1(n.getClientRects()), (e, r)=>{
                    const s = Math.abs(t - e.left);
                    return Math.abs(t - r.left) <= s ? n : o;
                }).or(e625)
            )
        , M1.none())
    , ex = (e, t429)=>ie1(t429.getClientRects()).bind((t)=>ZC(e, t.left)
        )
    , tx = O1(QC, Ua.isAbove, -1), nx = O1(QC, Ua.isBelow, 1), ox = O1(JC, -1, tx), rx = O1(JC, 1, nx), sx = Mo, ax = (e, t)=>Math.abs(e.left - t)
    , ix = (e, t)=>Math.abs(e.right - t)
    , lx = (e626, t)=>Oe1(e626, (e, n)=>{
            const o = Math.min(ax(e, t), ix(e, t)), r = Math.min(ax(n, t), ix(n, t));
            return r === o && ke1(n, "node") && sx(n.node) || r < o ? n : e;
        })
    , dx = (e)=>{
        const t430 = (t431)=>H1(t431, (t)=>{
                const n = ma(t);
                return n.node = e, n;
            })
        ;
        if (yo(e)) return t430(e.getClientRects());
        if (No(e)) {
            const n = e.ownerDocument.createRange();
            return n.setStart(e, 0), n.setEnd(e, e.data.length), t430(n.getClientRects());
        }
        return [];
    }, cx = (e)=>ee1(e, dx)
    ;
    var ux;
    !function(e) {
        e[e.Up = -1] = "Up", e[e.Down = 1] = "Down";
    }(ux || (ux = {}));
    const mx = (e628, t432, n270, o147, r, s43)=>{
        let a = 0;
        const i = [], l = (o)=>{
            let s = cx([
                o
            ]);
            -1 === e628 && (s = s.reverse());
            for(let e627 = 0; e627 < s.length; e627++){
                const o = s[e627];
                if (!n270(o, d)) {
                    if (i.length > 0 && t432(o, Be1(i)) && a++, o.line = a, r(o)) return !0;
                    i.push(o);
                }
            }
        }, d = Be1(s43.getClientRects());
        if (!d) return i;
        const c = s43.getNode();
        return l(c), ((e, t, n, o)=>{
            for(; o = Ad(o, e, Mr, t);)if (n(o)) return;
        })(e628, o147, l, c), i;
    }, fx = O1(mx, ux.Up, pa, ha), gx = O1(mx, ux.Down, ha, pa), px = (e629)=>(t433)=>((e, t)=>t.line > e
            )(e629, t433)
    , hx = (e630)=>(t434)=>((e, t)=>t.line === e
            )(e630, t434)
    , bx = (e, t)=>{
        e.selection.setRng(t), Pm(e, e.selection.getRng());
    }, vx = (e, t, n)=>M1.some(aC(e, t, n))
    , yx = (e, t, n, o, r, s)=>{
        const a = t === $d.Forwards, i = tc(e.getBody()), l = O1(Vd, a ? i.next : i.prev), d = a ? o : r;
        if (!n.collapsed) {
            const o = va(n);
            if (s(o)) return rC(t, e, o, t === $d.Backwards, !1);
        }
        const c = zd(t, e.getBody(), n);
        if (d(c)) return sC(e, c.getNode(!a));
        const u = Ly(a, l(c)), m = _r(n);
        if (!u) return m ? M1.some(n) : M1.none();
        if (d(u)) return rC(t, e, u.getNode(!a), a, !1);
        const f = l(u);
        return f && d(f) && Hd(u, f) ? rC(t, e, f.getNode(!a), a, !1) : m ? vx(e, u.toRange(), !1) : M1.none();
    }, Cx = (e631, t435, n, o149, r77, s44)=>{
        const a35 = zd(t435, e631.getBody(), n), i24 = Be1(a35.getClientRects()), l21 = t435 === ux.Down;
        if (!i24) return M1.none();
        const d14 = (l21 ? gx : fx)(e631.getBody(), px(1), a35), c9 = K1(d14, hx(1)), u8 = i24.left, m5 = lx(c9, u8);
        if (m5 && s44(m5.node)) {
            const n = Math.abs(u8 - m5.left), o = Math.abs(u8 - m5.right);
            return rC(t435, e631, m5.node, n < o, !1);
        }
        let f;
        if (f = o149(a35) ? a35.getNode() : r77(a35) ? a35.getNode(!0) : va(n), f) {
            const n271 = ((e632, t, n, o)=>{
                const r = tc(t);
                let s, a, i, l;
                const d = [];
                let c = 0;
                const u = (e)=>Be1(e.getClientRects())
                ;
                1 === e632 ? (s = r.next, a = ha, i = pa, l = Ua.after(o)) : (s = r.prev, a = pa, i = ha, l = Ua.before(o));
                const m = u(l);
                do {
                    if (!l.isVisible()) continue;
                    const e = u(l);
                    if (i(e, m)) continue;
                    d.length > 0 && a(e, Be1(d)) && c++;
                    const t = ma(e);
                    if (t.position = l, t.line = c, n(t)) return d;
                    d.push(t);
                }while (l = s(l))
                return d;
            })(t435, e631.getBody(), px(1), f);
            let o148 = lx(K1(n271, hx(1)), u8);
            if (o148) return vx(e631, o148.position.toRange(), !1);
            if (o148 = Be1(K1(n271, hx(0))), o148) return vx(e631, o148.position.toRange(), !1);
        }
        return 0 === c9.length ? xx(e631, l21).filter(l21 ? r77 : o149).map((t)=>aC(e631, t.toRange(), !1)
        ) : M1.none();
    }, xx = (e633, t)=>{
        const n = e633.selection.getRng(), o = t ? Ua.fromRangeEnd(n) : Ua.fromRangeStart(n), r = (s = o.container(), a = e633.getBody(), Ho(mn(s), (e)=>vd(e.dom)
        , (e)=>e.dom === a
        ).map((e)=>e.dom
        ).getOr(a));
        var s, a;
        if (t) {
            const e = nx(r, o);
            return le1(e.positions);
        }
        {
            const e = tx(r, o);
            return ie1(e.positions);
        }
    }, wx = (e, t436, n)=>xx(e, t436).filter(n).exists((t)=>(e.selection.setRng(t.toRange()), !0)
        )
    , kx = (e, t)=>{
        const n = e.dom.createRng();
        n.setStart(t.container(), t.offset()), n.setEnd(t.container(), t.offset()), e.selection.setRng(n);
    }, Sx = (e, t)=>{
        e ? t.setAttribute("data-mce-selected", "inline-boundary") : t.removeAttribute("data-mce-selected");
    }, _x = (e, t437, n)=>NC(t437, n).map((t)=>(kx(e, t), n)
        )
    , Ex = (e634, t438, n272)=>!!ml(e634) && ((e635, t439, n273)=>{
            const o150 = e635.getBody(), r78 = Ua.fromRangeStart(e635.selection.getRng());
            return ((e636, t440, n274, o151)=>{
                const r79 = Ly(e636, o151), s45 = FC(t440, n274, r79);
                return FC(t440, n274, r79).bind(O1(qC, e636)).orThunk(()=>((e, t, n, o, r80)=>{
                        const s = Ly(e, r80);
                        return sc(e, n, s).map(O1(Ly, e)).fold(()=>o.map(jC)
                        , (r)=>FC(t, n, r).map(O1(HC, e, t, n, s, r)).filter(O1($C, o))
                        ).filter(IC);
                    })(e636, t440, n274, s45, o151)
                );
            })(n273, O1(By, e635), o150, r78).bind((n)=>_x(e635, t439, n)
            );
        })(e634, t438, n272).isSome()
    , Nx = (e637, t441, n275)=>!!ml(t441) && ((e638, t)=>{
            const n = t.selection.getRng(), o = e638 ? Ua.fromRangeEnd(n) : Ua.fromRangeStart(n);
            return !!((e)=>x1(e.selection.getSel().modify)
            )(t) && (e638 && Cr(o) ? WC(!0, t.selection, o) : !(e638 || !xr(o)) && WC(!1, t.selection, o));
        })(e637, t441)
    , Rx = (e639)=>{
        const t442 = zs(null), n276 = O1(By, e639);
        return e639.on("NodeChange", (o152)=>{
            ml(e639) && (((e640, t, n)=>{
                const o = H1(Xs(mn(t.getRoot()), '*[data-mce-selected="inline-boundary"]'), (e)=>e.dom
                ), r = K1(o, e640), s = K1(n, e640);
                $1(oe1(r, s), O1(Sx, !1)), $1(oe1(s, r), O1(Sx, !0));
            })(n276, e639.dom, o152.parents), ((e641, t)=>{
                if (e641.selection.isCollapsed() && !0 !== e641.composing && t.get()) {
                    const n = Ua.fromRangeStart(e641.selection.getRng());
                    Ua.isTextPosition(n) && !1 === ((e)=>Cr(e) || xr(e)
                    )(n) && (kx(e641, ld(t.get(), n)), t.set(null));
                }
            })(e639, t442), ((e642, t, n, o)=>{
                if (t.selection.isCollapsed()) {
                    const r81 = K1(o, e642);
                    $1(r81, (o)=>{
                        const r = Ua.fromRangeStart(t.selection.getRng());
                        FC(e642, t.getBody(), r).bind((e)=>_x(t, n, e)
                        );
                    });
                }
            })(n276, e639, t442, o152.parents));
        }), t442;
    }, Ax = O1(Nx, !0), Ox = O1(Nx, !1), Tx = (e, t443, n277)=>{
        if (ml(e)) {
            const o153 = xx(e, t443).getOrThunk(()=>{
                const n = e.selection.getRng();
                return t443 ? Ua.fromRangeEnd(n) : Ua.fromRangeStart(n);
            });
            return FC(O1(By, e), e.getBody(), o153).exists((t444)=>{
                const o = jC(t444);
                return NC(n277, o).exists((t)=>(kx(e, t), !0)
                );
            });
        }
        return !1;
    }, Bx = (e, t445)=>(n)=>NC(t445, n).map((t)=>()=>kx(e, t)
            )
    , Dx = (e643, t446, n278, o)=>{
        const r = e643.getBody(), s = O1(By, e643);
        e643.undoManager.ignore(()=>{
            e643.selection.setRng(((e, t)=>{
                const n = document.createRange();
                return n.setStart(e.container(), e.offset()), n.setEnd(t.container(), t.offset()), n;
            })(n278, o)), Fy(e643), FC(s, r, Ua.fromRangeStart(e643.selection.getRng())).map(VC).bind(Bx(e643, t446)).each(D1);
        }), e643.nodeChanged();
    }, Lx = (e644, t447, n279)=>{
        if (e644.selection.isCollapsed() && ml(e644)) {
            const o155 = Ua.fromRangeStart(e644.selection.getRng());
            return ((e645, t448, n280, o157)=>{
                const r83 = ((e, t)=>Od(t, e) || e
                )(e645.getBody(), o157.container()), s = O1(By, e645), a = FC(s, r83, o157);
                return a.bind((e)=>n280 ? e.fold(N1(M1.some(VC(e))), M1.none, N1(M1.some(jC(e))), M1.none) : e.fold(M1.none, N1(M1.some(jC(e))), M1.none, N1(M1.some(VC(e))))
                ).map(Bx(e645, t448)).getOrThunk(()=>{
                    const i = ac(n280, r83, o157), l = i.bind((e)=>FC(s, r83, e)
                    );
                    return Lt(a, l, ()=>Dy(s, r83, o157).bind((t449)=>((e646)=>Lt(uc(e646), mc(e646), (t, n)=>{
                                    const o = Ly(!0, t), r = Ly(!1, n);
                                    return dc(e646, o).forall((e)=>e.isEqual(r)
                                    );
                                }).getOr(!0)
                            )(t449) ? M1.some(()=>{
                                Lg(e645, n280, mn(t449));
                            }) : M1.none()
                        )
                    ).getOrThunk(()=>l.bind(()=>i.map((r)=>()=>{
                                    n280 ? Dx(e645, t448, o157, r) : Dx(e645, t448, r, o157);
                                }
                            )
                        )
                    );
                });
            })(e644, t447, n279, o155);
        }
        return M1.none();
    }, Px = (e)=>1 === Tn(e)
    , Mx = (e647, t450)=>{
        const n281 = mn(e647.getBody()), o158 = mn(e647.selection.getStart()), r84 = K1(((e648, t)=>{
            const n = Qf(t, e648);
            return J1(n, Zo).fold(N1(n), (e)=>n.slice(0, e)
            );
        })(n281, o158), Px);
        return le1(r84).bind((n282)=>{
            const o159 = Ua.fromRangeStart(e647.selection.getRng());
            var s46;
            return !((e649, t, n)=>Lt(uc(n), mc(n), (o, r)=>{
                    const s = Ly(!0, o), a = Ly(!1, r), i = Ly(!1, t);
                    return e649 ? dc(n, i).exists((e)=>e.isEqual(a) && t.isEqual(s)
                    ) : cc(n, i).exists((e)=>e.isEqual(s) && t.isEqual(a)
                    );
                }).getOr(!0)
            )(t450, o159, n282.dom) || gc((s46 = n282).dom) && Up(s46.dom) ? M1.none() : M1.some(()=>((e650, t451, n283, o160)=>{
                    const r = O1(Kp, t451), s = H1(K1(o160, r), (e)=>e.dom
                    );
                    if (0 === s.length) Lg(t451, e650, n283);
                    else {
                        const e651 = ((e, t)=>{
                            const n = jp(!1), o = qp(t, n.dom);
                            return Yn(mn(e), n), to(mn(e)), Ua(o, 0);
                        })(n283.dom, s);
                        t451.selection.setRng(e651.toRange());
                    }
                })(t450, e647, n282, r84)
            );
        });
    }, Ix = (e, t)=>e.selection.isCollapsed() ? Mx(e, t) : M1.none()
    , Fx = (e, t, n)=>M1.some(()=>{
            e._selectionOverrides.hideFakeCaret(), Lg(e, t, mn(n));
        })
    , Ux = (e653, t452)=>e653.selection.isCollapsed() ? ((e654, t)=>{
            const n284 = t ? Vf : Hf, o = t ? $d.Forwards : $d.Backwards, r = zd(o, e654.getBody(), e654.selection.getRng());
            return n284(r) ? Fx(e654, t, r.getNode(!t)) : M1.from(Ly(t, r)).filter((e)=>n284(e) && Hd(r, e)
            ).map((n)=>()=>Fx(e654, t, n.getNode(!t))
            );
        })(e653, t452) : ((e, t)=>{
            const n = e.selection.getNode();
            return Fo(n) ? Fx(e, t, n) : M1.none();
        })(e653, t452)
    , zx = (e)=>{
        const t = parseInt(e, 10);
        return isNaN(t) ? 0 : t;
    }, jx = (e, t)=>(e || "table" === Mt(t) ? "margin" : "padding") + ("rtl" === $n(t, "direction") ? "-right" : "-left")
    , Vx = (e655)=>{
        const t453 = $x(e655);
        return !e655.mode.isReadOnly() && (t453.length > 1 || ((e, t454)=>te1(t454, (t)=>{
                const n = jx(Xi(e), t), o = Wn(t, n).map(zx).getOr(0);
                return "false" !== e.dom.getContentEditable(t.dom) && o > 0;
            })
        )(e655, t453));
    }, Hx = (e)=>or(e) || rr(e)
    , $x = (e656)=>{
        var t;
        return K1((t = e656.selection.getSelectedBlocks(), H1(t, mn)), (e657)=>!Hx(e657) && !((e)=>wn(e).exists(Hx)
            )(e657) && $o(e657, (e)=>Po(e.dom) || Mo(e.dom)
            ).exists((e)=>Po(e.dom)
            )
        );
    }, qx = (e658, t455)=>{
        const { dom: n285  } = e658, o161 = Qi(e658), r85 = /[a-z%]+$/i.exec(o161)[0], s47 = parseInt(o161, 10), a36 = Xi(e658);
        $1($x(e658), (e659)=>{
            ((e, t, n, o, r, s)=>{
                const a = jx(n, mn(s));
                if ("outdent" === t) {
                    const t = Math.max(0, zx(s.style[a]) - o);
                    e.setStyle(s, a, t ? t + r : "");
                } else {
                    const t = zx(s.style[a]) + o + r;
                    e.setStyle(s, a, t);
                }
            })(n285, t455, a36, s47, r85, e659.dom);
        });
    }, Wx = (e)=>qx(e, "outdent")
    , Kx = (e)=>{
        if (e.selection.isCollapsed() && Vx(e)) {
            const t = e.dom, n = e.selection.getRng(), o = Ua.fromRangeStart(n), r = t.getParent(n.startContainer, t.isBlock);
            if (null !== r && ng(mn(r), o)) return M1.some(()=>Wx(e)
            );
        }
        return M1.none();
    }, Gx = (e660, t456, n286)=>ce1([
            Kx,
            hC,
            cC,
            (e, n)=>Lx(e, t456, n)
            ,
            Jy,
            ap,
            bC,
            Ux,
            tC,
            Ix
        ], (t)=>t(e660, n286)
        )
    , Yx = (e661, t457)=>{
        e661.addCommand("delete", ()=>{
            ((e, t)=>{
                Gx(e, t, !1).fold(()=>{
                    Fy(e), jy(e);
                }, D1);
            })(e661, t457);
        }), e661.addCommand("forwardDelete", ()=>{
            ((e662, t)=>{
                Gx(e662, t, !0).fold(()=>((e)=>Iy(e, "ForwardDelete")
                    )(e662)
                , D1);
            })(e661, t457);
        });
    }, Xx = (e)=>void 0 === e.touches || 1 !== e.touches.length ? M1.none() : M1.some(e.touches[0])
    , Qx = (e, t)=>we1(e, t.nodeName)
    , Jx = (e, t)=>!!No(t) || !!yo(t) && !Qx(e, t) && !_c(t)
    , Zx = (e, t)=>{
        if (No(t)) {
            if (0 === t.nodeValue.length) return !0;
            if (/^\s+$/.test(t.nodeValue) && (!t.nextSibling || Qx(e, t.nextSibling))) return !0;
        }
        return !1;
    }, ew = (e663)=>{
        const t458 = e663.dom, n287 = e663.selection, o = e663.schema, r = o.getBlockElements();
        let s = n287.getStart();
        const a = e663.getBody();
        let i, l, d;
        const c = Ti(e663);
        if (!s || !yo(s)) return;
        const u = a.nodeName.toLowerCase();
        if (!o.isValidChild(u, c.toLowerCase()) || ((e, t459, n)=>V1(Xf(mn(n), mn(t459)), (t)=>Qx(e, t.dom)
            )
        )(r, a, s)) return;
        const m = n287.getRng(), f = m.startContainer, g = m.startOffset, p = m.endContainer, h = m.endOffset, b = nf(e663);
        for(s = a.firstChild; s;)if (Jx(r, s)) {
            if (Zx(r, s)) {
                l = s, s = s.nextSibling, t458.remove(l);
                continue;
            }
            i || (i = t458.create(c, Bi(e663)), s.parentNode.insertBefore(i, s), d = !0), l = s, s = s.nextSibling, i.appendChild(l);
        } else i = null, s = s.nextSibling;
        d && b && (m.setStart(f, g), m.setEnd(p, h), n287.setRng(m), e663.nodeChanged());
    }, tw = (e)=>(t)=>-1 !== (" " + t.attr("class") + " ").indexOf(e)
    , nw = (e664, t, n)=>function(o) {
            const r = arguments, s = r[r.length - 2], a = s > 0 ? t.charAt(s - 1) : "";
            if ('"' === a) return o;
            if (">" === a) {
                const e = t.lastIndexOf("<", s);
                if (-1 !== e && -1 !== t.substring(e, s).indexOf('contenteditable="false"')) return o;
            }
            return '<span class="' + n + '" data-mce-content="' + e664.dom.encode(r[0]) + '">' + e664.dom.encode("string" == typeof r[1] ? r[1] : r[0]) + "</span>";
        }
    , ow = (e, t)=>{
        t.hasAttribute("data-mce-caret") && (Sr(t), e.selection.setRng(e.selection.getRng()), e.selection.scrollIntoView(t));
    }, rw = (e665, t)=>{
        const n = ((e666)=>Wo(mn(e666.getBody()), "*[data-mce-caret]").map((e)=>e.dom
            ).getOrNull()
        )(e665);
        if (n) return "compositionstart" === t.type ? (t.preventDefault(), t.stopPropagation(), void ow(e665, n)) : void (yr(n) && (ow(e665, n), e665.undoManager.add()));
    }, sw = Mo, aw = (e667, t460, n)=>{
        const o = tc(e667.getBody()), r = O1(Vd, 1 === t460 ? o.next : o.prev);
        if (n.collapsed) {
            const o = e667.dom.getParent(n.startContainer, "PRE");
            if (!o) return;
            if (!r(Ua.fromRangeStart(n))) {
                const n = mn(((e)=>{
                    const t = e.dom.create(Ti(e));
                    return t.innerHTML = '<br data-mce-bogus="1">', t;
                })(e667));
                1 === t460 ? Xn(mn(o), n) : Yn(mn(o), n), e667.selection.select(n.dom, !0), e667.selection.collapse();
            }
        }
    }, iw = (e668, t461)=>((e669, t462)=>{
            const n288 = t462 ? $d.Forwards : $d.Backwards, o = e669.selection.getRng();
            return ((e, t, n)=>yx(t, e, n, Wf, Kf, sw)
            )(n288, e669, o).orThunk(()=>(aw(e669, n288, o), M1.none())
            );
        })(e668, t461).exists((t)=>(bx(e668, t), !0)
        )
    , lw = (e670, t463)=>((e671, t464)=>{
            const n289 = t464 ? 1 : -1, o = e671.selection.getRng();
            return ((e672, t, n)=>Cx(t, e672, n, (e)=>Wf(e) || $f(e)
                , (e)=>Kf(e) || qf(e)
                , sw)
            )(n289, e671, o).orThunk(()=>(aw(e671, n289, o), M1.none())
            );
        })(e670, t463).exists((t)=>(bx(e670, t), !0)
        )
    , dw = (e, t)=>wx(e, t, t ? Kf : Wf)
    , cw = (e)=>j1([
            "figcaption"
        ], Mt(e))
    , uw = (e673, t465)=>{
        const n290 = mn(e673.getBody()), o162 = Ua.fromRangeStart(e673.selection.getRng()), r86 = Ti(e673), s48 = Bi(e673);
        return ((e, t)=>{
            const n = O1(bn, t);
            return $o(mn(e.container()), Zo, n).filter(cw);
        })(o162, n290).exists(()=>{
            if (((e674, t466, n)=>t466 ? ((e, t)=>nx(e, t).breakAt.isNone()
                )(e674.dom, n) : ((e, t)=>tx(e, t).breakAt.isNone()
                )(e674.dom, n)
            )(n290, t465, o162)) {
                const o163 = ((e675, t467, n291, o)=>{
                    const r = cn(n291), s = cn("br");
                    return qt(r, o), Jn(r, s), ((e, t, n)=>{
                        n ? Jn(e, t) : Qn(e, t);
                    })(e675, r, t467), ((e)=>{
                        const t = document.createRange();
                        return t.setStartBefore(e.dom), t.setEndBefore(e.dom), t;
                    })(s);
                })(n290, t465, r86, s48);
                return e673.selection.setRng(o163), !0;
            }
            return !1;
        });
    }, mw = (e, t)=>!!e.selection.isCollapsed() && uw(e, t)
    , fw = {
        shiftKey: !1,
        altKey: !1,
        ctrlKey: !1,
        metaKey: !1,
        keyCode: 0
    }, gw = (e, t)=>t.keyCode === e.keyCode && t.shiftKey === e.shiftKey && t.altKey === e.altKey && t.ctrlKey === e.ctrlKey && t.metaKey === e.metaKey
    , pw = (e, ...t)=>()=>e.apply(null, t)
    , hw = (e676, t468)=>Q1(((e677, t)=>ee1(((e678)=>H1(e678, (e)=>({
                        ...fw,
                        action: S1,
                        ...e
                    })
                )
            )(e677), (e)=>gw(e, t) ? [
                    e
                ] : []
            )
        )(e676, t468), (e)=>e.action()
        )
    , bw = (e679, t469)=>ce1(((e680, t)=>ee1(((e681)=>H1(e681, (e)=>({
                        ...fw,
                        action: ()=>M1.none()
                        ,
                        ...e
                    })
                )
            )(e680), (e)=>gw(e, t) ? [
                    e
                ] : []
            )
        )(e679, t469), (e)=>e.action()
        )
    , vw = (e, t470)=>{
        const n = t470 ? $d.Forwards : $d.Backwards, o = e.selection.getRng();
        return yx(e, n, o, Vf, Hf, Fo).exists((t)=>(bx(e, t), !0)
        );
    }, yw = (e, t471)=>{
        const n = t471 ? 1 : -1, o = e.selection.getRng();
        return Cx(e, n, o, Vf, Hf, Fo).exists((t)=>(bx(e, t), !0)
        );
    }, Cw = (e, t)=>wx(e, t, t ? Hf : Vf)
    , xw = ci([
        {
            none: [
                "current"
            ]
        },
        {
            first: [
                "current"
            ]
        },
        {
            middle: [
                "current",
                "target"
            ]
        },
        {
            last: [
                "current"
            ]
        }
    ]), ww = {
        ...xw,
        none: (e)=>xw.none(e)
    }, kw = (e682, t, n)=>ee1(Nn(e682), (e)=>pn(e, t) ? n(e) ? [
                e
            ] : [] : kw(e, t, n)
        )
    , Sw = (e, t)=>Ko(e, "table", t)
    , _w = (e, t, n, o, r = P1)=>{
        const s = 1 === o;
        if (!s && n <= 0) return ww.first(e[0]);
        if (s && n >= e.length - 1) return ww.last(e[e.length - 1]);
        {
            const s = n + o, a = e[s];
            return r(a) ? ww.middle(t, a) : _w(e, t, s, o, r);
        }
    }, Ew = (e683, t472)=>Sw(e683, t472).bind((t473)=>{
            const n = kw(t473, "th,td", P1);
            return J1(n, (t)=>bn(e683, t)
            ).map((e)=>({
                    index: e,
                    all: n
                })
            );
        })
    , Nw = (e684, t = !1)=>{
        var n;
        return zn(e684) ? e684.dom.isContentEditable : (n = e684, Ko(n, "[contenteditable]")).fold(N1(t), (e)=>"true" === Rw(e)
        );
    }, Rw = (e)=>e.dom.contentEditable
    , Aw = (e685, t474, n292, o165, r87)=>{
        const s49 = Xs(mn(n292), "td,th,caption").map((e)=>e.dom
        ), a = K1(((e686, t475)=>ee1(t475, (t476)=>{
                const n = ((e, t)=>({
                        left: e.left - t,
                        top: e.top - t,
                        right: e.right + -2,
                        bottom: e.bottom + -2,
                        width: e.width + t,
                        height: e.height + t
                    })
                )(ma(t476.getBoundingClientRect()), -1);
                return [
                    {
                        x: n.left,
                        y: e686(n),
                        cell: t476
                    },
                    {
                        x: n.right,
                        y: e686(n),
                        cell: t476
                    }
                ];
            })
        )(e685, s49), (e)=>t474(e, r87)
        );
        return ((e687, t, n)=>Y1(e687, (e688, o)=>e688.fold(()=>M1.some(o)
                , (e)=>{
                    const r = Math.sqrt(Math.abs(e.x - t) + Math.abs(e.y - n)), s = Math.sqrt(Math.abs(o.x - t) + Math.abs(o.y - n));
                    return M1.some(s < r ? o : e);
                })
            , M1.none())
        )(a, o165, r87).map((e)=>e.cell
        );
    }, Ow = O1(Aw, (e)=>e.bottom
    , (e, t)=>e.y < t
    ), Tw = O1(Aw, (e)=>e.top
    , (e, t)=>e.y > t
    ), Bw = (e689, t477, n293)=>{
        const o = e689(t477, n293);
        return ((e)=>e.breakType === KC.Wrap && 0 === e.positions.length
        )(o) || !Do(n293.getNode()) && ((e)=>e.breakType === KC.Br && 1 === e.positions.length
        )(o) ? !((e, t, n294)=>n294.breakAt.exists((n)=>e(t, n).breakAt.isSome()
            )
        )(e689, t477, o) : o.breakAt.isNone();
    }, Dw = O1(Bw, tx), Lw = O1(Bw, nx), Pw = (e690, t478, n295, o166)=>{
        const r = e690.selection.getRng(), s = t478 ? 1 : -1;
        return !(!pd() || !((e691, t, n)=>{
            const o = Ua.fromRangeStart(t);
            return lc(!e691, n).exists((e)=>e.isEqual(o)
            );
        })(t478, r, n295) || (rC(s, e690, n295, !t478, !1).each((t)=>{
            bx(e690, t);
        }), 0));
    }, Mw = (e692, t479, n296)=>{
        const o167 = ((e, t)=>{
            const n = t.getNode(e);
            return yo(n) && "TABLE" === n.nodeName ? M1.some(n) : M1.none();
        })(!!t479, n296), r88 = !1 === t479;
        o167.fold(()=>bx(e692, n296.toRange())
        , (o168)=>lc(r88, e692.getBody()).filter((e)=>e.isEqual(n296)
            ).fold(()=>bx(e692, n296.toRange())
            , (n297)=>((e, t, n)=>{
                    const o = Ti(t);
                    t.undoManager.transact(()=>{
                        const r = cn(o);
                        qt(r, Bi(t)), Jn(r, cn("br")), e ? Xn(mn(n), r) : Yn(mn(n), r);
                        const s = t.dom.createRng();
                        s.setStart(r.dom, 0), s.setEnd(r.dom, 0), bx(t, s);
                    });
                })(t479, e692, o168)
            )
        );
    }, Iw = (e693, t480, n298, o)=>{
        const r = e693.selection.getRng(), s = Ua.fromRangeStart(r), a = e693.getBody();
        if (!t480 && Dw(o, s)) {
            const o = ((e694, t481, n299)=>((e695, t482)=>ie1(t482.getClientRects()).bind((t)=>Ow(e695, t.left, t.top)
                    ).bind((e696)=>{
                        var n;
                        return ex(mc(n = e696).map((e)=>tx(n, e).positions.concat(e)
                        ).getOr([]), t482);
                    })
                )(t481, n299).orThunk(()=>ie1(n299.getClientRects()).bind((n)=>ZC(ox(e694, Ua.before(t481)), n.left)
                    )
                ).getOr(Ua.before(t481))
            )(a, n298, s);
            return Mw(e693, t480, o), !0;
        }
        if (t480 && Lw(o, s)) {
            const o = ((e697, t483, n300)=>((e698, t484)=>le1(t484.getClientRects()).bind((t)=>Tw(e698, t.left, t.top)
                    ).bind((e699)=>{
                        var n;
                        return ex(uc(n = e699).map((e)=>[
                                e
                            ].concat(nx(n, e).positions)
                        ).getOr([]), t484);
                    })
                )(t483, n300).orThunk(()=>ie1(n300.getClientRects()).bind((n)=>ZC(rx(e697, Ua.after(t483)), n.left)
                    )
                ).getOr(Ua.after(t483))
            )(a, n298, s);
            return Mw(e693, t480, o), !0;
        }
        return !1;
    }, Fw = (e, t, n)=>M1.from(e.dom.getParent(e.selection.getNode(), "td,th")).bind((o)=>M1.from(e.dom.getParent(o, "table")).map((r)=>n(e, t, r, o)
            )
        ).getOr(!1)
    , Uw = (e, t)=>Fw(e, t, Pw)
    , zw = (e, t)=>Fw(e, t, Iw)
    , jw = (e700, t485, n301)=>n301.fold(M1.none, M1.none, (e701, t486)=>{
            var n302;
            return (n302 = t486, ((e702, t)=>{
                const n = (e)=>{
                    for(let o = 0; o < e.childNodes.length; o++){
                        const r = mn(e.childNodes[o]);
                        if (t(r)) return M1.some(r);
                        const s = n(e.childNodes[o]);
                        if (s.isSome()) return s;
                    }
                    return M1.none();
                };
                return n(e702.dom);
            })(n302, uf)).map((e703)=>((e)=>{
                    const t = Xu.exact(e, 0, e, 0);
                    return tm(t);
                })(e703)
            );
        }, (n)=>(e700.execCommand("mceTableInsertRowAfter"), Vw(e700, t485, n))
        )
    , Vw = (e704, t, n)=>{
        var o, r;
        return jw(e704, t, (r = Nw, Ew(o = n, void 0).fold(()=>ww.none(o)
        , (e)=>_w(e.all, o, e.index, 1, r)
        )));
    }, Hw = (e705, t, n)=>{
        var o, r;
        return jw(e705, t, (r = Nw, Ew(o = n, void 0).fold(()=>ww.none()
        , (e)=>_w(e.all, o, e.index, -1, r)
        )));
    }, $w = (e706, t487)=>{
        const n303 = [
            "table",
            "li",
            "dl"
        ], o = mn(e706.getBody()), r = (e)=>{
            const t = Mt(e);
            return bn(e, o) || j1(n303, t);
        }, s = e706.selection.getRng();
        return ((e707, t488)=>((e708, t, n = L1)=>n(t) ? M1.none() : j1(e708, Mt(t)) ? M1.some(t) : qo(t, e708.join(","), (e)=>pn(e, "table") || n(e)
                )
            )([
                "td",
                "th"
            ], e707, t488)
        )(mn(t487 ? s.endContainer : s.startContainer), r).map((n)=>(Sw(n, r).each((t)=>{
                e706.model.table.clearSelectedCells(t.dom);
            }), e706.selection.collapse(!t487), (t487 ? Vw : Hw)(e706, r, n).each((t)=>{
                e706.selection.setRng(t);
            }), !0)
        ).getOr(!1);
    }, qw = (e, t)=>({
            container: e,
            offset: t
        })
    , Ww = Is.DOM, Kw = (e)=>(t)=>e === t ? -1 : 0
    , Gw = (e709, t, n)=>{
        if (No(e709) && t >= 0) return M1.some(qw(e709, t));
        {
            const o = ca(Ww);
            return M1.from(o.backwards(e709, t, Kw(e709), n)).map((e)=>qw(e.container, e.container.data.length)
            );
        }
    }, Yw = (e710, t, n)=>{
        if (!No(e710)) return M1.none();
        const o = e710.textContent;
        if (t >= 0 && t <= o.length) return M1.some(qw(e710, t));
        {
            const o169 = ca(Ww);
            return M1.from(o169.backwards(e710, t, Kw(e710), n)).bind((e)=>{
                const o = e.container.data;
                return Yw(e.container, t + o.length, n);
            });
        }
    }, Xw = (e711, t, n)=>{
        if (!No(e711)) return M1.none();
        const o = e711.textContent;
        if (t <= o.length) return M1.some(qw(e711, t));
        {
            const r = ca(Ww);
            return M1.from(r.forwards(e711, t, Kw(e711), n)).bind((e)=>Xw(e.container, t - o.length, n)
            );
        }
    }, Qw = (e712, t489, n, o, r)=>{
        const s = ca(e712, ((e)=>(t)=>e.isBlock(t) || j1([
                    "BR",
                    "IMG",
                    "HR",
                    "INPUT"
                ], t.nodeName) || "false" === e.getContentEditable(t)
        )(e712));
        return M1.from(s.backwards(t489, n, o, r));
    }, Jw = (e)=>e.toString().replace(/\u00A0/g, " ").replace(/\uFEFF/g, "")
    , Zw = (e)=>"" !== e && -1 !== " \xa0\f\n\r\t\v".indexOf(e)
    , ek = (e, t)=>e.substring(t.length)
    , tk = (e713, t490, n304, o170 = 0)=>{
        var r89;
        return (r89 = mn(t490.startContainer), Ko(r89, mf)).fold(()=>((e714, t491, n305, o171 = 0)=>{
                if (!(r90 = t491).collapsed || 3 !== r90.startContainer.nodeType) return M1.none();
                var r90;
                const s50 = e714.getParent(t491.startContainer, e714.isBlock) || e714.getRoot();
                return Qw(e714, t491.startContainer, t491.startOffset, (e715, t492, o172)=>((e, t, n)=>{
                        let o;
                        for(o = t - 1; o >= 0; o--){
                            const t = e.charAt(o);
                            if (Zw(t)) return M1.none();
                            if (t === n) break;
                        }
                        return M1.some(o);
                    })(o172, t492, n305).getOr(t492)
                , s50).bind((e)=>{
                    const r = t491.cloneRange();
                    if (r.setStart(e.container, e.offset), r.setEnd(t491.endContainer, t491.endOffset), r.collapsed) return M1.none();
                    const s = Jw(r);
                    return 0 !== s.lastIndexOf(n305) || ek(s, n305).length < o171 ? M1.none() : M1.some({
                        text: ek(s, n305),
                        range: r,
                        triggerChar: n305
                    });
                });
            })(e713, t490, n304, o170)
        , (t)=>{
            const o = e713.createRng();
            o.selectNode(t.dom);
            const r = Jw(o);
            return M1.some({
                range: o,
                text: ek(r, n304),
                triggerChar: n304
            });
        });
    }, nk = (e716)=>{
        if (((e)=>3 === e.nodeType
        )(e716)) return qw(e716, e716.data.length);
        {
            const t = e716.childNodes;
            return t.length > 0 ? nk(t[t.length - 1]) : qw(e716, t.length);
        }
    }, ok = (e717, t)=>{
        const n = e717.childNodes;
        return n.length > 0 && t < n.length ? ok(n[t], 0) : n.length > 0 && ((e)=>1 === e.nodeType
        )(e717) && n.length === t ? nk(n[n.length - 1]) : qw(e717, t);
    }, rk = (e718, t493, n306, o = {})=>{
        const r = t493(), s = e718.selection.getRng().startContainer.nodeValue, a = K1(r.lookupByChar(n306.triggerChar), (t494)=>n306.text.length >= t494.minChars && t494.matches.getOrThunk(()=>((e719)=>(t495)=>{
                        const n = ok(t495.startContainer, t495.startOffset);
                        return !((e720, t496)=>Qw(e720, t496.container, t496.offset, (e, t)=>0 === t ? -1 : t
                            , e720.getRoot()).filter((e)=>{
                                const t = e.container.data.charAt(e.offset - 1);
                                return !Zw(t);
                            }).isSome()
                        )(e719, n);
                    }
                )(e718.dom)
            )(n306.range, s, n306.text)
        );
        if (0 === a.length) return M1.none();
        const i = Promise.all(H1(a, (e)=>e.fetch(n306.text, e.maxResults, o).then((t)=>({
                    matchText: n306.text,
                    items: t,
                    columns: e.columns,
                    onAction: e.onAction,
                    highlightOn: e.highlightOn
                })
            )
        ));
        return M1.some({
            lookupData: i,
            context: n306
        });
    };
    var sk;
    !function(e) {
        e[e.Error = 0] = "Error", e[e.Value = 1] = "Value";
    }(sk || (sk = {}));
    const ak = (e, t, n)=>e.stype === sk.Error ? t(e.serror) : n(e.svalue)
    , ik = (e)=>({
            stype: sk.Value,
            svalue: e
        })
    , lk = (e)=>({
            stype: sk.Error,
            serror: e
        })
    , dk = ak, ck = (e)=>f1(e) && ue1(e).length > 100 ? " removed due to size" : JSON.stringify(e, null, 2)
    , uk = (e, t)=>lk([
            {
                path: e,
                getErrorInfo: t
            }
        ])
    , mk = (e721, t497)=>({
            extract: (n307, o173)=>xe1(o173, e721).fold(()=>((e, t)=>uk(e, ()=>'Choice schema did not contain choice key: "' + t + '"'
                        )
                    )(n307, e721)
                , (e722)=>((e723, t498, n308, o)=>xe1(n308, o).fold(()=>((e, t, n)=>uk(e, ()=>'The chosen schema: "' + n + '" did not exist in branches: ' + ck(t)
                                )
                            )(e723, n308, o)
                        , (n)=>n.extract(e723.concat([
                                "branch: " + o
                            ]), t498)
                        )
                    )(n307, o173, t497, e722)
                )
            ,
            toString: ()=>"chooseOn(" + e721 + "). Possible values: " + ue1(t497)
        })
    , fk = (e)=>(...t)=>{
            if (0 === t.length) throw new Error("Can't merge zero objects");
            const n = {};
            for(let o = 0; o < t.length; o++){
                const r = t[o];
                for(const t499 in r)we1(r, t499) && (n[t499] = e(n[t499], r[t499]));
            }
            return n;
        }
    , gk = fk((e, t)=>g1(e) && g1(t) ? gk(e, t) : t
    ), pk = (fk((e, t)=>t
    ), (e)=>({
            tag: "defaultedThunk",
            process: N1(e)
        })
    ), hk = (e724)=>{
        const t500 = ((e725)=>{
            const t = [], n = [];
            return $1(e725, (e726)=>{
                ak(e726, (e)=>n.push(e)
                , (e)=>t.push(e)
                );
            }), {
                values: t,
                errors: n
            };
        })(e724);
        var n309;
        return t500.errors.length > 0 ? (n309 = t500.errors, _1(lk, Z1)(n309)) : ik(t500.values);
    }, bk = (e, t, n)=>{
        switch(e.tag){
            case "field":
                return t(e.key, e.newKey, e.presence, e.prop);
            case "custom":
                return n(e.newKey, e.instantiator);
        }
    }, vk = (e727)=>({
            extract: (t501, n)=>{
                var o, r;
                return o = e727(n), r = (e728)=>((e, t)=>uk(e, N1(t))
                    )(t501, e728)
                , o.stype === sk.Error ? r(o.serror) : o;
            },
            toString: N1("val")
        })
    , yk = vk(ik), Ck = (e, t, n, o)=>o(xe1(e, t).getOrThunk(()=>n(e)
        ))
    , xk = (e729, t502, n310, o174, r)=>{
        const s51 = (e)=>r.extract(t502.concat([
                o174
            ]), e)
        , a37 = (e730)=>e730.fold(()=>ik(M1.none())
            , (e)=>{
                const n = r.extract(t502.concat([
                    o174
                ]), e);
                var s, a;
                return s = n, a = M1.some, s.stype === sk.Value ? {
                    stype: sk.Value,
                    svalue: a(s.svalue)
                } : s;
            })
        ;
        switch(e729.tag){
            case "required":
                return ((e731, t503, n311, o)=>xe1(t503, n311).fold(()=>((e, t, n)=>uk(e, ()=>'Could not find valid *required* value for "' + t + '" in ' + ck(n)
                            )
                        )(e731, n311, t503)
                    , o)
                )(t502, n310, o174, s51);
            case "defaultedThunk":
                return Ck(n310, o174, e729.process, s51);
            case "option":
                return ((e, t, n)=>n(xe1(e, t))
                )(n310, o174, a37);
            case "defaultedOptionThunk":
                return ((e, t504, n, o)=>o(xe1(e, t504).map((t)=>!0 === t ? n(e) : t
                    ))
                )(n310, o174, e729.process, a37);
            case "mergeWithThunk":
                return Ck(n310, o174, N1({}), (t)=>{
                    const o = gk(e729.process(n310), t);
                    return s51(o);
                });
        }
    }, wk = (e732)=>({
            extract: (t505, n312)=>((e733, t, n313)=>{
                    const o = {}, r = [];
                    for (const s52 of n313)bk(s52, (n, s, a, i)=>{
                        const l = xk(a, e733, t, n, i);
                        dk(l, (e)=>{
                            r.push(...e);
                        }, (e)=>{
                            o[s] = e;
                        });
                    }, (e, n)=>{
                        o[e] = n(t);
                    });
                    return r.length > 0 ? lk(r) : ik(o);
                })(t505, n312, e732)
            ,
            toString: ()=>{
                const t = H1(e732, (e734)=>bk(e734, (e, t, n, o)=>e + " -> " + o.toString()
                    , (e, t)=>"state(" + e + ")"
                    )
                );
                return "obj{\n" + t.join("\n") + "}";
            }
        })
    , kk = (e)=>({
            extract: (t, n314)=>{
                const o175 = H1(n314, (n, o)=>e.extract(t.concat([
                        "[" + o + "]"
                    ]), n)
                );
                return hk(o175);
            },
            toString: ()=>"array(" + e.toString() + ")"
        })
    , Sk = (e735, t506, n315)=>{
        var o;
        return o = ((e736, t507, n)=>((e, t)=>e.stype === sk.Error ? {
                    stype: sk.Error,
                    serror: t(e.serror)
                } : e
            )(t507.extract([
                e736
            ], n), (e)=>({
                    input: n,
                    errors: e
                })
            )
        )(e735, t506, n315), ak(o, di.error, di.value);
    }, _k = (e, t)=>mk(e, ge1(t, wk))
    , Ek = N1(yk), Nk = (e, t)=>vk((n)=>{
            const o = typeof n;
            return e(n) ? ik(n) : lk(`Expected type: ${t} but got: ${o}`);
        })
    , Rk = Nk(w1, "number"), Ak = Nk(m1, "string"), Ok = Nk(b1, "boolean"), Tk = Nk(x1, "function"), Bk = (e, t, n, o)=>({
            tag: "field",
            key: e,
            newKey: t,
            presence: n,
            prop: o
        })
    , Dk = (e, t)=>({
            tag: "custom",
            newKey: e,
            instantiator: t
        })
    , Lk = (e, t)=>Bk(e, e, {
            tag: "required",
            process: {}
        }, t)
    , Pk = (e)=>Lk(e, Ak)
    , Mk = (e)=>Lk(e, Tk)
    , Ik = (e, t)=>Bk(e, e, {
            tag: "option",
            process: {}
        }, t)
    , Fk = (e)=>Ik(e, Ak)
    , Uk = (e, t, n)=>Bk(e, e, pk(t), n)
    , zk = (e, t)=>Uk(e, t, Rk)
    , jk = (e737, t508, n)=>Uk(e737, t508, ((e738)=>{
            var t509;
            return t509 = (t)=>j1(e738, t) ? di.value(t) : di.error(`Unsupported value: "${t}", choose one of "${e738.join(", ")}".`)
            , vk((e)=>t509(e).fold(lk, ik)
            );
        })(n))
    , Vk = (e, t)=>Uk(e, t, Ok)
    , Hk = (e, t)=>Uk(e, t, Tk)
    , $k = Pk("type"), qk = Mk("fetch"), Wk = Mk("onAction"), Kk = Hk("onSetup", ()=>S1
    ), Gk = Fk("text"), Yk = Fk("icon"), Xk = Fk("tooltip"), Qk = Fk("label"), Jk = Vk("active", !1), Zk = Vk("enabled", !0), eS = Vk("primary", !1), tS = (e)=>((e, t)=>Uk("type", t, Ak)
        )(0, e)
    , nS = wk([
        $k,
        Pk("ch"),
        zk("minChars", 1),
        ((e, t)=>Bk(e, e, pk(1), Ek())
        )("columns"),
        zk("maxResults", 10),
        Ik("matches", Tk),
        qk,
        Wk,
        (oS = Ak, Uk("highlightOn", [], kk(oS)))
    ]);
    var oS;
    const rS = [
        Zk,
        Xk,
        Yk,
        Gk,
        Kk
    ], sS = [
        Jk
    ].concat(rS), aS = [
        Hk("predicate", L1),
        jk("scope", "node", [
            "node",
            "editor"
        ]),
        jk("position", "selection", [
            "node",
            "selection",
            "line"
        ])
    ], iS = rS.concat([
        tS("contextformbutton"),
        eS,
        Wk,
        Dk("original", R1)
    ]), lS = sS.concat([
        tS("contextformbutton"),
        eS,
        Wk,
        Dk("original", R1)
    ]), dS = rS.concat([
        tS("contextformbutton")
    ]), cS = sS.concat([
        tS("contextformtogglebutton")
    ]), uS = _k("type", {
        contextformbutton: iS,
        contextformtogglebutton: lS
    });
    wk([
        tS("contextform"),
        Hk("initValue", N1("")),
        Qk,
        ((e, t)=>Bk(e, e, {
                tag: "required",
                process: {}
            }, kk(t))
        )("commands", uS),
        Ik("launch", _k("type", {
            contextformbutton: dS,
            contextformtogglebutton: cS
        }))
    ].concat(aS));
    const mS = (e739)=>{
        const t510 = e739.ui.registry.getAll().popups, n = ge1(t510, (e740)=>{
            var t511;
            return (t511 = e740, Sk("Autocompleter", nS, t511)).fold((e741)=>{
                var t512;
                throw new Error("Errors: \n" + ((e742)=>{
                    const t = e742.length > 10 ? e742.slice(0, 10).concat([
                        {
                            path: [],
                            getErrorInfo: N1("... (only showing first ten failures)")
                        }
                    ]) : e742;
                    return H1(t, (e)=>"Failed path: (" + e.path.join(" > ") + ")\n" + e.getErrorInfo()
                    );
                })((t512 = e741).errors).join("\n") + "\n\nInput object: " + ck(t512.input));
            }, R1);
        }), o = Se1(ye1(n, (e)=>e.ch
        )), r = Ce1(n);
        return {
            dataset: n,
            triggerChars: o,
            lookupByChar: (e)=>K1(r, (t)=>t.ch === e
                )
        };
    }, fS = (e743)=>{
        const t513 = Ws(), n316 = zs(!1), o176 = t513.isSet, r = ()=>{
            o176() && (((e)=>{
                Nv(e).autocompleter.removeDecoration();
            })(e743), ((e)=>{
                e.dispatch("AutocompleterEnd");
            })(e743), n316.set(!1), t513.clear());
        }, s53 = De1(()=>mS(e743)
        ), a38 = (a39)=>{
            ((n317)=>t513.get().map((t514)=>tk(e743.dom, e743.selection.getRng(), t514.triggerChar).bind((t)=>rk(e743, s53, t, n317)
                    )
                ).getOrThunk(()=>((e744, t515)=>{
                        const n318 = t515(), o = e744.selection.getRng();
                        return ((e, t, n319)=>ce1(n319.triggerChars, (n)=>tk(e, t, n)
                            )
                        )(e744.dom, o, n318).bind((n)=>rk(e744, t515, n)
                        );
                    })(e743, s53)
                )
            )(a39).fold(r, (s)=>{
                ((n)=>{
                    o176() || (((e, t)=>{
                        Nv(e).autocompleter.addDecoration(t);
                    })(e743, n.range), t513.set({
                        triggerChar: n.triggerChar,
                        matchLength: n.text.length
                    }));
                })(s.context), s.lookupData.then((o)=>{
                    t513.get().map((a)=>{
                        const i = s.context;
                        a.triggerChar === i.triggerChar && (i.text.length - a.matchLength >= 10 ? r() : (t513.set({
                            ...a,
                            matchLength: i.text.length
                        }), n316.get() ? ((e, t)=>{
                            e.dispatch("AutocompleterUpdate", t);
                        })(e743, {
                            lookupData: o
                        }) : (n316.set(!0), ((e, t)=>{
                            e.dispatch("AutocompleterStart", t);
                        })(e743, {
                            lookupData: o
                        }))));
                    });
                });
            });
        };
        e743.addCommand("mceAutocompleterReload", (e, t)=>{
            const n = f1(t) ? t.fetchOptions : {};
            a38(n);
        }), e743.addCommand("mceAutocompleterClose", r), ((e745, t)=>{
            const n = Gs(t.load, 50);
            e745.on("keypress compositionend", (e)=>{
                27 !== e.which && n.throttle();
            }), e745.on("keydown", (e)=>{
                const o = e.which;
                8 === o ? n.throttle() : 27 === o && t.cancelIfNecessary();
            }), e745.on("remove", n.cancel);
        })(e743, {
            cancelIfNecessary: r,
            load: a38
        });
    }, gS = (e)=>(t, n, o = {})=>{
            const r = t.getBody(), s = {
                bubbles: !0,
                composed: !0,
                data: null,
                isComposing: !1,
                detail: 0,
                view: null,
                target: r,
                currentTarget: r,
                eventPhase: Event.AT_TARGET,
                originalTarget: r,
                explicitOriginalTarget: r,
                isTrusted: !1,
                srcElement: r,
                cancelable: !1,
                preventDefault: S1,
                inputType: n
            }, a = xs(new InputEvent(e));
            return t.dispatch(e, {
                ...a,
                ...s,
                ...o
            });
        }
    , pS = gS("input"), hS = gS("beforeinput"), bS = (e747, t)=>{
        let n, o = t;
        const r = e747.dom, s = e747.schema.getMoveCaretBeforeOnEnterElements();
        if (!t) return;
        if (/^(LI|DT|DD)$/.test(t.nodeName)) {
            const e746 = ((e)=>{
                for(; e;){
                    if (1 === e.nodeType || 3 === e.nodeType && e.data && /[\r\n\s]/.test(e.data)) return e;
                    e = e.nextSibling;
                }
            })(t.firstChild);
            e746 && /^(UL|OL|DL)$/.test(e746.nodeName) && t.insertBefore(r.doc.createTextNode(dr), t.firstChild);
        }
        const a = r.createRng();
        if (t.normalize(), t.hasChildNodes()) {
            const e = new Xo(t, t);
            for(; n = e.current();){
                if (No(n)) {
                    a.setStart(n, 0), a.setEnd(n, 0);
                    break;
                }
                if (s[n.nodeName.toLowerCase()]) {
                    a.setStartBefore(n), a.setEndBefore(n);
                    break;
                }
                o = n, n = e.next();
            }
            n || (a.setStart(o, 0), a.setEnd(o, 0));
        } else Do(t) ? t.nextSibling && r.isBlock(t.nextSibling) ? (a.setStartBefore(t), a.setEndBefore(t)) : (a.setStartAfter(t), a.setEndAfter(t)) : (a.setStart(t, 0), a.setEnd(t, 0));
        e747.selection.setRng(a), Pm(e747, a);
    }, vS = (e)=>M1.from(e.dom.getParent(e.selection.getStart(!0), e.dom.isBlock))
    , yS = (e, t)=>e && e.parentNode && e.parentNode.nodeName === t
    , CS = (e)=>e && /^(OL|UL|LI)$/.test(e.nodeName)
    , xS = (e)=>{
        const t = e.parentNode;
        return /^(LI|DT|DD)$/.test(t.nodeName) ? t : e;
    }, wS = (e, t, n)=>{
        let o = e[n ? "firstChild" : "lastChild"];
        for(; o && !yo(o);)o = o[n ? "nextSibling" : "previousSibling"];
        return o === t;
    }, kS = (e, t)=>t && "A" === t.nodeName && e.isEmpty(t)
    , SS = (e)=>{
        e.innerHTML = '<br data-mce-bogus="1">';
    }, _S = (e, t)=>e.nodeName === t || e.previousSibling && e.previousSibling.nodeName === t
    , ES = (e, t)=>t && e.isBlock(t) && !/^(TD|TH|CAPTION|FORM)$/.test(t.nodeName) && !/^(fixed|absolute)/i.test(t.style.position) && "true" !== e.getContentEditable(t)
    , NS = (e, t, n)=>!1 === No(t) ? n : e ? 1 === n && t.data.charAt(n - 1) === ur ? 0 : n : n === t.data.length - 1 && t.data.charAt(n) === ur ? t.data.length : n
    , RS = (e, t)=>{
        const n = e.getRoot();
        let o, r;
        for(o = t; o !== n && "false" !== e.getContentEditable(o);)"true" === e.getContentEditable(o) && (r = o), o = o.parentNode;
        return o !== n ? r : n;
    }, AS = (e748, t516)=>{
        Ti(e748).toLowerCase() === t516.tagName.toLowerCase() && ((e749, t517, n320)=>{
            const o = e749.dom;
            M1.from(n320.style).map(o.parseStyle).each((e)=>{
                const n = {
                    ...Kn(mn(t517)),
                    ...e
                };
                o.setStyles(t517, n);
            });
            const r91 = M1.from(n320.class).map((e)=>e.split(/\s+/)
            ), s54 = M1.from(t517.className).map((e750)=>K1(e750.split(/\s+/), (e)=>"" !== e
                )
            );
            Lt(r91, s54, (e, n)=>{
                const r = K1(n, (t)=>!j1(e, t)
                ), s = [
                    ...e,
                    ...r
                ];
                o.setAttrib(t517, "class", s.join(" "));
            });
            const a = [
                "style",
                "class"
            ], i = ve1(n320, (e, t)=>!j1(a, t)
            );
            o.setAttribs(t517, i);
        })(e748, t516, Bi(e748));
    }, OS = (e751, t518)=>{
        let n321, o177, r92, s55, a40, i25, l22, d15, c10;
        const u9 = e751.dom, m6 = e751.schema, f = m6.getNonEmptyElements(), g = e751.selection.getRng(), p = Ti(e751), h = (t)=>{
            let n, r, a, i = o177;
            const l = m6.getTextInlineElements();
            if (n = t || "TABLE" === d15 || "HR" === d15 ? u9.create(t || p) : s55.cloneNode(!1), a = n, !1 === Pi(e751)) u9.setAttrib(n, "style", null), u9.setAttrib(n, "class", null);
            else do if (l[i.nodeName]) {
                if (gc(i) || _c(i)) continue;
                r = i.cloneNode(!1), u9.setAttrib(r, "id", ""), n.hasChildNodes() ? (r.appendChild(n.firstChild), n.appendChild(r)) : (a = r, n.appendChild(r));
            }
            while ((i = i.parentNode) && i !== x)
            return AS(e751, n), SS(a), n;
        }, b = (e)=>{
            let t, n;
            const a = NS(e, o177, r92);
            if (No(o177) && (e ? a > 0 : a < o177.nodeValue.length)) return !1;
            if (o177.parentNode === s55 && c10 && !e) return !0;
            if (e && yo(o177) && o177 === s55.firstChild) return !0;
            if (_S(o177, "TABLE") || _S(o177, "HR")) return c10 && !e || !c10 && e;
            const i = new Xo(o177, s55);
            for(No(o177) && (e && 0 === a ? i.prev() : e || a !== o177.nodeValue.length || i.next()); t = i.current();){
                if (yo(t)) {
                    if (!t.getAttribute("data-mce-bogus") && (n = t.nodeName.toLowerCase(), f[n] && "br" !== n)) return !1;
                } else if (No(t) && !Fr(t.nodeValue)) return !1;
                e ? i.prev() : i.next();
            }
            return !0;
        }, v = ()=>{
            a40 = /^(H[1-6]|PRE|FIGURE)$/.test(d15) && "HGROUP" !== w ? h(p) : h(), Mi(e751) && ES(u9, l22) && u9.isEmpty(s55) ? a40 = u9.split(l22, s55) : u9.insertAfter(a40, s55), bS(e751, a40);
        };
        mm(u9, g).each((e)=>{
            g.setStart(e.startContainer, e.startOffset), g.setEnd(e.endContainer, e.endOffset);
        }), o177 = g.startContainer, r92 = g.startOffset;
        const y = !(!t518 || !t518.shiftKey), C = !(!t518 || !t518.ctrlKey);
        yo(o177) && o177.hasChildNodes() && (c10 = r92 > o177.childNodes.length - 1, o177 = o177.childNodes[Math.min(r92, o177.childNodes.length - 1)] || o177, r92 = c10 && No(o177) ? o177.nodeValue.length : 0);
        const x = RS(u9, o177);
        if (!x) return;
        y || (o177 = ((e752, t, n, o, r)=>{
            let s, a, i, l, d, c;
            const u = e752.dom, m = RS(u, o);
            if (a = u.getParent(o, u.isBlock), !a || !ES(u, a)) {
                if (a = a || m, c = a === e752.getBody() || ((e)=>e && /^(TD|TH|CAPTION)$/.test(e.nodeName)
                )(a) ? a.nodeName.toLowerCase() : a.parentNode.nodeName.toLowerCase(), !a.hasChildNodes()) return s = u.create(t), AS(e752, s), a.appendChild(s), n.setStart(s, 0), n.setEnd(s, 0), s;
                for(l = o; l.parentNode !== a;)l = l.parentNode;
                for(; l && !u.isBlock(l);)i = l, l = l.previousSibling;
                if (i && e752.schema.isValidChild(c, t.toLowerCase())) {
                    for(s = u.create(t), AS(e752, s), i.parentNode.insertBefore(s, i), l = i; l && !u.isBlock(l);)d = l.nextSibling, s.appendChild(l), l = d;
                    n.setStart(o, r), n.setEnd(o, r);
                }
            }
            return o;
        })(e751, p, g, o177, r92)), s55 = u9.getParent(o177, u9.isBlock), l22 = s55 ? u9.getParent(s55.parentNode, u9.isBlock) : null, d15 = s55 ? s55.nodeName.toUpperCase() : "";
        const w = l22 ? l22.nodeName.toUpperCase() : "";
        "LI" !== w || C || (s55 = l22, l22 = l22.parentNode, d15 = w), /^(LI|DT|DD)$/.test(d15) && u9.isEmpty(s55) ? ((e755, t519, n, o, r)=>{
            const s = e755.dom, a = e755.selection.getRng();
            if (n === e755.getBody()) return;
            var i;
            CS(i = n) && CS(i.parentNode) && (r = "LI");
            let l = t519(r);
            if (wS(n, o, !0) && wS(n, o, !1)) {
                if (yS(n, "LI")) {
                    const e753 = xS(n);
                    s.insertAfter(l, e753), ((e)=>{
                        var t;
                        return (null === (t = e.parentNode) || void 0 === t ? void 0 : t.firstChild) === e;
                    })(n) ? s.remove(e753) : s.remove(n);
                } else s.replace(l, n);
            } else if (wS(n, o, !0)) yS(n, "LI") ? (s.insertAfter(l, xS(n)), l.appendChild(s.doc.createTextNode(" ")), l.appendChild(n)) : n.parentNode.insertBefore(l, n), s.remove(o);
            else if (wS(n, o, !1)) s.insertAfter(l, xS(n)), s.remove(o);
            else {
                n = xS(n);
                const e756 = a.cloneRange();
                e756.setStartAfter(o), e756.setEndAfter(n);
                const t = e756.extractContents();
                "LI" === r && ((e, t)=>e.firstChild && "LI" === e.firstChild.nodeName
                )(t) ? (l = t.firstChild, s.insertAfter(t, n)) : (s.insertAfter(t, n), s.insertAfter(l, n)), s.remove(o);
            }
            bS(e755, l);
        })(e751, h, l22, s55, p) : s55 !== e751.getBody() && (hr(s55) ? (a40 = Sr(s55), u9.isEmpty(s55) && SS(s55), AS(e751, a40), bS(e751, a40)) : b() ? v() : b(!0) ? (a40 = s55.parentNode.insertBefore(h(), s55), bS(e751, _S(s55, "HR") ? a40 : s55)) : (n321 = ((e)=>{
            const t = e.cloneRange();
            return t.setStart(e.startContainer, NS(!0, e.startContainer, e.startOffset)), t.setEnd(e.endContainer, NS(!1, e.endContainer, e.endOffset)), t;
        })(g).cloneRange(), n321.setEndAfter(s55), i25 = n321.extractContents(), ((e758)=>{
            $1(Ys(mn(e758), zt), (e)=>{
                const t = e.dom;
                t.nodeValue = fr(t.nodeValue);
            });
        })(i25), ((e)=>{
            do No(e) && (e.nodeValue = e.nodeValue.replace(/^[\r\n]+/, "")), e = e.firstChild;
            while (e)
        })(i25), a40 = i25.firstChild, u9.insertAfter(i25, s55), ((e, t, n)=>{
            let o = n;
            const r = [];
            let s;
            if (o) {
                for(; o = o.firstChild;){
                    if (e.isBlock(o)) return;
                    yo(o) && !t[o.nodeName.toLowerCase()] && r.push(o);
                }
                for(s = r.length; s--;)o = r[s], (!o.hasChildNodes() || o.firstChild === o.lastChild && "" === o.firstChild.nodeValue || kS(e, o)) && e.remove(o);
            }
        })(u9, f, a40), ((e, t)=>{
            t.normalize();
            const n = t.lastChild;
            n && !/^(left|right)$/gi.test(e.getStyle(n, "float", !0)) || e.add(t, "br");
        })(u9, s55), u9.isEmpty(s55) && SS(s55), a40.normalize(), u9.isEmpty(a40) ? (u9.remove(a40), v()) : (AS(e751, a40), bS(e751, a40))), u9.setAttrib(a40, "id", ""), e751.dispatch("NewBlock", {
            newBlock: a40
        }));
    }, TS = (e, t, n)=>{
        const o = e.dom.createRng();
        n ? (o.setStartBefore(t), o.setEndBefore(t)) : (o.setStartAfter(t), o.setEndAfter(t)), e.selection.setRng(o), Pm(e, o);
    }, BS = (e, t)=>{
        const n = cn("br");
        Yn(mn(t), n), e.undoManager.add();
    }, DS = (e, t)=>{
        LS(e.getBody(), t) || Xn(mn(t), cn("br"));
        const n = cn("br");
        Xn(mn(t), n), TS(e, n.dom, !1), e.undoManager.add();
    }, LS = (e759, t)=>{
        var n;
        return n = Ua.after(t), !!Do(n.getNode()) || dc(e759, Ua.after(t)).map((e)=>Do(e.getNode())
        ).getOr(!1);
    }, PS = (e)=>e && "A" === e.nodeName && "href" in e
    , MS = (e)=>e.fold(L1, PS, PS, L1)
    , IS = (e, t)=>{
        t.fold(S1, O1(BS, e), O1(DS, e), S1);
    }, FS = (e760, t520)=>{
        const n322 = ((e)=>{
            const t = O1(By, e), n = Ua.fromRangeStart(e.selection.getRng());
            return FC(t, e.getBody(), n).filter(MS);
        })(e760);
        n322.isSome() ? n322.each(O1(IS, e760)) : ((e761, t521)=>{
            const n323 = e761.selection, o178 = e761.dom, r93 = n323.getRng();
            let s56, a;
            mm(o178, r93).each((e)=>{
                r93.setStart(e.startContainer, e.startOffset), r93.setEnd(e.endContainer, e.endOffset);
            });
            let i = r93.startOffset, l = r93.startContainer;
            if (1 === l.nodeType && l.hasChildNodes()) {
                const e = i > l.childNodes.length - 1;
                l = l.childNodes[Math.min(i, l.childNodes.length - 1)] || l, i = e && 3 === l.nodeType ? l.nodeValue.length : 0;
            }
            let d = o178.getParent(l, o178.isBlock);
            const c = d ? o178.getParent(d.parentNode, o178.isBlock) : null, u = c ? c.nodeName.toUpperCase() : "", m = !(!t521 || !t521.ctrlKey);
            "LI" !== u || m || (d = c), l && 3 === l.nodeType && i >= l.nodeValue.length && (((e, t, n)=>{
                const o = new Xo(t, n);
                let r;
                const s = e.getNonEmptyElements();
                for(; r = o.next();)if (s[r.nodeName.toLowerCase()] || r.length > 0) return !0;
            })(e761.schema, l, d) || (s56 = o178.create("br"), r93.insertNode(s56), r93.setStartAfter(s56), r93.setEndAfter(s56), a = !0)), s56 = o178.create("br"), ja(o178, r93, s56), TS(e761, s56, a), e761.undoManager.add();
        })(e760, t520);
    }, US = (e762, t)=>vS(e762).filter((e)=>t.length > 0 && pn(mn(e), t)
        ).isSome()
    , zS = ci([
        {
            br: []
        },
        {
            block: []
        },
        {
            none: []
        }
    ]), jS = (e763, t)=>((e)=>US(e, Li(e))
        )(e763)
    , VS = (e764)=>(t, n)=>((e765)=>vS(e765).filter((e)=>rr(mn(e))
                ).isSome()
            )(t) === e764
    , HS = (e766, t)=>(n, o)=>{
            const r = ((e767)=>vS(e767).fold(N1(""), (e)=>e.nodeName.toUpperCase()
                )
            )(n) === e766.toUpperCase();
            return r === t;
        }
    , $S = (e)=>HS("pre", e)
    , qS = (e)=>(t, n)=>Oi(t) === e
    , WS = (e768, t)=>((e)=>US(e, Di(e))
        )(e768)
    , KS = (e, t)=>t
    , GS = (e769)=>{
        const t522 = Ti(e769), n324 = ((e, t)=>{
            const n = e.getRoot();
            let o, r;
            for(o = t; o !== n && "false" !== e.getContentEditable(o);)"true" === e.getContentEditable(o) && (r = o), o = o.parentNode;
            return o !== n ? r : n;
        })(e769.dom, e769.selection.getStart());
        return n324 && e769.schema.isValidChild(n324.nodeName, t522);
    }, YS = (e770, t523)=>(n, o)=>Y1(e770, (e, t)=>e && t(n, o)
            , !0) ? M1.some(t523) : M1.none()
    , XS = (e771, t524)=>{
        ((e, t)=>RC([
                YS([
                    jS
                ], zS.none()),
                YS([
                    HS("summary", !0)
                ], zS.br()),
                YS([
                    $S(!0),
                    qS(!1),
                    KS
                ], zS.br()),
                YS([
                    $S(!0),
                    qS(!1)
                ], zS.block()),
                YS([
                    $S(!0),
                    qS(!0),
                    KS
                ], zS.block()),
                YS([
                    $S(!0),
                    qS(!0)
                ], zS.br()),
                YS([
                    VS(!0),
                    KS
                ], zS.br()),
                YS([
                    VS(!0)
                ], zS.block()),
                YS([
                    WS
                ], zS.br()),
                YS([
                    KS
                ], zS.br()),
                YS([
                    GS
                ], zS.block())
            ], [
                e,
                !(!t || !t.shiftKey)
            ]).getOr(zS.none())
        )(e771, t524).fold(()=>{
            C1(t524) && hS(e771, "insertLineBreak").isDefaultPrevented() || (FS(e771, t524), C1(t524) && pS(e771, "insertLineBreak"));
        }, ()=>{
            C1(t524) && hS(e771, "insertParagraph").isDefaultPrevented() || (OS(e771, t524), C1(t524) && pS(e771, "insertParagraph"));
        }, S1);
    }, QS = Ct(), JS = (e)=>e.stopImmediatePropagation()
    , ZS = (e)=>e.keyCode === Uu.PAGE_UP || e.keyCode === Uu.PAGE_DOWN
    , e_ = (e, t, n)=>{
        n && !e.get() ? t.on("NodeChange", JS, !0) : !n && e.get() && t.off("NodeChange", JS), e.set(n);
    }, t_ = (e, t)=>{
        const n325 = t.container(), o179 = t.offset();
        return No(n325) ? (n325.insertData(o179, e), M1.some(Ua(n325, o179 + e.length))) : jd(t).map((n)=>{
            const o = un(e);
            return t.isAtEnd() ? Xn(n, o) : Yn(n, o), Ua(o.dom, e.length);
        });
    }, n_ = O1(t_, dr), o_ = O1(t_, " "), r_ = (e772, t525)=>(n)=>((e773, t526)=>!hg(t526) && (((e774, t527)=>((e, t)=>cc(e.dom, t).isNone()
                    )(e774, t527) || ((e, t)=>dc(e.dom, t).isNone()
                    )(e774, t527) || ng(e774, t527) || og(e774, t527) || dg(e774, t527) || lg(e774, t527)
                )(e773, t526) || gg(e773, t526) || pg(e773, t526))
            )(e772, n) ? n_(t525) : o_(t525)
    , s_ = (e775)=>{
        const t528 = Ua.fromRangeStart(e775.selection.getRng()), n = mn(e775.getBody());
        if (e775.selection.isCollapsed()) {
            const o180 = O1(By, e775), r = Ua.fromRangeStart(e775.selection.getRng());
            return FC(o180, e775.getBody(), r).bind(((e776)=>(t529)=>t529.fold((t)=>cc(e776.dom, Ua.before(t))
                    , (e)=>uc(e)
                    , (e)=>mc(e)
                    , (t)=>dc(e776.dom, Ua.after(t))
                    )
            )(n)).map((o)=>()=>r_(n, t528)(o).each(((e)=>(t)=>(e.selection.setRng(t.toRange()), e.nodeChanged(), !0)
                    )(e775))
            );
        }
        return M1.none();
    }, a_ = (e)=>td(e) ? [
            {
                keyCode: Uu.TAB,
                action: pw($w, e, !0)
            },
            {
                keyCode: Uu.TAB,
                shiftKey: !0,
                action: pw($w, e, !1)
            }
        ] : []
    , i_ = (e777)=>{
        if (e777.addShortcut("Meta+P", "", "mcePrint"), fS(e777), _v(e777)) return zs(null);
        {
            const t530 = Rx(e777);
            return ((e)=>{
                e.on("keyup compositionstart", O1(rw, e));
            })(e777), ((e778, t532)=>{
                e778.on("keydown", (n326)=>{
                    !1 === n326.isDefaultPrevented() && ((e, t, n)=>{
                        const o = Ct().os;
                        hw([
                            {
                                keyCode: Uu.RIGHT,
                                action: pw(iw, e, !0)
                            },
                            {
                                keyCode: Uu.LEFT,
                                action: pw(iw, e, !1)
                            },
                            {
                                keyCode: Uu.UP,
                                action: pw(lw, e, !1)
                            },
                            {
                                keyCode: Uu.DOWN,
                                action: pw(lw, e, !0)
                            },
                            {
                                keyCode: Uu.RIGHT,
                                action: pw(Uw, e, !0)
                            },
                            {
                                keyCode: Uu.LEFT,
                                action: pw(Uw, e, !1)
                            },
                            {
                                keyCode: Uu.UP,
                                action: pw(zw, e, !1)
                            },
                            {
                                keyCode: Uu.DOWN,
                                action: pw(zw, e, !0)
                            },
                            {
                                keyCode: Uu.RIGHT,
                                action: pw(vw, e, !0)
                            },
                            {
                                keyCode: Uu.LEFT,
                                action: pw(vw, e, !1)
                            },
                            {
                                keyCode: Uu.UP,
                                action: pw(yw, e, !1)
                            },
                            {
                                keyCode: Uu.DOWN,
                                action: pw(yw, e, !0)
                            },
                            {
                                keyCode: Uu.RIGHT,
                                action: pw(Ex, e, t, !0)
                            },
                            {
                                keyCode: Uu.LEFT,
                                action: pw(Ex, e, t, !1)
                            },
                            {
                                keyCode: Uu.RIGHT,
                                ctrlKey: !o.isMacOS(),
                                altKey: o.isMacOS(),
                                action: pw(Ax, e, t)
                            },
                            {
                                keyCode: Uu.LEFT,
                                ctrlKey: !o.isMacOS(),
                                altKey: o.isMacOS(),
                                action: pw(Ox, e, t)
                            },
                            {
                                keyCode: Uu.UP,
                                action: pw(mw, e, !1)
                            },
                            {
                                keyCode: Uu.DOWN,
                                action: pw(mw, e, !0)
                            }
                        ], n).each((e)=>{
                            n.preventDefault();
                        });
                    })(e778, t532, n326);
                });
            })(e777, t530), ((e779, t533)=>{
                e779.on("keydown", (n327)=>{
                    !1 === n327.isDefaultPrevented() && ((e, t534, n)=>{
                        const o = n.keyCode === Uu.BACKSPACE ? "deleteContentBackward" : "deleteContentForward";
                        bw([
                            {
                                keyCode: Uu.BACKSPACE,
                                action: pw(Kx, e)
                            },
                            {
                                keyCode: Uu.BACKSPACE,
                                action: pw(hC, e, !1)
                            },
                            {
                                keyCode: Uu.DELETE,
                                action: pw(hC, e, !0)
                            },
                            {
                                keyCode: Uu.BACKSPACE,
                                action: pw(cC, e, !1)
                            },
                            {
                                keyCode: Uu.DELETE,
                                action: pw(cC, e, !0)
                            },
                            {
                                keyCode: Uu.BACKSPACE,
                                action: pw(Lx, e, t534, !1)
                            },
                            {
                                keyCode: Uu.DELETE,
                                action: pw(Lx, e, t534, !0)
                            },
                            {
                                keyCode: Uu.BACKSPACE,
                                action: pw(ap, e, !1)
                            },
                            {
                                keyCode: Uu.DELETE,
                                action: pw(ap, e, !0)
                            },
                            {
                                keyCode: Uu.BACKSPACE,
                                action: pw(bC, e, !1)
                            },
                            {
                                keyCode: Uu.DELETE,
                                action: pw(bC, e, !0)
                            },
                            {
                                keyCode: Uu.BACKSPACE,
                                action: pw(Ux, e, !1)
                            },
                            {
                                keyCode: Uu.DELETE,
                                action: pw(Ux, e, !0)
                            },
                            {
                                keyCode: Uu.BACKSPACE,
                                action: pw(tC, e, !1)
                            },
                            {
                                keyCode: Uu.DELETE,
                                action: pw(tC, e, !0)
                            },
                            {
                                keyCode: Uu.BACKSPACE,
                                action: pw(Jy, e, !1)
                            },
                            {
                                keyCode: Uu.DELETE,
                                action: pw(Jy, e, !0)
                            },
                            {
                                keyCode: Uu.BACKSPACE,
                                action: pw(Ix, e, !1)
                            },
                            {
                                keyCode: Uu.DELETE,
                                action: pw(Ix, e, !0)
                            }
                        ], n).each((t)=>{
                            n.preventDefault(), hS(e, o).isDefaultPrevented() || (t(), pS(e, o));
                        });
                    })(e779, t533, n327);
                }), e779.on("keyup", (t535)=>{
                    !1 === t535.isDefaultPrevented() && ((e, t)=>{
                        hw([
                            {
                                keyCode: Uu.BACKSPACE,
                                action: pw(pC, e)
                            },
                            {
                                keyCode: Uu.DELETE,
                                action: pw(pC, e)
                            }
                        ], t);
                    })(e779, t535);
                });
            })(e777, t530), ((e780)=>{
                e780.on("keydown", (t536)=>{
                    t536.keyCode === Uu.ENTER && ((e, t)=>{
                        var n;
                        t.isDefaultPrevented() || (t.preventDefault(), (n = e.undoManager).typing && (n.typing = !1, n.add()), e.undoManager.transact(()=>{
                            !1 === e.selection.isCollapsed() && Fy(e), XS(e, t);
                        }));
                    })(e780, t536);
                });
            })(e777), ((e781)=>{
                e781.on("keydown", (t537)=>{
                    !1 === t537.isDefaultPrevented() && ((e, t)=>{
                        bw([
                            {
                                keyCode: Uu.SPACEBAR,
                                action: pw(s_, e)
                            }
                        ], t).each((n)=>{
                            t.preventDefault(), hS(e, "insertText", {
                                data: " "
                            }).isDefaultPrevented() || (n(), pS(e, "insertText", {
                                data: " "
                            }));
                        });
                    })(e781, t537);
                });
            })(e777), ((e782)=>{
                e782.on("input", (t538)=>{
                    !1 === t538.isComposing && ((e)=>{
                        const t539 = mn(e.getBody());
                        e.selection.isCollapsed() && wg(t539, Ua.fromRangeStart(e.selection.getRng())).each((t)=>{
                            e.selection.setRng(t.toRange());
                        });
                    })(e782);
                });
            })(e777), ((e783)=>{
                e783.on("keydown", (t540)=>{
                    !1 === t540.isDefaultPrevented() && ((e, t)=>{
                        hw([
                            ...a_(e)
                        ], t).each((e)=>{
                            t.preventDefault();
                        });
                    })(e783, t540);
                });
            })(e777), ((e784, t541)=>{
                e784.on("keydown", (n328)=>{
                    !1 === n328.isDefaultPrevented() && ((e, t, n)=>{
                        hw([
                            {
                                keyCode: Uu.END,
                                action: pw(dw, e, !0)
                            },
                            {
                                keyCode: Uu.HOME,
                                action: pw(dw, e, !1)
                            },
                            {
                                keyCode: Uu.END,
                                action: pw(Cw, e, !0)
                            },
                            {
                                keyCode: Uu.HOME,
                                action: pw(Cw, e, !1)
                            },
                            {
                                keyCode: Uu.END,
                                action: pw(Tx, e, !0, t)
                            },
                            {
                                keyCode: Uu.HOME,
                                action: pw(Tx, e, !1, t)
                            }
                        ], n).each((e)=>{
                            n.preventDefault();
                        });
                    })(e784, t541, n328);
                });
            })(e777, t530), ((e785, t542)=>{
                if (QS.os.isMacOS()) return;
                const n329 = zs(!1);
                e785.on("keydown", (t)=>{
                    ZS(t) && e_(n329, e785, !0);
                }), e785.on("keyup", (o)=>{
                    !1 === o.isDefaultPrevented() && ((e, t, n)=>{
                        hw([
                            {
                                keyCode: Uu.PAGE_UP,
                                action: pw(Tx, e, !1, t)
                            },
                            {
                                keyCode: Uu.PAGE_DOWN,
                                action: pw(Tx, e, !0, t)
                            }
                        ], n);
                    })(e785, t542, o), ZS(o) && n329.get() && (e_(n329, e785, !1), e785.nodeChanged());
                });
            })(e777, t530), t530;
        }
    };
    class l_ {
        constructor(e){
            let t543;
            this.lastPath = [], this.editor = e;
            const n330 = this;
            "onselectionchange" in e.getDoc() || e.on("NodeChange click mouseup keyup focus", (n)=>{
                const o = e.selection.getRng(), r = {
                    startContainer: o.startContainer,
                    startOffset: o.startOffset,
                    endContainer: o.endContainer,
                    endOffset: o.endOffset
                };
                "nodechange" !== n.type && om(r, t543) || e.dispatch("SelectionChange"), t543 = r;
            }), e.on("contextmenu", ()=>{
                e.dispatch("SelectionChange");
            }), e.on("SelectionChange", ()=>{
                const t = e.selection.getStart(!0);
                t && wu(e) && !n330.isSameElementPath(t) && e.dom.isChildOf(t, e.getBody()) && e.nodeChanged({
                    selectionChange: !0
                });
            }), e.on("mouseup", (t)=>{
                !t.isDefaultPrevented() && wu(e) && ("IMG" === e.selection.getNode().nodeName ? Gm.setEditorTimeout(e, ()=>{
                    e.nodeChanged();
                }) : e.nodeChanged());
            });
        }
        nodeChanged(e786) {
            const t = this.editor.selection;
            let n, o, r;
            this.editor.initialized && t && !kl(this.editor) && !this.editor.mode.isReadOnly() && (r = this.editor.getBody(), n = t.getStart(!0) || r, n.ownerDocument === this.editor.getDoc() && this.editor.dom.isChildOf(n, r) || (n = r), o = [], this.editor.dom.getParent(n, (e)=>{
                if (e === r) return !0;
                o.push(e);
            }), (e786 = e786 || {}).element = n, e786.parents = o, this.editor.dispatch("NodeChange", e786));
        }
        isSameElementPath(e) {
            let t;
            const n = this.editor, o = ne1(n.dom.getParents(e, P1, n.getBody()));
            if (o.length === this.lastPath.length) {
                for(t = o.length; t >= 0 && o[t] === this.lastPath[t]; t--);
                if (-1 === t) return this.lastPath = o, !0;
            }
            return this.lastPath = o, !1;
        }
    }
    const d_ = N1("x-tinymce/html"), c_ = "\x3c!-- x-tinymce/html --\x3e", u_ = (e)=>c_ + e
    , m_ = (e)=>-1 !== e.indexOf(c_)
    , f_ = "%MCEPASTEBIN%", g_ = (e)=>e.dom.get("mcepastebin")
    , p_ = (e)=>e && "mcepastebin" === e.id
    , h_ = (e)=>e === f_
    , b_ = (e, t544)=>(Bt.each(t544, (t)=>{
            e = u1(t, RegExp) ? e.replace(t, "") : e.replace(t[0], t[1]);
        }), e)
    , v_ = (e)=>b_(e, [
            /^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/gi,
            /<!--StartFragment-->|<!--EndFragment-->/g,
            [
                /( ?)<span class="Apple-converted-space">\u00a0<\/span>( ?)/g,
                (e, t, n)=>t || n ? dr : " "
            ],
            /<br class="Apple-interchange-newline">/g,
            /<br>$/i
        ])
    , y_ = (e, t)=>({
            content: e,
            cancelled: t
        })
    , C_ = (e, t)=>(e.insertContent(t, {
            merge: ql(e),
            paste: !0
        }), !0)
    , x_ = (e)=>/^https?:\/\/[\w\?\-\/+=.&%@~#]+$/i.test(e)
    , w_ = (e787, t545, n331)=>!(e787.selection.isCollapsed() || !x_(t545)) && ((e, t, n)=>(e.undoManager.extra(()=>{
                n(e, t);
            }, ()=>{
                e.execCommand("mceInsertLink", !1, t);
            }), !0)
        )(e787, t545, n331)
    , k_ = (e788, t546, n332)=>!!((e789, t)=>x_(t) && V1(ed(e789), (e)=>je1(t.toLowerCase(), `.${e.toLowerCase()}`)
            )
        )(e788, t546) && ((e, t, n)=>(e.undoManager.extra(()=>{
                n(e, t);
            }, ()=>{
                e.insertContent('<img src="' + t + '">');
            }), !0)
        )(e788, t546, n332)
    , S_ = ((e)=>{
        let t = 0;
        return ()=>"mceclip" + t++
        ;
    })(), __ = (e790, t547, n333, o182)=>{
        const r94 = ((e791, t548, n334)=>((e792, t549, n335)=>{
                const o183 = ((e, t, n)=>e.dispatch("PastePreProcess", {
                        content: t,
                        internal: n
                    })
                )(e792, t549, n335), r95 = ((e793, t)=>{
                    const n = Wb({}, e793.schema);
                    n.addNodeFilter("meta", (e794)=>{
                        Bt.each(e794, (e)=>{
                            e.remove();
                        });
                    });
                    const o = n.parse(t, {
                        forced_root_block: !1,
                        isRootContent: !0
                    });
                    return Rf({
                        validate: !0
                    }, e793.schema).serialize(o);
                })(e792, o183.content);
                return e792.hasEventListeners("PastePostProcess") && !o183.isDefaultPrevented() ? ((e795, t550, n336)=>{
                    const o = e795.dom.create("div", {
                        style: "display:none"
                    }, t550), r = ((e, t, n)=>e.dispatch("PastePostProcess", {
                            node: t,
                            internal: n
                        })
                    )(e795, o, n336);
                    return y_(r.node.innerHTML, r.isDefaultPrevented());
                })(e792, r95, n335) : y_(r95, o183.isDefaultPrevented());
            })(e791, t548, n334)
        )(e790, t547, n333);
        !1 === r94.cancelled && ((e796, t551, n337)=>{
            n337 || !Wl(e796) ? C_(e796, t551) : ((e, t)=>{
                Bt.each([
                    w_,
                    k_,
                    C_
                ], (n)=>!0 !== n(e, t, C_)
                );
            })(e796, t551);
        })(e790, r94.content, o182);
    }, E_ = (e797, t, n)=>{
        const o = n || m_(t);
        __(e797, ((e)=>e.replace(c_, "")
        )(t), o, !1);
    }, N_ = (e798, t552)=>{
        const n338 = e798.dom.encode(t552).replace(/\r\n/g, "\n"), o184 = ((e799, t553, n339)=>{
            const o185 = e799.split(/\n\n/), r = ((e800, t554)=>{
                let n = "<" + e800;
                const o = ye1(t554, (e, t)=>t + '="' + ls.encodeAllRaw(e) + '"'
                );
                return o.length && (n += " " + o.join(" ")), n + ">";
            })(t553, n339), s = "</" + t553 + ">", a = H1(o185, (e)=>e.split(/\n/).join("<br />")
            );
            return 1 === a.length ? a[0] : H1(a, (e)=>r + e + s
            ).join("");
        })(zr(n338, Gl(e798)), Ti(e798), Bi(e798));
        __(e798, o184, !1, !0);
    }, R_ = (e)=>{
        const t = {};
        if (e && e.types) for(let n = 0; n < e.types.length; n++){
            const o = e.types[n];
            try {
                t[o] = e.getData(o);
            } catch (e) {
                t[o] = "";
            }
        }
        return t;
    }, A_ = (e, t)=>t in e && e[t].length > 0
    , O_ = (e)=>A_(e, "text/html") || A_(e, "text/plain")
    , T_ = (e801, t555, n340)=>{
        const o186 = "paste" === t555.type ? t555.clipboardData : t555.dataTransfer;
        var r96;
        if (zl(e801) && o186) {
            const s57 = ((e802, t556)=>{
                const n341 = t556.items ? ee1(de1(t556.items), (e)=>"file" === e.kind ? [
                        e.getAsFile()
                    ] : []
                ) : [], o = t556.files ? de1(t556.files) : [];
                return K1(n341.length > 0 ? n341 : o, ((e803)=>{
                    const t557 = ed(e803);
                    return (e804)=>ze1(e804.type, "image/") && V1(t557, (t558)=>((e)=>{
                                const t = e.toLowerCase(), n = {
                                    jpg: "jpeg",
                                    jpe: "jpeg",
                                    jfi: "jpeg",
                                    jif: "jpeg",
                                    jfif: "jpeg",
                                    pjpeg: "jpeg",
                                    pjp: "jpeg",
                                    svg: "svg+xml"
                                };
                                return Bt.hasOwn(n, t) ? "image/" + n[t] : "image/" + t;
                            })(t558) === e804.type
                        )
                    ;
                })(e802));
            })(e801, o186);
            if (s57.length > 0) return t555.preventDefault(), (r96 = s57, Promise.all(H1(r96, (e)=>Nb(e).then((t)=>({
                        file: e,
                        uri: t
                    })
                )
            ))).then((t559)=>{
                n340 && e801.selection.setRng(n340), $1(t559, (t560)=>{
                    ((e805, t561)=>{
                        const { data: n342 , type: o187  } = Sb(t561.uri), r97 = t561.file, s59 = e805.editorUpload.blobCache, a41 = s59.getByData(n342, o187), i26 = null != a41 ? a41 : ((e806, t562, n343, o)=>{
                            const r = S_(), s = Fi(e806) && C1(n343.name), a = s ? ((e, t)=>{
                                const n = t.match(/([\s\S]+?)(?:\.[a-z0-9.]+)$/i);
                                return C1(n) ? e.dom.encode(n[1]) : null;
                            })(e806, n343.name) : r, i = s ? n343.name : void 0, l = t562.create(r, n343, o, a, i);
                            return t562.add(l), l;
                        })(e805, s59, r97, n342);
                        E_(e805, `<img src="${i26.blobUri()}">`, !1);
                    })(e801, t560);
                });
            }), !0;
        }
        return !1;
    }, B_ = (e807, t563, n344, o188)=>{
        let r98 = v_(n344);
        const s60 = A_(t563, d_()) || m_(n344), a42 = !s60 && ((e)=>!/<(?:\/?(?!(?:div|p|br|span)>)\w+|(?:(?!(?:span style="white-space:\s?pre;?">)|br\s?\/>))\w+\s[^>]+)>/i.test(e)
        )(r98), i27 = x_(r98);
        (h_(r98) || !r98.length || a42 && !i27) && (o188 = !0), (o188 || i27) && (r98 = A_(t563, "text/plain") && a42 ? t563["text/plain"] : ((e808)=>{
            const t = vs(), n345 = Wb({}, t);
            let o = "";
            const r = t.getVoidElements(), s = Bt.makeMap("script noscript style textarea video audio iframe object", " "), a = t.getBlockElements(), i = (e)=>{
                const n = e.name, l = e;
                if ("br" !== n) {
                    if ("wbr" !== n) {
                        if (r[n] && (o += " "), s[n]) o += " ";
                        else {
                            if (3 === e.type && (o += e.value), !(e.name in t.getVoidElements()) && (e = e.firstChild)) do i(e);
                            while (e = e.next)
                            a[n] && l.next && (o += "\n", "p" === n && (o += "\n"));
                        }
                    }
                } else o += "\n";
            };
            return e808 = b_(e808, [
                /<!\[[^\]]+\]>/g
            ]), i(n345.parse(e808)), o;
        })(r98)), h_(r98) || (o188 ? N_(e807, r98) : E_(e807, r98, s60));
    }, D_ = (e809, t564, n346)=>{
        ((e810, t565, n347)=>{
            let o;
            e810.on("keydown", (e811)=>{
                ((e)=>Uu.metaKeyPressed(e) && 86 === e.keyCode || e.shiftKey && 45 === e.keyCode
                )(e811) && !e811.isDefaultPrevented() && (o = e811.shiftKey && 86 === e811.keyCode);
            }), e810.on("paste", (r)=>{
                if (r.isDefaultPrevented() || ((e)=>{
                    var t, n;
                    return Nt.os.isAndroid() && 0 === (null === (n = null === (t = e.clipboardData) || void 0 === t ? void 0 : t.items) || void 0 === n ? void 0 : n.length);
                })(r)) return;
                const s = "text" === n347.get() || o;
                o = !1;
                const a = R_(r.clipboardData);
                !O_(a) && T_(e810, r, t565.getLastRng() || e810.selection.getRng()) || (A_(a, "text/html") ? (r.preventDefault(), B_(e810, a, a["text/html"], s)) : (t565.create(), Gm.setEditorTimeout(e810, ()=>{
                    const n = t565.getHtml();
                    t565.remove(), B_(e810, a, n, s);
                }, 0)));
            });
        })(e809, t564, n346), ((e812)=>{
            const t566 = (e)=>ze1(e, "webkit-fake-url")
            , n = (e)=>ze1(e, "data:")
            ;
            e812.parser.addNodeFilter("img", (o, r, s)=>{
                if (!zl(e812) && ((e)=>{
                    var t;
                    return !0 === (null === (t = e.data) || void 0 === t ? void 0 : t.paste);
                })(s)) for (const r99 of o){
                    const o = r99.attr("src");
                    m1(o) && !r99.attr("data-mce-object") && o !== Nt.transparentSrc && (t566(o) || !Yl(e812) && n(o)) && r99.remove();
                }
            });
        })(e809);
    }, L_ = (e813, t567, n348, o)=>{
        ((e, t, n)=>{
            try {
                return e.clearData(), e.setData("text/html", t), e.setData("text/plain", n), e.setData(d_(), t), !0;
            } catch (e814) {
                return !1;
            }
        })(e813.clipboardData, t567.html, t567.text) ? (e813.preventDefault(), o()) : n348(t567.html, o);
    }, P_ = (e)=>(t, n)=>{
            const { dom: o , selection: r  } = e, s = o.create("div", {
                contenteditable: "false",
                "data-mce-bogus": "all"
            }), a = o.create("div", {
                contenteditable: "true"
            }, t);
            o.setStyles(s, {
                position: "fixed",
                top: "0",
                left: "-3000px",
                width: "1000px",
                overflow: "hidden"
            }), s.appendChild(a), o.add(e.getBody(), s);
            const i = r.getRng();
            a.focus();
            const l = o.createRng();
            l.selectNodeContents(a), r.setRng(l), Gm.setEditorTimeout(e, ()=>{
                r.setRng(i), o.remove(s), n();
            }, 0);
        }
    , M_ = (e)=>({
            html: u_(e.selection.getContent({
                contextual: !0
            })),
            text: e.selection.getContent({
                format: "text"
            })
        })
    , I_ = (e815)=>!e815.selection.isCollapsed() || ((e)=>!!e.dom.getParent(e.selection.getStart(), "td[data-mce-selected],th[data-mce-selected]", e.getBody())
        )(e815)
    , F_ = (e, t)=>{
        var n, o;
        return pm.getCaretRangeFromPoint(null !== (n = t.clientX) && void 0 !== n ? n : 0, null !== (o = t.clientY) && void 0 !== o ? o : 0, e.getDoc());
    }, U_ = (e, t)=>{
        e.focus(), t && e.selection.setRng(t);
    }, z_ = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi, j_ = (e)=>Bt.trim(e).replace(z_, Pc).toLowerCase()
    , V_ = (e, t568, n349)=>{
        const o189 = Hl(e);
        if (n349 || "all" === o189 || !$l(e)) return t568;
        const r = o189 ? o189.split(/[, ]/) : [];
        if (r && "none" !== o189) {
            const n = e.dom, o = e.selection.getNode();
            t568 = t568.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, (e, t, s, a)=>{
                const i = n.parseStyle(n.decode(s)), l = {};
                for(let e816 = 0; e816 < r.length; e816++){
                    const t = i[r[e816]];
                    let s = t, a = n.getStyle(o, r[e816], !0);
                    /color/.test(r[e816]) && (s = j_(s), a = j_(a)), a !== s && (l[r[e816]] = t);
                }
                const d = n.serializeStyle(l, "span");
                return d ? t + ' style="' + d + '"' + a : t + a;
            });
        } else t568 = t568.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, "$1$3");
        return t568 = t568.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, (e, t, n, o)=>t + ' style="' + n + '"' + o
        ), t568;
    }, H_ = (e817)=>{
        const t569 = zs(!1), n350 = zs(Kl(e817) ? "text" : "html"), o190 = ((e818)=>{
            const t570 = zs(null);
            return {
                create: ()=>((e819, t)=>{
                        const { dom: n , selection: o  } = e819, r = e819.getBody();
                        t.set(o.getRng());
                        const s = n.add(e819.getBody(), "div", {
                            id: "mcepastebin",
                            class: "mce-pastebin",
                            contentEditable: !0,
                            "data-mce-bogus": "all",
                            style: "position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0"
                        }, f_);
                        Nt.browser.isFirefox() && n.setStyle(s, "left", "rtl" === n.getStyle(r, "direction", !0) ? 65535 : -65535), n.bind(s, "beforedeactivate focusin focusout", (e)=>{
                            e.stopPropagation();
                        }), s.focus(), o.select(s, !0);
                    })(e818, t570)
                ,
                remove: ()=>((e, t)=>{
                        const n = e.dom;
                        if (g_(e)) {
                            let o;
                            const r = t.get();
                            for(; o = g_(e);)n.remove(o), n.unbind(o);
                            r && e.selection.setRng(r);
                        }
                        t.set(null);
                    })(e818, t570)
                ,
                getEl: ()=>g_(e818)
                ,
                getHtml: ()=>((e821)=>{
                        const t = e821.dom, n351 = (e, n)=>{
                            e.appendChild(n), t.remove(n, !0);
                        }, [o, ...r] = K1(e821.getBody().childNodes, p_);
                        $1(r, (e)=>{
                            n351(o, e);
                        });
                        const s = t.select("div[id=mcepastebin]", o);
                        for(let e820 = s.length - 1; e820 >= 0; e820--){
                            const r = t.create("div");
                            o.insertBefore(r, s[e820]), n351(r, s[e820]);
                        }
                        return o ? o.innerHTML : "";
                    })(e818)
                ,
                getLastRng: t570.get
            };
        })(e817);
        ((e822)=>{
            (Nt.browser.isChromium() || Nt.browser.isSafari()) && ((e, t)=>{
                e.on("PastePreProcess", (n)=>{
                    n.content = t(e, n.content, n.internal);
                });
            })(e822, V_);
        })(e817), ((e823, t571)=>{
            e823.addCommand("mceTogglePlainTextPaste", ()=>{
                ((e, t)=>{
                    "text" === t.get() ? (t.set("html"), Fu(e, !1)) : (t.set("text"), Fu(e, !0)), e.focus();
                })(e823, t571);
            }), e823.addCommand("mceInsertClipboardContent", (t, n)=>{
                n.html && E_(e823, n.html, n.internal), n.text && N_(e823, n.text);
            });
        })(e817, n350), ((e)=>{
            const t572 = (t)=>(n)=>{
                    t(e, n);
                }
            , n352 = jl(e);
            x1(n352) && e.on("PastePreProcess", t572(n352));
            const o = Vl(e);
            x1(o) && e.on("PastePostProcess", t572(o));
        })(e817), e817.on("PreInit", ()=>{
            ((e824)=>{
                e824.on("cut", ((e)=>(t573)=>{
                        !t573.isDefaultPrevented() && I_(e) && L_(t573, M_(e), P_(e), ()=>{
                            if (Nt.browser.isChromium() || Nt.browser.isFirefox()) {
                                const t = e.selection.getRng();
                                Gm.setEditorTimeout(e, ()=>{
                                    e.selection.setRng(t), e.execCommand("Delete");
                                }, 0);
                            } else e.execCommand("Delete");
                        });
                    }
                )(e824)), e824.on("copy", ((e)=>(t)=>{
                        !t.isDefaultPrevented() && I_(e) && L_(t, M_(e), P_(e), S1);
                    }
                )(e824));
            })(e817), ((e825, t574)=>{
                Ul(e825) && e825.on("dragend dragover draggesture dragdrop drop drag", (e)=>{
                    e.preventDefault(), e.stopPropagation();
                }), zl(e825) || e825.on("drop", (e826)=>{
                    const t = e826.dataTransfer;
                    t && ((e827)=>V1(e827.files, (e)=>/^image\//.test(e.type)
                        )
                    )(t) && e826.preventDefault();
                }), e825.on("drop", (n)=>{
                    if (n.isDefaultPrevented() || t574.get()) return;
                    const o = F_(e825, n);
                    if (y1(o)) return;
                    const r = R_(n.dataTransfer), s = A_(r, d_());
                    if ((!O_(r) || ((e)=>{
                        const t = e["text/plain"];
                        return !!t && 0 === t.indexOf("file://");
                    })(r)) && T_(e825, n, o)) return;
                    const a = r[d_()], i = a || r["text/html"] || r["text/plain"];
                    i && (n.preventDefault(), Gm.setEditorTimeout(e825, ()=>{
                        e825.undoManager.transact(()=>{
                            a && e825.execCommand("Delete"), U_(e825, o);
                            const t = v_(i);
                            r["text/html"] ? E_(e825, t, s) : N_(e825, t);
                        });
                    }));
                }), e825.on("dragstart", (e)=>{
                    t574.set(!0);
                }), e825.on("dragover dragend", (n)=>{
                    zl(e825) && !1 === t574.get() && (n.preventDefault(), U_(e825, F_(e825, n))), "dragend" === n.type && t574.set(!1);
                });
            })(e817, t569), D_(e817, o190, n350);
        });
    }, $_ = (e)=>yo(e) && nr(mn(e))
    ;
    var q_;
    !function(e) {
        e.Before = "before", e.After = "after";
    }(q_ || (q_ = {}));
    const W_ = (e, t)=>Math.abs(e.left - t)
    , K_ = (e, t)=>Math.abs(e.right - t)
    , G_ = (e828, t575)=>((e829)=>Y1(e829, (e830, t)=>e830.fold(()=>M1.some(t)
                , (e)=>{
                    const n = Math.min(t.left, e.left), o = Math.min(t.top, e.top), r = Math.max(t.right, e.right), s = Math.max(t.bottom, e.bottom);
                    return M1.some({
                        top: o,
                        right: r,
                        bottom: s,
                        left: n,
                        width: r - n,
                        height: s - o
                    });
                })
            , M1.none())
        )(K1(e828, (e)=>{
            var n, o;
            return (n = t575) >= (o = e).top && n <= o.bottom;
        })).fold(()=>[
                [],
                e828
            ]
        , (t576)=>{
            const { pass: n353 , fail: o  } = W1(e828, (e831)=>((e832, t577)=>{
                    const n = ((e, t)=>Math.max(0, Math.min(e.bottom, t.bottom) - Math.max(e.top, t.top))
                    )(e832, t577) / Math.min(e832.height, t577.height);
                    return ((e, t)=>e.top < t.bottom && e.bottom > t.top
                    )(e832, t577) && n > 0.5;
                })(e831, t576)
            );
            return [
                n353,
                o
            ];
        })
    , Y_ = (e, t, n)=>t > e.left && t < e.right ? 0 : Math.min(Math.abs(e.left - t), Math.abs(e.right - t))
    , X_ = (e833, t, n)=>{
        const o191 = (e)=>Lr(e.node) ? M1.some(e) : yo(e.node) ? X_(de1(e.node.childNodes), t, n) : M1.none()
        , r100 = (e834, r101)=>{
            const s62 = se1(e834, (e, o)=>r101(e, t, n) - r101(o, t, n)
            );
            return ((e, r)=>{
                if (e.length >= 2) {
                    const s = o191(e[0]).getOr(e[0]), a = o191(e[1]).getOr(e[1]);
                    if (Math.abs(r(s, t, n) - r(a, t, n)) < 2) {
                        if (No(s.node)) return M1.some(s);
                        if (No(a.node)) return M1.some(a);
                    }
                }
                return M1.none();
            })(s62, r101).orThunk(()=>ce1(s62, o191)
            );
        }, [s61, a43] = G_(cx(e833), n), { pass: i , fail: l  } = W1(a43, (e)=>e.top < n
        );
        return r100(s61, Y_).orThunk(()=>r100(l, ba)
        ).orThunk(()=>r100(i, ba)
        );
    }, Q_ = (e835, t578, n354)=>((e836, t579, n355)=>{
            const o192 = mn(e836), r102 = Cn(o192), s63 = fn(r102, t579, n355).filter((e)=>vn(o192, e)
            ).getOr(o192);
            return ((e837, t580, n356, o)=>{
                const r103 = (t581, s)=>s.fold(()=>X_(de1(t581.dom.childNodes), n356, o)
                    , (e)=>{
                        const r = K1(de1(t581.dom.childNodes), (t)=>t !== e.dom
                        );
                        return X_(r, n356, o);
                    }).orThunk(()=>{
                        var n;
                        return (bn(t581, e837) ? M1.none() : (n = t581, M1.from(n.dom.parentElement).map(mn))).bind((e)=>r103(e, M1.some(t581))
                        );
                    })
                ;
                return r103(t580, M1.none());
            })(o192, s63, t579, n355);
        })(e835, t578, n354).filter((e)=>bd(e.node)
        ).map((e838)=>((e, t)=>({
                    node: e.node,
                    position: W_(e, t) < K_(e, t) ? q_.Before : q_.After
                })
            )(e838, t578)
        )
    , J_ = (e)=>{
        const t = e.getBoundingClientRect(), n = e.ownerDocument, o = n.documentElement, r = n.defaultView;
        return {
            top: t.top + r.pageYOffset - o.clientTop,
            left: t.left + r.pageXOffset - o.clientLeft
        };
    }, Z_ = Mo, eE = Po, tE = (e, t, n, o)=>{
        const r = e.dom, s = t.cloneNode(!0);
        r.setStyles(s, {
            width: n,
            height: o
        }), r.setAttrib(s, "data-mce-selected", null);
        const a = r.create("div", {
            class: "mce-drag-container",
            "data-mce-bogus": "all",
            unselectable: "on",
            contenteditable: "false"
        });
        return r.setStyles(a, {
            position: "absolute",
            opacity: 0.5,
            overflow: "hidden",
            border: 0,
            padding: 0,
            margin: 0,
            width: n,
            height: o
        }), r.setStyles(s, {
            margin: 0,
            boxSizing: "border-box"
        }), a.appendChild(s), a;
    }, nE = (e)=>{
        e && e.parentNode && e.parentNode.removeChild(e);
    }, oE = (e839)=>{
        e839.on((e)=>{
            nE(e.ghost);
        }), e839.clear();
    }, rE = (e840)=>{
        const t582 = Ws(), n357 = Is.DOM, o193 = document, r104 = ((e841, t583)=>(n358)=>{
                if (((e)=>0 === e.button
                )(n358)) {
                    const s = Q1(t583.dom.getParents(n358.target), ((...e)=>(t)=>{
                            for(let n = 0; n < e.length; n++)if (e[n](t)) return !0;
                            return !1;
                        }
                    )(Z_, eE)).getOr(null);
                    if (o = t583.getBody(), Z_(r = s) && r !== o) {
                        const o = t583.dom.getPos(s), r = t583.getBody(), a = t583.getDoc().documentElement;
                        e841.set({
                            element: s,
                            dragging: !1,
                            screenX: n358.screenX,
                            screenY: n358.screenY,
                            maxX: (t583.inline ? r.scrollWidth : a.offsetWidth) - 2,
                            maxY: (t583.inline ? r.scrollHeight : a.offsetHeight) - 2,
                            relX: n358.pageX - o.x,
                            relY: n358.pageY - o.y,
                            width: s.offsetWidth,
                            height: s.offsetHeight,
                            ghost: tE(t583, s, s.offsetWidth, s.offsetHeight)
                        });
                    }
                }
                var o, r;
            }
        )(t582, e840), s64 = ((e842, t584)=>{
            const n359 = Ks((e, n)=>{
                t584._selectionOverrides.hideFakeCaret(), t584.selection.placeCaretAt(e, n);
            }, 0);
            return t584.on("remove", n359.cancel), (o194)=>e842.on((e843)=>{
                    const r106 = Math.max(Math.abs(o194.screenX - e843.screenX), Math.abs(o194.screenY - e843.screenY));
                    if (!e843.dragging && r106 > 10) {
                        if (t584.dispatch("dragstart", {
                            target: e843.element
                        }).isDefaultPrevented()) return;
                        e843.dragging = !0, t584.focus();
                    }
                    if (e843.dragging) {
                        const r105 = ((e, t)=>({
                                pageX: t.pageX - e.relX,
                                pageY: t.pageY + 5
                            })
                        )(e843, ((e844, t585)=>{
                            var n360, o195, r107;
                            return n360 = ((e)=>e.inline ? J_(e.getBody()) : {
                                    left: 0,
                                    top: 0
                                }
                            )(e844), o195 = ((e)=>{
                                const t = e.getBody();
                                return e.inline ? {
                                    left: t.scrollLeft,
                                    top: t.scrollTop
                                } : {
                                    left: 0,
                                    top: 0
                                };
                            })(e844), r107 = ((e845, t586)=>{
                                if (t586.target.ownerDocument !== e845.getDoc()) {
                                    const n361 = J_(e845.getContentAreaContainer()), o196 = ((e)=>{
                                        const t = e.getBody(), n = e.getDoc().documentElement, o = {
                                            left: t.scrollLeft,
                                            top: t.scrollTop
                                        }, r = {
                                            left: t.scrollLeft || n.scrollLeft,
                                            top: t.scrollTop || n.scrollTop
                                        };
                                        return e.inline ? o : r;
                                    })(e845);
                                    return {
                                        left: t586.pageX - n361.left + o196.left,
                                        top: t586.pageY - n361.top + o196.top
                                    };
                                }
                                return {
                                    left: t586.pageX,
                                    top: t586.pageY
                                };
                            })(e844, t585), {
                                pageX: r107.left - n360.left + o195.left,
                                pageY: r107.top - n360.top + o195.top
                            };
                        })(t584, o194));
                        s65 = e843.ghost, a45 = t584.getBody(), s65.parentNode !== a45 && a45.appendChild(s65), ((e, t, n, o, r, s)=>{
                            let a = 0, i = 0;
                            e.style.left = t.pageX + "px", e.style.top = t.pageY + "px", t.pageX + n > r && (a = t.pageX + n - r), t.pageY + o > s && (i = t.pageY + o - s), e.style.width = n - a + "px", e.style.height = o - i + "px";
                        })(e843.ghost, r105, e843.width, e843.height, e843.maxX, e843.maxY), n359.throttle(o194.clientX, o194.clientY);
                    }
                    var s65, a45;
                })
            ;
        })(t582, e840), a44 = ((e846, t587)=>(n363)=>{
                e846.on((e847)=>{
                    if (e847.dragging) {
                        if (((e, t, n)=>t !== n && !e.dom.isChildOf(t, n) && !Z_(t)
                        )(t587, ((e)=>{
                            const t = e.getSel().getRangeAt(0).startContainer;
                            return 3 === t.nodeType ? t.parentNode : t;
                        })(t587.selection), e847.element)) {
                            const o = ((e)=>{
                                const t = e.cloneNode(!0);
                                return t.removeAttribute("data-mce-selected"), t;
                            })(e847.element);
                            t587.dispatch("drop", {
                                clientX: n363.clientX,
                                clientY: n363.clientY
                            }).isDefaultPrevented() || t587.undoManager.transact(()=>{
                                nE(e847.element), t587.insertContent(t587.dom.getOuterHTML(o)), t587._selectionOverrides.hideFakeCaret();
                            });
                        }
                        t587.dispatch("dragend");
                    }
                }), oE(e846);
            }
        )(t582, e840), i28 = ((e848, t)=>()=>{
                e848.on((e)=>{
                    e.dragging && t.dispatch("dragend");
                }), oE(e848);
            }
        )(t582, e840);
        e840.on("mousedown", r104), e840.on("mousemove", s64), e840.on("mouseup", a44), n357.bind(o193, "mousemove", s64), n357.bind(o193, "mouseup", i28), e840.on("remove", ()=>{
            n357.unbind(o193, "mousemove", s64), n357.unbind(o193, "mouseup", i28);
        }), e840.on("keydown", (e)=>{
            e.keyCode === Uu.ESC && i28();
        });
    }, sE = Mo, aE = (e, t)=>ip(e.getBody(), t)
    , iE = (e849)=>{
        const t588 = e849.selection, n364 = e849.dom, o198 = n364.isBlock, r108 = e849.getBody(), s66 = gd(e849, r108, o198, ()=>nf(e849)
        ), a46 = "sel-" + n364.uniqueId(), i29 = "data-mce-selected";
        let l23;
        const d16 = (e)=>e !== r108 && (sE(e) || Fo(e)) && n364.isChildOf(e, r108)
        , c11 = (n, o, r, a = !0)=>e849.dispatch("ShowCaret", {
                target: o,
                direction: n,
                before: r
            }).isDefaultPrevented() ? null : (a && t588.scrollIntoView(o, -1 === n), s66.show(r, o))
        , u10 = (e)=>vr(e) || wr(e) || kr(e)
        , m = (e)=>u10(e.startContainer) || u10(e.endContainer)
        , f5 = (t)=>{
            const o = e849.schema.getVoidElements(), r = n364.createRng(), s = t.startContainer, a = t.startOffset, i = t.endContainer, l = t.endOffset;
            return we1(o, s.nodeName.toLowerCase()) ? 0 === a ? r.setStartBefore(s) : r.setStartAfter(s) : r.setStart(s, a), we1(o, i.nodeName.toLowerCase()) ? 0 === l ? r.setEndBefore(i) : r.setEndAfter(i) : r.setEnd(i, l), r;
        }, g4 = (o200, s67)=>{
            if (!o200) return null;
            if (o200.collapsed) {
                if (!m(o200)) {
                    const e = s67 ? 1 : -1, t = zd(e, r108, o200), n = t.getNode(!s67);
                    if (bd(n)) return c11(e, n, !!s67 && !t.isAtEnd(), !1);
                    const a = t.getNode(s67);
                    if (bd(a)) return c11(e, a, !s67 && !t.isAtEnd(), !1);
                }
                return null;
            }
            let u = o200.startContainer, f = o200.startOffset;
            const g = o200.endOffset;
            if (3 === u.nodeType && 0 === f && sE(u.parentNode) && (u = u.parentNode, f = n364.nodeIndex(u), u = u.parentNode), 1 !== u.nodeType) return null;
            if (g === f + 1 && u === o200.endContainer) {
                const o199 = u.childNodes[f];
                if (d16(o199)) return ((o201)=>{
                    const r109 = o201.cloneNode(!0), s68 = e849.dispatch("ObjectSelected", {
                        target: o201,
                        targetClone: r109
                    });
                    if (s68.isDefaultPrevented()) return null;
                    const d17 = ((o, r)=>{
                        const s = mn(e849.getBody()), i = e849.getDoc(), l = Wo(s, "#" + a46).getOrThunk(()=>{
                            const e = dn('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>', i);
                            return $t(e, "id", a46), Jn(s, e), e;
                        }), d = n364.createRng();
                        eo(l), Zn(l, [
                            un(dr, i),
                            mn(r),
                            un(dr, i)
                        ]), d.setStart(l.dom.firstChild, 1), d.setEnd(l.dom.lastChild, 0), Hn(l, {
                            top: n364.getPos(o, e849.getBody()).y + "px"
                        }), Mm(l);
                        const c = t588.getSel();
                        return c.removeAllRanges(), c.addRange(d), d;
                    })(o201, s68.targetClone), c12 = mn(o201);
                    return $1(Xs(mn(e849.getBody()), "*[data-mce-selected]"), (e)=>{
                        bn(c12, e) || Yt(e, i29);
                    }), n364.getAttrib(o201, i29) || o201.setAttribute(i29, "1"), l23 = o201, h(), d17;
                })(o199);
            }
            return null;
        }, p = ()=>{
            l23 && l23.removeAttribute(i29), Wo(mn(e849.getBody()), "#" + a46).each(to), l23 = null;
        }, h = ()=>{
            s66.hide();
        };
        return _v(e849) || (e849.on("click", (t)=>{
            const n = aE(e849, t.target);
            n && sE(n) && (t.preventDefault(), e849.focus());
        }), e849.on("blur NewBlock", p), e849.on("ResizeWindow FullscreenStateChanged", s66.reposition), e849.on("tap", (t)=>{
            const n = t.target, o = aE(e849, n);
            sE(o) ? (t.preventDefault(), sC(e849, o).each(g4)) : d16(n) && sC(e849, n).each(g4);
        }, !0), e849.on("mousedown", (o202)=>{
            const s69 = o202.target;
            if (s69 !== r108 && "HTML" !== s69.nodeName && !n364.isChildOf(s69, r108)) return;
            if (!1 === ((e850, t589, n365)=>{
                const o203 = mn(e850.getBody()), r110 = e850.inline ? o203 : mn(Cn(o203).dom.documentElement), s = ((e851, t, n, o)=>{
                    const r = ((e)=>e.dom.getBoundingClientRect()
                    )(t);
                    return {
                        x: n - (e851 ? r.left + t.dom.clientLeft + Qv(t) : 0),
                        y: o - (e851 ? r.top + t.dom.clientTop + Xv(t) : 0)
                    };
                })(e850.inline, r110, t589, n365);
                return ((e, t, n)=>{
                    const o = Gv(e), r = Yv(e);
                    return t >= 0 && n >= 0 && t <= o && n <= r;
                })(r110, s.x, s.y);
            })(e849, o202.clientX, o202.clientY)) return;
            p(), h();
            const a = aE(e849, s69);
            sE(a) ? (o202.preventDefault(), sC(e849, a).each(g4)) : Q_(r108, o202.clientX, o202.clientY).each((n)=>{
                var r;
                o202.preventDefault(), (r = c11(1, n.node, n.position === q_.Before, !1)) && t588.setRng(r), yo(a) ? a.focus() : e849.getBody().focus();
            });
        }), e849.on("keypress", (e)=>{
            Uu.modifierPressed(e) || sE(t588.getNode()) && e.preventDefault();
        }), e849.on("GetSelectionRange", (e)=>{
            let t = e.range;
            if (l23) {
                if (!l23.parentNode) return void (l23 = null);
                t = t.cloneRange(), t.selectNode(l23), e.range = t;
            }
        }), e849.on("SetSelectionRange", (e)=>{
            e.range = f5(e.range);
            const t = g4(e.range, e.forward);
            t && (e.range = t);
        }), e849.on("AfterSetSelectionRange", (e)=>{
            const t = e.range, o = t.startContainer.parentNode;
            var r;
            m(t) || "mcepastebin" === o.id || h(), r = o, n364.hasClass(r, "mce-offscreen-selection") || p();
        }), ((e852)=>{
            rE(e852), Rl(e852) && ((e853)=>{
                const t590 = (t)=>{
                    if (!t.isDefaultPrevented()) {
                        const n = t.dataTransfer;
                        n && (j1(n.types, "Files") || n.files.length > 0) && (t.preventDefault(), "drop" === t.type && oy(e853, "Dropped file type is not supported"));
                    }
                }, n366 = (n)=>{
                    Qm(e853, n.target) && t590(n);
                }, o204 = ()=>{
                    const o = Is.DOM, r = e853.dom, s = document, a = e853.inline ? e853.getBody() : e853.getDoc(), i = [
                        "drop",
                        "dragover"
                    ];
                    $1(i, (e)=>{
                        o.bind(s, e, n366), r.bind(a, e, t590);
                    }), e853.on("remove", ()=>{
                        $1(i, (e)=>{
                            o.unbind(s, e, n366), r.unbind(a, e, t590);
                        });
                    });
                };
                e853.on("init", ()=>{
                    Gm.setEditorTimeout(e853, o204, 0);
                });
            })(e852);
        })(e849), ((e)=>{
            const t591 = Ks(()=>{
                if (!e.removed && e.getBody().contains(document.activeElement)) {
                    const t = e.selection.getRng();
                    if (t.collapsed) {
                        const n = aC(e, t, !1);
                        e.selection.setRng(n);
                    }
                }
            }, 0);
            e.on("focus", ()=>{
                t591.throttle();
            }), e.on("blur", ()=>{
                t591.cancel();
            });
        })(e849), ((e)=>{
            e.on("init", ()=>{
                e.on("focusin", (t)=>{
                    const n = t.target;
                    if (Fo(n)) {
                        const t592 = ip(e.getBody(), n), o = Mo(t592) ? t592 : n;
                        e.selection.getNode() !== o && sC(e, o).each((t)=>e.selection.setRng(t)
                        );
                    }
                });
            });
        })(e849)), {
            showCaret: c11,
            showBlockCaretContainer: (e)=>{
                e.hasAttribute("data-mce-caret") && (Sr(e), t588.scrollIntoView(e));
            },
            hideFakeCaret: h,
            destroy: ()=>{
                s66.destroy(), l23 = null;
            }
        };
    }, lE = (e, t, n)=>{
        if (No(t) && (n < 0 || n > t.data.length)) return [];
        const o = [
            n
        ];
        let r = t;
        for(; r !== e && r.parentNode;){
            const e = r.parentNode;
            for(let t = 0; t < e.childNodes.length; t++)if (e.childNodes[t] === r) {
                o.push(t);
                break;
            }
            r = e;
        }
        return r === e ? o.reverse() : [];
    }, dE = (e, t, n, o, r)=>({
            start: lE(e, t, n),
            end: lE(e, o, r)
        })
    , cE = (e854, t593)=>{
        const n = t593.slice(), o = n.pop();
        return Y1(n, (e855, t)=>e855.bind((e)=>M1.from(e.childNodes[t])
            )
        , M1.some(e854)).bind((e)=>No(e) && (o < 0 || o > e.data.length) ? M1.none() : M1.some({
                node: e,
                offset: o
            })
        );
    }, uE = (e856, t594)=>cE(e856, t594.start).bind(({ node: n , offset: o  })=>cE(e856, t594.end).map(({ node: e , offset: t  })=>{
                const r = document.createRange();
                return r.setStart(n, o), r.setEnd(e, t), r;
            })
        )
    , mE = (e, t, n)=>{
        if (t && e.isEmpty(t) && !n(t)) {
            const o = t.parentNode;
            e.remove(t), mE(e, o, n);
        }
    }, fE = (e, t, n, o = !0)=>{
        const r = t.startContainer.parentNode, s = t.endContainer.parentNode;
        t.deleteContents(), o && !n(t.startContainer) && (No(t.startContainer) && 0 === t.startContainer.data.length && e.remove(t.startContainer), No(t.endContainer) && 0 === t.endContainer.data.length && e.remove(t.endContainer), mE(e, r, n), r !== s && mE(e, s, n));
    }, gE = (e, t)=>M1.from(e.dom.getParent(t.startContainer, e.dom.isBlock))
    , pE = (e857, t595, n367)=>{
        ((e858, t, n)=>{
            if (No(e858) && 0 >= e858.length) return M1.some(qw(e858, 0));
            {
                const t = ca(Ww);
                return M1.from(t.forwards(e858, 0, Kw(e858), n)).map((e)=>qw(e.container, 0)
                );
            }
        })(t595, 0, t595).each((o205)=>{
            const r = o205.container;
            Xw(r, n367.start.length, t595).each((n)=>{
                const o = e857.createRng();
                o.setStart(r, 0), o.setEnd(n.container, n.offset), fE(e857, o, (e)=>e === t595
                );
            });
        });
    }, hE = (e, t)=>e.create("span", {
            "data-mce-type": "bookmark",
            id: t
        })
    , bE = (e, t)=>{
        const n = e.createRng();
        return n.setStartAfter(t.start), n.setEndBefore(t.end), n;
    }, vE = (e, t, n)=>{
        const o = uE(e.getRoot(), n).getOrDie("Unable to resolve path range"), r = o.startContainer, s = o.endContainer, a = 0 === o.endOffset ? s : s.splitText(o.endOffset), i = 0 === o.startOffset ? r : r.splitText(o.startOffset);
        return {
            prefix: t,
            end: a.parentNode.insertBefore(hE(e, t + "-end"), a),
            start: i.parentNode.insertBefore(hE(e, t + "-start"), i)
        };
    }, yE = (e, t, n)=>{
        mE(e, e.get(t.prefix + "-end"), n), mE(e, e.get(t.prefix + "-start"), n);
    }, CE = (e)=>0 === e.start.length
    , xE = (e859, t596, n368, o206)=>{
        const r111 = t596.start;
        var s70;
        return Qw(e859, o206.container, o206.offset, (s70 = r111, (e, t)=>{
            const n = e.data.substring(0, t), o = n.lastIndexOf(s70.charAt(s70.length - 1)), r = n.lastIndexOf(s70);
            return -1 !== r ? r + s70.length : -1 !== o ? o + 1 : -1;
        }), n368).bind((o)=>{
            if (o.offset >= r111.length) {
                const t = e859.createRng();
                return t.setStart(o.container, o.offset - r111.length), t.setEnd(o.container, o.offset), M1.some(t);
            }
            {
                const s = o.offset - r111.length;
                return Yw(o.container, s, n368).map((t)=>{
                    const n = e859.createRng();
                    return n.setStart(t.container, t.offset), n.setEnd(o.container, o.offset), n;
                }).filter((e)=>e.toString() === r111
                ).orThunk(()=>xE(e859, t596, n368, qw(o.container, 0))
                );
            }
        });
    }, wE = (e860, t597, n369)=>{
        const o207 = e860.dom, r112 = o207.getRoot(), s71 = n369.pattern, a47 = n369.position.container, i30 = n369.position.offset;
        return Yw(a47, i30 - n369.pattern.end.length, t597).bind((l)=>{
            const d = dE(r112, l.container, l.offset, a47, i30);
            if (CE(s71)) return M1.some({
                matches: [
                    {
                        pattern: s71,
                        startRng: d,
                        endRng: d
                    }
                ],
                position: l
            });
            {
                const a = kE(e860, n369.remainingPatterns, l.container, l.offset, t597), i = a.getOr({
                    matches: [],
                    position: l
                }), c = i.position, u = ((e861, t, n370, o, r, s = !1)=>{
                    if (0 === t.start.length && !s) {
                        const t = e861.createRng();
                        return t.setStart(n370, o), t.setEnd(n370, o), M1.some(t);
                    }
                    return Gw(n370, o, r).bind((n)=>xE(e861, t, r, n).bind((e)=>{
                            if (s) {
                                if (e.endContainer === n.container && e.endOffset === n.offset) return M1.none();
                                if (0 === n.offset && e.endContainer.textContent.length === e.endOffset) return M1.none();
                            }
                            return M1.some(e);
                        })
                    );
                })(o207, s71, c.container, c.offset, t597, a.isNone());
                return u.map((e862)=>{
                    const t598 = ((e, t)=>dE(e, t.startContainer, t.startOffset, t.endContainer, t.endOffset)
                    )(r112, e862);
                    return {
                        matches: i.matches.concat([
                            {
                                pattern: s71,
                                startRng: t598,
                                endRng: d
                            }
                        ]),
                        position: qw(e862.startContainer, e862.startOffset)
                    };
                });
            }
        });
    }, kE = (e, t, n, o208, r)=>{
        const s72 = e.dom;
        return Gw(n, o208, s72.getRoot()).bind((a)=>{
            const i = s72.createRng();
            i.setStart(r, 0), i.setEnd(n, o208);
            const l = i.toString();
            for(let n371 = 0; n371 < t.length; n371++){
                const o = t[n371];
                if (!je1(l, o.end)) continue;
                const s = t.slice();
                s.splice(n371, 1);
                const i = wE(e, r, {
                    pattern: o,
                    remainingPatterns: s,
                    position: a
                });
                if (i.isSome()) return i;
            }
            return M1.none();
        });
    }, SE = (e, t599, n)=>{
        e.selection.setRng(n), "inline-format" === t599.type ? $1(t599.format, (t)=>{
            e.formatter.apply(t);
        }) : e.execCommand(t599.cmd, !1, t599.value);
    }, _E = (e863, t, n)=>{
        const o = e863.selection.getRng();
        return !1 === o.collapsed ? [] : gE(e863, o).bind((r)=>{
            const s = Math.max(0, o.startOffset - (n ? 1 : 0));
            return kE(e863, t, o.startContainer, s, r);
        }).fold(()=>[]
        , (e)=>e.matches
        );
    }, EE = (e864, t600)=>{
        if (0 === t600.length) return;
        const n372 = e864.dom, o209 = e864.selection.getBookmark(), r113 = ((e, t601)=>{
            const n = sa("mce_textpattern"), o210 = G1(t601, (t, o)=>{
                const r = vE(e, n + `_end${t.length}`, o.endRng);
                return t.concat([
                    {
                        ...o,
                        endMarker: r
                    }
                ]);
            }, []);
            return G1(o210, (t, r)=>{
                const s = o210.length - t.length - 1, a = CE(r.pattern) ? r.endMarker : vE(e, n + `_start${s}`, r.startRng);
                return t.concat([
                    {
                        ...r,
                        startMarker: a
                    }
                ]);
            }, []);
        })(n372, t600);
        $1(r113, (t602)=>{
            const o211 = n372.getParent(t602.startMarker.start, n372.isBlock), r114 = (e)=>e === o211
            ;
            CE(t602.pattern) ? ((e, t, n, o)=>{
                const r = bE(e.dom, n);
                fE(e.dom, r, o), SE(e, t, r);
            })(e864, t602.pattern, t602.endMarker, r114) : ((e, t, n, o, r)=>{
                const s = e.dom, a = bE(s, o), i = bE(s, n);
                fE(s, i, r), fE(s, a, r);
                const l = {
                    prefix: n.prefix,
                    start: n.end,
                    end: o.start
                }, d = bE(s, l);
                SE(e, t, d);
            })(e864, t602.pattern, t602.startMarker, t602.endMarker, r114), yE(n372, t602.endMarker, r114), yE(n372, t602.startMarker, r114);
        }), e864.selection.moveToBookmark(o209);
    }, NE = (e865, t603)=>{
        if (!e865.selection.isCollapsed() || !((e)=>e.inlinePatterns.length > 0 || e.blockPatterns.length > 0
        )(t603)) return !1;
        const n373 = _E(e865, t603.inlinePatterns, !1), o212 = ((e866, t604)=>{
            const n374 = e866.dom, o213 = e866.selection.getRng();
            return gE(e866, o213).filter((t)=>{
                const o = Ti(e866), r = n374.is(t, o);
                return null !== t && r;
            }).bind((e867)=>{
                const o = e867.textContent, r = ((e868, t)=>{
                    const n = t.replace(dr, " ");
                    return Q1(e868, (e)=>0 === t.indexOf(e.start) || 0 === n.indexOf(e.start)
                    );
                })(t604, o);
                return r.map((t)=>Bt.trim(o).length === t.start.length ? [] : [
                        {
                            pattern: t,
                            range: dE(n374.getRoot(), e867, 0, e867, 0)
                        }
                    ]
                );
            }).getOr([]);
        })(e865, t603.blockPatterns);
        return (o212.length > 0 || n373.length > 0) && (e865.undoManager.add(), e865.undoManager.extra(()=>{
            e865.execCommand("mceInsertNewLine");
        }, ()=>{
            e865.insertContent(lr), EE(e865, n373), ((e869, t606)=>{
                if (0 === t606.length) return;
                const n375 = e869.selection.getBookmark();
                $1(t606, (t607)=>((e870, t608)=>{
                        const n376 = e870.dom, o = t608.pattern, r = uE(n376.getRoot(), t608.range).getOrDie("Unable to resolve path range");
                        return gE(e870, r).each((t609)=>{
                            "block-format" === o.type ? ((e871, t)=>{
                                const n = t.get(e871);
                                return p1(n) && ie1(n).exists((e)=>we1(e, "block")
                                );
                            })(o.format, e870.formatter) && e870.undoManager.transact(()=>{
                                pE(e870.dom, t609, o), e870.formatter.apply(o.format);
                            }) : "block-command" === o.type && e870.undoManager.transact(()=>{
                                pE(e870.dom, t609, o), e870.execCommand(o.cmd, !1, o.value);
                            });
                        }), !0;
                    })(e869, t607)
                ), e869.selection.moveToBookmark(n375);
            })(e865, o212);
            const t605 = e865.selection.getRng(), r115 = Gw(t605.startContainer, t605.startOffset, e865.dom.getRoot());
            e865.execCommand("mceInsertNewLine"), r115.each((t610)=>{
                const n = t610.container;
                n.data.charAt(t610.offset - 1) === lr && (n.deleteData(t610.offset - 1, 1), mE(e865.dom, n.parentNode, (t)=>t === e865.dom.getRoot()
                ));
            });
        }), !0);
    }, RE = (e, t)=>{
        if (t.length > 0) {
            const n = _E(e, t, !0);
            n.length > 0 && e.undoManager.transact(()=>{
                EE(e, n);
            });
        }
    }, AE = (e, t, n)=>{
        for(let o = 0; o < e.length; o++)if (n(e[o], t)) return !0;
        return !1;
    }, OE = (e872)=>{
        const t611 = [
            ",",
            ".",
            ";",
            ":",
            "!",
            "?"
        ], n377 = [
            32
        ], o = ()=>pi(Xl(e872))
        ;
        e872.on("keydown", (t)=>{
            var n;
            13 !== t.keyCode || Uu.modifierPressed(t) || NE(e872, (n = Xl(e872), {
                inlinePatterns: pi(n),
                blockPatterns: gi(n)
            })) && t.preventDefault();
        }, !0), e872.on("keyup", (t612)=>{
            AE(n377, t612, (e, t)=>e === t.keyCode && !1 === Uu.modifierPressed(t)
            ) && RE(e872, o());
        }), e872.on("keypress", (n)=>{
            AE(t611, n, (e, t)=>e.charCodeAt(0) === t.charCode
            ) && Gm.setEditorTimeout(e872, ()=>{
                RE(e872, o());
            });
        });
    }, TE = (e873)=>{
        const t613 = Bt.each, n378 = Uu.BACKSPACE, o214 = Uu.DELETE, r116 = e873.dom, s73 = e873.selection, a48 = e873.parser, i31 = Nt.browser, l24 = i31.isFirefox(), d = i31.isChromium() || i31.isSafari(), c = Nt.deviceType.isiPhone() || Nt.deviceType.isiPad(), u = Nt.os.isMacOS() || Nt.os.isiOS(), m = (t, n)=>{
            try {
                e873.getDoc().execCommand(t, !1, n);
            } catch (e) {}
        }, f = (e)=>e.isDefaultPrevented()
        , g = ()=>{
            e873.shortcuts.add("meta+a", null, "SelectAll");
        }, p = ()=>{
            e873.inline || r116.bind(e873.getDoc(), "mousedown mouseup", (t)=>{
                let n;
                if (t.target === e873.getDoc().documentElement) {
                    if (n = s73.getRng(), e873.getBody().focus(), "mousedown" === t.type) {
                        if (vr(n.startContainer)) return;
                        s73.placeCaretAt(t.clientX, t.clientY);
                    } else s73.setRng(n);
                }
            });
        }, h = ()=>{
            Range.prototype.getClientRects || e873.on("mousedown", (t)=>{
                if (!f(t) && "HTML" === t.target.nodeName) {
                    const t = e873.getBody();
                    t.blur(), Gm.setEditorTimeout(e873, ()=>{
                        t.focus();
                    });
                }
            });
        }, b = ()=>{
            const t = Tl(e873);
            e873.on("click", (n)=>{
                const o = n.target;
                /^(IMG|HR)$/.test(o.nodeName) && "false" !== r116.getContentEditableParent(o) && (n.preventDefault(), e873.selection.select(o), e873.nodeChanged()), "A" === o.nodeName && r116.hasClass(o, t) && 0 === o.childNodes.length && (n.preventDefault(), s73.select(o));
            });
        }, v = ()=>{
            e873.on("keydown", (e)=>{
                if (!f(e) && e.keyCode === n378 && s73.isCollapsed() && 0 === s73.getRng().startOffset) {
                    const t = s73.getNode().previousSibling;
                    if (t && t.nodeName && "table" === t.nodeName.toLowerCase()) return e.preventDefault(), !1;
                }
            });
        }, y = ()=>{
            Sl(e873) || e873.on("BeforeExecCommand mousedown", ()=>{
                m("StyleWithCSS", !1), m("enableInlineTableEditing", !1), ol(e873) || m("enableObjectResizing", !1);
            });
        }, C = ()=>{
            e873.contentStyles.push("img:-moz-broken {-moz-force-broken-image-icon:1;min-width:24px;min-height:24px}");
        }, x = ()=>{
            e873.inline || e873.on("keydown", ()=>{
                document.activeElement === document.body && e873.getWin().focus();
            });
        }, w = ()=>{
            e873.inline || (e873.contentStyles.push("body {min-height: 150px}"), e873.on("click", (t)=>{
                let n;
                "HTML" === t.target.nodeName && (n = e873.selection.getRng(), e873.getBody().focus(), e873.selection.setRng(n), e873.selection.normalize(), e873.nodeChanged());
            }));
        }, k = ()=>{
            u && e873.on("keydown", (t)=>{
                !Uu.metaKeyPressed(t) || t.shiftKey || 37 !== t.keyCode && 39 !== t.keyCode || (t.preventDefault(), e873.selection.getSel().modify("move", 37 === t.keyCode ? "backward" : "forward", "lineboundary"));
            });
        }, _ = ()=>{
            e873.on("click", (e)=>{
                let t = e.target;
                do {
                    if ("A" === t.tagName) return void e.preventDefault();
                }while (t = t.parentNode)
            }), e873.contentStyles.push(".mce-content-body {-webkit-touch-callout: none}");
        }, E = ()=>{
            e873.on("init", ()=>{
                e873.dom.bind(e873.getBody(), "submit", (e)=>{
                    e.preventDefault();
                });
            });
        }, N = S1;
        return _v(e873) ? (d && (p(), b(), E(), g(), c && (x(), w(), _())), l24 && (h(), y(), C(), k())) : (e873.on("keydown", (t)=>{
            let n, o;
            if (f(t) || t.keyCode !== Uu.BACKSPACE) return;
            n = s73.getRng();
            const a = n.startContainer, i = n.startOffset, l = r116.getRoot();
            if (o = a, n.collapsed && 0 === i) {
                for(; o && o.parentNode && o.parentNode.firstChild === o && o.parentNode !== l;)o = o.parentNode;
                "BLOCKQUOTE" === o.tagName && (e873.formatter.toggle("blockquote", null, o), n = r116.createRng(), n.setStart(a, 0), n.setEnd(a, 0), s73.setRng(n));
            }
        }), (()=>{
            const t614 = (e)=>{
                const t = r116.create("body"), n = e.cloneContents();
                return t.appendChild(n), s73.serializer.serialize(t, {
                    format: "html"
                });
            };
            e873.on("keydown", (s74)=>{
                const a = s74.keyCode;
                let i, l;
                if (!f(s74) && (a === o214 || a === n378)) {
                    if (i = e873.selection.isCollapsed(), l = e873.getBody(), i && !r116.isEmpty(l)) return;
                    if (!i && !((n)=>{
                        const o = t614(n), s = r116.createRng();
                        return s.selectNode(e873.getBody()), o === t614(s);
                    })(e873.selection.getRng())) return;
                    s74.preventDefault(), e873.setContent(""), l.firstChild && r116.isBlock(l.firstChild) ? e873.selection.setCursorLocation(l.firstChild, 0) : e873.selection.setCursorLocation(l, 0), e873.nodeChanged();
                }
            });
        })(), Nt.windowsPhone || e873.on("keyup focusin mouseup", (e)=>{
            Uu.modifierPressed(e) || s73.normalize();
        }, !0), d && (p(), b(), e873.on("init", ()=>{
            m("DefaultParagraphSeparator", Ti(e873));
        }), E(), v(), a48.addNodeFilter("br", (e)=>{
            let t = e.length;
            for(; t--;)"Apple-interchange-newline" === e[t].attr("class") && e[t].remove();
        }), c ? (x(), w(), _()) : g()), l24 && (e873.on("keydown", (t)=>{
            if (!f(t) && t.keyCode === n378) {
                if (!e873.getBody().getElementsByTagName("hr").length) return;
                if (s73.isCollapsed() && 0 === s73.getRng().startOffset) {
                    const e = s73.getNode(), n = e.previousSibling;
                    if ("HR" === e.nodeName) return r116.remove(e), void t.preventDefault();
                    n && n.nodeName && "hr" === n.nodeName.toLowerCase() && (r116.remove(n), t.preventDefault());
                }
            }
        }), h(), (()=>{
            const n379 = ()=>{
                const n = r116.getAttribs(s73.getStart().cloneNode(!1));
                return ()=>{
                    const o = s73.getStart();
                    o !== e873.getBody() && (r116.setAttrib(o, "style", null), t613(n, (e)=>{
                        o.setAttributeNode(e.cloneNode(!0));
                    }));
                };
            }, o215 = ()=>!s73.isCollapsed() && r116.getParent(s73.getStart(), r116.isBlock) !== r116.getParent(s73.getEnd(), r116.isBlock)
            ;
            e873.on("keypress", (t)=>{
                let r;
                if (!f(t) && (8 === t.keyCode || 46 === t.keyCode) && o215()) return r = n379(), e873.getDoc().execCommand("delete", !1, null), r(), t.preventDefault(), !1;
            }), r116.bind(e873.getDoc(), "cut", (t)=>{
                let r;
                !f(t) && o215() && (r = n379(), Gm.setEditorTimeout(e873, ()=>{
                    r();
                }));
            });
        })(), y(), e873.on("SetContent ExecCommand", (e874)=>{
            "setcontent" !== e874.type && "mceInsertLink" !== e874.command || t613(r116.select("a"), (e)=>{
                let t = e.parentNode;
                const n = r116.getRoot();
                if (t.lastChild === e) {
                    for(; t && !r116.isBlock(t);){
                        if (t.parentNode.lastChild !== t || t === n) return;
                        t = t.parentNode;
                    }
                    r116.add(t, "br", {
                        "data-mce-bogus": 1
                    });
                }
            });
        }), C(), k(), v())), {
            refreshContentEditable: N,
            isHidden: ()=>{
                if (!l24 || e873.removed) return !1;
                const t = e873.selection.getSel();
                return !t || !t.rangeCount || 0 === t.rangeCount;
            }
        };
    }, BE = Is.DOM, DE = (e)=>e.inline ? e.getElement().nodeName.toLowerCase() : void 0
    , LE = (e875)=>ve1(e875, (e)=>!1 === v1(e)
        )
    , PE = (e)=>{
        const t = e.options.get, n = e.editorUpload.blobCache;
        return LE({
            allow_conditional_comments: t("allow_conditional_comments"),
            allow_html_data_urls: t("allow_html_data_urls"),
            allow_svg_data_urls: t("allow_svg_data_urls"),
            allow_html_in_named_anchor: t("allow_html_in_named_anchor"),
            allow_script_urls: t("allow_script_urls"),
            allow_unsafe_link_target: t("allow_unsafe_link_target"),
            convert_fonts_to_spans: t("convert_fonts_to_spans"),
            fix_list_elements: t("fix_list_elements"),
            font_size_legacy_values: t("font_size_legacy_values"),
            forced_root_block: t("forced_root_block"),
            forced_root_block_attrs: t("forced_root_block_attrs"),
            preserve_cdata: t("preserve_cdata"),
            remove_trailing_brs: t("remove_trailing_brs"),
            inline_styles: t("inline_styles"),
            root_name: DE(e),
            validate: !0,
            blob_cache: n,
            document: e.getDoc()
        });
    }, ME = (e)=>{
        const t = e.options.get;
        return LE({
            custom_elements: t("custom_elements"),
            extended_valid_elements: t("extended_valid_elements"),
            invalid_elements: t("invalid_elements"),
            invalid_styles: t("invalid_styles"),
            schema: t("schema"),
            valid_children: t("valid_children"),
            valid_classes: t("valid_classes"),
            valid_elements: t("valid_elements"),
            valid_styles: t("valid_styles"),
            verify_html: t("verify_html")
        });
    }, IE = (e)=>e.inline ? e.ui.styleSheetLoader : e.dom.styleSheetLoader
    , FE = (e876)=>{
        const t615 = IE(e876), n380 = el(e876), o216 = e876.contentCSS, r117 = ()=>{
            t615.unloadAll(o216), e876.inline || e876.ui.styleSheetLoader.unloadAll(n380);
        }, s = ()=>{
            e876.removed ? r117() : e876.on("remove", r117);
        };
        if (e876.contentStyles.length > 0) {
            let t = "";
            Bt.each(e876.contentStyles, (e)=>{
                t += e + "\r\n";
            }), e876.dom.addStyle(t);
        }
        const a = Promise.all(((e, t, n)=>{
            const o = [
                IE(e).loadAll(t)
            ];
            return e.inline ? o : o.concat([
                e.ui.styleSheetLoader.loadAll(n)
            ]);
        })(e876, o216, n380)).then(s).catch(s), i = Zi(e876);
        return i && ((e, t)=>{
            const n = mn(e.getBody()), o = Mn(Pn(n)), r = cn("style");
            $t(r, "type", "text/css"), Jn(r, un(t)), Jn(o, r), e.on("remove", ()=>{
                to(r);
            });
        })(e876, i), a;
    }, UE = (e877)=>{
        !0 !== e877.removed && (((e)=>{
            _v(e) || e.load({
                initial: !0,
                format: "html"
            }), e.startContent = e.getContent({
                format: "raw"
            });
        })(e877), ((e878)=>{
            e878.bindPendingEventDelegates(), e878.initialized = !0, ((e)=>{
                e.dispatch("Init");
            })(e878), e878.focus(!0), ((e)=>{
                const t617 = e.dom.getRoot();
                e.inline || wu(e) && e.selection.getStart(!0) !== t617 || uc(t617).each((t)=>{
                    const n = t.getNode(), o = So(n) ? uc(n).getOr(t) : t;
                    e.selection.setRng(o.toRange());
                });
            })(e878), e878.nodeChanged({
                initial: !0
            });
            const t616 = Ll(e878);
            x1(t616) && t616.call(e878, e878), ((e)=>{
                const t = Ml(e);
                t && Gm.setEditorTimeout(e, ()=>{
                    let n;
                    n = !0 === t ? e : e.editorManager.get(t), n.destroyed || n.focus();
                }, 100);
            })(e878);
        })(e877));
    }, zE = (e879)=>{
        const t618 = e879.getElement();
        let n381 = e879.getDoc();
        e879.inline && (BE.addClass(t618, "mce-content-body"), e879.contentDocument = n381 = document, e879.contentWindow = window, e879.bodyElement = t618, e879.contentAreaContainer = t618);
        const o217 = e879.getBody();
        o217.disabled = !0, e879.readonly = Sl(e879), e879.readonly || (e879.inline && "static" === BE.getStyle(o217, "position", !0) && (o217.style.position = "relative"), o217.contentEditable = "true"), o217.disabled = !1, e879.editorUpload = gy(e879), e879.schema = vs(ME(e879)), e879.dom = Is(n381, {
            keep_values: !0,
            url_converter: e879.convertURL,
            url_converter_scope: e879,
            update_styles: !0,
            root_element: e879.inline ? e879.getBody() : null,
            collect: ()=>e879.inline
            ,
            schema: e879.schema,
            contentCssCors: Wi(e879),
            referrerPolicy: Ki(e879),
            onSetAttrib: (t)=>{
                e879.dispatch("SetAttrib", t);
            }
        }), e879.parser = ((e880)=>{
            const t619 = Wb(PE(e880), e880.schema);
            return t619.addAttributeFilter("src,href,style,tabindex", (t, n)=>{
                let o, r, s = t.length;
                const a = e880.dom, i = "data-mce-" + n;
                for(; s--;)if (o = t[s], r = o.attr(n), r && !o.attr(i)) {
                    if (0 === r.indexOf("data:") || 0 === r.indexOf("blob:")) continue;
                    "style" === n ? (r = a.serializeStyle(a.parseStyle(r), o.name), r.length || (r = null), o.attr(i, r), o.attr(n, r)) : "tabindex" === n ? (o.attr(i, r), o.attr(n, null)) : o.attr(i, e880.convertURL(r, n, o.name));
                }
            }), t619.addNodeFilter("script", (e)=>{
                let t = e.length;
                for(; t--;){
                    const n = e[t], o = n.attr("type") || "no/type";
                    0 !== o.indexOf("mce-") && n.attr("type", "mce-" + o);
                }
            }), e880.options.get("preserve_cdata") && t619.addNodeFilter("#cdata", (t)=>{
                let n = t.length;
                for(; n--;){
                    const o = t[n];
                    o.type = 8, o.name = "#comment", o.value = "[CDATA[" + e880.dom.encode(o.value) + "]]";
                }
            }), t619.addNodeFilter("p,h1,h2,h3,h4,h5,h6,div", (t)=>{
                let n = t.length;
                const o = e880.schema.getNonEmptyElements();
                for(; n--;){
                    const e = t[n];
                    e.isEmpty(o) && 0 === e.getAll("br").length && e.append(new yf("br", 1));
                }
            }), t619;
        })(e879), e879.serializer = Mv(((e)=>{
            const t = e.options.get;
            return {
                ...PE(e),
                ...ME(e),
                ...LE({
                    url_converter: t("url_converter"),
                    url_converter_scope: t("url_converter_scope"),
                    element_format: t("element_format"),
                    entities: t("entities"),
                    entity_encoding: t("entity_encoding"),
                    indent: t("indent"),
                    indent_after: t("indent_after"),
                    indent_before: t("indent_before")
                })
            };
        })(e879), e879), e879.selection = Dv(e879.dom, e879.getWin(), e879.serializer, e879), e879.annotator = Ou(e879), e879.formatter = Sy(e879), e879.undoManager = Ey(e879), e879._nodeChangeDispatcher = new l_(e879), e879._selectionOverrides = iE(e879), ((e881)=>{
            const t620 = Ws(), n382 = zs(!1), o218 = Gs((t)=>{
                e881.dispatch("longpress", {
                    ...t,
                    type: "longpress"
                }), n382.set(!0);
            }, 400);
            e881.on("touchstart", (e)=>{
                Xx(e).each((r)=>{
                    o218.cancel();
                    const s = {
                        x: r.clientX,
                        y: r.clientY,
                        target: e.target
                    };
                    o218.throttle(e), n382.set(!1), t620.set(s);
                });
            }, !0), e881.on("touchmove", (r119)=>{
                o218.cancel(), Xx(r119).each((o219)=>{
                    t620.on((r)=>{
                        ((e, t)=>{
                            const n = Math.abs(e.clientX - t.x), o = Math.abs(e.clientY - t.y);
                            return n > 5 || o > 5;
                        })(o219, r) && (t620.clear(), n382.set(!1), e881.dispatch("longpresscancel"));
                    });
                });
            }, !0), e881.on("touchend touchcancel", (r)=>{
                o218.cancel(), "touchcancel" !== r.type && t620.get().filter((e)=>e.target.isEqualNode(r.target)
                ).each(()=>{
                    n382.get() ? r.preventDefault() : e881.dispatch("tap", {
                        ...r,
                        type: "tap"
                    });
                });
            }, !0);
        })(e879), ((e882)=>{
            ((e)=>{
                e.on("click", (t)=>{
                    e.dom.getParent(t.target, "details") && t.preventDefault();
                });
            })(e882), ((e883)=>{
                e883.parser.addNodeFilter("details", (e884)=>{
                    $1(e884, (e)=>{
                        e.attr("data-mce-open", e.attr("open")), e.attr("open", "open");
                    });
                }), e883.serializer.addNodeFilter("details", (e885)=>{
                    $1(e885, (e)=>{
                        const t = e.attr("data-mce-open");
                        e.attr("open", m1(t) ? t : null), e.attr("data-mce-open", null);
                    });
                });
            })(e882);
        })(e879), ((e886)=>{
            const t621 = "contenteditable", n383 = " " + Bt.trim(Jl(e886)) + " ", o220 = " " + Bt.trim(Ql(e886)) + " ", r120 = tw(n383), s = tw(o220), a = Zl(e886);
            a.length > 0 && e886.on("BeforeSetContent", (t622)=>{
                ((e, t, n)=>{
                    let o = t.length, r = n.content;
                    if ("raw" !== n.format) {
                        for(; o--;)r = r.replace(t[o], nw(e, r, Ql(e)));
                        n.content = r;
                    }
                })(e886, a, t622);
            }), e886.parser.addAttributeFilter("class", (e)=>{
                let n = e.length;
                for(; n--;){
                    const o = e[n];
                    r120(o) ? o.attr(t621, "true") : s(o) && o.attr(t621, "false");
                }
            }), e886.serializer.addAttributeFilter(t621, (e)=>{
                let n = e.length;
                for(; n--;){
                    const o = e[n];
                    (r120(o) || s(o)) && (a.length > 0 && o.attr("data-mce-content") ? (o.name = "#text", o.type = 3, o.raw = !0, o.value = o.attr("data-mce-content")) : o.attr(t621, null));
                }
            });
        })(e879), _v(e879) || (((e887)=>{
            e887.on("click", (t623)=>{
                t623.detail >= 3 && ((e889)=>{
                    const t = e889.selection.getRng(), n = Ua.fromRangeStart(t), o = Ua.fromRangeEnd(t);
                    if (Ua.isElementPosition(n)) {
                        const e888 = n.container();
                        $_(e888) && uc(e888).each((e)=>t.setStart(e.container(), e.offset())
                        );
                    }
                    if (Ua.isElementPosition(o)) {
                        const e890 = n.container();
                        $_(e890) && mc(e890).each((e)=>t.setEnd(e.container(), e.offset())
                        );
                    }
                    e889.selection.setRng(bp(t));
                })(e887);
            });
        })(e879), ((e)=>{
            OE(e);
        })(e879));
        const r118 = i_(e879);
        Yx(e879, r118), ((e)=>{
            e.on("NodeChange", O1(ew, e));
        })(e879), ((e892)=>{
            const t624 = e892.dom, n384 = Ti(e892), o221 = sl(e892), r = (s, a)=>{
                if (((e)=>{
                    if (Ay(e)) {
                        const t = e.keyCode;
                        return !Oy(e) && (Uu.metaKeyPressed(e) || e.altKey || t >= 112 && t <= 123 || j1(Ny, t));
                    }
                    return !1;
                })(s)) return;
                const i = e892.getBody(), l = !((e)=>Ay(e) && !(Oy(e) || "keyup" === e.type && 229 === e.keyCode)
                )(s) && ((e, t, n)=>{
                    if (qr(mn(t), !1)) {
                        const o = t.firstElementChild;
                        return !o || !e.getStyle(t.firstElementChild, "padding-left") && !e.getStyle(t.firstElementChild, "padding-right") && n === o.nodeName.toLowerCase();
                    }
                    return !1;
                })(t624, i, n384);
                ("" !== t624.getAttrib(i, Ry) !== l || a) && (t624.setAttrib(i, Ry, l ? o221 : null), t624.setAttrib(i, "aria-placeholder", l ? o221 : null), ((e, t)=>{
                    e.dispatch("PlaceholderToggle", {
                        state: t
                    });
                })(e892, l), e892.on(l ? "keydown" : "keyup", r), e892.off(l ? "keyup" : "keydown", r));
            };
            o221 && e892.on("init", (t625)=>{
                r(t625, !0), e892.on("change SetContent ExecCommand", r), e892.on("paste", (t)=>Gm.setEditorTimeout(e892, ()=>r(t)
                    )
                );
            });
        })(e879), H_(e879);
        const s75 = ((e893)=>{
            const t626 = e893;
            return ((e894)=>xe1(e894.plugins, "rtc").bind((e)=>M1.from(e.setup)
                )
            )(e893).fold(()=>(t626.rtcInstance = Sv(e893), M1.none())
            , (e895)=>(t626.rtcInstance = (()=>{
                    const e = N1(null), t = N1("");
                    return {
                        init: {
                            bindEvents: S1
                        },
                        undoManager: {
                            beforeChange: S1,
                            add: e,
                            undo: e,
                            redo: e,
                            clear: S1,
                            reset: S1,
                            hasUndo: L1,
                            hasRedo: L1,
                            transact: e,
                            ignore: S1,
                            extra: S1
                        },
                        formatter: {
                            match: L1,
                            matchAll: N1([]),
                            matchNode: N1(void 0),
                            canApply: L1,
                            closest: t,
                            apply: S1,
                            remove: S1,
                            toggle: S1,
                            formatChanged: N1({
                                unbind: S1
                            })
                        },
                        editor: {
                            getContent: t,
                            setContent: N1({
                                content: "",
                                html: ""
                            }),
                            insertContent: N1(""),
                            addVisual: S1
                        },
                        selection: {
                            getContent: t
                        },
                        autocompleter: {
                            addDecoration: S1,
                            removeDecoration: S1
                        },
                        raw: {
                            getModel: N1(M1.none())
                        }
                    };
                })(), M1.some(()=>e895().then((e896)=>(t626.rtcInstance = ((e897)=>{
                            const t627 = (e)=>f1(e) ? e : {}
                            , { init: n385 , undoManager: o222 , formatter: r121 , editor: s76 , selection: a , autocompleter: i , raw: l  } = e897;
                            return {
                                init: {
                                    bindEvents: n385.bindEvents
                                },
                                undoManager: {
                                    beforeChange: o222.beforeChange,
                                    add: o222.add,
                                    undo: o222.undo,
                                    redo: o222.redo,
                                    clear: o222.clear,
                                    reset: o222.reset,
                                    hasUndo: o222.hasUndo,
                                    hasRedo: o222.hasRedo,
                                    transact: (e, t, n)=>o222.transact(n)
                                    ,
                                    ignore: (e, t)=>o222.ignore(t)
                                    ,
                                    extra: (e, t, n, r)=>o222.extra(n, r)
                                },
                                formatter: {
                                    match: (e, n, o, s)=>r121.match(e, t627(n), s)
                                    ,
                                    matchAll: r121.matchAll,
                                    matchNode: r121.matchNode,
                                    canApply: (e)=>r121.canApply(e)
                                    ,
                                    closest: (e)=>r121.closest(e)
                                    ,
                                    apply: (e, n, o)=>r121.apply(e, t627(n))
                                    ,
                                    remove: (e, n, o, s)=>r121.remove(e, t627(n))
                                    ,
                                    toggle: (e, n, o)=>r121.toggle(e, t627(n))
                                    ,
                                    formatChanged: (e, t, n, o, s)=>r121.formatChanged(t, n, o, s)
                                },
                                editor: {
                                    getContent: (e)=>s76.getContent(e)
                                    ,
                                    setContent: (e, t)=>({
                                            content: s76.setContent(e, t),
                                            html: ""
                                        })
                                    ,
                                    insertContent: (e, t)=>(s76.insertContent(e), "")
                                    ,
                                    addVisual: s76.addVisual
                                },
                                selection: {
                                    getContent: (e, t)=>a.getContent(t)
                                },
                                autocompleter: {
                                    addDecoration: i.addDecoration,
                                    removeDecoration: i.removeDecoration
                                },
                                raw: {
                                    getModel: ()=>M1.some(l.getRawModel())
                                }
                            };
                        })(e896), e896.rtc.isRemote)
                    )
                ))
            );
        })(e879);
        ((e898)=>{
            const t628 = e898.getDoc(), n = e898.getBody();
            ((e)=>{
                e.dispatch("PreInit");
            })(e898), Il(e898) || (t628.body.spellcheck = !1, BE.setAttrib(n, "spellcheck", "false")), e898.quirks = TE(e898), ((e)=>{
                e.dispatch("PostRender");
            })(e898);
            const o = tl(e898);
            void 0 !== o && (n.dir = o);
            const r = Fl(e898);
            r && e898.on("BeforeSetContent", (e899)=>{
                Bt.each(r, (t)=>{
                    e899.content = e899.content.replace(t, (e)=>"\x3c!--mce:protected " + escape(e) + "--\x3e"
                    );
                });
            }), e898.on("SetContent", ()=>{
                e898.addVisual(e898.getBody());
            }), e898.on("compositionstart compositionend", (t)=>{
                e898.composing = "compositionstart" === t.type;
            });
        })(e879), s75.fold(()=>{
            FE(e879).then(()=>UE(e879)
            );
        }, (t629)=>{
            e879.setProgressState(!0), FE(e879).then(()=>{
                t629().then((t)=>{
                    e879.setProgressState(!1), UE(e879), Rv(e879);
                }, (t)=>{
                    e879.notificationManager.open({
                        type: "error",
                        text: String(t)
                    }), UE(e879), Rv(e879);
                });
            });
        });
    }, jE = (e, t)=>{
        if (e.inline || (e.getElement().style.visibility = e.orgVisibility), t || e.inline) zE(e);
        else {
            const t = e.iframeElement, o = (n = mn(t), so(n, "load", ly, ()=>{
                o.unbind(), e.contentDocument = t.contentDocument, zE(e);
            }));
            t.srcdoc = e.iframeHTML;
        }
        var n;
    }, VE = Is.DOM, HE = Is.DOM, $E = (e)=>({
            editorContainer: e,
            iframeContainer: e,
            api: {}
        })
    , qE = (e900)=>{
        const t630 = e900.getElement();
        return e900.orgDisplay = t630.style.display, m1(ll(e900)) ? ((e)=>e.theme.renderUI()
        )(e900) : x1(ll(e900)) ? ((e)=>{
            const t = e.getElement(), n = ll(e)(e, t);
            return n.editorContainer.nodeType && (n.editorContainer.id = n.editorContainer.id || e.id + "_parent"), n.iframeContainer && n.iframeContainer.nodeType && (n.iframeContainer.id = n.iframeContainer.id || e.id + "_iframecontainer"), n.height = n.iframeHeight ? n.iframeHeight : t.offsetHeight, n;
        })(e900) : ((e901)=>{
            const t631 = e901.getElement();
            return e901.inline ? $E(null) : ((e)=>{
                const t = HE.create("div");
                return HE.insertAfter(t, e), $E(t);
            })(t631);
        })(e900);
    }, WE = (e902)=>{
        e902.dispatch("ScriptsLoaded"), ((e)=>{
            const t633 = Bt.trim(zi(e)), n = e.ui.registry.getAll().icons, o223 = {
                ...$v.get("default").icons,
                ...$v.get(t633).icons
            };
            fe1(o223, (t, o)=>{
                we1(n, o) || e.ui.registry.addIcon(o, t);
            });
        })(e902), ((e)=>{
            const t = ll(e);
            if (m1(t)) {
                const n = ey.get(t);
                e.theme = n(e, ey.urls[t]) || {}, x1(e.theme.init) && e.theme.init(e, ey.urls[t] || e.documentBaseUrl.replace(/\/$/, ""));
            } else e.theme = {};
        })(e902), ((e)=>{
            const t = cl(e), n = qv.get(t);
            e.model = n(e, qv.urls[t]);
        })(e902), ((e903)=>{
            const t634 = [];
            $1(El(e903), (n387)=>{
                ((e904, t, n388)=>{
                    const o224 = Zv.get(n388), r = Zv.urls[n388] || e904.documentBaseUrl.replace(/\/$/, "");
                    if (n388 = Bt.trim(n388), o224 && -1 === Bt.inArray(t, n388)) {
                        if (e904.plugins[n388]) return;
                        try {
                            const s = o224(e904, r) || {};
                            e904.plugins[n388] = s, x1(s.init) && (s.init(e904, r), t.push(n388));
                        } catch (t635) {
                            ((e, t, n)=>{
                                const o = $s.translate([
                                    "Failed to initialize plugin: {0}",
                                    t
                                ]);
                                Du(e, "PluginLoadError", {
                                    message: o
                                }), ay(o, n), oy(e, o);
                            })(e904, n388, t635);
                        }
                    }
                })(e903, t634, ((e)=>e.replace(/^\-/, "")
                )(n387));
            });
        })(e902);
        const t632 = qE(e902);
        ((e905, t)=>{
            const n389 = {
                show: M1.from(t.show).getOr(S1),
                hide: M1.from(t.hide).getOr(S1),
                isEnabled: M1.from(t.isEnabled).getOr(P1),
                setEnabled: (n)=>{
                    e905.mode.isReadOnly() || M1.from(t.setEnabled).each((e)=>e(n)
                    );
                }
            };
            e905.ui = {
                ...e905.ui,
                ...n389
            };
        })(e902, M1.from(t632.api).getOr({}));
        const n386 = {
            editorContainer: t632.editorContainer,
            iframeContainer: t632.iframeContainer
        };
        return e902.editorContainer = n386.editorContainer ? n386.editorContainer : null, ((e906)=>{
            e906.contentCSS = e906.contentCSS.concat(((e)=>iy(e, Ji(e))
            )(e906), ((e)=>iy(e, el(e))
            )(e906));
        })(e902), e902.inline ? jE(e902) : ((e907, t636)=>{
            ((e908, t637)=>{
                const n390 = e908.translate("Rich Text Area"), o225 = Kt(mn(e908.getElement()), "tabindex").bind(Ge), r122 = ((e909, t, n, o)=>{
                    const r = cn("iframe");
                    return o.each((e)=>$t(r, "tabindex", e)
                    ), qt(r, n), qt(r, {
                        id: e909 + "_ifr",
                        frameBorder: "0",
                        allowTransparency: "true",
                        title: t
                    }), nn(r, "tox-edit-area__iframe"), r;
                })(e908.id, n390, Si(e908), o225).dom;
                r122.onload = ()=>{
                    r122.onload = null, e908.dispatch("load");
                }, e908.contentAreaContainer = t637.iframeContainer, e908.iframeElement = r122, e908.iframeHTML = ((e)=>{
                    let t = _i(e) + "<html><head>";
                    Ei(e) !== e.documentBaseUrl && (t += '<base href="' + e.documentBaseURI.getURI() + '" />'), t += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
                    const n = Ni(e), o = Ri(e), r = e.translate(Bl(e));
                    return Ai(e) && (t += '<meta http-equiv="Content-Security-Policy" content="' + Ai(e) + '" />'), t += `</head><body id="${n}" class="mce-content-body ${o}" data-id="${e.id}" aria-label="${r}"><br></body></html>`, t;
                })(e908), VE.add(t637.iframeContainer, r122);
            })(e907, t636), t636.editorContainer && (VE.get(t636.editorContainer).style.display = e907.orgDisplay, e907.hidden = VE.isHidden(t636.editorContainer)), e907.getElement().style.display = "none", VE.setAttrib(e907.id, "aria-hidden", "true"), jE(e907);
        })(e902, n386);
    }, KE = Is.DOM, GE = (e)=>"-" === e.charAt(0)
    , YE = (e910, t638, n)=>M1.from(t638).filter((e)=>We(e) && !$v.has(e)
        ).map((t)=>({
                url: `${e910.editorManager.baseURL}/icons/${t}/icons${n}.js`,
                name: M1.some(t)
            })
        )
    , XE = (e911, t639)=>{
        const n391 = Us.ScriptLoader, o226 = ()=>{
            !e911.removed && ((e)=>{
                const t = ll(e);
                return !m1(t) || C1(ey.get(t));
            })(e911) && ((e)=>{
                const t = cl(e);
                return C1(qv.get(t));
            })(e911) && WE(e911);
        };
        ((e912, t640)=>{
            const n392 = ll(e912);
            if (m1(n392) && !GE(n392) && !we1(ey.urls, n392)) {
                const o = dl(e912), r = o ? e912.documentBaseURI.toAbsolute(o) : `themes/${n392}/theme${t640}.js`;
                ey.load(n392, r).catch(()=>{
                    ((e, t, n)=>{
                        ry(e, "ThemeLoadError", sy("theme", t, n));
                    })(e912, r, n392);
                });
            }
        })(e911, t639), ((e913, t641)=>{
            const n393 = cl(e913);
            if ("plugin" !== n393 && !we1(qv.urls, n393)) {
                const o = ul(e913), r = m1(o) ? e913.documentBaseURI.toAbsolute(o) : `models/${n393}/model${t641}.js`;
                qv.load(n393, r).catch(()=>{
                    ((e, t, n)=>{
                        ry(e, "ModelLoadError", sy("model", t, n));
                    })(e913, r, n393);
                });
            }
        })(e911, t639), ((e914, t642)=>{
            const n394 = Gi(t642), o = Yi(t642);
            if (!1 === $s.hasCode(n394) && "en" !== n394) {
                const r = We(o) ? o : `${t642.editorManager.baseURL}/langs/${n394}.js`;
                e914.add(r).catch(()=>{
                    ((e, t, n)=>{
                        ry(e, "LanguageLoadError", sy("language", t, n));
                    })(t642, r, n394);
                });
            }
        })(n391, e911), ((e915, t644, n395)=>{
            const o = YE(t644, "default", n395), r = ((e916)=>M1.from(ji(e916)).filter(We).map((e)=>({
                        url: e,
                        name: M1.none()
                    })
                )
            )(t644).orThunk(()=>YE(t644, zi(t644), "")
            );
            $1(((e917)=>{
                const t = [], n = (e)=>{
                    t.push(e);
                };
                for(let t643 = 0; t643 < e917.length; t643++)e917[t643].each(n);
                return t;
            })([
                o,
                r
            ]), (n396)=>{
                e915.add(n396.url).catch(()=>{
                    ((e, t, n)=>{
                        ry(e, "IconsLoadError", sy("icons", t, n));
                    })(t644, n396.url, n396.name.getOrUndefined());
                });
            });
        })(n391, e911, t639), ((e918, t645)=>{
            const n397 = (t646, n398)=>{
                Zv.load(t646, n398).catch(()=>{
                    ((e, t, n)=>{
                        ry(e, "PluginLoadError", sy("plugin", t, n));
                    })(e918, n398, t646);
                });
            };
            fe1(Nl(e918), (t, o)=>{
                n397(o, t), e918.options.set("plugins", El(e918).concat(o));
            }), $1(El(e918), (e)=>{
                !(e = Bt.trim(e)) || Zv.urls[e] || GE(e) || n397(e, `plugins/${e}/plugin${t645}.js`);
            });
        })(e911, t639), n391.loadQueue().then(o226, o226);
    }, QE = Ct().deviceType, JE = QE.isPhone(), ZE = QE.isTablet(), eN = (e)=>{
        if (y1(e)) return [];
        {
            const t = p1(e) ? e : e.split(/[ ,]/), n = H1(t, He);
            return K1(n, We);
        }
    }, tN = (e, t647)=>{
        const n399 = ((t, n400)=>{
            const o = {}, r = {};
            return be1(t, (t, n)=>j1(e, n)
            , he1(o), he1(r)), {
                t: o,
                f: r
            };
        })(t647);
        var o227, r123;
        return o227 = n399.t, r123 = n399.f, {
            sections: N1(o227),
            options: N1(r123)
        };
    }, nN = (e, t)=>we1(e.sections(), t)
    , oN = (e, t)=>({
            table_grid: !1,
            object_resizing: !1,
            resize: !1,
            toolbar_mode: xe1(e, "toolbar_mode").getOr("scrolling"),
            toolbar_sticky: !1,
            ...t ? {
                menubar: !1
            } : {}
        })
    , rN = (e, t)=>{
        var n;
        const o = null !== (n = t.external_plugins) && void 0 !== n ? n : {};
        return e && e.external_plugins ? Bt.extend({}, e.external_plugins, o) : o;
    }, sN = (e919, t648, n401, o228, r124)=>{
        var s77;
        const a49 = e919 ? {
            mobile: oN(null !== (s77 = r124.mobile) && void 0 !== s77 ? s77 : {}, t648)
        } : {}, i32 = tN([
            "mobile"
        ], gk(a49, r124)), l25 = Bt.extend(n401, o228, i32.options(), ((e, t)=>e && nN(t, "mobile")
        )(e919, i32) ? ((e, t, n = {})=>{
            const o = e.sections(), r = xe1(o, t).getOr({});
            return Bt.extend({}, n, r);
        })(i32, "mobile") : {}, {
            external_plugins: rN(o228, i32.options())
        });
        return ((e920, t649, n402, o229)=>{
            const r = eN(n402.forced_plugins), s = eN(o229.plugins), a = ((e, t)=>nN(e, t) ? e.sections()[t] : {}
            )(t649, "mobile"), i = ((e, t, n, o)=>e && nN(t, "mobile") ? o : n
            )(e920, t649, s, a.plugins ? eN(a.plugins) : s), l = ((e, t)=>[].concat(eN(e)).concat(eN(t))
            )(r, i);
            return Bt.extend(o229, {
                forced_plugins: r,
                plugins: l
            });
        })(e919, i32, o228, l25);
    }, aN = (e921)=>{
        ((e)=>{
            const t650 = (t651)=>()=>{
                    $1("left,center,right,justify".split(","), (n)=>{
                        t651 !== n && e.formatter.remove("align" + n);
                    }), "none" !== t651 && ((t, n)=>{
                        e.formatter.toggle(t, void 0), e.nodeChanged();
                    })("align" + t651);
                }
            ;
            e.editorCommands.addCommands({
                JustifyLeft: t650("left"),
                JustifyCenter: t650("center"),
                JustifyRight: t650("right"),
                JustifyFull: t650("justify"),
                JustifyNone: t650("none")
            });
        })(e921), ((e)=>{
            const t652 = (t)=>()=>{
                    const n403 = e.selection, o = n403.isCollapsed() ? [
                        e.dom.getParent(n403.getNode(), e.dom.isBlock)
                    ] : n403.getSelectedBlocks();
                    return V1(o, (n)=>C1(e.formatter.matchNode(n, t))
                    );
                }
            ;
            e.editorCommands.addCommands({
                JustifyLeft: t652("alignleft"),
                JustifyCenter: t652("aligncenter"),
                JustifyRight: t652("alignright"),
                JustifyFull: t652("alignjustify")
            }, "state");
        })(e921);
    }, iN = (e922, t653)=>{
        const n404 = e922.selection, o230 = e922.dom;
        return /^ | $/.test(t653) ? ((e, t, n)=>{
            const o = mn(e.getRoot());
            return n = bg(o, Ua.fromRangeStart(t)) ? n.replace(/^ /, "&nbsp;") : n.replace(/^&nbsp;/, " "), vg(o, Ua.fromRangeEnd(t)) ? n.replace(/(&nbsp;| )(<br( \/)>)?$/, "&nbsp;") : n.replace(/&nbsp;(<br( \/)?>)?$/, " ");
        })(o230, n404.getRng(), t653) : t653;
    }, lN = (e923, t654)=>{
        const { content: n405 , details: o  } = ((e)=>{
            if ("string" != typeof e) {
                const t = Bt.extend({
                    paste: e.paste,
                    data: {
                        paste: e.paste
                    }
                }, e);
                return {
                    content: e.content,
                    details: t
                };
            }
            return {
                content: e,
                details: {}
            };
        })(t654);
        Xb(e923, {
            content: iN(e923, n405),
            format: "html",
            set: !1,
            selection: !0,
            paste: o.paste
        }).each((t655)=>{
            const n406 = ((e, t, n)=>Ev(e).editor.insertContent(t, n)
            )(e923, t655.content, o);
            Qb(e923, n406, t655), e923.addVisual();
        });
    }, dN = {
        "font-size": "size",
        "font-family": "face"
    }, cN = (e924)=>(t656, n407)=>M1.from(n407).map(mn).filter(Ut).bind((n408)=>((e925, t657, n)=>Ap(mn(n), (t658)=>((t)=>Wn(t, e925).orThunk(()=>"font" === Mt(t) ? xe1(dN, e925).bind((e)=>Kt(t, e)
                                ) : M1.none()
                            )
                        )(t658)
                    , (e)=>bn(mn(t657), e)
                    )
                )(e924, t656, n408.dom).or(((e, t)=>M1.from(Is.DOM.getStyle(t, e, !0))
                )(e924, n408.dom))
            ).getOr("")
    , uN = cN("font-size"), mN = _1((e)=>e.replace(/[\'\"\\]/g, "").replace(/,\s+/g, ",")
    , cN("font-family")), fN = (e926)=>uc(e926.getBody()).map((e)=>{
            const t = e.container();
            return No(t) ? t.parentNode : t;
        })
    , gN = (e927, t659)=>((e928, t660)=>((e)=>M1.from(e.selection.getRng()).bind((t)=>{
                    const n = e.getBody();
                    return t.startContainer === n && 0 === t.startOffset ? M1.none() : M1.from(e.selection.getStart(!0));
                })
            )(e928).orThunk(O1(fN, e928)).map(mn).filter(Ut).bind(t660)
        )(e927, E1(M1.some, t659))
    , pN = (e929, t)=>{
        if (/^[0-9.]+$/.test(t)) {
            const n = parseInt(t, 10);
            if (n >= 1 && n <= 7) {
                const o = ((e)=>Bt.explode(e.options.get("font_size_style_values"))
                )(e929), r = ((e)=>Bt.explode(e.options.get("font_size_classes"))
                )(e929);
                return r ? r[n - 1] || t : o[n - 1] || t;
            }
            return t;
        }
        return t;
    }, hN = (e930)=>{
        const t = e930.split(/\s*,\s*/);
        return H1(t, (e)=>-1 === e.indexOf(" ") || ze1(e, '"') || ze1(e, "'") ? e : `'${e}'`
        ).join(",");
    }, bN = (e931)=>{
        aN(e931), ((e)=>{
            e.editorCommands.addCommands({
                "Cut,Copy,Paste": (t)=>{
                    const n = e.getDoc();
                    let o;
                    try {
                        n.execCommand(t);
                    } catch (e932) {
                        o = !0;
                    }
                    if ("paste" !== t || n.queryCommandEnabled(t) || (o = !0), o || !n.queryCommandSupported(t)) {
                        let t = e.translate("Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.");
                        (Nt.os.isMacOS() || Nt.os.isiOS()) && (t = t.replace(/Ctrl\+/g, "\u2318+")), e.notificationManager.open({
                            text: t,
                            type: "error"
                        });
                    }
                }
            });
        })(e931), ((e)=>{
            e.editorCommands.addCommands({
                mceAddUndoLevel: ()=>{
                    e.undoManager.add();
                },
                mceEndUndoLevel: ()=>{
                    e.undoManager.add();
                },
                Undo: ()=>{
                    e.undoManager.undo();
                },
                Redo: ()=>{
                    e.undoManager.redo();
                }
            });
        })(e931), ((e)=>{
            e.editorCommands.addCommands({
                mceSelectNodeDepth: (t661, n, o)=>{
                    let r = 0;
                    e.dom.getParent(e.selection.getNode(), (t)=>{
                        if (1 === t.nodeType && (r++) === o) return e.selection.select(t), !1;
                    }, e.getBody());
                },
                mceSelectNode: (t, n, o)=>{
                    e.selection.select(o);
                },
                selectAll: ()=>{
                    const t = e.dom.getParent(e.selection.getStart(), Po);
                    if (t) {
                        const n = e.dom.createRng();
                        n.selectNodeContents(t), e.selection.setRng(n);
                    }
                }
            });
        })(e931), ((e)=>{
            e.editorCommands.addCommands({
                mceCleanup: ()=>{
                    const t = e.selection.getBookmark();
                    e.setContent(e.getContent()), e.selection.moveToBookmark(t);
                },
                insertImage: (t, n, o)=>{
                    lN(e, e.dom.createHTML("img", {
                        src: o
                    }));
                },
                insertHorizontalRule: ()=>{
                    e.execCommand("mceInsertContent", !1, "<hr>");
                },
                insertText: (t, n, o)=>{
                    lN(e, e.dom.encode(o));
                },
                insertHTML: (t, n, o)=>{
                    lN(e, o);
                },
                mceInsertContent: (t, n, o)=>{
                    lN(e, o);
                },
                mceSetContent: (t, n, o)=>{
                    e.setContent(o);
                },
                mceReplaceContent: (t, n, o)=>{
                    e.execCommand("mceInsertContent", !1, o.replace(/\{\$selection\}/g, e.selection.getContent({
                        format: "text"
                    })));
                },
                mceNewDocument: ()=>{
                    e.setContent("");
                }
            });
        })(e931), ((e)=>{
            const t662 = (t, n, o)=>{
                const r = m1(o) ? {
                    href: o
                } : o, s = e.dom.getParent(e.selection.getNode(), "a");
                f1(r) && m1(r.href) && (r.href = r.href.replace(/ /g, "%20"), s && r.href || e.formatter.remove("link"), r.href && e.formatter.apply("link", r, s));
            };
            e.editorCommands.addCommands({
                unlink: ()=>{
                    if (e.selection.isCollapsed()) {
                        const t = e.dom.getParent(e.selection.getStart(), "a");
                        t && e.dom.remove(t, !0);
                    } else e.formatter.remove("link");
                },
                mceInsertLink: t662,
                createLink: t662
            });
        })(e931), ((e933)=>{
            e933.editorCommands.addCommands({
                Indent: ()=>{
                    ((e)=>{
                        qx(e, "indent");
                    })(e933);
                },
                Outdent: ()=>{
                    Wx(e933);
                }
            }), e933.editorCommands.addCommands({
                Outdent: ()=>Vx(e933)
            }, "state");
        })(e931), ((e)=>{
            e.editorCommands.addCommands({
                insertParagraph: ()=>{
                    XS(e);
                },
                mceInsertNewLine: (t, n, o)=>{
                    XS(e, o);
                },
                InsertLineBreak: (t, n, o)=>{
                    FS(e, o);
                }
            });
        })(e931), ((e934)=>{
            ((e)=>{
                e.editorCommands.addCommands({
                    "InsertUnorderedList,InsertOrderedList": (t)=>{
                        e.getDoc().execCommand(t);
                        const n = e.dom.getParent(e.selection.getNode(), "ol,ul");
                        if (n) {
                            const t = n.parentNode;
                            if (/^(H[1-6]|P|ADDRESS|PRE)$/.test(t.nodeName)) {
                                const o = e.selection.getBookmark();
                                e.dom.split(t, n), e.selection.moveToBookmark(o);
                            }
                        }
                    }
                });
            })(e934), ((e)=>{
                e.editorCommands.addCommands({
                    "InsertUnorderedList,InsertOrderedList": (t)=>{
                        const n = e.dom.getParent(e.selection.getNode(), "ul,ol");
                        return n && ("insertunorderedlist" === t && "UL" === n.tagName || "insertorderedlist" === t && "OL" === n.tagName);
                    }
                }, "state");
            })(e934);
        })(e931), ((e935)=>{
            ((e936)=>{
                const t663 = (t, n)=>{
                    e936.formatter.toggle(t, n), e936.nodeChanged();
                };
                e936.editorCommands.addCommands({
                    "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (e)=>{
                        t663(e);
                    },
                    "ForeColor,HiliteColor": (e, n, o)=>{
                        t663(e, {
                            value: o
                        });
                    },
                    BackColor: (e, n, o)=>{
                        t663("hilitecolor", {
                            value: o
                        });
                    },
                    FontName: (t664, n409, o)=>{
                        ((e, t)=>{
                            const n = pN(e, t);
                            e.formatter.toggle("fontname", {
                                value: hN(n)
                            }), e.nodeChanged();
                        })(e936, o);
                    },
                    FontSize: (t665, n, o)=>{
                        ((e, t)=>{
                            e.formatter.toggle("fontsize", {
                                value: pN(e, t)
                            }), e.nodeChanged();
                        })(e936, o);
                    },
                    LineHeight: (t666, n, o)=>{
                        ((e, t)=>{
                            e.formatter.toggle("lineheight", {
                                value: String(t)
                            }), e.nodeChanged();
                        })(e936, o);
                    },
                    Lang: (e, n, o)=>{
                        t663(e, {
                            value: o.code,
                            customValue: o.customCode
                        });
                    },
                    RemoveFormat: (t)=>{
                        e936.formatter.remove(t);
                    },
                    mceBlockQuote: ()=>{
                        t663("blockquote");
                    },
                    FormatBlock: (e, n, o)=>{
                        t663(m1(o) ? o : "p");
                    },
                    mceToggleFormat: (e, n, o)=>{
                        t663(o);
                    }
                });
            })(e935), ((e937)=>{
                const t667 = (t)=>e937.formatter.match(t)
                ;
                e937.editorCommands.addCommands({
                    "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (e)=>t667(e)
                    ,
                    mceBlockQuote: ()=>t667("blockquote")
                }, "state"), e937.editorCommands.addQueryValueHandler("FontName", ()=>((e)=>gN(e, (t)=>mN(e.getBody(), t.dom)
                        ).getOr("")
                    )(e937)
                ), e937.editorCommands.addQueryValueHandler("FontSize", ()=>((e)=>gN(e, (t)=>uN(e.getBody(), t.dom)
                        ).getOr("")
                    )(e937)
                ), e937.editorCommands.addQueryValueHandler("LineHeight", ()=>((e938)=>gN(e938, (t)=>{
                            const n410 = mn(e938.getBody()), o = Ap(t, (e)=>Wn(e, "line-height")
                            , O1(bn, n410));
                            return o.getOrThunk(()=>{
                                const e = parseFloat($n(t, "line-height")), n = parseFloat($n(t, "font-size"));
                                return String(e / n);
                            });
                        }).getOr("")
                    )(e937)
                );
            })(e935);
        })(e931), ((e939)=>{
            e939.editorCommands.addCommands({
                mceRemoveNode: (t, n, o)=>{
                    const r = null != o ? o : e939.selection.getNode();
                    if (r !== e939.getBody()) {
                        const t = e939.selection.getBookmark();
                        e939.dom.remove(r, !0), e939.selection.moveToBookmark(t);
                    }
                },
                mcePrint: ()=>{
                    e939.getWin().print();
                },
                mceFocus: (t668, n411, o231)=>{
                    ((e940, t669)=>{
                        e940.removed || (t669 ? of(e940) : ((e941)=>{
                            const t670 = e941.selection, n = e941.getBody();
                            let o = t670.getRng();
                            e941.quirks.refreshContentEditable(), void 0 !== e941.bookmark && !1 === nf(e941) && Wm(e941).each((t)=>{
                                e941.selection.setRng(t), o = t;
                            });
                            const r = ((e, t671)=>e.dom.getParent(t671, (t)=>"true" === e.dom.getContentEditable(t)
                                )
                            )(e941, t670.getNode());
                            if (e941.dom.isChildOf(r, n)) return tf(r), ef(e941, o), void of(e941);
                            e941.inline || (Nt.browser.isOpera() || tf(n), e941.getWin().focus()), (Nt.browser.isFirefox() || e941.inline) && (tf(n), ef(e941, o)), of(e941);
                        })(e940));
                    })(e939, o231);
                },
                mceToggleVisualAid: ()=>{
                    e939.hasVisual = !e939.hasVisual, e939.addVisual();
                }
            });
        })(e931);
    };
    class vN {
        constructor(e){
            this.commands = {
                state: {},
                exec: {},
                value: {}
            }, this.editor = e;
        }
        execCommand(e942, t672, n, o) {
            const r = this.editor, s = e942.toLowerCase(), a = null == o ? void 0 : o.skip_focus;
            if (r.removed) return !1;
            if ("mcefocus" !== s && (/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(s) || a ? ((e)=>{
                Wm(e).each((t)=>e.selection.setRng(t)
                );
            })(r) : r.focus()), r.dispatch("BeforeExecCommand", {
                command: e942,
                ui: t672,
                value: n
            }).isDefaultPrevented()) return !1;
            const i = this.commands.exec[s];
            return !!x1(i) && (i(s, t672, n), r.dispatch("ExecCommand", {
                command: e942,
                ui: t672,
                value: n
            }), !0);
        }
        queryCommandState(e) {
            if (this.editor.quirks.isHidden() || this.editor.removed) return !1;
            const t = e.toLowerCase(), n = this.commands.state[t];
            return !!x1(n) && n(t);
        }
        queryCommandValue(e) {
            if (this.editor.quirks.isHidden() || this.editor.removed) return "";
            const t = e.toLowerCase(), n = this.commands.value[t];
            return x1(n) ? n(t) : "";
        }
        addCommands(e943, t = "exec") {
            const n = this.commands;
            fe1(e943, (e, o232)=>{
                $1(o232.toLowerCase().split(","), (o)=>{
                    n[t][o] = e;
                });
            });
        }
        addCommand(e, t, n) {
            const o233 = e.toLowerCase();
            this.commands.exec[o233] = (e, o, r)=>t.call(null != n ? n : this.editor, o, r)
            ;
        }
        queryCommandSupported(e) {
            const t = e.toLowerCase();
            return !!this.commands.exec[t];
        }
        addQueryStateHandler(e, t, n) {
            this.commands.state[e.toLowerCase()] = ()=>t.call(null != n ? n : this.editor)
            ;
        }
        addQueryValueHandler(e, t, n) {
            this.commands.value[e.toLowerCase()] = ()=>t.call(null != n ? n : this.editor)
            ;
        }
    }
    const yN = "data-mce-contenteditable", CN = (e, t, n)=>{
        try {
            e.getDoc().execCommand(t, !1, String(n));
        } catch (e944) {}
    }, xN = (e, t)=>{
        e.dom.contentEditable = t ? "true" : "false";
    }, wN = (e945, t673)=>{
        const n412 = mn(e945.getBody());
        ((e, t, n)=>{
            sn(e, t) && !1 === n ? rn(e, t) : n && nn(e, t);
        })(n412, "mce-content-readonly", t673), t673 ? (e945.selection.controlSelection.hideResizeRect(), e945._selectionOverrides.hideFakeCaret(), ((e946)=>{
            M1.from(e946.selection.getNode()).each((e)=>{
                e.removeAttribute("data-mce-selected");
            });
        })(e945), e945.readonly = !0, xN(n412, !1), $1(Xs(n412, '*[contenteditable="true"]'), (e)=>{
            $t(e, yN, "true"), xN(e, !1);
        })) : (e945.readonly = !1, xN(n412, !0), $1(Xs(n412, '*[data-mce-contenteditable="true"]'), (e)=>{
            Yt(e, yN), xN(e, !0);
        }), CN(e945, "StyleWithCSS", !1), CN(e945, "enableInlineTableEditing", !1), CN(e945, "enableObjectResizing", !1), ((e947)=>nf(e947) || ((e948)=>{
                const t674 = Pn(mn(e948.getElement()));
                return Fm(t674).filter((t675)=>!((e)=>{
                        const t = e.classList;
                        return void 0 !== t && (t.contains("tox-edit-area") || t.contains("tox-edit-area__iframe") || t.contains("mce-content-body"));
                    })(t675.dom) && Qm(e948, t675.dom)
                ).isSome();
            })(e947)
        )(e945) && e945.focus(), ((e)=>{
            e.selection.setRng(e.selection.getRng());
        })(e945), e945.nodeChanged());
    }, kN = (e)=>e.readonly
    , SN = (e949)=>{
        e949.parser.addAttributeFilter("contenteditable", (t)=>{
            kN(e949) && $1(t, (e)=>{
                e.attr(yN, e.attr("contenteditable")), e.attr("contenteditable", "false");
            });
        }), e949.serializer.addAttributeFilter(yN, (t)=>{
            kN(e949) && $1(t, (e)=>{
                e.attr("contenteditable", e.attr(yN));
            });
        }), e949.serializer.addTempAttr(yN);
    }, _N = Bt.makeMap("focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover draggesture dragdrop drop drag submit compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel", " ");
    class EN {
        constructor(e){
            this.bindings = {}, this.settings = e || {}, this.scope = this.settings.scope || this, this.toggleEvent = this.settings.toggleEvent || L1;
        }
        static isNative(e) {
            return !!_N[e.toLowerCase()];
        }
        fire(e, t) {
            return this.dispatch(e, t);
        }
        dispatch(e, t) {
            const n = e.toLowerCase(), o = ws(n, null != t ? t : {}, this.scope);
            this.settings.beforeFire && this.settings.beforeFire(o);
            const r = this.bindings[n];
            if (r) for(let e950 = 0, t676 = r.length; e950 < t676; e950++){
                const t = r[e950];
                if (!t.removed) {
                    if (t.once && this.off(n, t.func), o.isImmediatePropagationStopped()) return o;
                    if (!1 === t.func.call(this.scope, o)) return o.preventDefault(), o;
                }
            }
            return o;
        }
        on(e, t, n, o) {
            if (!1 === t && (t = L1), t) {
                const r = {
                    func: t,
                    removed: !1
                };
                o && Bt.extend(r, o);
                const s = e.toLowerCase().split(" ");
                let a = s.length;
                for(; a--;){
                    const e = s[a];
                    let t = this.bindings[e];
                    t || (t = [], this.toggleEvent(e, !0)), t = n ? [
                        r,
                        ...t
                    ] : [
                        ...t,
                        r
                    ], this.bindings[e] = t;
                }
            }
            return this;
        }
        off(e955, t677) {
            if (e955) {
                const n = e955.toLowerCase().split(" ");
                let o = n.length;
                for(; o--;){
                    const r = n[o];
                    let s = this.bindings[r];
                    if (!r) return fe1(this.bindings, (e, t)=>{
                        this.toggleEvent(t, !1), delete this.bindings[t];
                    }), this;
                    if (s) {
                        if (t677) {
                            const e951 = W1(s, (e)=>e.func === t677
                            );
                            s = e951.fail, this.bindings[r] = s, $1(e951.pass, (e)=>{
                                e.removed = !0;
                            });
                        } else s.length = 0;
                        s.length || (this.toggleEvent(e955, !1), delete this.bindings[r]);
                    }
                }
            } else fe1(this.bindings, (e, t)=>{
                this.toggleEvent(t, !1);
            }), this.bindings = {};
            return this;
        }
        once(e, t, n) {
            return this.on(e, t, n, {
                once: !0
            });
        }
        has(e) {
            return e = e.toLowerCase(), !(!this.bindings[e] || 0 === this.bindings[e].length);
        }
    }
    const NN = (e)=>(e._eventDispatcher || (e._eventDispatcher = new EN({
            scope: e,
            toggleEvent: (t, n)=>{
                EN.isNative(t) && e.toggleNativeEvent && e.toggleNativeEvent(t, n);
            }
        })), e._eventDispatcher)
    , RN = {
        fire (e, t, n) {
            return this.dispatch(e, t, n);
        },
        dispatch (e, t, n) {
            const o = this;
            if (o.removed && "remove" !== e && "detach" !== e) return ws(e.toLowerCase(), null != t ? t : {}, o);
            const r = NN(o).dispatch(e, t);
            if (!1 !== n && o.parent) {
                let t = o.parent();
                for(; t && !r.isPropagationStopped();)t.dispatch(e, r, !1), t = t.parent();
            }
            return r;
        },
        on (e, t, n) {
            return NN(this).on(e, t, n);
        },
        off (e, t) {
            return NN(this).off(e, t);
        },
        once (e, t) {
            return NN(this).once(e, t);
        },
        hasEventListeners (e) {
            return NN(this).has(e);
        }
    }, AN = Is.DOM;
    let ON;
    const TN = (e, t)=>{
        if ("selectionchange" === t) return e.getDoc();
        if (!e.inline && /^mouse|touch|click|contextmenu|drop|dragover|dragend/.test(t)) return e.getDoc().documentElement;
        const n = al(e);
        return n ? (e.eventRoot || (e.eventRoot = AN.select(n)[0]), e.eventRoot) : e.getBody();
    }, BN = (e956, t678, n413)=>{
        ((e)=>!e.hidden && !kN(e)
        )(e956) ? e956.dispatch(t678, n413) : kN(e956) && ((e957, t679)=>{
            if (((e)=>"click" === e.type
            )(t679) && !Uu.metaKeyPressed(t679)) {
                const n414 = mn(t679.target);
                ((e958, t680)=>Ko(t680, "a", (t)=>bn(t, mn(e958.getBody()))
                    ).bind((e)=>Kt(e, "href")
                    )
                )(e957, n414).each((n)=>{
                    if (t679.preventDefault(), /^#/.test(n)) {
                        const t681 = e957.dom.select(`${n},[name="${(o = n, ze1(o, "#") ? ((e, t)=>e.substring(t)
                        )(o, 1) : o)}"]`);
                        t681.length && e957.selection.scrollIntoView(t681[0], !0);
                    } else window.open(n, "_blank", "rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes");
                    var o;
                });
            }
        })(e956, n413);
    }, DN = (e959, t)=>{
        let n416;
        if (e959.delegates || (e959.delegates = {}), e959.delegates[t] || e959.removed) return;
        const o234 = TN(e959, t);
        if (al(e959)) {
            if (ON || (ON = {}, e959.editorManager.on("removeEditor", ()=>{
                e959.editorManager.activeEditor || ON && (fe1(ON, (t, n)=>{
                    e959.dom.unbind(TN(e959, n));
                }), ON = null);
            })), ON[t]) return;
            n416 = (n)=>{
                const o = n.target, r = e959.editorManager.get();
                let s = r.length;
                for(; s--;){
                    const e = r[s].getBody();
                    (e === o || AN.isChildOf(o, e)) && BN(r[s], t, n);
                }
            }, ON[t] = n416, AN.bind(o234, t, n416);
        } else n416 = (n)=>{
            BN(e959, t, n);
        }, AN.bind(o234, t, n416), e959.delegates[t] = n416;
    }, LN = {
        ...RN,
        bindPendingEventDelegates () {
            const e = this;
            Bt.each(e._pendingNativeEvents, (t)=>{
                DN(e, t);
            });
        },
        toggleNativeEvent (e, t) {
            const n = this;
            "focus" !== e && "blur" !== e && (n.removed || (t ? n.initialized ? DN(n, e) : n._pendingNativeEvents ? n._pendingNativeEvents.push(e) : n._pendingNativeEvents = [
                e
            ] : n.initialized && (n.dom.unbind(TN(n, e), e, n.delegates[e]), delete n.delegates[e])));
        },
        unbindAllNativeEvents () {
            const e = this, t683 = e.getBody(), n417 = e.dom;
            e.delegates && (fe1(e.delegates, (t, n)=>{
                e.dom.unbind(TN(e, n), n, t);
            }), delete e.delegates), !e.inline && t683 && n417 && (t683.onload = null, n417.unbind(e.getWin()), n417.unbind(e.getDoc())), n417 && (n417.unbind(t683), n417.unbind(e.getContainer()));
        }
    }, PN = (e)=>m1(e) ? {
            value: e.split(/[ ,]/),
            valid: !0
        } : k1(e, m1) ? {
            value: e,
            valid: !0
        } : {
            valid: !1,
            message: "The value must be a string[] or a comma/space separated string."
        }
    , MN = (e, t)=>e + (Ke(t.message) ? "" : `. ${t.message}`)
    , IN = (e)=>e.valid
    , FN = (e, t, n = "")=>{
        const o = t(e);
        return b1(o) ? o ? {
            value: e,
            valid: !0
        } : {
            valid: !1,
            message: n
        } : o;
    }, UN = [
        "design",
        "readonly"
    ], zN = (e961, t684, n, o)=>{
        const r = n[t684.get()], s = n[o];
        try {
            s.activate();
        } catch (e960) {
            return void console.error(`problem while activating editor mode ${o}:`, e960);
        }
        r.deactivate(), r.editorReadOnly !== s.editorReadOnly && wN(e961, s.editorReadOnly), t684.set(o), ((e, t)=>{
            e.dispatch("SwitchMode", {
                mode: t
            });
        })(e961, o);
    }, jN = Bt.each, VN = Bt.explode, HN = {
        f1: 112,
        f2: 113,
        f3: 114,
        f4: 115,
        f5: 116,
        f6: 117,
        f7: 118,
        f8: 119,
        f9: 120,
        f10: 121,
        f11: 122,
        f12: 123
    }, $N = Bt.makeMap("alt,ctrl,shift,meta,access"), qN = (e962)=>{
        let t;
        const n = {}, o = Nt.os.isMacOS() || Nt.os.isiOS();
        jN(VN(e962.toLowerCase(), "+"), (e)=>{
            e in $N ? n[e] = !0 : /^[0-9]{2,}$/.test(e) ? n.keyCode = parseInt(e, 10) : (n.charCode = e.charCodeAt(0), n.keyCode = HN[e] || e.toUpperCase().charCodeAt(0));
        });
        const r = [
            n.keyCode
        ];
        for(t in $N)n[t] ? r.push(t) : n[t] = !1;
        return n.id = r.join(","), n.access && (n.alt = !0, o ? n.ctrl = !0 : n.shift = !0), n.meta && (o ? n.meta = !0 : (n.ctrl = !0, n.meta = !1)), n;
    };
    class WN {
        constructor(e963){
            this.shortcuts = {}, this.pendingPatterns = [], this.editor = e963;
            const t = this;
            e963.on("keyup keypress keydown", (e)=>{
                !t.hasModifier(e) && !t.isFunctionKey(e) || e.isDefaultPrevented() || (jN(t.shortcuts, (n)=>{
                    if (t.matchShortcut(e, n)) return t.pendingPatterns = n.subpatterns.slice(0), "keydown" === e.type && t.executeShortcutAction(n), !0;
                }), t.matchShortcut(e, t.pendingPatterns[0]) && (1 === t.pendingPatterns.length && "keydown" === e.type && t.executeShortcutAction(t.pendingPatterns[0]), t.pendingPatterns.shift()));
            });
        }
        add(e964, t, n418, o) {
            const r = this, s = r.normalizeCommandFunc(n418);
            return jN(VN(Bt.trim(e964)), (e)=>{
                const n = r.createShortcut(e, t, s, o);
                r.shortcuts[n.id] = n;
            }), !0;
        }
        remove(e) {
            const t = this.createShortcut(e);
            return !!this.shortcuts[t.id] && (delete this.shortcuts[t.id], !0);
        }
        normalizeCommandFunc(e) {
            const t = this, n = e;
            return "string" == typeof n ? ()=>{
                t.editor.execCommand(n, !1, null);
            } : Bt.isArray(n) ? ()=>{
                t.editor.execCommand(n[0], n[1], n[2]);
            } : n;
        }
        createShortcut(e, t, n, o) {
            const r = Bt.map(VN(e, ">"), qN);
            return r[r.length - 1] = Bt.extend(r[r.length - 1], {
                func: n,
                scope: o || this.editor
            }), Bt.extend(r[0], {
                desc: this.editor.translate(t),
                subpatterns: r.slice(1)
            });
        }
        hasModifier(e) {
            return e.altKey || e.ctrlKey || e.metaKey;
        }
        isFunctionKey(e) {
            return "keydown" === e.type && e.keyCode >= 112 && e.keyCode <= 123;
        }
        matchShortcut(e, t) {
            return !!t && t.ctrl === e.ctrlKey && t.meta === e.metaKey && t.alt === e.altKey && t.shift === e.shiftKey && !!(e.keyCode === t.keyCode || e.charCode && e.charCode === t.charCode) && (e.preventDefault(), !0);
        }
        executeShortcutAction(e) {
            return e.func ? e.func.call(e.scope) : null;
        }
    }
    const KN = ()=>{
        const e965 = (()=>{
            const e966 = {}, t685 = {}, n419 = {}, o235 = {}, r = {}, s = {}, a = {}, i = (e, t)=>(n, o)=>e[n.toLowerCase()] = {
                        ...o,
                        type: t
                    }
            ;
            return {
                addButton: i(e966, "button"),
                addGroupToolbarButton: i(e966, "grouptoolbarbutton"),
                addToggleButton: i(e966, "togglebutton"),
                addMenuButton: i(e966, "menubutton"),
                addSplitButton: i(e966, "splitbutton"),
                addMenuItem: i(t685, "menuitem"),
                addNestedMenuItem: i(t685, "nestedmenuitem"),
                addToggleMenuItem: i(t685, "togglemenuitem"),
                addAutocompleter: i(n419, "autocompleter"),
                addContextMenu: i(r, "contextmenu"),
                addContextToolbar: i(s, "contexttoolbar"),
                addContextForm: i(s, "contextform"),
                addSidebar: i(a, "sidebar"),
                addIcon: (e, t)=>o235[e.toLowerCase()] = t
                ,
                getAll: ()=>({
                        buttons: e966,
                        menuItems: t685,
                        icons: o235,
                        popups: n419,
                        contextMenus: r,
                        contextToolbars: s,
                        sidebars: a
                    })
            };
        })();
        return {
            addAutocompleter: e965.addAutocompleter,
            addButton: e965.addButton,
            addContextForm: e965.addContextForm,
            addContextMenu: e965.addContextMenu,
            addContextToolbar: e965.addContextToolbar,
            addIcon: e965.addIcon,
            addMenuButton: e965.addMenuButton,
            addMenuItem: e965.addMenuItem,
            addNestedMenuItem: e965.addNestedMenuItem,
            addSidebar: e965.addSidebar,
            addSplitButton: e965.addSplitButton,
            addToggleButton: e965.addToggleButton,
            addGroupToolbarButton: e965.addGroupToolbarButton,
            addToggleMenuItem: e965.addToggleMenuItem,
            getAll: e965.getAll
        };
    }, GN = Is.DOM, YN = Bt.extend, XN = Bt.each;
    class QN {
        constructor(e967, t686, n420){
            this.plugins = {}, this.contentCSS = [], this.contentStyles = [], this.loadedCSS = {}, this.isNotDirty = !1, this.editorManager = n420, this.documentBaseUrl = n420.documentBaseURL, YN(this, LN);
            const o236 = this;
            this.id = e967, this.hidden = !1;
            const r125 = ((e, t)=>sN(JE || ZE, JE, t, e, t)
            )(n420.defaultOptions, t686);
            this.options = ((e968, t687)=>{
                const n421 = {}, o237 = {}, r126 = (e, t, n)=>{
                    const r = FN(t, n);
                    return IN(r) ? (o237[e] = r.value, !0) : (console.warn(MN(`Invalid value passed for the ${e} option`, r)), !1);
                }, s79 = (e)=>we1(n421, e)
                ;
                return {
                    register: (e969, s)=>{
                        const a = ((e)=>m1(e.processor)
                        )(s) ? ((e970)=>{
                            const t = (()=>{
                                switch(e970){
                                    case "array":
                                        return p1;
                                    case "boolean":
                                        return b1;
                                    case "function":
                                        return x1;
                                    case "number":
                                        return w1;
                                    case "object":
                                        return f1;
                                    case "string":
                                        return m1;
                                    case "string[]":
                                        return PN;
                                    case "object[]":
                                        return (e)=>k1(e, f1)
                                        ;
                                    case "regexp":
                                        return (e)=>u1(e, RegExp)
                                        ;
                                }
                            })();
                            return (n)=>FN(n, t, `The value must be a ${e970}.`)
                            ;
                        })(s.processor) : s.processor, i = ((e, t, n)=>{
                            if (!v1(t)) {
                                const o = FN(t, n);
                                if (IN(o)) return o.value;
                                console.error(MN(`Invalid default value passed for the "${e}" option`, o));
                            }
                        })(e969, s.default, a);
                        n421[e969] = {
                            ...s,
                            default: i,
                            processor: a
                        }, xe1(o237, e969).orThunk(()=>xe1(t687, e969)
                        ).each((t)=>r126(e969, t, a)
                        );
                    },
                    isRegistered: s79,
                    get: (e971)=>xe1(o237, e971).orThunk(()=>xe1(n421, e971).map((e)=>e.default
                            )
                        ).getOrUndefined()
                    ,
                    set: (e, t)=>{
                        if (s79(e)) {
                            const o = n421[e];
                            return o.immutable ? (console.error(`"${e}" is an immutable option and cannot be updated`), !1) : r126(e, t, o.processor);
                        }
                        return console.warn(`"${e}" is not a registered option. Ensure the option has been registered before setting a value.`), !1;
                    },
                    unset: (e)=>{
                        const t = s79(e);
                        return t && delete o237[e], t;
                    },
                    isSet: (e)=>we1(o237, e)
                };
            })(0, r125), ((e972)=>{
                const t688 = e972.options.register;
                t688("id", {
                    processor: "string",
                    default: e972.id
                }), t688("selector", {
                    processor: "string"
                }), t688("target", {
                    processor: "object"
                }), t688("suffix", {
                    processor: "string"
                }), t688("cache_suffix", {
                    processor: "string"
                }), t688("base_url", {
                    processor: "string"
                }), t688("referrer_policy", {
                    processor: "string",
                    default: ""
                }), t688("language_load", {
                    processor: "boolean"
                }), t688("inline", {
                    processor: "boolean",
                    default: !1
                }), t688("iframe_attrs", {
                    processor: "object",
                    default: {}
                }), t688("doctype", {
                    processor: "string",
                    default: "<!DOCTYPE html>"
                }), t688("document_base_url", {
                    processor: "string",
                    default: e972.documentBaseUrl
                }), t688("body_id", {
                    processor: ki(e972, "tinymce"),
                    default: "tinymce"
                }), t688("body_class", {
                    processor: ki(e972),
                    default: ""
                }), t688("content_security_policy", {
                    processor: "string",
                    default: ""
                }), t688("br_in_pre", {
                    processor: "boolean",
                    default: !0
                }), t688("forced_root_block", {
                    processor: (e)=>{
                        const t = m1(e) && We(e);
                        return t ? {
                            value: e,
                            valid: t
                        } : {
                            valid: !1,
                            message: "Must be a non-empty string."
                        };
                    },
                    default: "p"
                }), t688("forced_root_block_attrs", {
                    processor: "object",
                    default: {}
                }), t688("br_newline_selector", {
                    processor: "string",
                    default: ".mce-toc h2,figcaption,caption"
                }), t688("no_newline_selector", {
                    processor: "string",
                    default: ""
                }), t688("keep_styles", {
                    processor: "boolean",
                    default: !0
                }), t688("end_container_on_empty_block", {
                    processor: "boolean",
                    default: !1
                }), t688("font_size_style_values", {
                    processor: "string",
                    default: "xx-small,x-small,small,medium,large,x-large,xx-large"
                }), t688("font_size_legacy_values", {
                    processor: "string",
                    default: "xx-small,small,medium,large,x-large,xx-large,300%"
                }), t688("font_size_classes", {
                    processor: "string",
                    default: ""
                }), t688("automatic_uploads", {
                    processor: "boolean",
                    default: !0
                }), t688("images_reuse_filename", {
                    processor: "boolean",
                    default: !1
                }), t688("images_replace_blob_uris", {
                    processor: "boolean",
                    default: !0
                }), t688("icons", {
                    processor: "string",
                    default: ""
                }), t688("icons_url", {
                    processor: "string",
                    default: ""
                }), t688("images_upload_url", {
                    processor: "string",
                    default: ""
                }), t688("images_upload_base_path", {
                    processor: "string",
                    default: ""
                }), t688("images_upload_base_path", {
                    processor: "string",
                    default: ""
                }), t688("images_upload_credentials", {
                    processor: "boolean",
                    default: !1
                }), t688("images_upload_handler", {
                    processor: "function"
                }), t688("language", {
                    processor: "string",
                    default: "en"
                }), t688("language_url", {
                    processor: "string",
                    default: ""
                }), t688("entity_encoding", {
                    processor: "string",
                    default: "named"
                }), t688("indent", {
                    processor: "boolean",
                    default: !0
                }), t688("indent_before", {
                    processor: "string",
                    default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
                }), t688("indent_after", {
                    processor: "string",
                    default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
                }), t688("indent_use_margin", {
                    processor: "boolean",
                    default: !1
                }), t688("indentation", {
                    processor: "string",
                    default: "40px"
                }), t688("content_css", {
                    processor: (e)=>{
                        const t = !1 === e || m1(e) || k1(e, m1);
                        return t ? m1(e) ? {
                            value: H1(e.split(","), He),
                            valid: t
                        } : p1(e) ? {
                            value: e,
                            valid: t
                        } : !1 === e ? {
                            value: [],
                            valid: t
                        } : {
                            value: e,
                            valid: t
                        } : {
                            valid: !1,
                            message: "Must be false, a string or an array of strings."
                        };
                    },
                    default: bl(e972) ? [] : [
                        "default"
                    ]
                }), t688("content_style", {
                    processor: "string"
                }), t688("content_css_cors", {
                    processor: "boolean",
                    default: !1
                }), t688("font_css", {
                    processor: (e)=>{
                        const t = m1(e) || k1(e, m1);
                        return t ? {
                            value: p1(e) ? e : H1(e.split(","), He),
                            valid: t
                        } : {
                            valid: !1,
                            message: "Must be a string or an array of strings."
                        };
                    },
                    default: []
                }), t688("inline_boundaries", {
                    processor: "boolean",
                    default: !0
                }), t688("inline_boundaries_selector", {
                    processor: "string",
                    default: "a[href],code,.mce-annotation"
                }), t688("object_resizing", {
                    processor: (e)=>{
                        const t = b1(e) || m1(e);
                        return t ? !1 === e || bi.isiPhone() || bi.isiPad() ? {
                            value: "",
                            valid: t
                        } : {
                            value: !0 === e ? "table,img,figure.image,div,video,iframe" : e,
                            valid: t
                        } : {
                            valid: !1,
                            message: "Must be boolean or a string"
                        };
                    },
                    default: !vi
                }), t688("resize_img_proportional", {
                    processor: "boolean",
                    default: !0
                }), t688("event_root", {
                    processor: "object"
                }), t688("service_message", {
                    processor: "string"
                }), t688("theme", {
                    processor: (e)=>!1 === e || m1(e) || x1(e)
                    ,
                    default: "silver"
                }), t688("theme_url", {
                    processor: "string"
                }), t688("formats", {
                    processor: "object"
                }), t688("format_empty_lines", {
                    processor: "boolean",
                    default: !1
                }), t688("preview_styles", {
                    processor: (e)=>{
                        const t = !1 === e || m1(e);
                        return t ? {
                            value: !1 === e ? "" : e,
                            valid: t
                        } : {
                            valid: !1,
                            message: "Must be false or a string"
                        };
                    },
                    default: "font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow"
                }), t688("custom_ui_selector", {
                    processor: "string",
                    default: ""
                }), t688("hidden_input", {
                    processor: "boolean",
                    default: !0
                }), t688("submit_patch", {
                    processor: "boolean",
                    default: !0
                }), t688("encoding", {
                    processor: "string"
                }), t688("add_form_submit_trigger", {
                    processor: "boolean",
                    default: !0
                }), t688("add_unload_trigger", {
                    processor: "boolean",
                    default: !0
                }), t688("custom_undo_redo_levels", {
                    processor: "number",
                    default: 0
                }), t688("disable_nodechange", {
                    processor: "boolean",
                    default: !1
                }), t688("readonly", {
                    processor: "boolean",
                    default: !1
                }), t688("plugins", {
                    processor: "string[]",
                    default: []
                }), t688("external_plugins", {
                    processor: "object"
                }), t688("forced_plugins", {
                    processor: "string[]"
                }), t688("model", {
                    processor: "string",
                    default: e972.hasPlugin("rtc") ? "plugin" : "dom"
                }), t688("model_url", {
                    processor: "string"
                }), t688("block_unsupported_drop", {
                    processor: "boolean",
                    default: !0
                }), t688("visual", {
                    processor: "boolean",
                    default: !0
                }), t688("visual_table_class", {
                    processor: "string",
                    default: "mce-item-table"
                }), t688("visual_anchor_class", {
                    processor: "string",
                    default: "mce-item-anchor"
                }), t688("iframe_aria_text", {
                    processor: "string",
                    default: "Rich Text Area. Press ALT-0 for help."
                }), t688("setup", {
                    processor: "function"
                }), t688("init_instance_callback", {
                    processor: "function"
                }), t688("url_converter", {
                    processor: "function",
                    default: e972.convertURL
                }), t688("url_converter_scope", {
                    processor: "object",
                    default: e972
                }), t688("urlconverter_callback", {
                    processor: "function"
                }), t688("allow_conditional_comments", {
                    processor: "boolean",
                    default: !1
                }), t688("allow_html_data_urls", {
                    processor: "boolean",
                    default: !1
                }), t688("allow_svg_data_urls", {
                    processor: "boolean"
                }), t688("allow_html_in_named_anchor", {
                    processor: "boolean",
                    default: !1
                }), t688("allow_script_urls", {
                    processor: "boolean",
                    default: !1
                }), t688("allow_unsafe_link_target", {
                    processor: "boolean",
                    default: !1
                }), t688("convert_fonts_to_spans", {
                    processor: "boolean",
                    default: !0,
                    deprecated: !0
                }), t688("fix_list_elements", {
                    processor: "boolean",
                    default: !1
                }), t688("preserve_cdata", {
                    processor: "boolean",
                    default: !1
                }), t688("remove_trailing_brs", {
                    processor: "boolean"
                }), t688("inline_styles", {
                    processor: "boolean",
                    default: !0,
                    deprecated: !0
                }), t688("element_format", {
                    processor: "string",
                    default: "html"
                }), t688("entities", {
                    processor: "string"
                }), t688("schema", {
                    processor: "string",
                    default: "html5"
                }), t688("convert_urls", {
                    processor: "boolean",
                    default: !0
                }), t688("relative_urls", {
                    processor: "boolean",
                    default: !0
                }), t688("remove_script_host", {
                    processor: "boolean",
                    default: !0
                }), t688("custom_elements", {
                    processor: "string"
                }), t688("extended_valid_elements", {
                    processor: "string"
                }), t688("invalid_elements", {
                    processor: "string"
                }), t688("invalid_styles", {
                    processor: wi
                }), t688("valid_children", {
                    processor: "string"
                }), t688("valid_classes", {
                    processor: wi
                }), t688("valid_elements", {
                    processor: "string"
                }), t688("valid_styles", {
                    processor: wi
                }), t688("verify_html", {
                    processor: "boolean",
                    default: !0
                }), t688("auto_focus", {
                    processor: (e)=>m1(e) || !0 === e
                }), t688("browser_spellcheck", {
                    processor: "boolean",
                    default: !1
                }), t688("protect", {
                    processor: "array"
                }), t688("images_file_types", {
                    processor: "string",
                    default: "jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp"
                }), t688("deprecation_warnings", {
                    processor: "boolean",
                    default: !0
                }), t688("a11y_advanced_options", {
                    processor: "boolean",
                    default: !1
                }), t688("api_key", {
                    processor: "string"
                }), t688("paste_block_drop", {
                    processor: "boolean",
                    default: !1
                }), t688("paste_data_images", {
                    processor: "boolean",
                    default: !0
                }), t688("paste_preprocess", {
                    processor: "function"
                }), t688("paste_postprocess", {
                    processor: "function"
                }), t688("paste_webkit_styles", {
                    processor: "string",
                    default: "none"
                }), t688("paste_remove_styles_if_webkit", {
                    processor: "boolean",
                    default: !0
                }), t688("paste_merge_formats", {
                    processor: "boolean",
                    default: !0
                }), t688("smart_paste", {
                    processor: "boolean",
                    default: !0
                }), t688("paste_as_text", {
                    processor: "boolean",
                    default: !1
                }), t688("paste_tab_spaces", {
                    processor: "number",
                    default: 4
                }), t688("text_patterns", {
                    processor: (e)=>k1(e, f1) || !1 === e ? {
                            value: hi(!1 === e ? [] : e),
                            valid: !0
                        } : {
                            valid: !1,
                            message: "Must be an array of objects or false."
                        }
                    ,
                    default: [
                        {
                            start: "*",
                            end: "*",
                            format: "italic"
                        },
                        {
                            start: "**",
                            end: "**",
                            format: "bold"
                        },
                        {
                            start: "#",
                            format: "h1"
                        },
                        {
                            start: "##",
                            format: "h2"
                        },
                        {
                            start: "###",
                            format: "h3"
                        },
                        {
                            start: "####",
                            format: "h4"
                        },
                        {
                            start: "#####",
                            format: "h5"
                        },
                        {
                            start: "######",
                            format: "h6"
                        },
                        {
                            start: "1. ",
                            cmd: "InsertOrderedList"
                        },
                        {
                            start: "* ",
                            cmd: "InsertUnorderedList"
                        },
                        {
                            start: "- ",
                            cmd: "InsertUnorderedList"
                        }
                    ]
                }), t688("noneditable_class", {
                    processor: "string",
                    default: "mceNonEditable"
                }), t688("editable_class", {
                    processor: "string",
                    default: "mceEditable"
                }), t688("noneditable_regexp", {
                    processor: (e)=>k1(e, Ci) ? {
                            value: e,
                            valid: !0
                        } : Ci(e) ? {
                            value: [
                                e
                            ],
                            valid: !0
                        } : {
                            valid: !1,
                            message: "Must be a RegExp or an array of RegExp."
                        }
                    ,
                    default: []
                }), t688("table_tab_navigation", {
                    processor: "boolean",
                    default: !0
                }), e972.on("ScriptsLoaded", ()=>{
                    t688("directionality", {
                        processor: "string",
                        default: $s.isRtl() ? "rtl" : void 0
                    }), t688("placeholder", {
                        processor: "string",
                        default: yi.getAttrib(e972.getElement(), "placeholder")
                    });
                });
            })(o236);
            const s78 = this.options.get;
            s78("deprecation_warnings") && ((e973, t689)=>{
                ((e, t)=>{
                    const n = zv(e), o = jv(t), r = o.length > 0, s = n.length > 0, a = "mobile" === t.theme;
                    if (r || s || a) {
                        const e = "\n- ", t = a ? `\n\nThemes:${e}mobile` : "", i = r ? `\n\nPlugins:${e}${o.join(e)}` : "", l = s ? `\n\nOptions:${e}${n.join(e)}` : "";
                        console.warn("The following deprecated features are currently enabled and have been removed in TinyMCE 6.0. These features will no longer work and should be removed from the TinyMCE configuration. See https://www.tiny.cloud/docs/tinymce/6/migration-from-5x/ for more information." + t + i + l);
                    }
                })(e973, t689);
            })(t686, r125);
            const a50 = s78("suffix");
            a50 && (n420.suffix = a50), this.suffix = n420.suffix;
            const i33 = s78("base_url");
            i33 && n420._setBaseUrl(i33), this.baseUri = n420.baseURI;
            const l26 = Ki(o236);
            l26 && (Us.ScriptLoader._setReferrerPolicy(l26), Is.DOM.styleSheetLoader._setReferrerPolicy(l26)), qs.languageLoad = s78("language_load"), qs.baseURL = n420.baseURL, this.setDirty(!1), this.documentBaseURI = new Mb(Ei(o236), {
                base_uri: this.baseUri
            }), this.baseURI = this.baseUri, this.inline = bl(o236), this.shortcuts = new WN(this), this.editorCommands = new vN(this), bN(this);
            const d = s78("cache_suffix");
            d && (Nt.cacheSuffix = d.replace(/^[\?\&]+/, "")), this.ui = {
                registry: KN(),
                styleSheetLoader: void 0,
                show: S1,
                hide: S1,
                setEnabled: S1,
                isEnabled: P1
            }, this.mode = ((e974)=>{
                const t690 = zs("design"), n422 = zs({
                    design: {
                        activate: S1,
                        deactivate: S1,
                        editorReadOnly: !1
                    },
                    readonly: {
                        activate: S1,
                        deactivate: S1,
                        editorReadOnly: !0
                    }
                });
                return ((e)=>{
                    e.serializer ? SN(e) : e.on("PreInit", ()=>{
                        SN(e);
                    });
                })(e974), ((e)=>{
                    e.on("ShowCaret", (t)=>{
                        kN(e) && t.preventDefault();
                    }), e.on("ObjectSelected", (t)=>{
                        kN(e) && t.preventDefault();
                    });
                })(e974), {
                    isReadOnly: ()=>kN(e974)
                    ,
                    set: (o238)=>((e, t, n, o)=>{
                            if (o !== n.get()) {
                                if (!we1(t, o)) throw new Error(`Editor mode '${o}' is invalid`);
                                e.initialized ? zN(e, n, t, o) : e.on("init", ()=>zN(e, n, t, o)
                                );
                            }
                        })(e974, n422.get(), t690, o238)
                    ,
                    get: ()=>t690.get()
                    ,
                    register: (e975, t691)=>{
                        n422.set(((e976, t, n)=>{
                            if (j1(UN, t)) throw new Error(`Cannot override default mode ${t}`);
                            return {
                                ...e976,
                                [t]: {
                                    ...n,
                                    deactivate: ()=>{
                                        try {
                                            n.deactivate();
                                        } catch (e) {
                                            console.error(`problem while deactivating editor mode ${t}:`, e);
                                        }
                                    }
                                }
                            };
                        })(n422.get(), e975, t691));
                    }
                };
            })(o236), n420.dispatch("SetupEditor", {
                editor: this
            });
            const c = Dl(o236);
            x1(c) && c.call(o236, o236);
        }
        render() {
            ((e977)=>{
                const t692 = e977.id;
                $s.setCode(Gi(e977));
                const n = ()=>{
                    KE.unbind(window, "ready", n), e977.render();
                };
                if (!Rs.Event.domLoaded) return void KE.bind(window, "ready", n);
                if (!e977.getElement()) return;
                const o = mn(e977.getElement()), r = Xt(o);
                e977.on("remove", ()=>{
                    q1(o.dom.attributes, (e)=>Yt(o, e.name)
                    ), qt(o, r);
                }), e977.ui.styleSheetLoader = ((e, t)=>Yo.forElement(e, {
                        contentCssCors: _l(t),
                        referrerPolicy: Ki(t)
                    })
                )(o, e977), bl(e977) ? e977.inline = !0 : (e977.orgVisibility = e977.getElement().style.visibility, e977.getElement().style.visibility = "hidden");
                const s = e977.getElement().form || KE.getParent(t692, "form");
                s && (e977.formElement = s, vl(e977) && !Eo(e977.getElement()) && (KE.insertAfter(KE.create("input", {
                    type: "hidden",
                    name: t692
                }), t692), e977.hasHiddenInput = !0), e977.formEventDelegate = (t)=>{
                    e977.dispatch(t.type, t);
                }, KE.bind(s, "submit reset", e977.formEventDelegate), e977.on("reset", ()=>{
                    e977.resetContent();
                }), !yl(e977) || s.submit.nodeType || s.submit.length || s._mceOldSubmit || (s._mceOldSubmit = s.submit, s.submit = ()=>(e977.editorManager.triggerSave(), e977.setDirty(!1), s._mceOldSubmit(s))
                )), e977.windowManager = ty(e977), e977.notificationManager = Jv(e977), ((e)=>"xml" === e.options.get("encoding")
                )(e977) && e977.on("GetContent", (e)=>{
                    e.save && (e.content = KE.encode(e.content));
                }), Cl(e977) && e977.on("submit", ()=>{
                    e977.initialized && e977.save();
                }), xl(e977) && (e977._beforeUnload = ()=>{
                    !e977.initialized || e977.destroyed || e977.isHidden() || e977.save({
                        format: "raw",
                        no_events: !0,
                        set_dirty: !1
                    });
                }, e977.editorManager.on("BeforeUnload", e977._beforeUnload)), e977.editorManager.add(e977), XE(e977, e977.suffix);
            })(this);
        }
        focus(e) {
            this.execCommand("mceFocus", !1, e);
        }
        hasFocus() {
            return nf(this);
        }
        translate(e) {
            return $s.translate(e);
        }
        getParam(e, t, n) {
            const o = this.options;
            return o.isRegistered(e) || (C1(n) ? o.register(e, {
                processor: n,
                default: t
            }) : o.register(e, {
                processor: P1,
                default: t
            })), o.isSet(e) || v1(t) ? o.get(e) : t;
        }
        hasPlugin(e, t) {
            return !(!j1(El(this), e) || t && void 0 === Zv.get(e));
        }
        nodeChanged(e) {
            this._nodeChangeDispatcher.nodeChanged(e);
        }
        addCommand(e, t, n) {
            this.editorCommands.addCommand(e, t, n);
        }
        addQueryStateHandler(e, t, n) {
            this.editorCommands.addQueryStateHandler(e, t, n);
        }
        addQueryValueHandler(e, t, n) {
            this.editorCommands.addQueryValueHandler(e, t, n);
        }
        addShortcut(e, t, n, o) {
            this.shortcuts.add(e, t, n, o);
        }
        execCommand(e, t, n, o) {
            return this.editorCommands.execCommand(e, t, n, o);
        }
        queryCommandState(e) {
            return this.editorCommands.queryCommandState(e);
        }
        queryCommandValue(e) {
            return this.editorCommands.queryCommandValue(e);
        }
        queryCommandSupported(e) {
            return this.editorCommands.queryCommandSupported(e);
        }
        show() {
            const e = this;
            e.hidden && (e.hidden = !1, e.inline ? e.getBody().contentEditable = "true" : (GN.show(e.getContainer()), GN.hide(e.id)), e.load(), e.dispatch("show"));
        }
        hide() {
            const e = this;
            e.hidden || (e.save(), e.inline ? (e.getBody().contentEditable = "false", e === e.editorManager.focusedEditor && (e.editorManager.focusedEditor = null)) : (GN.hide(e.getContainer()), GN.setStyle(e.id, "display", e.orgDisplay)), e.hidden = !0, e.dispatch("hide"));
        }
        isHidden() {
            return this.hidden;
        }
        setProgressState(e, t) {
            this.dispatch("ProgressState", {
                state: e,
                time: t
            });
        }
        load(e) {
            const t = this;
            let n, o = t.getElement();
            if (t.removed) return "";
            if (o) {
                (e = e || {}).load = !0;
                const r = Eo(o) ? o.value : o.innerHTML;
                return n = t.setContent(r, e), e.element = o, e.no_events || t.dispatch("LoadContent", e), e.element = o = null, n;
            }
        }
        save(e978) {
            const t = this;
            let n, o, r = t.getElement();
            if (r && t.initialized && !t.removed) return (e978 = e978 || {}).save = !0, e978.element = r, n = e978.content = t.getContent(e978), e978.no_events || t.dispatch("SaveContent", e978), "raw" === e978.format && t.dispatch("RawSaveContent", e978), n = e978.content, Eo(r) ? r.value = n : (!e978.is_removing && t.inline || (r.innerHTML = n), (o = GN.getParent(t.id, "form")) && XN(o.elements, (e)=>{
                if (e.name === t.id) return e.value = n, !1;
            })), e978.element = r = null, !1 !== e978.set_dirty && t.setDirty(!1), n;
        }
        setContent(e, t) {
            return Iv(this, e, t);
        }
        getContent(e979) {
            return ((e980, t693 = {})=>{
                const n423 = ((e, t)=>({
                        ...e,
                        format: t,
                        get: !0,
                        getInner: !0
                    })
                )(t693, t693.format ? t693.format : "html");
                return Gb(e980, n423).fold(R1, (t694)=>{
                    const n = ((e, t)=>Ev(e).editor.getContent(t)
                    )(e980, t694);
                    return Yb(e980, n, t694);
                });
            })(this, e979);
        }
        insertContent(e, t) {
            t && (e = YN({
                content: e
            }, t)), this.execCommand("mceInsertContent", !1, e);
        }
        resetContent(e) {
            void 0 === e ? Iv(this, this.startContent, {
                format: "raw"
            }) : Iv(this, e), this.undoManager.reset(), this.setDirty(!1), this.nodeChanged();
        }
        isDirty() {
            return !this.isNotDirty;
        }
        setDirty(e) {
            const t = !this.isNotDirty;
            this.isNotDirty = !e, e && e !== t && this.dispatch("dirty");
        }
        getContainer() {
            const e = this;
            return e.container || (e.container = GN.get(e.editorContainer || e.id + "_parent")), e.container;
        }
        getContentAreaContainer() {
            return this.contentAreaContainer;
        }
        getElement() {
            return this.targetElm || (this.targetElm = GN.get(this.id)), this.targetElm;
        }
        getWin() {
            const e = this;
            let t;
            return e.contentWindow || (t = e.iframeElement, t && (e.contentWindow = t.contentWindow)), e.contentWindow;
        }
        getDoc() {
            const e = this;
            let t;
            return e.contentDocument || (t = e.getWin(), t && (e.contentDocument = t.document)), e.contentDocument;
        }
        getBody() {
            const e = this.getDoc();
            return this.bodyElement || (e ? e.body : null);
        }
        convertURL(e, t, n) {
            const o = this, r = o.options.get, s = Pl(o);
            return x1(s) ? s.call(o, e, n, !0, t) : !r("convert_urls") || n && "LINK" === n.nodeName || 0 === e.indexOf("file:") || 0 === e.length ? e : r("relative_urls") ? o.documentBaseURI.toRelative(e) : e = o.documentBaseURI.toAbsolute(e, r("remove_script_host"));
        }
        addVisual(e981) {
            ((e982, t695)=>{
                ((e, t)=>{
                    Nv(e).editor.addVisual(t);
                })(e982, t695);
            })(this, e981);
        }
        remove() {
            ((e983)=>{
                if (!e983.removed) {
                    const { _selectionOverrides: t , editorUpload: n  } = e983, o = e983.getBody(), r = e983.getElement();
                    o && e983.save({
                        is_removing: !0
                    }), e983.removed = !0, e983.unbindAllNativeEvents(), e983.hasHiddenInput && r && Vv.remove(r.nextSibling), ((e)=>{
                        e.dispatch("remove");
                    })(e983), e983.editorManager.remove(e983), !e983.inline && o && ((e)=>{
                        Vv.setStyle(e.id, "display", e.orgDisplay);
                    })(e983), ((e)=>{
                        e.dispatch("detach");
                    })(e983), Vv.remove(e983.getContainer()), Hv(t), Hv(n), e983.destroy();
                }
            })(this);
        }
        destroy(e984) {
            ((e985, t696)=>{
                const { selection: n , dom: o  } = e985;
                e985.destroyed || (t696 || e985.removed ? (t696 || (e985.editorManager.off("beforeunload", e985._beforeUnload), e985.theme && e985.theme.destroy && e985.theme.destroy(), Hv(n), Hv(o)), ((e)=>{
                    const t = e.formElement;
                    t && (t._mceOldSubmit && (t.submit = t._mceOldSubmit, t._mceOldSubmit = null), Vv.unbind(t, "submit reset", e.formEventDelegate));
                })(e985), ((e)=>{
                    e.contentAreaContainer = e.formElement = e.container = e.editorContainer = null, e.bodyElement = e.contentDocument = e.contentWindow = null, e.iframeElement = e.targetElm = null, e.selection && (e.selection = e.selection.win = e.selection.dom = e.selection.dom.doc = null);
                })(e985), e985.destroyed = !0) : e985.remove());
            })(this, e984);
        }
        uploadImages() {
            return this.editorUpload.uploadImages();
        }
        _scanForImages() {
            return this.editorUpload.scanForImages();
        }
    }
    const JN = Is.DOM, ZN = Bt.each;
    let eR, tR = !1, nR = [];
    const oR = (e)=>{
        const t = e.type;
        ZN(iR.get(), (n)=>{
            switch(t){
                case "scroll":
                    n.dispatch("ScrollWindow", e);
                    break;
                case "resize":
                    n.dispatch("ResizeWindow", e);
            }
        });
    }, rR = (e)=>{
        if (e !== tR) {
            const t = Is.DOM;
            e ? (t.bind(window, "resize", oR), t.bind(window, "scroll", oR)) : (t.unbind(window, "resize", oR), t.unbind(window, "scroll", oR)), tR = e;
        }
    }, sR = (e)=>{
        const t697 = nR;
        return nR = K1(nR, (t)=>e !== t
        ), iR.activeEditor === e && (iR.activeEditor = nR.length > 0 ? nR[0] : null), iR.focusedEditor === e && (iR.focusedEditor = null), t697.length !== nR.length;
    }, aR = "CSS1Compat" !== document.compatMode, iR = {
        ...RN,
        baseURI: null,
        baseURL: null,
        defaultOptions: {},
        documentBaseURL: null,
        suffix: null,
        majorVersion: "6",
        minorVersion: "0.1",
        releaseDate: "2022-03-23",
        i18n: $s,
        activeEditor: null,
        focusedEditor: null,
        setup () {
            const e = this;
            let t, n, o = "";
            n = Mb.getDocumentBaseUrl(document.location), /^[^:]+:\/\/\/?[^\/]+\//.test(n) && (n = n.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(n) || (n += "/"));
            const r = window.tinymce || window.tinyMCEPreInit;
            if (r) t = r.base || r.baseURL, o = r.suffix;
            else {
                const e = document.getElementsByTagName("script");
                for(let n = 0; n < e.length; n++){
                    const r = e[n].src || "";
                    if ("" === r) continue;
                    const s = r.substring(r.lastIndexOf("/"));
                    if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(r)) {
                        -1 !== s.indexOf(".min") && (o = ".min"), t = r.substring(0, r.lastIndexOf("/"));
                        break;
                    }
                }
                if (!t && document.currentScript) {
                    const e = document.currentScript.src;
                    -1 !== e.indexOf(".min") && (o = ".min"), t = e.substring(0, e.lastIndexOf("/"));
                }
            }
            var s;
            e.baseURL = new Mb(n).toAbsolute(t), e.documentBaseURL = n, e.baseURI = new Mb(e.baseURL), e.suffix = o, (s = e).on("AddEditor", O1(Jm, s)), s.on("RemoveEditor", O1(Zm, s));
        },
        overrideDefaults (e986) {
            const t698 = e986.base_url;
            t698 && this._setBaseUrl(t698);
            const n = e986.suffix;
            e986.suffix && (this.suffix = n), this.defaultOptions = e986;
            const o = e986.plugin_base_urls;
            void 0 !== o && fe1(o, (e, t)=>{
                qs.PluginManager.urls[t] = e;
            });
        },
        init (e987) {
            const t700 = this;
            let n424;
            const o239 = Bt.makeMap("area base basefont br col frame hr img input isindex link meta param embed source wbr track colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu", " ");
            let r127 = (e)=>{
                n424 = e;
            };
            const s80 = ()=>{
                let n425 = 0;
                const a = [];
                let i;
                JN.unbind(window, "ready", s80), ((n)=>{
                    const o = e987.onpageload;
                    o && o.apply(t700, []);
                })(), i = ((e988, t)=>{
                    const n426 = [], o = x1(t) ? (e)=>V1(n426, (n)=>t(n, e)
                        )
                     : (e)=>j1(n426, e)
                    ;
                    for(let t699 = 0, r = e988.length; t699 < r; t699++){
                        const r = e988[t699];
                        o(r) || n426.push(r);
                    }
                    return n426;
                })(((e)=>Nt.browser.isIE() || Nt.browser.isEdge() ? (ay("TinyMCE does not support the browser you are using. For a list of supported browsers please see: https://www.tiny.cloud/docs/tinymce/6/support/#supportedwebbrowsers"), []) : aR ? (ay("Failed to initialize the editor as the document is not in standards mode. TinyMCE requires standards mode."), []) : m1(e.selector) ? JN.select(e.selector) : C1(e.target) ? [
                        e.target
                    ] : []
                )(e987)), Bt.each(i, (e)=>{
                    var n;
                    (n = t700.get(e.id)) && n.initialized && !(n.getContainer() || n.getBody()).parentNode && (sR(n), n.unbindAllNativeEvents(), n.destroy(!0), n.removed = !0, n = null);
                }), i = Bt.grep(i, (e)=>!t700.get(e.id)
                ), 0 === i.length ? r127([]) : ZN(i, (s81)=>{
                    ((e, t)=>e.inline && t.tagName.toLowerCase() in o239
                    )(e987, s81) ? ay("Could not initialize inline editor on invalid inline target element", s81) : ((e, o, s)=>{
                        const l = new QN(e, o, t700);
                        a.push(l), l.on("init", ()=>{
                            ++n425 === i.length && r127(a);
                        }), l.targetElm = l.targetElm || s, l.render();
                    })(((e989)=>{
                        let t = e989.id;
                        return t || (t = xe1(e989, "name").filter((e)=>!JN.get(e)
                        ).getOrThunk(JN.uniqueId), e989.setAttribute("id", t)), t;
                    })(s81), e987, s81);
                });
            };
            return JN.bind(window, "ready", s80), new Promise((e)=>{
                n424 ? e(n424) : r127 = (t)=>{
                    e(t);
                };
            });
        },
        get (e) {
            return 0 === arguments.length ? nR.slice(0) : m1(e) ? Q1(nR, (t)=>t.id === e
            ).getOr(null) : w1(e) && nR[e] ? nR[e] : null;
        },
        add (e990) {
            const t = this, n427 = t.get(e990.id);
            return n427 === e990 || (null === n427 && nR.push(e990), rR(!0), t.activeEditor = e990, t.dispatch("AddEditor", {
                editor: e990
            }), eR || (eR = (e)=>{
                const n = t.dispatch("BeforeUnload");
                if (n.returnValue) return e.preventDefault(), e.returnValue = n.returnValue, n.returnValue;
            }, window.addEventListener("beforeunload", eR))), e990;
        },
        createEditor (e, t) {
            return this.add(new QN(e, t, this));
        },
        remove (e991) {
            const t = this;
            let n, o;
            if (e991) {
                if (!m1(e991)) return o = e991, h1(t.get(o.id)) ? null : (sR(o) && t.dispatch("RemoveEditor", {
                    editor: o
                }), 0 === nR.length && window.removeEventListener("beforeunload", eR), o.remove(), rR(nR.length > 0), o);
                ZN(JN.select(e991), (e)=>{
                    o = t.get(e.id), o && t.remove(o);
                });
            } else for(n = nR.length - 1; n >= 0; n--)t.remove(nR[n]);
        },
        execCommand (e, t, n) {
            var o;
            const r = this, s = f1(n) ? null !== (o = n.id) && void 0 !== o ? o : n.index : n;
            switch(e){
                case "mceAddEditor":
                    if (!r.get(s)) {
                        const e = n.options;
                        new QN(s, e, r).render();
                    }
                    return !0;
                case "mceRemoveEditor":
                    {
                        const e = r.get(s);
                        return e && e.remove(), !0;
                    }
                case "mceToggleEditor":
                    {
                        const e = r.get(s);
                        return e ? (e.isHidden() ? e.show() : e.hide(), !0) : (r.execCommand("mceAddEditor", !1, n), !0);
                    }
            }
            return !!r.activeEditor && r.activeEditor.execCommand(e, t, n);
        },
        triggerSave: ()=>{
            ZN(nR, (e)=>{
                e.save();
            });
        },
        addI18n: (e, t)=>{
            $s.add(e, t);
        },
        translate: (e)=>$s.translate(e)
        ,
        setActive (e) {
            const t = this.activeEditor;
            this.activeEditor !== e && (t && t.dispatch("deactivate", {
                relatedTarget: e
            }), e.dispatch("activate", {
                relatedTarget: t
            })), this.activeEditor = e;
        },
        _setBaseUrl (e) {
            this.baseURL = new Mb(this.documentBaseURL).toAbsolute(e.replace(/\/+$/, "")), this.baseURI = new Mb(this.baseURL);
        }
    };
    iR.setup();
    const lR = (()=>{
        const e992 = Ws();
        return {
            FakeClipboardItem: (e)=>({
                    items: e,
                    types: ue1(e),
                    getType: (t)=>xe1(e, t).getOrUndefined()
                })
            ,
            write: (t)=>{
                e992.set(t);
            },
            read: ()=>e992.get().getOrUndefined()
            ,
            clear: e992.clear
        };
    })(), dR = Math.min, cR = Math.max, uR = Math.round, mR = (e, t, n)=>{
        let o = t.x, r = t.y;
        const s = e.w, a = e.h, i = t.w, l = t.h, d = (n || "").split("");
        return "b" === d[0] && (r += l), "r" === d[1] && (o += i), "c" === d[0] && (r += uR(l / 2)), "c" === d[1] && (o += uR(i / 2)), "b" === d[3] && (r -= a), "r" === d[4] && (o -= s), "c" === d[3] && (r -= uR(a / 2)), "c" === d[4] && (o -= uR(s / 2)), fR(o, r, s, a);
    }, fR = (e, t, n, o)=>({
            x: e,
            y: t,
            w: n,
            h: o
        })
    , gR = {
        inflate: (e, t, n)=>fR(e.x - t, e.y - n, e.w + 2 * t, e.h + 2 * n)
        ,
        relativePosition: mR,
        findBestRelativePosition: (e, t, n, o)=>{
            let r, s;
            for(s = 0; s < o.length; s++)if (r = mR(e, t, o[s]), r.x >= n.x && r.x + r.w <= n.w + n.x && r.y >= n.y && r.y + r.h <= n.h + n.y) return o[s];
            return null;
        },
        intersect: (e, t)=>{
            const n = cR(e.x, t.x), o = cR(e.y, t.y), r = dR(e.x + e.w, t.x + t.w), s = dR(e.y + e.h, t.y + t.h);
            return r - n < 0 || s - o < 0 ? null : fR(n, o, r - n, s - o);
        },
        clamp: (e, t, n)=>{
            let o = e.x, r = e.y, s = e.x + e.w, a = e.y + e.h;
            const i = t.x + t.w, l = t.y + t.h, d = cR(0, t.x - o), c = cR(0, t.y - r), u = cR(0, s - i), m = cR(0, a - l);
            return o += d, r += c, n && (s += d, a += c, o -= u, r -= m), s -= u, a -= m, fR(o, r, s - o, a - r);
        },
        create: fR,
        fromClientRect: (e)=>fR(e.left, e.top, e.width, e.height)
    }, pR = (()=>{
        const e993 = {}, t701 = {};
        return {
            load: (n428, o240)=>{
                const r128 = `Script at URL "${o240}" failed to load`, s82 = `Script at URL "${o240}" did not call \`tinymce.Resource.add('${n428}', data)\` within 1 second`;
                if (void 0 !== e993[n428]) return e993[n428];
                {
                    const a51 = new Promise((e994, a53)=>{
                        const i34 = ((e995, t702, n = 1000)=>{
                            let o = !1, r = null;
                            const s = (e)=>(...t)=>{
                                    o || (o = !0, null !== r && (clearTimeout(r), r = null), e.apply(null, t));
                                }
                            , a = s(e995), i = s(t702);
                            return {
                                start: (...e)=>{
                                    o || null !== r || (r = setTimeout(()=>i.apply(null, e)
                                    , n));
                                },
                                resolve: a,
                                reject: i
                            };
                        })(e994, a53);
                        t701[n428] = i34.resolve, Us.ScriptLoader.loadScript(o240).then(()=>i34.start(s82)
                        , ()=>i34.reject(r128)
                        );
                    });
                    return e993[n428] = a51, a51;
                }
            },
            add: (n, o)=>{
                void 0 !== t701[n] && (t701[n](o), delete t701[n]), e993[n] = Promise.resolve(o);
            },
            unload: (t)=>{
                delete e993[t];
            }
        };
    })();
    let hR;
    try {
        const e = "__storage_test__";
        hR = window.localStorage, hR.setItem(e, e), hR.removeItem(e);
    } catch (e996) {
        hR = (()=>{
            let e997 = {}, t703 = [];
            const n429 = {
                getItem: (t)=>e997[t] || null
                ,
                setItem: (n, o)=>{
                    t703.push(n), e997[n] = String(o);
                },
                key: (e)=>t703[e]
                ,
                removeItem: (n)=>{
                    t703 = t703.filter((e)=>e === n
                    ), delete e997[n];
                },
                clear: ()=>{
                    t703 = [], e997 = {};
                },
                length: 0
            };
            return Object.defineProperty(n429, "length", {
                get: ()=>t703.length
                ,
                configurable: !1,
                enumerable: !1
            }), n429;
        })();
    }
    const bR = {
        geom: {
            Rect: gR
        },
        util: {
            Delay: Gm,
            Tools: Bt,
            VK: Uu,
            URI: Mb,
            EventDispatcher: EN,
            Observable: RN,
            I18n: $s,
            LocalStorage: hR,
            ImageUploader: (e)=>{
                const t704 = dy(), n = fy(e, t704);
                return {
                    upload: (t, o = !0)=>n.upload(t, o ? my(e) : void 0)
                };
            }
        },
        dom: {
            EventUtils: Rs,
            TreeWalker: Xo,
            TextSeeker: ca,
            DOMUtils: Is,
            ScriptLoader: Us,
            RangeUtils: pm,
            Serializer: Mv,
            StyleSheetLoader: Go,
            ControlSelection: zu,
            BookmarkManager: Tu,
            Selection: Dv,
            Event: Rs.Event
        },
        html: {
            Styles: ys,
            Entities: ls,
            Node: yf,
            Schema: vs,
            DomParser: Wb,
            Writer: Nf,
            Serializer: Rf
        },
        Env: Nt,
        AddOnManager: qs,
        Annotator: Ou,
        Formatter: Sy,
        UndoManager: Ey,
        EditorCommands: vN,
        WindowManager: ty,
        NotificationManager: Jv,
        EditorObservable: LN,
        Shortcuts: WN,
        Editor: QN,
        FocusManager: Km,
        EditorManager: iR,
        DOM: Is.DOM,
        ScriptLoader: Us.ScriptLoader,
        PluginManager: Zv,
        ThemeManager: ey,
        ModelManager: qv,
        IconManager: $v,
        Resource: pR,
        FakeClipboard: lR,
        trim: Bt.trim,
        isArray: Bt.isArray,
        is: Bt.is,
        toArray: Bt.toArray,
        makeMap: Bt.makeMap,
        each: Bt.each,
        map: Bt.map,
        grep: Bt.grep,
        inArray: Bt.inArray,
        extend: Bt.extend,
        walk: Bt.walk,
        resolve: Bt.resolve,
        explode: Bt.explode,
        _addCacheSuffix: Bt._addCacheSuffix
    }, vR = Bt.extend(iR, bR);
    ((e)=>{
        window.tinymce = e, window.tinyMCE = e;
    })(vR), ((e)=>{
        if ("object" == typeof module) try {
            module.exports = e;
        } catch (e998) {}
    })(vR);
}();


</script>
  <script referrerpolicy="origin">
/**
 * TinyMCE version 6.0.1 (2022-03-23)
 */ (function() {
    const getPrototypeOf = Object.getPrototypeOf;
    const hasProto = (v, constructor, predicate)=>{
        var _a;
        if (predicate(v, constructor.prototype)) return true;
        else return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;
    };
    const typeOf = (x)=>{
        const t = typeof x;
        if (x === null) return 'null';
        else if (t === 'object' && Array.isArray(x)) return 'array';
        else if (t === 'object' && hasProto(x, String, (o, proto)=>proto.isPrototypeOf(o)
        )) return 'string';
        else return t;
    };
    const isType$1 = (type)=>(value)=>typeOf(value) === type
    ;
    const isSimpleType = (type)=>(value)=>typeof value === type
    ;
    const eq$1 = (t)=>(a)=>t === a
    ;
    const is$2 = (value, constructor)=>isObject(value) && hasProto(value, constructor, (o, proto)=>getPrototypeOf(o) === proto
        )
    ;
    const isString = isType$1('string');
    const isObject = isType$1('object');
    const isPlainObject = (value)=>is$2(value, Object)
    ;
    const isArray = isType$1('array');
    const isNull = eq$1(null);
    const isBoolean = isSimpleType('boolean');
    const isUndefined = eq$1(undefined);
    const isNullable = (a)=>a === null || a === undefined
    ;
    const isNonNullable = (a)=>!isNullable(a)
    ;
    const isFunction = isSimpleType('function');
    const isNumber = isSimpleType('number');
    const isArrayOf = (value, pred)=>{
        if (isArray(value)) {
            for(let i = 0, len = value.length; i < len; ++i){
                if (!pred(value[i])) return false;
            }
            return true;
        }
        return false;
    };
    const noop = ()=>{};
    const noarg = (f)=>()=>f()
    ;
    const compose = (fa, fb)=>{
        return (...args)=>{
            return fa(fb.apply(null, args));
        };
    };
    const compose1 = (fbc, fab)=>(a)=>fbc(fab(a))
    ;
    const constant$1 = (value)=>{
        return ()=>{
            return value;
        };
    };
    const identity = (x)=>{
        return x;
    };
    const tripleEquals = (a, b)=>{
        return a === b;
    };
    function curry(fn, ...initialArgs) {
        return (...restArgs)=>{
            const all = initialArgs.concat(restArgs);
            return fn.apply(null, all);
        };
    }
    const not = (f)=>(t)=>!f(t)
    ;
    const die = (msg)=>{
        return ()=>{
            throw new Error(msg);
        };
    };
    const apply = (f)=>{
        return f();
    };
    const never = constant$1(false);
    const always = constant$1(true);
    var global$a = tinymce.util.Tools.resolve('tinymce.ThemeManager');
    class Optional {
        constructor(tag, value){
            this.tag = tag;
            this.value = value;
        }
        static some(value) {
            return new Optional(true, value);
        }
        static none() {
            return Optional.singletonNone;
        }
        fold(onNone, onSome) {
            if (this.tag) return onSome(this.value);
            else return onNone();
        }
        isSome() {
            return this.tag;
        }
        isNone() {
            return !this.tag;
        }
        map(mapper) {
            if (this.tag) return Optional.some(mapper(this.value));
            else return Optional.none();
        }
        bind(binder) {
            if (this.tag) return binder(this.value);
            else return Optional.none();
        }
        exists(predicate) {
            return this.tag && predicate(this.value);
        }
        forall(predicate) {
            return !this.tag || predicate(this.value);
        }
        filter(predicate) {
            if (!this.tag || predicate(this.value)) return this;
            else return Optional.none();
        }
        getOr(replacement) {
            return this.tag ? this.value : replacement;
        }
        or(replacement) {
            return this.tag ? this : replacement;
        }
        getOrThunk(thunk) {
            return this.tag ? this.value : thunk();
        }
        orThunk(thunk) {
            return this.tag ? this : thunk();
        }
        getOrDie(message) {
            if (!this.tag) throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');
            else return this.value;
        }
        static from(value) {
            return isNonNullable(value) ? Optional.some(value) : Optional.none();
        }
        getOrNull() {
            return this.tag ? this.value : null;
        }
        getOrUndefined() {
            return this.value;
        }
        each(worker) {
            if (this.tag) worker(this.value);
        }
        toArray() {
            return this.tag ? [
                this.value
            ] : [];
        }
        toString() {
            return this.tag ? `some(${this.value})` : 'none()';
        }
    }
    Optional.singletonNone = new Optional(false);
    const nativeSlice = Array.prototype.slice;
    const nativeIndexOf = Array.prototype.indexOf;
    const nativePush = Array.prototype.push;
    const rawIndexOf = (ts, t)=>nativeIndexOf.call(ts, t)
    ;
    const indexOf = (xs, x)=>{
        const r = rawIndexOf(xs, x);
        return r === -1 ? Optional.none() : Optional.some(r);
    };
    const contains$2 = (xs, x)=>rawIndexOf(xs, x) > -1
    ;
    const exists = (xs, pred)=>{
        for(let i = 0, len = xs.length; i < len; i++){
            const x = xs[i];
            if (pred(x, i)) return true;
        }
        return false;
    };
    const range$2 = (num, f)=>{
        const r = [];
        for(let i = 0; i < num; i++)r.push(f(i));
        return r;
    };
    const chunk$1 = (array, size)=>{
        const r = [];
        for(let i = 0; i < array.length; i += size){
            const s = nativeSlice.call(array, i, i + size);
            r.push(s);
        }
        return r;
    };
    const map$2 = (xs, f)=>{
        const len = xs.length;
        const r = new Array(len);
        for(let i = 0; i < len; i++){
            const x = xs[i];
            r[i] = f(x, i);
        }
        return r;
    };
    const each$1 = (xs, f)=>{
        for(let i = 0, len = xs.length; i < len; i++){
            const x = xs[i];
            f(x, i);
        }
    };
    const eachr = (xs, f)=>{
        for(let i = xs.length - 1; i >= 0; i--){
            const x = xs[i];
            f(x, i);
        }
    };
    const partition$3 = (xs, pred)=>{
        const pass = [];
        const fail = [];
        for(let i = 0, len = xs.length; i < len; i++){
            const x = xs[i];
            const arr = pred(x, i) ? pass : fail;
            arr.push(x);
        }
        return {
            pass,
            fail
        };
    };
    const filter$2 = (xs, pred)=>{
        const r = [];
        for(let i = 0, len = xs.length; i < len; i++){
            const x = xs[i];
            if (pred(x, i)) r.push(x);
        }
        return r;
    };
    const foldr = (xs, f, acc)=>{
        eachr(xs, (x, i)=>{
            acc = f(acc, x, i);
        });
        return acc;
    };
    const foldl = (xs, f, acc)=>{
        each$1(xs, (x, i)=>{
            acc = f(acc, x, i);
        });
        return acc;
    };
    const findUntil = (xs, pred, until)=>{
        for(let i = 0, len = xs.length; i < len; i++){
            const x = xs[i];
            if (pred(x, i)) return Optional.some(x);
            else if (until(x, i)) break;
        }
        return Optional.none();
    };
    const find$5 = (xs, pred)=>{
        return findUntil(xs, pred, never);
    };
    const findIndex$1 = (xs, pred)=>{
        for(let i = 0, len = xs.length; i < len; i++){
            const x = xs[i];
            if (pred(x, i)) return Optional.some(i);
        }
        return Optional.none();
    };
    const flatten1 = (xs)=>{
        const r = [];
        for(let i = 0, len = xs.length; i < len; ++i){
            if (!isArray(xs[i])) throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);
            nativePush.apply(r, xs[i]);
        }
        return r;
    };
    const bind$3 = (xs, f)=>flatten1(map$2(xs, f))
    ;
    const forall = (xs, pred)=>{
        for(let i = 0, len = xs.length; i < len; ++i){
            const x = xs[i];
            if (pred(x, i) !== true) return false;
        }
        return true;
    };
    const reverse = (xs)=>{
        const r = nativeSlice.call(xs, 0);
        r.reverse();
        return r;
    };
    const difference = (a1, a2)=>filter$2(a1, (x)=>!contains$2(a2, x)
        )
    ;
    const mapToObject = (xs, f)=>{
        const r = {};
        for(let i = 0, len = xs.length; i < len; i++){
            const x = xs[i];
            r[String(x)] = f(x, i);
        }
        return r;
    };
    const pure$2 = (x)=>[
            x
        ]
    ;
    const sort = (xs, comparator)=>{
        const copy = nativeSlice.call(xs, 0);
        copy.sort(comparator);
        return copy;
    };
    const get$h = (xs, i)=>i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none()
    ;
    const head = (xs)=>get$h(xs, 0)
    ;
    const last$1 = (xs)=>get$h(xs, xs.length - 1)
    ;
    const from = isFunction(Array.from) ? Array.from : (x)=>nativeSlice.call(x)
    ;
    const findMap = (arr, f)=>{
        for(let i = 0; i < arr.length; i++){
            const r = f(arr[i], i);
            if (r.isSome()) return r;
        }
        return Optional.none();
    };
    const keys1 = Object.keys;
    const hasOwnProperty = Object.hasOwnProperty;
    const each = (obj, f)=>{
        const props = keys1(obj);
        for(let k = 0, len = props.length; k < len; k++){
            const i = props[k];
            const x = obj[i];
            f(x, i);
        }
    };
    const map$1 = (obj, f)=>{
        return tupleMap(obj, (x, i)=>({
                k: i,
                v: f(x, i)
            })
        );
    };
    const tupleMap = (obj, f)=>{
        const r = {};
        each(obj, (x, i)=>{
            const tuple = f(x, i);
            r[tuple.k] = tuple.v;
        });
        return r;
    };
    const objAcc = (r)=>(x, i)=>{
            r[i] = x;
        }
    ;
    const internalFilter = (obj, pred, onTrue, onFalse)=>{
        const r = {};
        each(obj, (x, i)=>{
            (pred(x, i) ? onTrue : onFalse)(x, i);
        });
        return r;
    };
    const bifilter = (obj, pred)=>{
        const t = {};
        const f = {};
        internalFilter(obj, pred, objAcc(t), objAcc(f));
        return {
            t,
            f
        };
    };
    const filter$1 = (obj, pred)=>{
        const t = {};
        internalFilter(obj, pred, objAcc(t), noop);
        return t;
    };
    const mapToArray = (obj, f)=>{
        const r = [];
        each(obj, (value, name)=>{
            r.push(f(value, name));
        });
        return r;
    };
    const find$4 = (obj, pred)=>{
        const props = keys1(obj);
        for(let k = 0, len = props.length; k < len; k++){
            const i = props[k];
            const x = obj[i];
            if (pred(x, i, obj)) return Optional.some(x);
        }
        return Optional.none();
    };
    const values1 = (obj)=>{
        return mapToArray(obj, identity);
    };
    const get$g = (obj, key)=>{
        return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();
    };
    const has$2 = (obj, key)=>hasOwnProperty.call(obj, key)
    ;
    const hasNonNullableKey = (obj, key)=>has$2(obj, key) && obj[key] !== undefined && obj[key] !== null
    ;
    const is$11 = (lhs, rhs, comparator = tripleEquals)=>lhs.exists((left)=>comparator(left, rhs)
        )
    ;
    const equals = (lhs, rhs, comparator = tripleEquals)=>lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone())
    ;
    const cat = (arr)=>{
        const r = [];
        const push = (x)=>{
            r.push(x);
        };
        for(let i = 0; i < arr.length; i++)arr[i].each(push);
        return r;
    };
    const sequence1 = (arr)=>{
        const r = [];
        for(let i = 0; i < arr.length; i++){
            const x = arr[i];
            if (x.isSome()) r.push(x.getOrDie());
            else return Optional.none();
        }
        return Optional.some(r);
    };
    const lift2 = (oa, ob, f)=>oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none()
    ;
    const lift3 = (oa, ob, oc, f)=>oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none()
    ;
    const mapFrom = (a, f)=>a !== undefined && a !== null ? Optional.some(f(a)) : Optional.none()
    ;
    const someIf = (b, a)=>b ? Optional.some(a) : Optional.none()
    ;
    const addToEnd = (str, suffix)=>{
        return str + suffix;
    };
    const removeFromStart = (str, numChars)=>{
        return str.substring(numChars);
    };
    const checkRange = (str, substr, start)=>substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr
    ;
    const removeLeading = (str, prefix)=>{
        return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;
    };
    const ensureTrailing = (str, suffix)=>{
        return endsWith(str, suffix) ? str : addToEnd(str, suffix);
    };
    const contains$1 = (str, substr)=>{
        return str.indexOf(substr) !== -1;
    };
    const startsWith = (str, prefix)=>{
        return checkRange(str, prefix, 0);
    };
    const endsWith = (str, suffix)=>{
        return checkRange(str, suffix, str.length - suffix.length);
    };
    const blank = (r)=>(s)=>s.replace(r, '')
    ;
    const trim$1 = blank(/^\s+|\s+$/g);
    const isNotEmpty = (s)=>s.length > 0
    ;
    const isEmpty = (s)=>!isNotEmpty(s)
    ;
    const isSupported$1 = (dom)=>dom.style !== undefined && isFunction(dom.style.getPropertyValue)
    ;
    const fromHtml$2 = (html, scope)=>{
        const doc = scope || document;
        const div = doc.createElement('div');
        div.innerHTML = html;
        if (!div.hasChildNodes() || div.childNodes.length > 1) {
            const message = 'HTML does not have a single root node';
            console.error(message, html);
            throw new Error(message);
        }
        return fromDom(div.childNodes[0]);
    };
    const fromTag = (tag, scope)=>{
        const doc = scope || document;
        const node = doc.createElement(tag);
        return fromDom(node);
    };
    const fromText = (text, scope)=>{
        const doc = scope || document;
        const node = doc.createTextNode(text);
        return fromDom(node);
    };
    const fromDom = (node)=>{
        if (node === null || node === undefined) throw new Error('Node cannot be null or undefined');
        return {
            dom: node
        };
    };
    const fromPoint = (docElm, x, y)=>Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom)
    ;
    const SugarElement = {
        fromHtml: fromHtml$2,
        fromTag,
        fromText,
        fromDom,
        fromPoint
    };
    typeof window !== 'undefined' || Function('return this;')();
    const DOCUMENT = 9;
    const DOCUMENT_FRAGMENT = 11;
    const ELEMENT = 1;
    const TEXT = 3;
    const name$3 = (element)=>{
        const r = element.dom.nodeName;
        return r.toLowerCase();
    };
    const type$1 = (element)=>element.dom.nodeType
    ;
    const isType = (t)=>(element)=>type$1(element) === t
    ;
    const isElement$1 = isType(ELEMENT);
    const isText = isType(TEXT);
    const isDocument = isType(DOCUMENT);
    const isDocumentFragment = isType(DOCUMENT_FRAGMENT);
    const isTag = (tag)=>(e)=>isElement$1(e) && name$3(e) === tag
    ;
    const is1 = (element, selector)=>{
        const dom = element.dom;
        if (dom.nodeType !== ELEMENT) return false;
        else {
            const elem = dom;
            if (elem.matches !== undefined) return elem.matches(selector);
            else if (elem.msMatchesSelector !== undefined) return elem.msMatchesSelector(selector);
            else if (elem.webkitMatchesSelector !== undefined) return elem.webkitMatchesSelector(selector);
            else if (elem.mozMatchesSelector !== undefined) return elem.mozMatchesSelector(selector);
            else throw new Error('Browser lacks native selectors');
        }
    };
    const bypassSelector = (dom)=>dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0
    ;
    const all$3 = (selector, scope)=>{
        const base = scope === undefined ? document : scope.dom;
        return bypassSelector(base) ? [] : map$2(base.querySelectorAll(selector), SugarElement.fromDom);
    };
    const one = (selector, scope)=>{
        const base = scope === undefined ? document : scope.dom;
        return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);
    };
    const eq = (e1, e2)=>e1.dom === e2.dom
    ;
    const contains = (e1, e2)=>{
        const d1 = e1.dom;
        const d2 = e2.dom;
        return d1 === d2 ? false : d1.contains(d2);
    };
    const owner$4 = (element)=>SugarElement.fromDom(element.dom.ownerDocument)
    ;
    const documentOrOwner = (dos)=>isDocument(dos) ? dos : owner$4(dos)
    ;
    const documentElement = (element)=>SugarElement.fromDom(documentOrOwner(element).dom.documentElement)
    ;
    const defaultView = (element)=>SugarElement.fromDom(documentOrOwner(element).dom.defaultView)
    ;
    const parent1 = (element)=>Optional.from(element.dom.parentNode).map(SugarElement.fromDom)
    ;
    const parentElement = (element)=>Optional.from(element.dom.parentElement).map(SugarElement.fromDom)
    ;
    const offsetParent = (element)=>Optional.from(element.dom.offsetParent).map(SugarElement.fromDom)
    ;
    const nextSibling = (element)=>Optional.from(element.dom.nextSibling).map(SugarElement.fromDom)
    ;
    const children1 = (element)=>map$2(element.dom.childNodes, SugarElement.fromDom)
    ;
    const child$2 = (element, index)=>{
        const cs = element.dom.childNodes;
        return Optional.from(cs[index]).map(SugarElement.fromDom);
    };
    const firstChild = (element)=>child$2(element, 0)
    ;
    const spot = (element, offset)=>({
            element,
            offset
        })
    ;
    const leaf = (element, offset)=>{
        const cs = children1(element);
        return cs.length > 0 && offset < cs.length ? spot(cs[offset], 0) : spot(element, offset);
    };
    const isShadowRoot = (dos)=>isDocumentFragment(dos) && isNonNullable(dos.dom.host)
    ;
    const supported1 = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);
    const isSupported = constant$1(supported1);
    const getRootNode = supported1 ? (e)=>SugarElement.fromDom(e.dom.getRootNode())
     : documentOrOwner;
    const getContentContainer = (dos)=>isShadowRoot(dos) ? dos : SugarElement.fromDom(documentOrOwner(dos).dom.body)
    ;
    const isInShadowRoot = (e)=>getShadowRoot(e).isSome()
    ;
    const getShadowRoot = (e)=>{
        const r = getRootNode(e);
        return isShadowRoot(r) ? Optional.some(r) : Optional.none();
    };
    const getShadowHost = (e)=>SugarElement.fromDom(e.dom.host)
    ;
    const getOriginalEventTarget = (event)=>{
        if (isSupported() && isNonNullable(event.target)) {
            const el = SugarElement.fromDom(event.target);
            if (isElement$1(el) && isOpenShadowHost(el)) {
                if (event.composed && event.composedPath) {
                    const composedPath = event.composedPath();
                    if (composedPath) return head(composedPath);
                }
            }
        }
        return Optional.from(event.target);
    };
    const isOpenShadowHost = (element)=>isNonNullable(element.dom.shadowRoot)
    ;
    const inBody = (element)=>{
        const dom = isText(element) ? element.dom.parentNode : element.dom;
        if (dom === undefined || dom === null || dom.ownerDocument === null) return false;
        const doc = dom.ownerDocument;
        return getShadowRoot(SugarElement.fromDom(dom)).fold(()=>doc.body.contains(dom)
        , compose1(inBody, getShadowHost));
    };
    const body1 = ()=>getBody(SugarElement.fromDom(document))
    ;
    const getBody = (doc)=>{
        const b = doc.dom.body;
        if (b === null || b === undefined) throw new Error('Body is not available yet');
        return SugarElement.fromDom(b);
    };
    const rawSet = (dom, key, value)=>{
        if (isString(value) || isBoolean(value) || isNumber(value)) dom.setAttribute(key, value + '');
        else {
            console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);
            throw new Error('Attribute value was not simple');
        }
    };
    const set$9 = (element, key, value)=>{
        rawSet(element.dom, key, value);
    };
    const setAll$1 = (element, attrs)=>{
        const dom = element.dom;
        each(attrs, (v, k)=>{
            rawSet(dom, k, v);
        });
    };
    const get$f = (element, key)=>{
        const v = element.dom.getAttribute(key);
        return v === null ? undefined : v;
    };
    const getOpt1 = (element, key)=>Optional.from(get$f(element, key))
    ;
    const has$1 = (element, key)=>{
        const dom = element.dom;
        return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;
    };
    const remove$7 = (element, key)=>{
        element.dom.removeAttribute(key);
    };
    const clone$1 = (element)=>foldl(element.dom.attributes, (acc, attr)=>{
            acc[attr.name] = attr.value;
            return acc;
        }, {})
    ;
    const internalSet = (dom, property, value)=>{
        if (!isString(value)) {
            console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);
            throw new Error('CSS value must be a string: ' + value);
        }
        if (isSupported$1(dom)) dom.style.setProperty(property, value);
    };
    const internalRemove = (dom, property)=>{
        if (isSupported$1(dom)) dom.style.removeProperty(property);
    };
    const set$8 = (element, property, value)=>{
        const dom = element.dom;
        internalSet(dom, property, value);
    };
    const setAll = (element, css)=>{
        const dom = element.dom;
        each(css, (v, k)=>{
            internalSet(dom, k, v);
        });
    };
    const setOptions = (element, css)=>{
        const dom = element.dom;
        each(css, (v, k)=>{
            v.fold(()=>{
                internalRemove(dom, k);
            }, (value)=>{
                internalSet(dom, k, value);
            });
        });
    };
    const get$e = (element, property)=>{
        const dom = element.dom;
        const styles = window.getComputedStyle(dom);
        const r = styles.getPropertyValue(property);
        return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;
    };
    const getUnsafeProperty = (dom, property)=>isSupported$1(dom) ? dom.style.getPropertyValue(property) : ''
    ;
    const getRaw = (element, property)=>{
        const dom = element.dom;
        const raw = getUnsafeProperty(dom, property);
        return Optional.from(raw).filter((r)=>r.length > 0
        );
    };
    const getAllRaw = (element)=>{
        const css = {};
        const dom = element.dom;
        if (isSupported$1(dom)) for(let i = 0; i < dom.style.length; i++){
            const ruleName = dom.style.item(i);
            css[ruleName] = dom.style[ruleName];
        }
        return css;
    };
    const isValidValue = (tag, property, value)=>{
        const element = SugarElement.fromTag(tag);
        set$8(element, property, value);
        const style = getRaw(element, property);
        return style.isSome();
    };
    const remove$6 = (element, property)=>{
        const dom = element.dom;
        internalRemove(dom, property);
        if (is$11(getOpt1(element, 'style').map(trim$1), '')) remove$7(element, 'style');
    };
    const reflow = (e)=>e.dom.offsetWidth
    ;
    const Dimension = (name, getOffset)=>{
        const set = (element, h)=>{
            if (!isNumber(h) && !h.match(/^[0-9]+$/)) throw new Error(name + '.set accepts only positive integer values. Value was ' + h);
            const dom = element.dom;
            if (isSupported$1(dom)) dom.style[name] = h + 'px';
        };
        const get = (element)=>{
            const r = getOffset(element);
            if (r <= 0 || r === null) {
                const css = get$e(element, name);
                return parseFloat(css) || 0;
            }
            return r;
        };
        const getOuter = get;
        const aggregate = (element, properties)=>foldl(properties, (acc, property)=>{
                const val = get$e(element, property);
                const value = val === undefined ? 0 : parseInt(val, 10);
                return isNaN(value) ? acc : acc + value;
            }, 0)
        ;
        const max = (element, value, properties)=>{
            const cumulativeInclusions = aggregate(element, properties);
            const absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;
            return absoluteMax;
        };
        return {
            set,
            get,
            getOuter,
            aggregate,
            max
        };
    };
    const api$2 = Dimension('height', (element)=>{
        const dom = element.dom;
        return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;
    });
    const get$d = (element)=>api$2.get(element)
    ;
    const getOuter$2 = (element)=>api$2.getOuter(element)
    ;
    const setMax$1 = (element, value)=>{
        const inclusions = [
            'margin-top',
            'border-top-width',
            'padding-top',
            'padding-bottom',
            'border-bottom-width',
            'margin-bottom'
        ];
        const absMax = api$2.max(element, value, inclusions);
        set$8(element, 'max-height', absMax + 'px');
    };
    const r$1 = (left, top)=>{
        const translate = (x, y)=>r$1(left + x, top + y)
        ;
        return {
            left,
            top,
            translate
        };
    };
    const SugarPosition = r$1;
    const boxPosition = (dom)=>{
        const box = dom.getBoundingClientRect();
        return SugarPosition(box.left, box.top);
    };
    const firstDefinedOrZero = (a, b)=>{
        if (a !== undefined) return a;
        else return b !== undefined ? b : 0;
    };
    const absolute$3 = (element)=>{
        const doc = element.dom.ownerDocument;
        const body = doc.body;
        const win = doc.defaultView;
        const html = doc.documentElement;
        if (body === element.dom) return SugarPosition(body.offsetLeft, body.offsetTop);
        const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);
        const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);
        const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);
        const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);
        return viewport$1(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);
    };
    const viewport$1 = (element)=>{
        const dom = element.dom;
        const doc = dom.ownerDocument;
        const body = doc.body;
        if (body === dom) return SugarPosition(body.offsetLeft, body.offsetTop);
        if (!inBody(element)) return SugarPosition(0, 0);
        return boxPosition(dom);
    };
    const api$1 = Dimension('width', (element)=>element.dom.offsetWidth
    );
    const set$7 = (element, h)=>api$1.set(element, h)
    ;
    const get$c = (element)=>api$1.get(element)
    ;
    const getOuter$1 = (element)=>api$1.getOuter(element)
    ;
    const setMax = (element, value)=>{
        const inclusions = [
            'margin-left',
            'border-left-width',
            'padding-left',
            'padding-right',
            'border-right-width',
            'margin-right'
        ];
        const absMax = api$1.max(element, value, inclusions);
        set$8(element, 'max-width', absMax + 'px');
    };
    const cached = (f)=>{
        let called = false;
        let r;
        return (...args)=>{
            if (!called) {
                called = true;
                r = f.apply(null, args);
            }
            return r;
        };
    };
    const DeviceType = (os, browser, userAgent, mediaMatch)=>{
        const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;
        const isiPhone = os.isiOS() && !isiPad;
        const isMobile = os.isiOS() || os.isAndroid();
        const isTouch = isMobile || mediaMatch('(pointer:coarse)');
        const isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');
        const isPhone = isiPhone || isMobile && !isTablet;
        const iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;
        const isDesktop = !isPhone && !isTablet && !iOSwebview;
        return {
            isiPad: constant$1(isiPad),
            isiPhone: constant$1(isiPhone),
            isTablet: constant$1(isTablet),
            isPhone: constant$1(isPhone),
            isTouch: constant$1(isTouch),
            isAndroid: os.isAndroid,
            isiOS: os.isiOS,
            isWebView: constant$1(iOSwebview),
            isDesktop: constant$1(isDesktop)
        };
    };
    const firstMatch = (regexes, s)=>{
        for(let i = 0; i < regexes.length; i++){
            const x = regexes[i];
            if (x.test(s)) return x;
        }
        return undefined;
    };
    const find$3 = (regexes, agent)=>{
        const r = firstMatch(regexes, agent);
        if (!r) return {
            major: 0,
            minor: 0
        };
        const group = (i)=>{
            return Number(agent.replace(r, '$' + i));
        };
        return nu$d(group(1), group(2));
    };
    const detect$4 = (versionRegexes, agent)=>{
        const cleanedAgent = String(agent).toLowerCase();
        if (versionRegexes.length === 0) return unknown$3();
        return find$3(versionRegexes, cleanedAgent);
    };
    const unknown$3 = ()=>{
        return nu$d(0, 0);
    };
    const nu$d = (major, minor)=>{
        return {
            major,
            minor
        };
    };
    const Version = {
        nu: nu$d,
        detect: detect$4,
        unknown: unknown$3
    };
    const detectBrowser$1 = (browsers, userAgentData)=>{
        return findMap(userAgentData.brands, (uaBrand)=>{
            const lcBrand = uaBrand.brand.toLowerCase();
            return find$5(browsers, (browser)=>{
                var _a;
                return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());
            }).map((info)=>({
                    current: info.name,
                    version: Version.nu(parseInt(uaBrand.version, 10), 0)
                })
            );
        });
    };
    const detect$3 = (candidates, userAgent)=>{
        const agent = String(userAgent).toLowerCase();
        return find$5(candidates, (candidate)=>{
            return candidate.search(agent);
        });
    };
    const detectBrowser = (browsers, userAgent)=>{
        return detect$3(browsers, userAgent).map((browser)=>{
            const version = Version.detect(browser.versionRegexes, userAgent);
            return {
                current: browser.name,
                version
            };
        });
    };
    const detectOs = (oses, userAgent)=>{
        return detect$3(oses, userAgent).map((os)=>{
            const version = Version.detect(os.versionRegexes, userAgent);
            return {
                current: os.name,
                version
            };
        });
    };
    const normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
    const checkContains = (target)=>{
        return (uastring)=>{
            return contains$1(uastring, target);
        };
    };
    const browsers1 = [
        {
            name: 'Edge',
            versionRegexes: [
                /.*?edge\/ ?([0-9]+)\.([0-9]+)$/
            ],
            search: (uastring)=>{
                return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');
            }
        },
        {
            name: 'Chromium',
            brand: 'Chromium',
            versionRegexes: [
                /.*?chrome\/([0-9]+)\.([0-9]+).*/,
                normalVersionRegex
            ],
            search: (uastring)=>{
                return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');
            }
        },
        {
            name: 'IE',
            versionRegexes: [
                /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
                /.*?rv:([0-9]+)\.([0-9]+).*/
            ],
            search: (uastring)=>{
                return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');
            }
        },
        {
            name: 'Opera',
            versionRegexes: [
                normalVersionRegex,
                /.*?opera\/([0-9]+)\.([0-9]+).*/
            ],
            search: checkContains('opera')
        },
        {
            name: 'Firefox',
            versionRegexes: [
                /.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/
            ],
            search: checkContains('firefox')
        },
        {
            name: 'Safari',
            versionRegexes: [
                normalVersionRegex,
                /.*?cpu os ([0-9]+)_([0-9]+).*/
            ],
            search: (uastring)=>{
                return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');
            }
        }
    ];
    const oses1 = [
        {
            name: 'Windows',
            search: checkContains('win'),
            versionRegexes: [
                /.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/
            ]
        },
        {
            name: 'iOS',
            search: (uastring)=>{
                return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');
            },
            versionRegexes: [
                /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
                /.*cpu os ([0-9]+)_([0-9]+).*/,
                /.*cpu iphone os ([0-9]+)_([0-9]+).*/
            ]
        },
        {
            name: 'Android',
            search: checkContains('android'),
            versionRegexes: [
                /.*?android\ ?([0-9]+)\.([0-9]+).*/
            ]
        },
        {
            name: 'macOS',
            search: checkContains('mac os x'),
            versionRegexes: [
                /.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/
            ]
        },
        {
            name: 'Linux',
            search: checkContains('linux'),
            versionRegexes: []
        },
        {
            name: 'Solaris',
            search: checkContains('sunos'),
            versionRegexes: []
        },
        {
            name: 'FreeBSD',
            search: checkContains('freebsd'),
            versionRegexes: []
        },
        {
            name: 'ChromeOS',
            search: checkContains('cros'),
            versionRegexes: [
                /.*?chrome\/([0-9]+)\.([0-9]+).*/
            ]
        }
    ];
    const PlatformInfo = {
        browsers: constant$1(browsers1),
        oses: constant$1(oses1)
    };
    const edge1 = 'Edge';
    const chromium = 'Chromium';
    const ie = 'IE';
    const opera = 'Opera';
    const firefox = 'Firefox';
    const safari = 'Safari';
    const unknown$2 = ()=>{
        return nu$c({
            current: undefined,
            version: Version.unknown()
        });
    };
    const nu$c = (info)=>{
        const current = info.current;
        const version = info.version;
        const isBrowser = (name)=>()=>current === name
        ;
        return {
            current,
            version,
            isEdge: isBrowser(edge1),
            isChromium: isBrowser(chromium),
            isIE: isBrowser(ie),
            isOpera: isBrowser(opera),
            isFirefox: isBrowser(firefox),
            isSafari: isBrowser(safari)
        };
    };
    const Browser = {
        unknown: unknown$2,
        nu: nu$c,
        edge: constant$1(edge1),
        chromium: constant$1(chromium),
        ie: constant$1(ie),
        opera: constant$1(opera),
        firefox: constant$1(firefox),
        safari: constant$1(safari)
    };
    const windows = 'Windows';
    const ios = 'iOS';
    const android = 'Android';
    const linux = 'Linux';
    const macos = 'macOS';
    const solaris = 'Solaris';
    const freebsd = 'FreeBSD';
    const chromeos = 'ChromeOS';
    const unknown$1 = ()=>{
        return nu$b({
            current: undefined,
            version: Version.unknown()
        });
    };
    const nu$b = (info)=>{
        const current = info.current;
        const version = info.version;
        const isOS = (name)=>()=>current === name
        ;
        return {
            current,
            version,
            isWindows: isOS(windows),
            isiOS: isOS(ios),
            isAndroid: isOS(android),
            isMacOS: isOS(macos),
            isLinux: isOS(linux),
            isSolaris: isOS(solaris),
            isFreeBSD: isOS(freebsd),
            isChromeOS: isOS(chromeos)
        };
    };
    const OperatingSystem = {
        unknown: unknown$1,
        nu: nu$b,
        windows: constant$1(windows),
        ios: constant$1(ios),
        android: constant$1(android),
        linux: constant$1(linux),
        macos: constant$1(macos),
        solaris: constant$1(solaris),
        freebsd: constant$1(freebsd),
        chromeos: constant$1(chromeos)
    };
    const detect$2 = (userAgent, userAgentDataOpt, mediaMatch)=>{
        const browsers = PlatformInfo.browsers();
        const oses = PlatformInfo.oses();
        const browser = userAgentDataOpt.bind((userAgentData)=>detectBrowser$1(browsers, userAgentData)
        ).orThunk(()=>detectBrowser(browsers, userAgent)
        ).fold(Browser.unknown, Browser.nu);
        const os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);
        const deviceType = DeviceType(os, browser, userAgent, mediaMatch);
        return {
            browser,
            os,
            deviceType
        };
    };
    const PlatformDetection = {
        detect: detect$2
    };
    const mediaMatch1 = (query)=>window.matchMedia(query).matches
    ;
    let platform1 = cached(()=>PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch1)
    );
    const detect$1 = ()=>platform1()
    ;
    const mkEvent = (target, x, y, stop, prevent, kill, raw)=>({
            target,
            x,
            y,
            stop,
            prevent,
            kill,
            raw
        })
    ;
    const fromRawEvent$1 = (rawEvent)=>{
        const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));
        const stop = ()=>rawEvent.stopPropagation()
        ;
        const prevent = ()=>rawEvent.preventDefault()
        ;
        const kill = compose(prevent, stop);
        return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);
    };
    const handle1 = (filter, handler)=>(rawEvent)=>{
            if (filter(rawEvent)) handler(fromRawEvent$1(rawEvent));
        }
    ;
    const binder1 = (element, event, filter, handler, useCapture)=>{
        const wrapped = handle1(filter, handler);
        element.dom.addEventListener(event, wrapped, useCapture);
        return {
            unbind: curry(unbind1, element, event, wrapped, useCapture)
        };
    };
    const bind$2 = (element, event, filter, handler)=>binder1(element, event, filter, handler, false)
    ;
    const capture$1 = (element, event, filter, handler)=>binder1(element, event, filter, handler, true)
    ;
    const unbind1 = (element, event, handler, useCapture)=>{
        element.dom.removeEventListener(event, handler, useCapture);
    };
    const before$1 = (marker, element)=>{
        const parent$1 = parent1(marker);
        parent$1.each((v)=>{
            v.dom.insertBefore(element.dom, marker.dom);
        });
    };
    const after$2 = (marker, element)=>{
        const sibling = nextSibling(marker);
        sibling.fold(()=>{
            const parent$1 = parent1(marker);
            parent$1.each((v)=>{
                append$2(v, element);
            });
        }, (v)=>{
            before$1(v, element);
        });
    };
    const prepend$1 = (parent, element)=>{
        const firstChild$1 = firstChild(parent);
        firstChild$1.fold(()=>{
            append$2(parent, element);
        }, (v)=>{
            parent.dom.insertBefore(element.dom, v.dom);
        });
    };
    const append$2 = (parent, element)=>{
        parent.dom.appendChild(element.dom);
    };
    const appendAt = (parent, element, index)=>{
        child$2(parent, index).fold(()=>{
            append$2(parent, element);
        }, (v)=>{
            before$1(v, element);
        });
    };
    const append$1 = (parent, elements)=>{
        each$1(elements, (x)=>{
            append$2(parent, x);
        });
    };
    const empty = (element)=>{
        element.dom.textContent = '';
        each$1(children1(element), (rogue)=>{
            remove$5(rogue);
        });
    };
    const remove$5 = (element)=>{
        const dom = element.dom;
        if (dom.parentNode !== null) dom.parentNode.removeChild(dom);
    };
    const get$b = (_DOC)=>{
        const doc = _DOC !== undefined ? _DOC.dom : document;
        const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;
        const y = doc.body.scrollTop || doc.documentElement.scrollTop;
        return SugarPosition(x, y);
    };
    const to = (x, y, _DOC)=>{
        const doc = _DOC !== undefined ? _DOC.dom : document;
        const win = doc.defaultView;
        if (win) win.scrollTo(x, y);
    };
    const get$a = (_win)=>{
        const win = _win === undefined ? window : _win;
        if (detect$1().browser.isFirefox()) return Optional.none();
        else return Optional.from(win.visualViewport);
    };
    const bounds$11 = (x, y, width, height)=>({
            x,
            y,
            width,
            height,
            right: x + width,
            bottom: y + height
        })
    ;
    const getBounds$3 = (_win)=>{
        const win = _win === undefined ? window : _win;
        const doc = win.document;
        const scroll = get$b(SugarElement.fromDom(doc));
        return get$a(win).fold(()=>{
            const html = win.document.documentElement;
            const width = html.clientWidth;
            const height = html.clientHeight;
            return bounds$11(scroll.left, scroll.top, width, height);
        }, (visualViewport)=>bounds$11(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height)
        );
    };
    const getDocument = ()=>SugarElement.fromDom(document)
    ;
    const walkUp = (navigation, doc)=>{
        const frame = navigation.view(doc);
        return frame.fold(constant$1([]), (f)=>{
            const parent = navigation.owner(f);
            const rest = walkUp(navigation, parent);
            return [
                f
            ].concat(rest);
        });
    };
    const pathTo = (element, navigation)=>{
        const d = navigation.owner(element);
        const paths = walkUp(navigation, d);
        return Optional.some(paths);
    };
    const view = (doc)=>{
        var _a;
        const element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);
        return element.map(SugarElement.fromDom);
    };
    const owner$3 = (element)=>owner$4(element)
    ;
    var Navigation = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        view: view,
        owner: owner$3
    });
    const find$2 = (element)=>{
        const doc = getDocument();
        const scroll = get$b(doc);
        const path = pathTo(element, Navigation);
        return path.fold(curry(absolute$3, element), (frames)=>{
            const offset = viewport$1(element);
            const r = foldr(frames, (b, a)=>{
                const loc = viewport$1(a);
                return {
                    left: b.left + loc.left,
                    top: b.top + loc.top
                };
            }, {
                left: 0,
                top: 0
            });
            return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);
        });
    };
    const pointed = (point, width, height)=>({
            point,
            width,
            height
        })
    ;
    const rect1 = (x, y, width, height)=>({
            x,
            y,
            width,
            height
        })
    ;
    const bounds1 = (x, y, width, height)=>({
            x,
            y,
            width,
            height,
            right: x + width,
            bottom: y + height
        })
    ;
    const box$1 = (element)=>{
        const xy = absolute$3(element);
        const w = getOuter$1(element);
        const h = getOuter$2(element);
        return bounds1(xy.left, xy.top, w, h);
    };
    const absolute$2 = (element)=>{
        const position = find$2(element);
        const width = getOuter$1(element);
        const height = getOuter$2(element);
        return bounds1(position.left, position.top, width, height);
    };
    const win1 = ()=>getBounds$3(window)
    ;
    const value$4 = (value)=>{
        const applyHelper = (fn)=>fn(value)
        ;
        const constHelper = constant$1(value);
        const outputHelper = ()=>output
        ;
        const output = {
            tag: true,
            inner: value,
            fold: (_onError, onValue)=>onValue(value)
            ,
            isValue: always,
            isError: never,
            map: (mapper)=>Result.value(mapper(value))
            ,
            mapError: outputHelper,
            bind: applyHelper,
            exists: applyHelper,
            forall: applyHelper,
            getOr: constHelper,
            or: outputHelper,
            getOrThunk: constHelper,
            orThunk: outputHelper,
            getOrDie: constHelper,
            each: (fn)=>{
                fn(value);
            },
            toOptional: ()=>Optional.some(value)
        };
        return output;
    };
    const error$1 = (error)=>{
        const outputHelper = ()=>output
        ;
        const output = {
            tag: false,
            inner: error,
            fold: (onError, _onValue)=>onError(error)
            ,
            isValue: never,
            isError: always,
            map: outputHelper,
            mapError: (mapper)=>Result.error(mapper(error))
            ,
            bind: outputHelper,
            exists: never,
            forall: always,
            getOr: identity,
            or: identity,
            getOrThunk: apply,
            orThunk: apply,
            getOrDie: die(String(error)),
            each: noop,
            toOptional: Optional.none
        };
        return output;
    };
    const fromOption = (optional, err)=>optional.fold(()=>error$1(err)
        , value$4)
    ;
    const Result = {
        value: value$4,
        error: error$1,
        fromOption
    };
    var SimpleResultType1;
    (function(SimpleResultType) {
        SimpleResultType[SimpleResultType['Error'] = 0] = 'Error';
        SimpleResultType[SimpleResultType['Value'] = 1] = 'Value';
    })(SimpleResultType1 || (SimpleResultType1 = {}));
    const fold$1 = (res, onError, onValue)=>res.stype === SimpleResultType1.Error ? onError(res.serror) : onValue(res.svalue)
    ;
    const partition$2 = (results)=>{
        const values = [];
        const errors = [];
        each$1(results, (obj)=>{
            fold$1(obj, (err)=>errors.push(err)
            , (val)=>values.push(val)
            );
        });
        return {
            values,
            errors
        };
    };
    const mapError1 = (res, f)=>{
        if (res.stype === SimpleResultType1.Error) return {
            stype: SimpleResultType1.Error,
            serror: f(res.serror)
        };
        else return res;
    };
    const map1 = (res, f)=>{
        if (res.stype === SimpleResultType1.Value) return {
            stype: SimpleResultType1.Value,
            svalue: f(res.svalue)
        };
        else return res;
    };
    const bind$1 = (res, f)=>{
        if (res.stype === SimpleResultType1.Value) return f(res.svalue);
        else return res;
    };
    const bindError = (res, f)=>{
        if (res.stype === SimpleResultType1.Error) return f(res.serror);
        else return res;
    };
    const svalue = (v)=>({
            stype: SimpleResultType1.Value,
            svalue: v
        })
    ;
    const serror = (e)=>({
            stype: SimpleResultType1.Error,
            serror: e
        })
    ;
    const toResult$1 = (res)=>fold$1(res, Result.error, Result.value)
    ;
    const fromResult$1 = (res)=>res.fold(serror, svalue)
    ;
    const SimpleResult = {
        fromResult: fromResult$1,
        toResult: toResult$1,
        svalue,
        partition: partition$2,
        serror,
        bind: bind$1,
        bindError,
        map: map1,
        mapError: mapError1,
        fold: fold$1
    };
    const field$2 = (key, newKey, presence, prop)=>({
            tag: 'field',
            key,
            newKey,
            presence,
            prop
        })
    ;
    const customField$1 = (newKey, instantiator)=>({
            tag: 'custom',
            newKey,
            instantiator
        })
    ;
    const fold = (value, ifField, ifCustom)=>{
        switch(value.tag){
            case 'field':
                return ifField(value.key, value.newKey, value.presence, value.prop);
            case 'custom':
                return ifCustom(value.newKey, value.instantiator);
        }
    };
    const shallow$1 = (old, nu)=>{
        return nu;
    };
    const deep = (old, nu)=>{
        const bothObjects = isPlainObject(old) && isPlainObject(nu);
        return bothObjects ? deepMerge(old, nu) : nu;
    };
    const baseMerge = (merger)=>{
        return (...objects)=>{
            if (objects.length === 0) throw new Error(`Can't merge zero objects`);
            const ret = {};
            for(let j = 0; j < objects.length; j++){
                const curObject = objects[j];
                for(const key in curObject)if (has$2(curObject, key)) ret[key] = merger(ret[key], curObject[key]);
            }
            return ret;
        };
    };
    const deepMerge = baseMerge(deep);
    const merge$1 = baseMerge(shallow$1);
    const required$2 = ()=>({
            tag: 'required',
            process: {}
        })
    ;
    const defaultedThunk = (fallbackThunk)=>({
            tag: 'defaultedThunk',
            process: fallbackThunk
        })
    ;
    const defaulted$1 = (fallback)=>defaultedThunk(constant$1(fallback))
    ;
    const asOption = ()=>({
            tag: 'option',
            process: {}
        })
    ;
    const mergeWithThunk = (baseThunk)=>({
            tag: 'mergeWithThunk',
            process: baseThunk
        })
    ;
    const mergeWith = (base)=>mergeWithThunk(constant$1(base))
    ;
    const mergeValues$1 = (values, base)=>values.length > 0 ? SimpleResult.svalue(deepMerge(base, merge$1.apply(undefined, values))) : SimpleResult.svalue(base)
    ;
    const mergeErrors$1 = (errors)=>compose(SimpleResult.serror, flatten1)(errors)
    ;
    const consolidateObj = (objects, base)=>{
        const partition = SimpleResult.partition(objects);
        return partition.errors.length > 0 ? mergeErrors$1(partition.errors) : mergeValues$1(partition.values, base);
    };
    const consolidateArr = (objects)=>{
        const partitions = SimpleResult.partition(objects);
        return partitions.errors.length > 0 ? mergeErrors$1(partitions.errors) : SimpleResult.svalue(partitions.values);
    };
    const ResultCombine = {
        consolidateObj,
        consolidateArr
    };
    const formatObj = (input)=>{
        return isObject(input) && keys1(input).length > 100 ? ' removed due to size' : JSON.stringify(input, null, 2);
    };
    const formatErrors = (errors)=>{
        const es = errors.length > 10 ? errors.slice(0, 10).concat([
            {
                path: [],
                getErrorInfo: constant$1('... (only showing first ten failures)')
            }
        ]) : errors;
        return map$2(es, (e)=>{
            return 'Failed path: (' + e.path.join(' > ') + ')\n' + e.getErrorInfo();
        });
    };
    const nu$a = (path, getErrorInfo)=>{
        return SimpleResult.serror([
            {
                path,
                getErrorInfo
            }
        ]);
    };
    const missingRequired = (path, key, obj)=>nu$a(path, ()=>'Could not find valid *required* value for "' + key + '" in ' + formatObj(obj)
        )
    ;
    const missingKey = (path, key)=>nu$a(path, ()=>'Choice schema did not contain choice key: "' + key + '"'
        )
    ;
    const missingBranch = (path, branches, branch)=>nu$a(path, ()=>'The chosen schema: "' + branch + '" did not exist in branches: ' + formatObj(branches)
        )
    ;
    const unsupportedFields = (path, unsupported)=>nu$a(path, ()=>'There are unsupported fields: [' + unsupported.join(', ') + '] specified'
        )
    ;
    const custom1 = (path, err)=>nu$a(path, constant$1(err))
    ;
    const value$3 = (validator)=>{
        const extract = (path, val)=>{
            return SimpleResult.bindError(validator(val), (err)=>custom1(path, err)
            );
        };
        const toString = constant$1('val');
        return {
            extract,
            toString
        };
    };
    const anyValue$1 = value$3(SimpleResult.svalue);
    const requiredAccess = (path, obj, key, bundle)=>get$g(obj, key).fold(()=>missingRequired(path, key, obj)
        , bundle)
    ;
    const fallbackAccess = (obj, key, fallback, bundle)=>{
        const v = get$g(obj, key).getOrThunk(()=>fallback(obj)
        );
        return bundle(v);
    };
    const optionAccess = (obj, key, bundle)=>bundle(get$g(obj, key))
    ;
    const optionDefaultedAccess = (obj, key, fallback, bundle)=>{
        const opt = get$g(obj, key).map((val)=>val === true ? fallback(obj) : val
        );
        return bundle(opt);
    };
    const extractField = (field, path, obj, key, prop)=>{
        const bundle = (av)=>prop.extract(path.concat([
                key
            ]), av)
        ;
        const bundleAsOption = (optValue)=>optValue.fold(()=>SimpleResult.svalue(Optional.none())
            , (ov)=>{
                const result = prop.extract(path.concat([
                    key
                ]), ov);
                return SimpleResult.map(result, Optional.some);
            })
        ;
        switch(field.tag){
            case 'required':
                return requiredAccess(path, obj, key, bundle);
            case 'defaultedThunk':
                return fallbackAccess(obj, key, field.process, bundle);
            case 'option':
                return optionAccess(obj, key, bundleAsOption);
            case 'defaultedOptionThunk':
                return optionDefaultedAccess(obj, key, field.process, bundleAsOption);
            case 'mergeWithThunk':
                return fallbackAccess(obj, key, constant$1({}), (v)=>{
                    const result = deepMerge(field.process(obj), v);
                    return bundle(result);
                });
        }
    };
    const extractFields = (path, obj, fields)=>{
        const success = {};
        const errors = [];
        for (const field of fields)fold(field, (key, newKey, presence, prop)=>{
            const result = extractField(presence, path, obj, key, prop);
            SimpleResult.fold(result, (err)=>{
                errors.push(...err);
            }, (res)=>{
                success[newKey] = res;
            });
        }, (newKey, instantiator)=>{
            success[newKey] = instantiator(obj);
        });
        return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);
    };
    const valueThunk1 = (getDelegate)=>{
        const extract = (path, val)=>getDelegate().extract(path, val)
        ;
        const toString = ()=>getDelegate().toString()
        ;
        return {
            extract,
            toString
        };
    };
    const getSetKeys = (obj)=>keys1(filter$1(obj, isNonNullable))
    ;
    const objOfOnly = (fields)=>{
        const delegate = objOf(fields);
        const fieldNames = foldr(fields, (acc, value)=>{
            return fold(value, (key)=>deepMerge(acc, {
                    [key]: true
                })
            , constant$1(acc));
        }, {});
        const extract = (path, o)=>{
            const keys = isBoolean(o) ? [] : getSetKeys(o);
            const extra = filter$2(keys, (k)=>!hasNonNullableKey(fieldNames, k)
            );
            return extra.length === 0 ? delegate.extract(path, o) : unsupportedFields(path, extra);
        };
        return {
            extract,
            toString: delegate.toString
        };
    };
    const objOf = (values)=>{
        const extract = (path, o)=>extractFields(path, o, values)
        ;
        const toString = ()=>{
            const fieldStrings = map$2(values, (value)=>fold(value, (key, _okey, _presence, prop)=>key + ' -> ' + prop.toString()
                , (newKey, _instantiator)=>'state(' + newKey + ')'
                )
            );
            return 'obj{\n' + fieldStrings.join('\n') + '}';
        };
        return {
            extract,
            toString
        };
    };
    const arrOf = (prop)=>{
        const extract = (path, array)=>{
            const results = map$2(array, (a, i)=>prop.extract(path.concat([
                    '[' + i + ']'
                ]), a)
            );
            return ResultCombine.consolidateArr(results);
        };
        const toString = ()=>'array(' + prop.toString() + ')'
        ;
        return {
            extract,
            toString
        };
    };
    const oneOf = (props)=>{
        const extract = (path, val)=>{
            const errors = [];
            for (const prop of props){
                const res = prop.extract(path, val);
                if (res.stype === SimpleResultType1.Value) return res;
                errors.push(res);
            }
            return ResultCombine.consolidateArr(errors);
        };
        const toString = ()=>'oneOf(' + map$2(props, (prop)=>prop.toString()
            ).join(', ') + ')'
        ;
        return {
            extract,
            toString
        };
    };
    const setOf$1 = (validator, prop)=>{
        const validateKeys = (path, keys)=>arrOf(value$3(validator)).extract(path, keys)
        ;
        const extract = (path, o)=>{
            const keys$1 = keys1(o);
            const validatedKeys = validateKeys(path, keys$1);
            return SimpleResult.bind(validatedKeys, (validKeys)=>{
                const schema = map$2(validKeys, (vk)=>{
                    return field$2(vk, vk, required$2(), prop);
                });
                return objOf(schema).extract(path, o);
            });
        };
        const toString = ()=>'setOf(' + prop.toString() + ')'
        ;
        return {
            extract,
            toString
        };
    };
    const thunk1 = (_desc, processor)=>{
        const getP = cached(processor);
        const extract = (path, val)=>getP().extract(path, val)
        ;
        const toString = ()=>getP().toString()
        ;
        return {
            extract,
            toString
        };
    };
    const arrOfObj = compose(arrOf, objOf);
    const anyValue = constant$1(anyValue$1);
    const typedValue = (validator, expectedType)=>value$3((a)=>{
            const actualType = typeof a;
            return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror(`Expected type: ${expectedType} but got: ${actualType}`);
        })
    ;
    const number1 = typedValue(isNumber, 'number');
    const string = typedValue(isString, 'string');
    const boolean = typedValue(isBoolean, 'boolean');
    const functionProcessor = typedValue(isFunction, 'function');
    const isPostMessageable = (val)=>{
        if (Object(val) !== val) return true;
        switch(({}).toString.call(val).slice(8, -1)){
            case 'Boolean':
            case 'Number':
            case 'String':
            case 'Date':
            case 'RegExp':
            case 'Blob':
            case 'FileList':
            case 'ImageData':
            case 'ImageBitmap':
            case 'ArrayBuffer':
                return true;
            case 'Array':
            case 'Object':
                return Object.keys(val).every((prop)=>isPostMessageable(val[prop])
                );
            default:
                return false;
        }
    };
    const postMessageable = value$3((a)=>{
        if (isPostMessageable(a)) return SimpleResult.svalue(a);
        else return SimpleResult.serror('Expected value to be acceptable for sending via postMessage');
    });
    const chooseFrom = (path, input, branches, ch)=>{
        const fields = get$g(branches, ch);
        return fields.fold(()=>missingBranch(path, branches, ch)
        , (vp)=>vp.extract(path.concat([
                'branch: ' + ch
            ]), input)
        );
    };
    const choose$2 = (key, branches)=>{
        const extract = (path, input)=>{
            const choice = get$g(input, key);
            return choice.fold(()=>missingKey(path, key)
            , (chosen)=>chooseFrom(path, input, branches, chosen)
            );
        };
        const toString = ()=>'chooseOn(' + key + '). Possible values: ' + keys1(branches)
        ;
        return {
            extract,
            toString
        };
    };
    const arrOfVal = ()=>arrOf(anyValue$1)
    ;
    const valueOf = (validator)=>value$3((v)=>validator(v).fold(SimpleResult.serror, SimpleResult.svalue)
        )
    ;
    const setOf = (validator, prop)=>setOf$1((v)=>SimpleResult.fromResult(validator(v))
        , prop)
    ;
    const extractValue = (label, prop, obj)=>{
        const res = prop.extract([
            label
        ], obj);
        return SimpleResult.mapError(res, (errs)=>({
                input: obj,
                errors: errs
            })
        );
    };
    const asRaw = (label, prop, obj)=>SimpleResult.toResult(extractValue(label, prop, obj))
    ;
    const getOrDie = (extraction)=>{
        return extraction.fold((errInfo)=>{
            throw new Error(formatError(errInfo));
        }, identity);
    };
    const asRawOrDie$1 = (label, prop, obj)=>getOrDie(asRaw(label, prop, obj))
    ;
    const formatError = (errInfo)=>{
        return 'Errors: \n' + formatErrors(errInfo.errors).join('\n') + '\n\nInput object: ' + formatObj(errInfo.input);
    };
    const choose$1 = (key, branches)=>choose$2(key, map$1(branches, objOf))
    ;
    const thunkOf = (desc, schema)=>thunk1(desc, schema)
    ;
    const field$1 = field$2;
    const customField = customField$1;
    const validateEnum = (values)=>valueOf((value)=>contains$2(values, value) ? Result.value(value) : Result.error(`Unsupported value: "${value}", choose one of "${values.join(', ')}".`)
        )
    ;
    const required$1 = (key)=>field$1(key, key, required$2(), anyValue())
    ;
    const requiredOf = (key, schema)=>field$1(key, key, required$2(), schema)
    ;
    const requiredNumber = (key)=>requiredOf(key, number1)
    ;
    const requiredString = (key)=>requiredOf(key, string)
    ;
    const requiredStringEnum = (key, values)=>field$1(key, key, required$2(), validateEnum(values))
    ;
    const requiredBoolean = (key)=>requiredOf(key, boolean)
    ;
    const requiredFunction = (key)=>requiredOf(key, functionProcessor)
    ;
    const forbid = (key, message)=>field$1(key, key, asOption(), value$3((_v)=>SimpleResult.serror('The field: ' + key + ' is forbidden. ' + message)
        ))
    ;
    const requiredObjOf = (key, objSchema)=>field$1(key, key, required$2(), objOf(objSchema))
    ;
    const requiredArrayOfObj = (key, objFields)=>field$1(key, key, required$2(), arrOfObj(objFields))
    ;
    const requiredArrayOf = (key, schema)=>field$1(key, key, required$2(), arrOf(schema))
    ;
    const option$3 = (key)=>field$1(key, key, asOption(), anyValue())
    ;
    const optionOf = (key, schema)=>field$1(key, key, asOption(), schema)
    ;
    const optionNumber = (key)=>optionOf(key, number1)
    ;
    const optionString = (key)=>optionOf(key, string)
    ;
    const optionStringEnum = (key, values)=>optionOf(key, validateEnum(values))
    ;
    const optionFunction = (key)=>optionOf(key, functionProcessor)
    ;
    const optionArrayOf = (key, schema)=>optionOf(key, arrOf(schema))
    ;
    const optionObjOf = (key, objSchema)=>optionOf(key, objOf(objSchema))
    ;
    const optionObjOfOnly = (key, objSchema)=>optionOf(key, objOfOnly(objSchema))
    ;
    const defaulted = (key, fallback)=>field$1(key, key, defaulted$1(fallback), anyValue())
    ;
    const defaultedOf = (key, fallback, schema)=>field$1(key, key, defaulted$1(fallback), schema)
    ;
    const defaultedNumber = (key, fallback)=>defaultedOf(key, fallback, number1)
    ;
    const defaultedString = (key, fallback)=>defaultedOf(key, fallback, string)
    ;
    const defaultedStringEnum = (key, fallback, values)=>defaultedOf(key, fallback, validateEnum(values))
    ;
    const defaultedBoolean = (key, fallback)=>defaultedOf(key, fallback, boolean)
    ;
    const defaultedFunction = (key, fallback)=>defaultedOf(key, fallback, functionProcessor)
    ;
    const defaultedPostMsg = (key, fallback)=>defaultedOf(key, fallback, postMessageable)
    ;
    const defaultedArrayOf = (key, fallback, schema)=>defaultedOf(key, fallback, arrOf(schema))
    ;
    const defaultedObjOf = (key, fallback, objSchema)=>defaultedOf(key, fallback, objOf(objSchema))
    ;
    const Cell = (initial)=>{
        let value = initial;
        const get = ()=>{
            return value;
        };
        const set = (v)=>{
            value = v;
        };
        return {
            get,
            set
        };
    };
    const generate$7 = (cases)=>{
        if (!isArray(cases)) throw new Error('cases must be an array');
        if (cases.length === 0) throw new Error('there must be at least one case');
        const constructors = [];
        const adt = {};
        each$1(cases, (acase, count)=>{
            const keys$1 = keys1(acase);
            if (keys$1.length !== 1) throw new Error('one and only one name per case');
            const key = keys$1[0];
            const value = acase[key];
            if (adt[key] !== undefined) throw new Error('duplicate key detected:' + key);
            else if (key === 'cata') throw new Error('cannot have a case named cata (sorry)');
            else if (!isArray(value)) throw new Error('case arguments must be an array');
            constructors.push(key);
            adt[key] = (...args)=>{
                const argLength = args.length;
                if (argLength !== value.length) throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);
                const match = (branches)=>{
                    const branchKeys = keys1(branches);
                    if (constructors.length !== branchKeys.length) throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\nActual: ' + branchKeys.join(','));
                    const allReqd = forall(constructors, (reqKey)=>{
                        return contains$2(branchKeys, reqKey);
                    });
                    if (!allReqd) throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\nRequired: ' + constructors.join(', '));
                    return branches[key].apply(null, args);
                };
                return {
                    fold: (...foldArgs)=>{
                        if (foldArgs.length !== cases.length) throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);
                        const target = foldArgs[count];
                        return target.apply(null, args);
                    },
                    match,
                    log: (label)=>{
                        console.log(label, {
                            constructors,
                            constructor: key,
                            params: args
                        });
                    }
                };
            };
        });
        return adt;
    };
    const Adt = {
        generate: generate$7
    };
    Adt.generate([
        {
            bothErrors: [
                'error1',
                'error2'
            ]
        },
        {
            firstError: [
                'error1',
                'value2'
            ]
        },
        {
            secondError: [
                'value1',
                'error2'
            ]
        },
        {
            bothValues: [
                'value1',
                'value2'
            ]
        }
    ]);
    const partition$1 = (results)=>{
        const errors = [];
        const values = [];
        each$1(results, (result)=>{
            result.fold((err)=>{
                errors.push(err);
            }, (value)=>{
                values.push(value);
            });
        });
        return {
            errors,
            values
        };
    };
    const exclude$1 = (obj, fields)=>{
        const r = {};
        each(obj, (v, k)=>{
            if (!contains$2(fields, k)) r[k] = v;
        });
        return r;
    };
    const wrap$2 = (key, value)=>({
            [key]: value
        })
    ;
    const wrapAll$1 = (keyvalues)=>{
        const r = {};
        each$1(keyvalues, (kv)=>{
            r[kv.key] = kv.value;
        });
        return r;
    };
    const exclude = (obj, fields)=>exclude$1(obj, fields)
    ;
    const wrap$1 = (key, value)=>wrap$2(key, value)
    ;
    const wrapAll = (keyvalues)=>wrapAll$1(keyvalues)
    ;
    const mergeValues = (values, base)=>{
        return values.length === 0 ? Result.value(base) : Result.value(deepMerge(base, merge$1.apply(undefined, values)));
    };
    const mergeErrors = (errors)=>Result.error(flatten1(errors))
    ;
    const consolidate = (objs, base)=>{
        const partitions = partition$1(objs);
        return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : mergeValues(partitions.values, base);
    };
    const ensureIsRoot = (isRoot)=>isFunction(isRoot) ? isRoot : never
    ;
    const ancestor$2 = (scope, transform, isRoot)=>{
        let element = scope.dom;
        const stop = ensureIsRoot(isRoot);
        while(element.parentNode){
            element = element.parentNode;
            const el = SugarElement.fromDom(element);
            const transformed = transform(el);
            if (transformed.isSome()) return transformed;
            else if (stop(el)) break;
        }
        return Optional.none();
    };
    const closest$4 = (scope, transform, isRoot)=>{
        const current = transform(scope);
        const stop = ensureIsRoot(isRoot);
        return current.orThunk(()=>stop(scope) ? Optional.none() : ancestor$2(scope, transform, stop)
        );
    };
    const isSource = (component, simulatedEvent)=>eq(component.element, simulatedEvent.event.target)
    ;
    const defaultEventHandler = {
        can: always,
        abort: never,
        run: noop
    };
    const nu$9 = (parts)=>{
        if (!hasNonNullableKey(parts, 'can') && !hasNonNullableKey(parts, 'abort') && !hasNonNullableKey(parts, 'run')) throw new Error('EventHandler defined by: ' + JSON.stringify(parts, null, 2) + ' does not have can, abort, or run!');
        return {
            ...defaultEventHandler,
            ...parts
        };
    };
    const all$2 = (handlers, f)=>(...args)=>foldl(handlers, (acc, handler)=>acc && f(handler).apply(undefined, args)
            , true)
    ;
    const any = (handlers, f)=>(...args)=>foldl(handlers, (acc, handler)=>acc || f(handler).apply(undefined, args)
            , false)
    ;
    const read$2 = (handler)=>isFunction(handler) ? {
            can: always,
            abort: never,
            run: handler
        } : handler
    ;
    const fuse$1 = (handlers)=>{
        const can = all$2(handlers, (handler)=>handler.can
        );
        const abort = any(handlers, (handler)=>handler.abort
        );
        const run = (...args)=>{
            each$1(handlers, (handler)=>{
                handler.run.apply(undefined, args);
            });
        };
        return {
            can,
            abort,
            run
        };
    };
    const constant = constant$1;
    const touchstart = constant('touchstart');
    const touchmove = constant('touchmove');
    const touchend = constant('touchend');
    const touchcancel = constant('touchcancel');
    const mousedown = constant('mousedown');
    const mousemove = constant('mousemove');
    const mouseout = constant('mouseout');
    const mouseup = constant('mouseup');
    const mouseover = constant('mouseover');
    const focusin = constant('focusin');
    const focusout = constant('focusout');
    const keydown = constant('keydown');
    const keyup = constant('keyup');
    const input1 = constant('input');
    const change1 = constant('change');
    const click = constant('click');
    const transitioncancel = constant('transitioncancel');
    const transitionend = constant('transitionend');
    const transitionstart = constant('transitionstart');
    const selectstart = constant('selectstart');
    const prefixName = (name)=>constant$1('alloy.' + name)
    ;
    const alloy = {
        tap: prefixName('tap')
    };
    const focus$4 = prefixName('focus');
    const postBlur = prefixName('blur.post');
    const postPaste = prefixName('paste.post');
    const receive = prefixName('receive');
    const execute$5 = prefixName('execute');
    const focusItem = prefixName('focus.item');
    const tap = alloy.tap;
    const longpress = prefixName('longpress');
    const sandboxClose = prefixName('sandbox.close');
    const typeaheadCancel = prefixName('typeahead.cancel');
    const systemInit = prefixName('system.init');
    const documentTouchmove = prefixName('system.touchmove');
    const documentTouchend = prefixName('system.touchend');
    const windowScroll = prefixName('system.scroll');
    const windowResize = prefixName('system.resize');
    const attachedToDom = prefixName('system.attached');
    const detachedFromDom = prefixName('system.detached');
    const dismissRequested = prefixName('system.dismissRequested');
    const repositionRequested = prefixName('system.repositionRequested');
    const focusShifted = prefixName('focusmanager.shifted');
    const slotVisibility = prefixName('slotcontainer.visibility');
    const changeTab = prefixName('change.tab');
    const dismissTab = prefixName('dismiss.tab');
    const highlight$1 = prefixName('highlight');
    const dehighlight$1 = prefixName('dehighlight');
    const emit = (component, event)=>{
        dispatchWith(component, component.element, event, {});
    };
    const emitWith = (component, event, properties)=>{
        dispatchWith(component, component.element, event, properties);
    };
    const emitExecute1 = (component)=>{
        emit(component, execute$5());
    };
    const dispatch = (component, target, event)=>{
        dispatchWith(component, target, event, {});
    };
    const dispatchWith = (component, target, event, properties)=>{
        const data = {
            target,
            ...properties
        };
        component.getSystem().triggerEvent(event, target, data);
    };
    const dispatchEvent = (component, target, event, simulatedEvent)=>{
        component.getSystem().triggerEvent(event, target, simulatedEvent.event);
    };
    const derive$2 = (configs)=>wrapAll(configs)
    ;
    const abort1 = (name, predicate)=>{
        return {
            key: name,
            value: nu$9({
                abort: predicate
            })
        };
    };
    const can1 = (name, predicate)=>{
        return {
            key: name,
            value: nu$9({
                can: predicate
            })
        };
    };
    const preventDefault = (name)=>{
        return {
            key: name,
            value: nu$9({
                run: (component, simulatedEvent)=>{
                    simulatedEvent.event.prevent();
                }
            })
        };
    };
    const run$1 = (name, handler)=>{
        return {
            key: name,
            value: nu$9({
                run: handler
            })
        };
    };
    const runActionExtra = (name, action, extra)=>{
        return {
            key: name,
            value: nu$9({
                run: (component, simulatedEvent)=>{
                    action.apply(undefined, [
                        component,
                        simulatedEvent
                    ].concat(extra));
                }
            })
        };
    };
    const runOnName = (name)=>{
        return (handler)=>run$1(name, handler)
        ;
    };
    const runOnSourceName = (name)=>{
        return (handler)=>({
                key: name,
                value: nu$9({
                    run: (component, simulatedEvent)=>{
                        if (isSource(component, simulatedEvent)) handler(component, simulatedEvent);
                    }
                })
            })
        ;
    };
    const redirectToUid = (name, uid)=>{
        return run$1(name, (component, simulatedEvent)=>{
            component.getSystem().getByUid(uid).each((redirectee)=>{
                dispatchEvent(redirectee, redirectee.element, name, simulatedEvent);
            });
        });
    };
    const redirectToPart = (name, detail, partName)=>{
        const uid = detail.partUids[partName];
        return redirectToUid(name, uid);
    };
    const runWithTarget = (name, f)=>{
        return run$1(name, (component, simulatedEvent)=>{
            const ev = simulatedEvent.event;
            const target = component.getSystem().getByDom(ev.target).getOrThunk(()=>{
                const closest = closest$4(ev.target, (el)=>component.getSystem().getByDom(el).toOptional()
                , never);
                return closest.getOr(component);
            });
            f(component, target, simulatedEvent);
        });
    };
    const cutter1 = (name)=>{
        return run$1(name, (component, simulatedEvent)=>{
            simulatedEvent.cut();
        });
    };
    const stopper1 = (name)=>{
        return run$1(name, (component, simulatedEvent)=>{
            simulatedEvent.stop();
        });
    };
    const runOnSource = (name, f)=>{
        return runOnSourceName(name)(f);
    };
    const runOnAttached = runOnSourceName(attachedToDom());
    const runOnDetached = runOnSourceName(detachedFromDom());
    const runOnInit = runOnSourceName(systemInit());
    const runOnExecute$1 = runOnName(execute$5());
    const fromHtml$1 = (html, scope)=>{
        const doc = scope || document;
        const div = doc.createElement('div');
        div.innerHTML = html;
        return children1(SugarElement.fromDom(div));
    };
    const get$9 = (element)=>element.dom.innerHTML
    ;
    const set$6 = (element, content)=>{
        const owner = owner$4(element);
        const docDom = owner.dom;
        const fragment = SugarElement.fromDom(docDom.createDocumentFragment());
        const contentElements = fromHtml$1(content, docDom);
        append$1(fragment, contentElements);
        empty(element);
        append$2(element, fragment);
    };
    const getOuter1 = (element)=>{
        const container = SugarElement.fromTag('div');
        const clone = SugarElement.fromDom(element.dom.cloneNode(true));
        append$2(container, clone);
        return get$9(container);
    };
    const clone1 = (original, isDeep)=>SugarElement.fromDom(original.dom.cloneNode(isDeep))
    ;
    const shallow = (original)=>clone1(original, false)
    ;
    const getHtml = (element)=>{
        if (isShadowRoot(element)) return '#shadow-root';
        else {
            const clone = shallow(element);
            return getOuter1(clone);
        }
    };
    const element1 = (elem)=>getHtml(elem)
    ;
    const isRecursive = (component, originator, target)=>eq(originator, component.element) && !eq(originator, target)
    ;
    const events$i = derive$2([
        can1(focus$4(), (component, simulatedEvent)=>{
            const event = simulatedEvent.event;
            const originator = event.originator;
            const target = event.target;
            if (isRecursive(component, originator, target)) {
                console.warn(focus$4() + ' did not get interpreted by the desired target. ' + '\nOriginator: ' + element1(originator) + '\nTarget: ' + element1(target) + '\nCheck the ' + focus$4() + ' event handlers');
                return false;
            } else return true;
        })
    ]);
    var DefaultEvents = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        events: events$i
    });
    let unique = 0;
    const generate$6 = (prefix)=>{
        const date = new Date();
        const time = date.getTime();
        const random = Math.floor(Math.random() * 1000000000);
        unique++;
        return prefix + '_' + random + unique + String(time);
    };
    const prefix$1 = constant$1('alloy-id-');
    const idAttr$1 = constant$1('data-alloy-id');
    const prefix1 = prefix$1();
    const idAttr = idAttr$1();
    const write = (label, elem)=>{
        const id = generate$6(prefix1 + label);
        writeOnly(elem, id);
        return id;
    };
    const writeOnly = (elem, uid)=>{
        Object.defineProperty(elem.dom, idAttr, {
            value: uid,
            writable: true
        });
    };
    const read$1 = (elem)=>{
        const id = isElement$1(elem) ? elem.dom[idAttr] : null;
        return Optional.from(id);
    };
    const generate$5 = (prefix)=>generate$6(prefix)
    ;
    const make$8 = identity;
    const NoContextApi = (getComp)=>{
        const getMessage = (event)=>`The component must be in a context to execute: ${event}` + (getComp ? '\n' + element1(getComp().element) + ' is not in context.' : '')
        ;
        const fail = (event)=>()=>{
                throw new Error(getMessage(event));
            }
        ;
        const warn = (event)=>()=>{
                console.warn(getMessage(event));
            }
        ;
        return {
            debugInfo: constant$1('fake'),
            triggerEvent: warn('triggerEvent'),
            triggerFocus: warn('triggerFocus'),
            triggerEscape: warn('triggerEscape'),
            broadcast: warn('broadcast'),
            broadcastOn: warn('broadcastOn'),
            broadcastEvent: warn('broadcastEvent'),
            build: fail('build'),
            buildOrPatch: fail('buildOrPatch'),
            addToWorld: fail('addToWorld'),
            removeFromWorld: fail('removeFromWorld'),
            addToGui: fail('addToGui'),
            removeFromGui: fail('removeFromGui'),
            getByUid: fail('getByUid'),
            getByDom: fail('getByDom'),
            isConnected: never
        };
    };
    const singleton$1 = NoContextApi();
    const markAsBehaviourApi = (f, apiName, apiFunction)=>{
        const delegate = apiFunction.toString();
        const endIndex = delegate.indexOf(')') + 1;
        const openBracketIndex = delegate.indexOf('(');
        const parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\s*/);
        f.toFunctionAnnotation = ()=>({
                name: apiName,
                parameters: cleanParameters(parameters.slice(0, 1).concat(parameters.slice(3)))
            })
        ;
        return f;
    };
    const cleanParameters = (parameters)=>map$2(parameters, (p)=>endsWith(p, '/*') ? p.substring(0, p.length - 2) : p
        )
    ;
    const markAsExtraApi = (f, extraName)=>{
        const delegate = f.toString();
        const endIndex = delegate.indexOf(')') + 1;
        const openBracketIndex = delegate.indexOf('(');
        const parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\s*/);
        f.toFunctionAnnotation = ()=>({
                name: extraName,
                parameters: cleanParameters(parameters)
            })
        ;
        return f;
    };
    const markAsSketchApi = (f, apiFunction)=>{
        const delegate = apiFunction.toString();
        const endIndex = delegate.indexOf(')') + 1;
        const openBracketIndex = delegate.indexOf('(');
        const parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\s*/);
        f.toFunctionAnnotation = ()=>({
                name: 'OVERRIDE',
                parameters: cleanParameters(parameters.slice(1))
            })
        ;
        return f;
    };
    const premadeTag = generate$6('alloy-premade');
    const premade$1 = (comp)=>{
        Object.defineProperty(comp.element.dom, premadeTag, {
            value: comp.uid,
            writable: true
        });
        return wrap$1(premadeTag, comp);
    };
    const isPremade = (element)=>has$2(element.dom, premadeTag)
    ;
    const getPremade = (spec)=>get$g(spec, premadeTag)
    ;
    const makeApi = (f)=>markAsSketchApi((component, ...rest)=>f(component.getApis(), component, ...rest)
        , f)
    ;
    const NoState = {
        init: ()=>nu$8({
                readState: constant$1('No State required')
            })
    };
    const nu$8 = (spec)=>spec
    ;
    const generateFrom$1 = (spec, all)=>{
        const schema = map$2(all, (a)=>optionObjOf(a.name(), [
                required$1('config'),
                defaulted('state', NoState)
            ])
        );
        const validated = asRaw('component.behaviours', objOf(schema), spec.behaviours).fold((errInfo)=>{
            throw new Error(formatError(errInfo) + '\nComplete spec:\n' + JSON.stringify(spec, null, 2));
        }, identity);
        return {
            list: all,
            data: map$1(validated, (optBlobThunk)=>{
                const output = optBlobThunk.map((blob)=>({
                        config: blob.config,
                        state: blob.state.init(blob.config)
                    })
                );
                return constant$1(output);
            })
        };
    };
    const getBehaviours$3 = (bData)=>bData.list
    ;
    const getData$2 = (bData)=>bData.data
    ;
    const byInnerKey = (data, tuple)=>{
        const r = {};
        each(data, (detail, key)=>{
            each(detail, (value, indexKey)=>{
                const chain = get$g(r, indexKey).getOr([]);
                r[indexKey] = chain.concat([
                    tuple(key, value)
                ]);
            });
        });
        return r;
    };
    const nu$7 = (s)=>({
            classes: isUndefined(s.classes) ? [] : s.classes,
            attributes: isUndefined(s.attributes) ? {} : s.attributes,
            styles: isUndefined(s.styles) ? {} : s.styles
        })
    ;
    const merge = (defnA, mod)=>({
            ...defnA,
            attributes: {
                ...defnA.attributes,
                ...mod.attributes
            },
            styles: {
                ...defnA.styles,
                ...mod.styles
            },
            classes: defnA.classes.concat(mod.classes)
        })
    ;
    const combine$2 = (info, baseMod, behaviours, base)=>{
        const modsByBehaviour = {
            ...baseMod
        };
        each$1(behaviours, (behaviour)=>{
            modsByBehaviour[behaviour.name()] = behaviour.exhibit(info, base);
        });
        const byAspect = byInnerKey(modsByBehaviour, (name, modification)=>({
                name,
                modification
            })
        );
        const combineObjects = (objects)=>foldr(objects, (b, a)=>({
                    ...a.modification,
                    ...b
                })
            , {})
        ;
        const combinedClasses = foldr(byAspect.classes, (b, a)=>a.modification.concat(b)
        , []);
        const combinedAttributes = combineObjects(byAspect.attributes);
        const combinedStyles = combineObjects(byAspect.styles);
        return nu$7({
            classes: combinedClasses,
            attributes: combinedAttributes,
            styles: combinedStyles
        });
    };
    const sortKeys = (label, keyName, array, order)=>{
        try {
            const sorted = sort(array, (a, b)=>{
                const aKey = a[keyName];
                const bKey = b[keyName];
                const aIndex = order.indexOf(aKey);
                const bIndex = order.indexOf(bKey);
                if (aIndex === -1) throw new Error('The ordering for ' + label + ' does not have an entry for ' + aKey + '.\nOrder specified: ' + JSON.stringify(order, null, 2));
                if (bIndex === -1) throw new Error('The ordering for ' + label + ' does not have an entry for ' + bKey + '.\nOrder specified: ' + JSON.stringify(order, null, 2));
                if (aIndex < bIndex) return -1;
                else if (bIndex < aIndex) return 1;
                else return 0;
            });
            return Result.value(sorted);
        } catch (err) {
            return Result.error([
                err
            ]);
        }
    };
    const uncurried = (handler, purpose)=>({
            handler,
            purpose
        })
    ;
    const curried = (handler, purpose)=>({
            cHandler: handler,
            purpose
        })
    ;
    const curryArgs = (descHandler, extraArgs)=>curried(curry.apply(undefined, [
            descHandler.handler
        ].concat(extraArgs)), descHandler.purpose)
    ;
    const getCurried = (descHandler)=>descHandler.cHandler
    ;
    const behaviourTuple = (name, handler)=>({
            name,
            handler
        })
    ;
    const nameToHandlers = (behaviours, info)=>{
        const r = {};
        each$1(behaviours, (behaviour)=>{
            r[behaviour.name()] = behaviour.handlers(info);
        });
        return r;
    };
    const groupByEvents = (info, behaviours, base)=>{
        const behaviourEvents = {
            ...base,
            ...nameToHandlers(behaviours, info)
        };
        return byInnerKey(behaviourEvents, behaviourTuple);
    };
    const combine$1 = (info, eventOrder, behaviours, base)=>{
        const byEventName = groupByEvents(info, behaviours, base);
        return combineGroups(byEventName, eventOrder);
    };
    const assemble = (rawHandler)=>{
        const handler = read$2(rawHandler);
        return (component, simulatedEvent, ...rest)=>{
            const args = [
                component,
                simulatedEvent
            ].concat(rest);
            if (handler.abort.apply(undefined, args)) simulatedEvent.stop();
            else if (handler.can.apply(undefined, args)) handler.run.apply(undefined, args);
        };
    };
    const missingOrderError = (eventName, tuples)=>Result.error([
            'The event (' + eventName + ') has more than one behaviour that listens to it.\nWhen this occurs, you must ' + 'specify an event ordering for the behaviours in your spec (e.g. [ "listing", "toggling" ]).\nThe behaviours that ' + 'can trigger it are: ' + JSON.stringify(map$2(tuples, (c)=>c.name
            ), null, 2)
        ])
    ;
    const fuse = (tuples, eventOrder, eventName)=>{
        const order = eventOrder[eventName];
        if (!order) return missingOrderError(eventName, tuples);
        else return sortKeys('Event: ' + eventName, 'name', tuples, order).map((sortedTuples)=>{
            const handlers = map$2(sortedTuples, (tuple)=>tuple.handler
            );
            return fuse$1(handlers);
        });
    };
    const combineGroups = (byEventName, eventOrder)=>{
        const r = mapToArray(byEventName, (tuples, eventName)=>{
            const combined = tuples.length === 1 ? Result.value(tuples[0].handler) : fuse(tuples, eventOrder, eventName);
            return combined.map((handler)=>{
                const assembled = assemble(handler);
                const purpose = tuples.length > 1 ? filter$2(eventOrder[eventName], (o)=>exists(tuples, (t)=>t.name === o
                    )
                ).join(' > ') : tuples[0].name;
                return wrap$1(eventName, uncurried(assembled, purpose));
            });
        });
        return consolidate(r, {});
    };
    const baseBehaviour = 'alloy.base.behaviour';
    const schema$z = objOf([
        field$1('dom', 'dom', required$2(), objOf([
            required$1('tag'),
            defaulted('styles', {}),
            defaulted('classes', []),
            defaulted('attributes', {}),
            option$3('value'),
            option$3('innerHtml')
        ])),
        required$1('components'),
        required$1('uid'),
        defaulted('events', {}),
        defaulted('apis', {}),
        field$1('eventOrder', 'eventOrder', mergeWith({
            [execute$5()]: [
                'disabling',
                baseBehaviour,
                'toggling',
                'typeaheadevents'
            ],
            [focus$4()]: [
                baseBehaviour,
                'focusing',
                'keying'
            ],
            [systemInit()]: [
                baseBehaviour,
                'disabling',
                'toggling',
                'representing'
            ],
            [input1()]: [
                baseBehaviour,
                'representing',
                'streaming',
                'invalidating'
            ],
            [detachedFromDom()]: [
                baseBehaviour,
                'representing',
                'item-events',
                'tooltipping'
            ],
            [mousedown()]: [
                'focusing',
                baseBehaviour,
                'item-type-events'
            ],
            [touchstart()]: [
                'focusing',
                baseBehaviour,
                'item-type-events'
            ],
            [mouseover()]: [
                'item-type-events',
                'tooltipping'
            ],
            [receive()]: [
                'receiving',
                'reflecting',
                'tooltipping'
            ]
        }), anyValue()),
        option$3('domModification')
    ]);
    const toInfo = (spec)=>asRaw('custom.definition', schema$z, spec)
    ;
    const toDefinition = (detail)=>({
            ...detail.dom,
            uid: detail.uid,
            domChildren: map$2(detail.components, (comp)=>comp.element
            )
        })
    ;
    const toModification = (detail)=>detail.domModification.fold(()=>nu$7({})
        , nu$7)
    ;
    const toEvents1 = (info)=>info.events
    ;
    const read = (element, attr)=>{
        const value = get$f(element, attr);
        return value === undefined || value === '' ? [] : value.split(' ');
    };
    const add$4 = (element, attr, id)=>{
        const old = read(element, attr);
        const nu = old.concat([
            id
        ]);
        set$9(element, attr, nu.join(' '));
        return true;
    };
    const remove$4 = (element, attr, id)=>{
        const nu = filter$2(read(element, attr), (v)=>v !== id
        );
        if (nu.length > 0) set$9(element, attr, nu.join(' '));
        else remove$7(element, attr);
        return false;
    };
    const supports = (element)=>element.dom.classList !== undefined
    ;
    const get$8 = (element)=>read(element, 'class')
    ;
    const add$3 = (element, clazz)=>add$4(element, 'class', clazz)
    ;
    const remove$3 = (element, clazz)=>remove$4(element, 'class', clazz)
    ;
    const add$2 = (element, clazz)=>{
        if (supports(element)) element.dom.classList.add(clazz);
        else add$3(element, clazz);
    };
    const cleanClass = (element)=>{
        const classList = supports(element) ? element.dom.classList : get$8(element);
        if (classList.length === 0) remove$7(element, 'class');
    };
    const remove$2 = (element, clazz)=>{
        if (supports(element)) {
            const classList = element.dom.classList;
            classList.remove(clazz);
        } else remove$3(element, clazz);
        cleanClass(element);
    };
    const has = (element, clazz)=>supports(element) && element.dom.classList.contains(clazz)
    ;
    const add$1 = (element, classes)=>{
        each$1(classes, (x)=>{
            add$2(element, x);
        });
    };
    const remove$1 = (element, classes)=>{
        each$1(classes, (x)=>{
            remove$2(element, x);
        });
    };
    const hasAll = (element, classes)=>forall(classes, (clazz)=>has(element, clazz)
        )
    ;
    const getNative = (element)=>{
        const classList = element.dom.classList;
        const r = new Array(classList.length);
        for(let i = 0; i < classList.length; i++){
            const item = classList.item(i);
            if (item !== null) r[i] = item;
        }
        return r;
    };
    const get$7 = (element)=>supports(element) ? getNative(element) : get$8(element)
    ;
    const get$6 = (element)=>element.dom.value
    ;
    const set$5 = (element, value)=>{
        if (value === undefined) throw new Error('Value.set was undefined');
        element.dom.value = value;
    };
    const determineObsoleted = (parent, index, oldObsoleted)=>{
        const newObsoleted = child$2(parent, index);
        return newObsoleted.map((newObs)=>{
            const elemChanged = oldObsoleted.exists((o)=>!eq(o, newObs)
            );
            if (elemChanged) {
                const oldTag = oldObsoleted.map(name$3).getOr('span');
                const marker = SugarElement.fromTag(oldTag);
                before$1(newObs, marker);
                return marker;
            } else return newObs;
        });
    };
    const ensureInDom = (parent, child, obsoleted)=>{
        obsoleted.fold(()=>append$2(parent, child)
        , (obs)=>{
            if (!eq(obs, child)) {
                before$1(obs, child);
                remove$5(obs);
            }
        });
    };
    const patchChildrenWith = (parent, nu, f)=>{
        const builtChildren = map$2(nu, f);
        const currentChildren = children1(parent);
        each$1(currentChildren.slice(builtChildren.length), remove$5);
        return builtChildren;
    };
    const patchSpecChild = (parent, index, spec, build)=>{
        const oldObsoleted = child$2(parent, index);
        const childComp = build(spec, oldObsoleted);
        const obsoleted = determineObsoleted(parent, index, oldObsoleted);
        ensureInDom(parent, childComp.element, obsoleted);
        return childComp;
    };
    const patchSpecChildren = (parent, specs, build)=>patchChildrenWith(parent, specs, (spec, index)=>patchSpecChild(parent, index, spec, build)
        )
    ;
    const patchDomChildren = (parent, nodes)=>patchChildrenWith(parent, nodes, (node, index)=>{
            const optObsoleted = child$2(parent, index);
            ensureInDom(parent, node, optObsoleted);
            return node;
        })
    ;
    const diffKeyValueSet = (newObj, oldObj)=>{
        const newKeys = keys1(newObj);
        const oldKeys = keys1(oldObj);
        const toRemove = difference(oldKeys, newKeys);
        const toSet = bifilter(newObj, (v, k)=>{
            return !has$2(oldObj, k) || v !== oldObj[k];
        }).t;
        return {
            toRemove,
            toSet
        };
    };
    const reconcileToDom = (definition, obsoleted)=>{
        const { class: clazz , style , ...existingAttributes } = clone$1(obsoleted);
        const { toSet: attrsToSet , toRemove: attrsToRemove  } = diffKeyValueSet(definition.attributes, existingAttributes);
        const updateAttrs = ()=>{
            each$1(attrsToRemove, (a)=>remove$7(obsoleted, a)
            );
            setAll$1(obsoleted, attrsToSet);
        };
        const existingStyles = getAllRaw(obsoleted);
        const { toSet: stylesToSet , toRemove: stylesToRemove  } = diffKeyValueSet(definition.styles, existingStyles);
        const updateStyles = ()=>{
            each$1(stylesToRemove, (s)=>remove$6(obsoleted, s)
            );
            setAll(obsoleted, stylesToSet);
        };
        const existingClasses = get$7(obsoleted);
        const classesToRemove = difference(existingClasses, definition.classes);
        const classesToAdd = difference(definition.classes, existingClasses);
        const updateClasses = ()=>{
            add$1(obsoleted, classesToAdd);
            remove$1(obsoleted, classesToRemove);
        };
        const updateHtml = (html)=>{
            set$6(obsoleted, html);
        };
        const updateChildren = ()=>{
            const children = definition.domChildren;
            patchDomChildren(obsoleted, children);
        };
        const updateValue = ()=>{
            const valueElement = obsoleted;
            definition.value.filter((value)=>value !== get$6(valueElement)
            ).each((value)=>set$5(valueElement, value)
            );
        };
        updateAttrs();
        updateClasses();
        updateStyles();
        definition.innerHtml.fold(updateChildren, updateHtml);
        updateValue();
        return obsoleted;
    };
    const introduceToDom = (definition)=>{
        const subject = SugarElement.fromTag(definition.tag);
        setAll$1(subject, definition.attributes);
        add$1(subject, definition.classes);
        setAll(subject, definition.styles);
        definition.innerHtml.each((html)=>set$6(subject, html)
        );
        const children = definition.domChildren;
        append$1(subject, children);
        definition.value.each((value)=>{
            set$5(subject, value);
        });
        return subject;
    };
    const attemptPatch = (definition, obsoleted)=>{
        try {
            const e = reconcileToDom(definition, obsoleted);
            return Optional.some(e);
        } catch (err) {
            return Optional.none();
        }
    };
    const hasMixedChildren = (definition)=>definition.innerHtml.isSome() && definition.domChildren.length > 0
    ;
    const renderToDom = (definition, optObsoleted)=>{
        const canBePatched = (candidate)=>name$3(candidate) === definition.tag && !hasMixedChildren(definition) && !isPremade(candidate)
        ;
        const elem = optObsoleted.filter(canBePatched).bind((obsoleted)=>attemptPatch(definition, obsoleted)
        ).getOrThunk(()=>introduceToDom(definition)
        );
        writeOnly(elem, definition.uid);
        return elem;
    };
    const getBehaviours$21 = (spec)=>{
        const behaviours = get$g(spec, 'behaviours').getOr({});
        return bind$3(keys1(behaviours), (name)=>{
            const behaviour = behaviours[name];
            return isNonNullable(behaviour) ? [
                behaviour.me
            ] : [];
        });
    };
    const generateFrom = (spec, all)=>generateFrom$1(spec, all)
    ;
    const generate$4 = (spec)=>{
        const all = getBehaviours$21(spec);
        return generateFrom(spec, all);
    };
    const getDomDefinition = (info, bList, bData)=>{
        const definition = toDefinition(info);
        const infoModification = toModification(info);
        const baseModification = {
            'alloy.base.modification': infoModification
        };
        const modification = bList.length > 0 ? combine$2(bData, baseModification, bList, definition) : infoModification;
        return merge(definition, modification);
    };
    const getEvents1 = (info, bList, bData)=>{
        const baseEvents = {
            'alloy.base.behaviour': toEvents1(info)
        };
        return combine$1(bData, info.eventOrder, bList, baseEvents).getOrDie();
    };
    const build$2 = (spec, obsoleted)=>{
        const getMe = ()=>me
        ;
        const systemApi = Cell(singleton$1);
        const info = getOrDie(toInfo(spec));
        const bBlob = generate$4(spec);
        const bList = getBehaviours$3(bBlob);
        const bData = getData$2(bBlob);
        const modDefinition = getDomDefinition(info, bList, bData);
        const item = renderToDom(modDefinition, obsoleted);
        const events = getEvents1(info, bList, bData);
        const subcomponents = Cell(info.components);
        const connect = (newApi)=>{
            systemApi.set(newApi);
        };
        const disconnect = ()=>{
            systemApi.set(NoContextApi(getMe));
        };
        const syncComponents = ()=>{
            const children$1 = children1(item);
            const subs = bind$3(children$1, (child)=>systemApi.get().getByDom(child).fold(()=>[]
                , pure$2)
            );
            subcomponents.set(subs);
        };
        const config = (behaviour)=>{
            const b = bData;
            const f = isFunction(b[behaviour.name()]) ? b[behaviour.name()] : ()=>{
                throw new Error('Could not find ' + behaviour.name() + ' in ' + JSON.stringify(spec, null, 2));
            };
            return f();
        };
        const hasConfigured = (behaviour)=>isFunction(bData[behaviour.name()])
        ;
        const getApis = ()=>info.apis
        ;
        const readState = (behaviourName)=>bData[behaviourName]().map((b)=>b.state.readState()
            ).getOr('not enabled')
        ;
        const me = {
            uid: spec.uid,
            getSystem: systemApi.get,
            config,
            hasConfigured,
            spec,
            readState,
            getApis,
            connect,
            disconnect,
            element: item,
            syncComponents,
            components: subcomponents.get,
            events
        };
        return me;
    };
    const buildSubcomponents = (spec, obsoleted)=>{
        const components = get$g(spec, 'components').getOr([]);
        return obsoleted.fold(()=>map$2(components, build$1)
        , (obs)=>map$2(components, (c, i)=>{
                return buildOrPatch(c, child$2(obs, i));
            })
        );
    };
    const buildFromSpec = (userSpec, obsoleted)=>{
        const { events: specEvents , ...spec } = make$8(userSpec);
        const components = buildSubcomponents(spec, obsoleted);
        const completeSpec = {
            ...spec,
            events: {
                ...DefaultEvents,
                ...specEvents
            },
            components
        };
        return Result.value(build$2(completeSpec, obsoleted));
    };
    const text$1 = (textContent)=>{
        const element = SugarElement.fromText(textContent);
        return external$1({
            element
        });
    };
    const external$1 = (spec)=>{
        const extSpec = asRawOrDie$1('external.component', objOfOnly([
            required$1('element'),
            option$3('uid')
        ]), spec);
        const systemApi = Cell(NoContextApi());
        const connect = (newApi)=>{
            systemApi.set(newApi);
        };
        const disconnect = ()=>{
            systemApi.set(NoContextApi(()=>me
            ));
        };
        const uid = extSpec.uid.getOrThunk(()=>generate$5('external')
        );
        writeOnly(extSpec.element, uid);
        const me = {
            uid,
            getSystem: systemApi.get,
            config: Optional.none,
            hasConfigured: never,
            connect,
            disconnect,
            getApis: ()=>({})
            ,
            element: extSpec.element,
            spec,
            readState: constant$1('No state'),
            syncComponents: noop,
            components: constant$1([]),
            events: {}
        };
        return premade$1(me);
    };
    const uids1 = generate$5;
    const isSketchSpec$1 = (spec)=>has$2(spec, 'uid')
    ;
    const buildOrPatch = (spec, obsoleted)=>getPremade(spec).getOrThunk(()=>{
            const userSpecWithUid = isSketchSpec$1(spec) ? spec : {
                uid: uids1(''),
                ...spec
            };
            return buildFromSpec(userSpecWithUid, obsoleted).getOrDie();
        })
    ;
    const build$1 = (spec)=>buildOrPatch(spec, Optional.none())
    ;
    const premade = premade$1;
    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot)=>{
        if (is(scope, a)) return Optional.some(scope);
        else if (isFunction(isRoot) && isRoot(scope)) return Optional.none();
        else return ancestor(scope, a, isRoot);
    };
    const ancestor$1 = (scope, predicate, isRoot)=>{
        let element = scope.dom;
        const stop = isFunction(isRoot) ? isRoot : never;
        while(element.parentNode){
            element = element.parentNode;
            const el = SugarElement.fromDom(element);
            if (predicate(el)) return Optional.some(el);
            else if (stop(el)) break;
        }
        return Optional.none();
    };
    const closest$3 = (scope, predicate, isRoot)=>{
        const is = (s, test)=>test(s)
        ;
        return ClosestOrAncestor(is, ancestor$1, scope, predicate, isRoot);
    };
    const child$1 = (scope, predicate)=>{
        const pred = (node)=>predicate(SugarElement.fromDom(node))
        ;
        const result = find$5(scope.dom.childNodes, pred);
        return result.map(SugarElement.fromDom);
    };
    const descendant$1 = (scope, predicate)=>{
        const descend = (node)=>{
            for(let i = 0; i < node.childNodes.length; i++){
                const child = SugarElement.fromDom(node.childNodes[i]);
                if (predicate(child)) return Optional.some(child);
                const res = descend(node.childNodes[i]);
                if (res.isSome()) return res;
            }
            return Optional.none();
        };
        return descend(scope.dom);
    };
    const closest$2 = (scope, predicate, isRoot)=>closest$3(scope, predicate, isRoot).isSome()
    ;
    const ancestor1 = (scope, selector, isRoot)=>ancestor$1(scope, (e)=>is1(e, selector)
        , isRoot)
    ;
    const child1 = (scope, selector)=>child$1(scope, (e)=>is1(e, selector)
        )
    ;
    const descendant = (scope, selector)=>one(selector, scope)
    ;
    const closest$1 = (scope, selector1, isRoot)=>{
        const is$1 = (element, selector)=>is1(element, selector)
        ;
        return ClosestOrAncestor(is$1, ancestor1, scope, selector1, isRoot);
    };
    const attribute = 'aria-controls';
    const find$1 = (queryElem)=>{
        const dependent = closest$3(queryElem, (elem)=>{
            if (!isElement$1(elem)) return false;
            const id = get$f(elem, 'id');
            return id !== undefined && id.indexOf(attribute) > -1;
        });
        return dependent.bind((dep)=>{
            const id = get$f(dep, 'id');
            const dos = getRootNode(dep);
            return descendant(dos, `[${attribute}="${id}"]`);
        });
    };
    const manager = ()=>{
        const ariaId = generate$6(attribute);
        const link = (elem)=>{
            set$9(elem, attribute, ariaId);
        };
        const unlink = (elem)=>{
            remove$7(elem, attribute);
        };
        return {
            id: ariaId,
            link,
            unlink
        };
    };
    const isAriaPartOf = (component, queryElem)=>find$1(queryElem).exists((owner)=>isPartOf$1(component, owner)
        )
    ;
    const isPartOf$1 = (component, queryElem)=>closest$2(queryElem, (el)=>eq(el, component.element)
        , never) || isAriaPartOf(component, queryElem)
    ;
    const unknown = 'unknown';
    var EventConfiguration1;
    (function(EventConfiguration) {
        EventConfiguration[EventConfiguration['STOP'] = 0] = 'STOP';
        EventConfiguration[EventConfiguration['NORMAL'] = 1] = 'NORMAL';
        EventConfiguration[EventConfiguration['LOGGING'] = 2] = 'LOGGING';
    })(EventConfiguration1 || (EventConfiguration1 = {}));
    const eventConfig = Cell({});
    const makeEventLogger = (eventName, initialTarget)=>{
        const sequence = [];
        const startTime = new Date().getTime();
        return {
            logEventCut: (_name, target, purpose)=>{
                sequence.push({
                    outcome: 'cut',
                    target,
                    purpose
                });
            },
            logEventStopped: (_name, target, purpose)=>{
                sequence.push({
                    outcome: 'stopped',
                    target,
                    purpose
                });
            },
            logNoParent: (_name, target, purpose)=>{
                sequence.push({
                    outcome: 'no-parent',
                    target,
                    purpose
                });
            },
            logEventNoHandlers: (_name, target)=>{
                sequence.push({
                    outcome: 'no-handlers-left',
                    target
                });
            },
            logEventResponse: (_name, target, purpose)=>{
                sequence.push({
                    outcome: 'response',
                    purpose,
                    target
                });
            },
            write: ()=>{
                const finishTime = new Date().getTime();
                if (contains$2([
                    'mousemove',
                    'mouseover',
                    'mouseout',
                    systemInit()
                ], eventName)) return;
                console.log(eventName, {
                    event: eventName,
                    time: finishTime - startTime,
                    target: initialTarget.dom,
                    sequence: map$2(sequence, (s)=>{
                        if (!contains$2([
                            'cut',
                            'stopped',
                            'response'
                        ], s.outcome)) return s.outcome;
                        else return '{' + s.purpose + '} ' + s.outcome + ' at (' + element1(s.target) + ')';
                    })
                });
            }
        };
    };
    const processEvent = (eventName, initialTarget, f)=>{
        const status = get$g(eventConfig.get(), eventName).orThunk(()=>{
            const patterns = keys1(eventConfig.get());
            return findMap(patterns, (p)=>eventName.indexOf(p) > -1 ? Optional.some(eventConfig.get()[p]) : Optional.none()
            );
        }).getOr(EventConfiguration1.NORMAL);
        switch(status){
            case EventConfiguration1.NORMAL:
                return f(noLogger());
            case EventConfiguration1.LOGGING:
                {
                    const logger = makeEventLogger(eventName, initialTarget);
                    const output = f(logger);
                    logger.write();
                    return output;
                }
            case EventConfiguration1.STOP:
                return true;
        }
    };
    const path1 = [
        'alloy/data/Fields',
        'alloy/debugging/Debugging'
    ];
    const getTrace = ()=>{
        const err = new Error();
        if (err.stack !== undefined) {
            const lines = err.stack.split('\n');
            return find$5(lines, (line)=>line.indexOf('alloy') > 0 && !exists(path1, (p)=>line.indexOf(p) > -1
                )
            ).getOr(unknown);
        } else return unknown;
    };
    const ignoreEvent = {
        logEventCut: noop,
        logEventStopped: noop,
        logNoParent: noop,
        logEventNoHandlers: noop,
        logEventResponse: noop,
        write: noop
    };
    const monitorEvent = (eventName, initialTarget, f)=>processEvent(eventName, initialTarget, f)
    ;
    const noLogger = constant$1(ignoreEvent);
    const menuFields = constant$1([
        required$1('menu'),
        required$1('selectedMenu')
    ]);
    const itemFields = constant$1([
        required$1('item'),
        required$1('selectedItem')
    ]);
    constant$1(objOf(itemFields().concat(menuFields())));
    const itemSchema$3 = constant$1(objOf(itemFields()));
    const _initSize = requiredObjOf('initSize', [
        required$1('numColumns'),
        required$1('numRows')
    ]);
    const itemMarkers = ()=>requiredOf('markers', itemSchema$3())
    ;
    const tieredMenuMarkers = ()=>requiredObjOf('markers', [
            required$1('backgroundMenu')
        ].concat(menuFields()).concat(itemFields()))
    ;
    const markers$1 = (required)=>requiredObjOf('markers', map$2(required, required$1))
    ;
    const onPresenceHandler = (label, fieldName, presence)=>{
        getTrace();
        return field$1(fieldName, fieldName, presence, valueOf((f)=>Result.value((...args)=>{
                return f.apply(undefined, args);
            })
        ));
    };
    const onHandler = (fieldName)=>onPresenceHandler('onHandler', fieldName, defaulted$1(noop))
    ;
    const onKeyboardHandler = (fieldName)=>onPresenceHandler('onKeyboardHandler', fieldName, defaulted$1(Optional.none))
    ;
    const onStrictHandler = (fieldName)=>onPresenceHandler('onHandler', fieldName, required$2())
    ;
    const onStrictKeyboardHandler = (fieldName)=>onPresenceHandler('onKeyboardHandler', fieldName, required$2())
    ;
    const output$1 = (name, value)=>customField(name, constant$1(value))
    ;
    const snapshot = (name)=>customField(name, identity)
    ;
    const initSize = constant$1(_initSize);
    const nu$6 = (x, y, bubble, direction, placement, boundsRestriction, labelPrefix, alwaysFit = false)=>({
            x,
            y,
            bubble,
            direction,
            placement,
            restriction: boundsRestriction,
            label: `${labelPrefix}-${placement}`,
            alwaysFit
        })
    ;
    const adt$a = Adt.generate([
        {
            southeast: []
        },
        {
            southwest: []
        },
        {
            northeast: []
        },
        {
            northwest: []
        },
        {
            south: []
        },
        {
            north: []
        },
        {
            east: []
        },
        {
            west: []
        }
    ]);
    const cata$2 = (subject, southeast, southwest, northeast, northwest, south, north, east, west)=>subject.fold(southeast, southwest, northeast, northwest, south, north, east, west)
    ;
    const cataVertical = (subject, south, middle, north)=>subject.fold(south, south, north, north, south, north, middle, middle)
    ;
    const cataHorizontal = (subject, east, middle, west)=>subject.fold(east, west, east, west, middle, middle, east, west)
    ;
    const southeast$3 = adt$a.southeast;
    const southwest$3 = adt$a.southwest;
    const northeast$3 = adt$a.northeast;
    const northwest$3 = adt$a.northwest;
    const south$3 = adt$a.south;
    const north$3 = adt$a.north;
    const east$3 = adt$a.east;
    const west$3 = adt$a.west;
    const cycleBy = (value, delta, min, max)=>{
        const r = value + delta;
        if (r > max) return min;
        else if (r < min) return max;
        else return r;
    };
    const clamp = (value, min, max)=>Math.min(Math.max(value, min), max)
    ;
    const getRestriction = (anchor, restriction)=>{
        switch(restriction){
            case 1:
                return anchor.x;
            case 0:
                return anchor.x + anchor.width;
            case 2:
                return anchor.y;
            case 3:
                return anchor.y + anchor.height;
        }
    };
    const boundsRestriction1 = (anchor, restrictions)=>mapToObject([
            'left',
            'right',
            'top',
            'bottom'
        ], (dir)=>get$g(restrictions, dir).map((restriction)=>getRestriction(anchor, restriction)
            )
        )
    ;
    const adjustBounds = (bounds$1, restriction, bubbleOffset)=>{
        const applyRestriction = (dir, current)=>restriction[dir].map((pos)=>{
                const isVerticalAxis = dir === 'top' || dir === 'bottom';
                const offset = isVerticalAxis ? bubbleOffset.top : bubbleOffset.left;
                const comparator = dir === 'left' || dir === 'top' ? Math.max : Math.min;
                const newPos = comparator(pos, current) + offset;
                return isVerticalAxis ? clamp(newPos, bounds$1.y, bounds$1.bottom) : clamp(newPos, bounds$1.x, bounds$1.right);
            }).getOr(current)
        ;
        const adjustedLeft = applyRestriction('left', bounds$1.x);
        const adjustedTop = applyRestriction('top', bounds$1.y);
        const adjustedRight = applyRestriction('right', bounds$1.right);
        const adjustedBottom = applyRestriction('bottom', bounds$1.bottom);
        return bounds1(adjustedLeft, adjustedTop, adjustedRight - adjustedLeft, adjustedBottom - adjustedTop);
    };
    const labelPrefix$2 = 'layout';
    const eastX$1 = (anchor)=>anchor.x
    ;
    const middleX$1 = (anchor, element)=>anchor.x + anchor.width / 2 - element.width / 2
    ;
    const westX$1 = (anchor, element)=>anchor.x + anchor.width - element.width
    ;
    const northY$2 = (anchor, element)=>anchor.y - element.height
    ;
    const southY$2 = (anchor)=>anchor.y + anchor.height
    ;
    const centreY$1 = (anchor, element)=>anchor.y + anchor.height / 2 - element.height / 2
    ;
    const eastEdgeX$1 = (anchor)=>anchor.x + anchor.width
    ;
    const westEdgeX$1 = (anchor, element)=>anchor.x - element.width
    ;
    const southeast$2 = (anchor, element, bubbles)=>nu$6(eastX$1(anchor), southY$2(anchor), bubbles.southeast(), southeast$3(), 'southeast', boundsRestriction1(anchor, {
            left: 1,
            top: 3
        }), labelPrefix$2)
    ;
    const southwest$2 = (anchor, element, bubbles)=>nu$6(westX$1(anchor, element), southY$2(anchor), bubbles.southwest(), southwest$3(), 'southwest', boundsRestriction1(anchor, {
            right: 0,
            top: 3
        }), labelPrefix$2)
    ;
    const northeast$2 = (anchor, element, bubbles)=>nu$6(eastX$1(anchor), northY$2(anchor, element), bubbles.northeast(), northeast$3(), 'northeast', boundsRestriction1(anchor, {
            left: 1,
            bottom: 2
        }), labelPrefix$2)
    ;
    const northwest$2 = (anchor, element, bubbles)=>nu$6(westX$1(anchor, element), northY$2(anchor, element), bubbles.northwest(), northwest$3(), 'northwest', boundsRestriction1(anchor, {
            right: 0,
            bottom: 2
        }), labelPrefix$2)
    ;
    const north$2 = (anchor, element, bubbles)=>nu$6(middleX$1(anchor, element), northY$2(anchor, element), bubbles.north(), north$3(), 'north', boundsRestriction1(anchor, {
            bottom: 2
        }), labelPrefix$2)
    ;
    const south$2 = (anchor, element, bubbles)=>nu$6(middleX$1(anchor, element), southY$2(anchor), bubbles.south(), south$3(), 'south', boundsRestriction1(anchor, {
            top: 3
        }), labelPrefix$2)
    ;
    const east$2 = (anchor, element, bubbles)=>nu$6(eastEdgeX$1(anchor), centreY$1(anchor, element), bubbles.east(), east$3(), 'east', boundsRestriction1(anchor, {
            left: 0
        }), labelPrefix$2)
    ;
    const west$2 = (anchor, element, bubbles)=>nu$6(westEdgeX$1(anchor, element), centreY$1(anchor, element), bubbles.west(), west$3(), 'west', boundsRestriction1(anchor, {
            right: 1
        }), labelPrefix$2)
    ;
    const all$1 = ()=>[
            southeast$2,
            southwest$2,
            northeast$2,
            northwest$2,
            south$2,
            north$2,
            east$2,
            west$2
        ]
    ;
    const allRtl$1 = ()=>[
            southwest$2,
            southeast$2,
            northwest$2,
            northeast$2,
            south$2,
            north$2,
            east$2,
            west$2
        ]
    ;
    const aboveOrBelow = ()=>[
            northeast$2,
            northwest$2,
            southeast$2,
            southwest$2,
            north$2,
            south$2
        ]
    ;
    const aboveOrBelowRtl = ()=>[
            northwest$2,
            northeast$2,
            southwest$2,
            southeast$2,
            north$2,
            south$2
        ]
    ;
    const belowOrAbove = ()=>[
            southeast$2,
            southwest$2,
            northeast$2,
            northwest$2,
            south$2,
            north$2
        ]
    ;
    const belowOrAboveRtl = ()=>[
            southwest$2,
            southeast$2,
            northwest$2,
            northeast$2,
            south$2,
            north$2
        ]
    ;
    const chooseChannels = (channels, message)=>message.universal ? channels : filter$2(channels, (ch)=>contains$2(message.channels, ch)
        )
    ;
    const events$h = (receiveConfig)=>derive$2([
            run$1(receive(), (component, message)=>{
                const channelMap = receiveConfig.channels;
                const channels = keys1(channelMap);
                const receivingData = message;
                const targetChannels = chooseChannels(channels, receivingData);
                each$1(targetChannels, (ch)=>{
                    const channelInfo = channelMap[ch];
                    const channelSchema = channelInfo.schema;
                    const data = asRawOrDie$1('channel[' + ch + '] data\nReceiver: ' + element1(component.element), channelSchema, receivingData.data);
                    channelInfo.onReceive(component, data);
                });
            })
        ])
    ;
    var ActiveReceiving = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        events: events$h
    });
    var ReceivingSchema = [
        requiredOf('channels', setOf(Result.value, objOfOnly([
            onStrictHandler('onReceive'),
            defaulted('schema', anyValue())
        ])))
    ];
    const executeEvent = (bConfig, bState, executor)=>runOnExecute$1((component)=>{
            executor(component, bConfig, bState);
        })
    ;
    const loadEvent = (bConfig, bState, f)=>runOnInit((component, _simulatedEvent)=>{
            f(component, bConfig, bState);
        })
    ;
    const create$4 = (schema, name, active, apis, extra, state)=>{
        const configSchema = objOfOnly(schema);
        const schemaSchema = optionObjOf(name, [
            optionObjOfOnly('config', schema)
        ]);
        return doCreate(configSchema, schemaSchema, name, active, apis, extra, state);
    };
    const createModes$1 = (modes, name, active, apis, extra, state)=>{
        const configSchema = modes;
        const schemaSchema = optionObjOf(name, [
            optionOf('config', modes)
        ]);
        return doCreate(configSchema, schemaSchema, name, active, apis, extra, state);
    };
    const wrapApi = (bName, apiFunction, apiName)=>{
        const f = (component, ...rest1)=>{
            const args = [
                component
            ].concat(rest1);
            return component.config({
                name: constant$1(bName)
            }).fold(()=>{
                throw new Error('We could not find any behaviour configuration for: ' + bName + '. Using API: ' + apiName);
            }, (info)=>{
                const rest = Array.prototype.slice.call(args, 1);
                return apiFunction.apply(undefined, [
                    component,
                    info.config,
                    info.state
                ].concat(rest));
            });
        };
        return markAsBehaviourApi(f, apiName, apiFunction);
    };
    const revokeBehaviour = (name)=>({
            key: name,
            value: undefined
        })
    ;
    const doCreate = (configSchema, schemaSchema, name, active, apis, extra, state)=>{
        const getConfig = (info)=>hasNonNullableKey(info, name) ? info[name]() : Optional.none()
        ;
        const wrappedApis = map$1(apis, (apiF, apiName)=>wrapApi(name, apiF, apiName)
        );
        const wrappedExtra = map$1(extra, (extraF, extraName)=>markAsExtraApi(extraF, extraName)
        );
        const me = {
            ...wrappedExtra,
            ...wrappedApis,
            revoke: curry(revokeBehaviour, name),
            config: (spec)=>{
                const prepared = asRawOrDie$1(name + '-config', configSchema, spec);
                return {
                    key: name,
                    value: {
                        config: prepared,
                        me,
                        configAsRaw: cached(()=>asRawOrDie$1(name + '-config', configSchema, spec)
                        ),
                        initialConfig: spec,
                        state
                    }
                };
            },
            schema: constant$1(schemaSchema),
            exhibit: (info, base)=>{
                return lift2(getConfig(info), get$g(active, 'exhibit'), (behaviourInfo, exhibitor)=>{
                    return exhibitor(base, behaviourInfo.config, behaviourInfo.state);
                }).getOrThunk(()=>nu$7({})
                );
            },
            name: constant$1(name),
            handlers: (info)=>{
                return getConfig(info).map((behaviourInfo)=>{
                    const getEvents = get$g(active, 'events').getOr(()=>({})
                    );
                    return getEvents(behaviourInfo.config, behaviourInfo.state);
                }).getOr({});
            }
        };
        return me;
    };
    const derive$1 = (capabilities)=>wrapAll(capabilities)
    ;
    const simpleSchema = objOfOnly([
        required$1('fields'),
        required$1('name'),
        defaulted('active', {}),
        defaulted('apis', {}),
        defaulted('state', NoState),
        defaulted('extra', {})
    ]);
    const create$3 = (data)=>{
        const value = asRawOrDie$1('Creating behaviour: ' + data.name, simpleSchema, data);
        return create$4(value.fields, value.name, value.active, value.apis, value.extra, value.state);
    };
    const modeSchema = objOfOnly([
        required$1('branchKey'),
        required$1('branches'),
        required$1('name'),
        defaulted('active', {}),
        defaulted('apis', {}),
        defaulted('state', NoState),
        defaulted('extra', {})
    ]);
    const createModes = (data)=>{
        const value = asRawOrDie$1('Creating behaviour: ' + data.name, modeSchema, data);
        return createModes$1(choose$1(value.branchKey, value.branches), value.name, value.active, value.apis, value.extra, value.state);
    };
    const revoke1 = constant$1(undefined);
    const Receiving = create$3({
        fields: ReceivingSchema,
        name: 'receiving',
        active: ActiveReceiving
    });
    const exhibit$6 = (base, posConfig)=>nu$7({
            classes: [],
            styles: posConfig.useFixed() ? {} : {
                position: 'relative'
            }
        })
    ;
    var ActivePosition = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        exhibit: exhibit$6
    });
    const focus$3 = (element)=>element.dom.focus()
    ;
    const blur$1 = (element)=>element.dom.blur()
    ;
    const hasFocus1 = (element)=>{
        const root = getRootNode(element).dom;
        return element.dom === root.activeElement;
    };
    const active$1 = (root = getDocument())=>Optional.from(root.dom.activeElement).map(SugarElement.fromDom)
    ;
    const search1 = (element)=>active$1(getRootNode(element)).filter((e)=>element.dom.contains(e.dom)
        )
    ;
    const preserve$1 = (f, container)=>{
        const dos = getRootNode(container);
        const refocus = active$1(dos).bind((focused)=>{
            const hasFocus = (elem)=>eq(focused, elem)
            ;
            return hasFocus(container) ? Optional.some(container) : descendant$1(container, hasFocus);
        });
        const result = f(container);
        refocus.each((oldFocus)=>{
            active$1(dos).filter((newFocus)=>eq(newFocus, oldFocus)
            ).fold(()=>{
                focus$3(oldFocus);
            }, noop);
        });
        return result;
    };
    const NuPositionCss = (position, left, top, right, bottom)=>{
        const toPx = (num)=>num + 'px'
        ;
        return {
            position,
            left: left.map(toPx),
            top: top.map(toPx),
            right: right.map(toPx),
            bottom: bottom.map(toPx)
        };
    };
    const toOptions = (position)=>({
            ...position,
            position: Optional.some(position.position)
        })
    ;
    const applyPositionCss = (element, position)=>{
        setOptions(element, toOptions(position));
    };
    const adt$9 = Adt.generate([
        {
            none: []
        },
        {
            relative: [
                'x',
                'y',
                'width',
                'height'
            ]
        },
        {
            fixed: [
                'x',
                'y',
                'width',
                'height'
            ]
        }
    ]);
    const positionWithDirection = (posName, decision, x, y, width, height)=>{
        const decisionRect = decision.rect;
        const decisionX = decisionRect.x - x;
        const decisionY = decisionRect.y - y;
        const decisionWidth = decisionRect.width;
        const decisionHeight = decisionRect.height;
        const decisionRight = width - (decisionX + decisionWidth);
        const decisionBottom = height - (decisionY + decisionHeight);
        const left = Optional.some(decisionX);
        const top = Optional.some(decisionY);
        const right = Optional.some(decisionRight);
        const bottom = Optional.some(decisionBottom);
        const none = Optional.none();
        return cata$2(decision.direction, ()=>NuPositionCss(posName, left, top, none, none)
        , ()=>NuPositionCss(posName, none, top, right, none)
        , ()=>NuPositionCss(posName, left, none, none, bottom)
        , ()=>NuPositionCss(posName, none, none, right, bottom)
        , ()=>NuPositionCss(posName, left, top, none, none)
        , ()=>NuPositionCss(posName, left, none, none, bottom)
        , ()=>NuPositionCss(posName, left, top, none, none)
        , ()=>NuPositionCss(posName, none, top, right, none)
        );
    };
    const reposition1 = (origin, decision)=>origin.fold(()=>{
            const decisionRect = decision.rect;
            return NuPositionCss('absolute', Optional.some(decisionRect.x), Optional.some(decisionRect.y), Optional.none(), Optional.none());
        }, (x, y, width, height)=>{
            return positionWithDirection('absolute', decision, x, y, width, height);
        }, (x, y, width, height)=>{
            return positionWithDirection('fixed', decision, x, y, width, height);
        })
    ;
    const toBox = (origin, element)=>{
        const rel = curry(find$2, element);
        const position = origin.fold(rel, rel, ()=>{
            const scroll = get$b();
            return find$2(element).translate(-scroll.left, -scroll.top);
        });
        const width = getOuter$1(element);
        const height = getOuter$2(element);
        return bounds1(position.left, position.top, width, height);
    };
    const viewport1 = (origin, getBounds)=>getBounds.fold(()=>origin.fold(win1, win1, bounds1)
        , (b)=>origin.fold(b, b, ()=>{
                const bounds$1 = b();
                const pos = translate$2(origin, bounds$1.x, bounds$1.y);
                return bounds1(pos.left, pos.top, bounds$1.width, bounds$1.height);
            })
        )
    ;
    const translate$2 = (origin, x, y)=>{
        const pos = SugarPosition(x, y);
        const removeScroll = ()=>{
            const outerScroll = get$b();
            return pos.translate(-outerScroll.left, -outerScroll.top);
        };
        return origin.fold(constant$1(pos), constant$1(pos), removeScroll);
    };
    const cata$1 = (subject, onNone, onRelative, onFixed)=>subject.fold(onNone, onRelative, onFixed)
    ;
    adt$9.none;
    const relative$1 = adt$9.relative;
    const fixed$11 = adt$9.fixed;
    const anchor1 = (anchorBox, origin)=>({
            anchorBox,
            origin
        })
    ;
    const box1 = (anchorBox, origin)=>anchor1(anchorBox, origin)
    ;
    const placementAttribute = 'data-alloy-placement';
    const setPlacement$1 = (element, placement)=>{
        set$9(element, placementAttribute, placement);
    };
    const getPlacement = (element)=>getOpt1(element, placementAttribute)
    ;
    const reset$2 = (element)=>remove$7(element, placementAttribute)
    ;
    const adt$8 = Adt.generate([
        {
            fit: [
                'reposition'
            ]
        },
        {
            nofit: [
                'reposition',
                'visibleW',
                'visibleH',
                'isVisible'
            ]
        }
    ]);
    const determinePosition = (box, bounds)=>{
        const { x: boundsX , y: boundsY , right: boundsRight , bottom: boundsBottom  } = bounds;
        const { x , y , right , bottom , width , height  } = box;
        const xInBounds = x >= boundsX && x <= boundsRight;
        const yInBounds = y >= boundsY && y <= boundsBottom;
        const originInBounds = xInBounds && yInBounds;
        const rightInBounds = right <= boundsRight && right >= boundsX;
        const bottomInBounds = bottom <= boundsBottom && bottom >= boundsY;
        const sizeInBounds = rightInBounds && bottomInBounds;
        const visibleW = Math.min(width, x >= boundsX ? boundsRight - x : right - boundsX);
        const visibleH = Math.min(height, y >= boundsY ? boundsBottom - y : bottom - boundsY);
        return {
            originInBounds,
            sizeInBounds,
            visibleW,
            visibleH
        };
    };
    const calcReposition = (box, bounds$1)=>{
        const { x: boundsX , y: boundsY , right: boundsRight , bottom: boundsBottom  } = bounds$1;
        const { x , y , width , height  } = box;
        const maxX = Math.max(boundsX, boundsRight - width);
        const maxY = Math.max(boundsY, boundsBottom - height);
        const restrictedX = clamp(x, boundsX, maxX);
        const restrictedY = clamp(y, boundsY, maxY);
        const restrictedWidth = Math.min(restrictedX + width, boundsRight) - restrictedX;
        const restrictedHeight = Math.min(restrictedY + height, boundsBottom) - restrictedY;
        return bounds1(restrictedX, restrictedY, restrictedWidth, restrictedHeight);
    };
    const calcMaxSizes = (direction, box, bounds)=>{
        const upAvailable = constant$1(box.bottom - bounds.y);
        const downAvailable = constant$1(bounds.bottom - box.y);
        const maxHeight = cataVertical(direction, downAvailable, downAvailable, upAvailable);
        const westAvailable = constant$1(box.right - bounds.x);
        const eastAvailable = constant$1(bounds.right - box.x);
        const maxWidth = cataHorizontal(direction, eastAvailable, eastAvailable, westAvailable);
        return {
            maxWidth,
            maxHeight
        };
    };
    const attempt = (candidate, width, height, bounds$1)=>{
        const bubble = candidate.bubble;
        const bubbleOffset = bubble.offset;
        const adjustedBounds = adjustBounds(bounds$1, candidate.restriction, bubbleOffset);
        const newX = candidate.x + bubbleOffset.left;
        const newY = candidate.y + bubbleOffset.top;
        const box = bounds1(newX, newY, width, height);
        const { originInBounds , sizeInBounds , visibleW , visibleH  } = determinePosition(box, adjustedBounds);
        const fits = originInBounds && sizeInBounds;
        const fittedBox = fits ? box : calcReposition(box, adjustedBounds);
        const isPartlyVisible = fittedBox.width > 0 && fittedBox.height > 0;
        const { maxWidth , maxHeight  } = calcMaxSizes(candidate.direction, fittedBox, bounds$1);
        const reposition = {
            rect: fittedBox,
            maxHeight,
            maxWidth,
            direction: candidate.direction,
            placement: candidate.placement,
            classes: {
                on: bubble.classesOn,
                off: bubble.classesOff
            },
            layout: candidate.label,
            testY: newY
        };
        return fits || candidate.alwaysFit ? adt$8.fit(reposition) : adt$8.nofit(reposition, visibleW, visibleH, isPartlyVisible);
    };
    const attempts = (element, candidates, anchorBox, elementBox, bubbles, bounds)=>{
        const panelWidth = elementBox.width;
        const panelHeight = elementBox.height;
        const attemptBestFit = (layout, reposition, visibleW, visibleH, isVisible)=>{
            const next = layout(anchorBox, elementBox, bubbles, element, bounds);
            const attemptLayout = attempt(next, panelWidth, panelHeight, bounds);
            return attemptLayout.fold(constant$1(attemptLayout), (newReposition, newVisibleW, newVisibleH, newIsVisible)=>{
                const improved = isVisible === newIsVisible ? newVisibleH > visibleH || newVisibleW > visibleW : !isVisible && newIsVisible;
                return improved ? attemptLayout : adt$8.nofit(reposition, visibleW, visibleH, isVisible);
            });
        };
        const abc = foldl(candidates, (b, a)=>{
            const bestNext = curry(attemptBestFit, a);
            return b.fold(constant$1(b), bestNext);
        }, adt$8.nofit({
            rect: anchorBox,
            maxHeight: elementBox.height,
            maxWidth: elementBox.width,
            direction: southeast$3(),
            placement: 'southeast',
            classes: {
                on: [],
                off: []
            },
            layout: 'none',
            testY: anchorBox.y
        }, -1, -1, false));
        return abc.fold(identity, identity);
    };
    const singleton1 = (doRevoke)=>{
        const subject = Cell(Optional.none());
        const revoke = ()=>subject.get().each(doRevoke)
        ;
        const clear = ()=>{
            revoke();
            subject.set(Optional.none());
        };
        const isSet = ()=>subject.get().isSome()
        ;
        const get = ()=>subject.get()
        ;
        const set = (s)=>{
            revoke();
            subject.set(Optional.some(s));
        };
        return {
            clear,
            isSet,
            get,
            set
        };
    };
    const destroyable = ()=>singleton1((s)=>s.destroy()
        )
    ;
    const unbindable = ()=>singleton1((s)=>s.unbind()
        )
    ;
    const value$2 = ()=>{
        const subject = singleton1(noop);
        const on = (f)=>subject.get().each(f)
        ;
        return {
            ...subject,
            on
        };
    };
    const filter1 = always;
    const bind1 = (element, event, handler)=>bind$2(element, event, filter1, handler)
    ;
    const capture = (element, event, handler)=>capture$1(element, event, filter1, handler)
    ;
    const fromRawEvent = fromRawEvent$1;
    const properties1 = [
        'top',
        'bottom',
        'right',
        'left'
    ];
    const timerAttr = 'data-alloy-transition-timer';
    const isTransitioning$1 = (element, transition)=>hasAll(element, transition.classes)
    ;
    const shouldApplyTransitionCss = (transition, decision, lastPlacement)=>{
        return lastPlacement.exists((placer)=>{
            const mode = transition.mode;
            return mode === 'all' ? true : placer[mode] !== decision[mode];
        });
    };
    const hasChanges = (position, intermediate)=>{
        const round = (value)=>parseFloat(value).toFixed(3)
        ;
        return find$4(intermediate, (value, key)=>{
            const newValue = position[key].map(round);
            const val = value.map(round);
            return !equals(newValue, val);
        }).isSome();
    };
    const getTransitionDuration = (element)=>{
        const get = (name)=>{
            const style = get$e(element, name);
            const times = style.split(/\s*,\s*/);
            return filter$2(times, isNotEmpty);
        };
        const parse = (value)=>{
            if (isString(value) && /^[\d.]+/.test(value)) {
                const num = parseFloat(value);
                return endsWith(value, 'ms') ? num : num * 1000;
            } else return 0;
        };
        const delay = get('transition-delay');
        const duration = get('transition-duration');
        return foldl(duration, (acc, dur, i)=>{
            const time = parse(delay[i]) + parse(dur);
            return Math.max(acc, time);
        }, 0);
    };
    const setupTransitionListeners = (element, transition)=>{
        const transitionEnd = unbindable();
        const transitionCancel = unbindable();
        let timer;
        const isSourceTransition = (e)=>{
            var _a;
            const pseudoElement = (_a = e.raw.pseudoElement) !== null && _a !== void 0 ? _a : '';
            return eq(e.target, element) && isEmpty(pseudoElement) && contains$2(properties1, e.raw.propertyName);
        };
        const transitionDone = (e)=>{
            if (isNullable(e) || isSourceTransition(e)) {
                transitionEnd.clear();
                transitionCancel.clear();
                const type = e === null || e === void 0 ? void 0 : e.raw.type;
                if (isNullable(type) || type === transitionend()) {
                    clearTimeout(timer);
                    remove$7(element, timerAttr);
                    remove$1(element, transition.classes);
                }
            }
        };
        const transitionStart = bind1(element, transitionstart(), (e)=>{
            if (isSourceTransition(e)) {
                transitionStart.unbind();
                transitionEnd.set(bind1(element, transitionend(), transitionDone));
                transitionCancel.set(bind1(element, transitioncancel(), transitionDone));
            }
        });
        const duration = getTransitionDuration(element);
        requestAnimationFrame(()=>{
            timer = setTimeout(transitionDone, duration + 17);
            set$9(element, timerAttr, timer);
        });
    };
    const startTransitioning = (element, transition)=>{
        add$1(element, transition.classes);
        getOpt1(element, timerAttr).each((timerId)=>{
            clearTimeout(parseInt(timerId, 10));
            remove$7(element, timerAttr);
        });
        setupTransitionListeners(element, transition);
    };
    const applyTransitionCss = (element, origin, position, transition, decision, lastPlacement)=>{
        const shouldTransition = shouldApplyTransitionCss(transition, decision, lastPlacement);
        if (shouldTransition || isTransitioning$1(element, transition)) {
            set$8(element, 'position', position.position);
            const rect = toBox(origin, element);
            const intermediatePosition = reposition1(origin, {
                ...decision,
                rect
            });
            const intermediateCssOptions = mapToObject(properties1, (prop)=>intermediatePosition[prop]
            );
            if (hasChanges(position, intermediateCssOptions)) {
                setOptions(element, intermediateCssOptions);
                if (shouldTransition) startTransitioning(element, transition);
                reflow(element);
            }
        } else remove$1(element, transition.classes);
    };
    const elementSize = (p)=>({
            width: getOuter$1(p),
            height: getOuter$2(p)
        })
    ;
    const layout1 = (anchorBox, element, bubbles, options)=>{
        remove$6(element, 'max-height');
        remove$6(element, 'max-width');
        const elementBox = elementSize(element);
        return attempts(element, options.preference, anchorBox, elementBox, bubbles, options.bounds);
    };
    const setClasses = (element, decision)=>{
        const classInfo = decision.classes;
        remove$1(element, classInfo.off);
        add$1(element, classInfo.on);
    };
    const setHeight = (element, decision, options)=>{
        const maxHeightFunction = options.maxHeightFunction;
        maxHeightFunction(element, decision.maxHeight);
    };
    const setWidth = (element, decision, options)=>{
        const maxWidthFunction = options.maxWidthFunction;
        maxWidthFunction(element, decision.maxWidth);
    };
    const position$2 = (element, decision, options)=>{
        const positionCss = reposition1(options.origin, decision);
        options.transition.each((transition)=>{
            applyTransitionCss(element, options.origin, positionCss, transition, decision, options.lastPlacement);
        });
        applyPositionCss(element, positionCss);
    };
    const setPlacement = (element, decision)=>{
        setPlacement$1(element, decision.placement);
    };
    const setMaxHeight = (element, maxHeight)=>{
        setMax$1(element, Math.floor(maxHeight));
    };
    const anchored = constant$1((element, available)=>{
        setMaxHeight(element, available);
        setAll(element, {
            'overflow-x': 'hidden',
            'overflow-y': 'auto'
        });
    });
    const expandable$1 = constant$1((element, available)=>{
        setMaxHeight(element, available);
    });
    const defaultOr = (options, key, dephault)=>options[key] === undefined ? dephault : options[key]
    ;
    const simple = (anchor, element, bubble, layouts, lastPlacement, getBounds, overrideOptions, transition)=>{
        const maxHeightFunction = defaultOr(overrideOptions, 'maxHeightFunction', anchored());
        const maxWidthFunction = defaultOr(overrideOptions, 'maxWidthFunction', noop);
        const anchorBox = anchor.anchorBox;
        const origin = anchor.origin;
        const options = {
            bounds: viewport1(origin, getBounds),
            origin,
            preference: layouts,
            maxHeightFunction,
            maxWidthFunction,
            lastPlacement,
            transition
        };
        return go1(anchorBox, element, bubble, options);
    };
    const go1 = (anchorBox, element, bubble, options)=>{
        const decision = layout1(anchorBox, element, bubble, options);
        position$2(element, decision, options);
        setPlacement(element, decision);
        setClasses(element, decision);
        setHeight(element, decision, options);
        setWidth(element, decision, options);
        return {
            layout: decision.layout,
            placement: decision.placement
        };
    };
    const allAlignments = [
        'valignCentre',
        'alignLeft',
        'alignRight',
        'alignCentre',
        'top',
        'bottom',
        'left',
        'right',
        'inset'
    ];
    const nu$5 = (xOffset, yOffset, classes, insetModifier = 1)=>{
        const insetXOffset = xOffset * insetModifier;
        const insetYOffset = yOffset * insetModifier;
        const getClasses = (prop)=>get$g(classes, prop).getOr([])
        ;
        const make = (xDelta, yDelta, alignmentsOn)=>{
            const alignmentsOff = difference(allAlignments, alignmentsOn);
            return {
                offset: SugarPosition(xDelta, yDelta),
                classesOn: bind$3(alignmentsOn, getClasses),
                classesOff: bind$3(alignmentsOff, getClasses)
            };
        };
        return {
            southeast: ()=>make(-xOffset, yOffset, [
                    'top',
                    'alignLeft'
                ])
            ,
            southwest: ()=>make(xOffset, yOffset, [
                    'top',
                    'alignRight'
                ])
            ,
            south: ()=>make(-xOffset / 2, yOffset, [
                    'top',
                    'alignCentre'
                ])
            ,
            northeast: ()=>make(-xOffset, -yOffset, [
                    'bottom',
                    'alignLeft'
                ])
            ,
            northwest: ()=>make(xOffset, -yOffset, [
                    'bottom',
                    'alignRight'
                ])
            ,
            north: ()=>make(-xOffset / 2, -yOffset, [
                    'bottom',
                    'alignCentre'
                ])
            ,
            east: ()=>make(xOffset, -yOffset / 2, [
                    'valignCentre',
                    'left'
                ])
            ,
            west: ()=>make(-xOffset, -yOffset / 2, [
                    'valignCentre',
                    'right'
                ])
            ,
            insetNortheast: ()=>make(insetXOffset, insetYOffset, [
                    'top',
                    'alignLeft',
                    'inset'
                ])
            ,
            insetNorthwest: ()=>make(-insetXOffset, insetYOffset, [
                    'top',
                    'alignRight',
                    'inset'
                ])
            ,
            insetNorth: ()=>make(-insetXOffset / 2, insetYOffset, [
                    'top',
                    'alignCentre',
                    'inset'
                ])
            ,
            insetSoutheast: ()=>make(insetXOffset, -insetYOffset, [
                    'bottom',
                    'alignLeft',
                    'inset'
                ])
            ,
            insetSouthwest: ()=>make(-insetXOffset, -insetYOffset, [
                    'bottom',
                    'alignRight',
                    'inset'
                ])
            ,
            insetSouth: ()=>make(-insetXOffset / 2, -insetYOffset, [
                    'bottom',
                    'alignCentre',
                    'inset'
                ])
            ,
            insetEast: ()=>make(-insetXOffset, -insetYOffset / 2, [
                    'valignCentre',
                    'right',
                    'inset'
                ])
            ,
            insetWest: ()=>make(insetXOffset, -insetYOffset / 2, [
                    'valignCentre',
                    'left',
                    'inset'
                ])
        };
    };
    const fallback1 = ()=>nu$5(0, 0, {})
    ;
    const nu$4 = identity;
    const onDirection = (isLtr, isRtl)=>(element)=>getDirection(element) === 'rtl' ? isRtl : isLtr
    ;
    const getDirection = (element)=>get$e(element, 'direction') === 'rtl' ? 'rtl' : 'ltr'
    ;
    var AttributeValue1;
    (function(AttributeValue) {
        AttributeValue['TopToBottom'] = 'toptobottom';
        AttributeValue['BottomToTop'] = 'bottomtotop';
    })(AttributeValue1 || (AttributeValue1 = {}));
    const Attribute = 'data-alloy-vertical-dir';
    const isBottomToTopDir = (el)=>closest$2(el, (current)=>isElement$1(current) && get$f(current, 'data-alloy-vertical-dir') === AttributeValue1.BottomToTop
        )
    ;
    const schema$y = ()=>optionObjOf('layouts', [
            required$1('onLtr'),
            required$1('onRtl'),
            option$3('onBottomLtr'),
            option$3('onBottomRtl')
        ])
    ;
    const get$5 = (elem, info, defaultLtr, defaultRtl, defaultBottomLtr, defaultBottomRtl, dirElement)=>{
        const isBottomToTop = dirElement.map(isBottomToTopDir).getOr(false);
        const customLtr = info.layouts.map((ls)=>ls.onLtr(elem)
        );
        const customRtl = info.layouts.map((ls)=>ls.onRtl(elem)
        );
        const ltr = isBottomToTop ? info.layouts.bind((ls)=>ls.onBottomLtr.map((f)=>f(elem)
            )
        ).or(customLtr).getOr(defaultBottomLtr) : customLtr.getOr(defaultLtr);
        const rtl = isBottomToTop ? info.layouts.bind((ls)=>ls.onBottomRtl.map((f)=>f(elem)
            )
        ).or(customRtl).getOr(defaultBottomRtl) : customRtl.getOr(defaultRtl);
        const f1 = onDirection(ltr, rtl);
        return f1(elem);
    };
    const placement$4 = (component, anchorInfo, origin)=>{
        const hotspot = anchorInfo.hotspot;
        const anchorBox = toBox(origin, hotspot.element);
        const layouts = get$5(component.element, anchorInfo, belowOrAbove(), belowOrAboveRtl(), aboveOrBelow(), aboveOrBelowRtl(), Optional.some(anchorInfo.hotspot.element));
        return Optional.some(nu$4({
            anchorBox,
            bubble: anchorInfo.bubble.getOr(fallback1()),
            overrides: anchorInfo.overrides,
            layouts,
            placer: Optional.none()
        }));
    };
    var HotspotAnchor = [
        required$1('hotspot'),
        option$3('bubble'),
        defaulted('overrides', {}),
        schema$y(),
        output$1('placement', placement$4)
    ];
    const placement$3 = (component, anchorInfo, origin)=>{
        const pos = translate$2(origin, anchorInfo.x, anchorInfo.y);
        const anchorBox = bounds1(pos.left, pos.top, anchorInfo.width, anchorInfo.height);
        const layouts = get$5(component.element, anchorInfo, all$1(), allRtl$1(), all$1(), allRtl$1(), Optional.none());
        return Optional.some(nu$4({
            anchorBox,
            bubble: anchorInfo.bubble,
            overrides: anchorInfo.overrides,
            layouts,
            placer: Optional.none()
        }));
    };
    var MakeshiftAnchor = [
        required$1('x'),
        required$1('y'),
        defaulted('height', 0),
        defaulted('width', 0),
        defaulted('bubble', fallback1()),
        defaulted('overrides', {}),
        schema$y(),
        output$1('placement', placement$3)
    ];
    const adt$7 = Adt.generate([
        {
            screen: [
                'point'
            ]
        },
        {
            absolute: [
                'point',
                'scrollLeft',
                'scrollTop'
            ]
        }
    ]);
    const toFixed = (pos)=>pos.fold(identity, (point, scrollLeft, scrollTop)=>point.translate(-scrollLeft, -scrollTop)
        )
    ;
    const toAbsolute = (pos)=>pos.fold(identity, identity)
    ;
    const sum = (points)=>foldl(points, (b, a)=>b.translate(a.left, a.top)
        , SugarPosition(0, 0))
    ;
    const sumAsFixed = (positions)=>{
        const points = map$2(positions, toFixed);
        return sum(points);
    };
    const sumAsAbsolute = (positions)=>{
        const points = map$2(positions, toAbsolute);
        return sum(points);
    };
    const screen = adt$7.screen;
    const absolute$1 = adt$7.absolute;
    const getOffset1 = (component, origin, anchorInfo)=>{
        const win = defaultView(anchorInfo.root).dom;
        const hasSameOwner = (frame)=>{
            const frameOwner = owner$4(frame);
            const compOwner = owner$4(component.element);
            return eq(frameOwner, compOwner);
        };
        return Optional.from(win.frameElement).map(SugarElement.fromDom).filter(hasSameOwner).map(absolute$3);
    };
    const getRootPoint = (component, origin, anchorInfo)=>{
        const doc = owner$4(component.element);
        const outerScroll = get$b(doc);
        const offset = getOffset1(component, origin, anchorInfo).getOr(outerScroll);
        return absolute$1(offset, outerScroll.left, outerScroll.top);
    };
    const getBox = (left, top, width, height)=>{
        const point = screen(SugarPosition(left, top));
        return Optional.some(pointed(point, width, height));
    };
    const calcNewAnchor = (optBox, rootPoint, anchorInfo, origin, elem)=>optBox.map((box)=>{
            const points = [
                rootPoint,
                box.point
            ];
            const topLeft = cata$1(origin, ()=>sumAsAbsolute(points)
            , ()=>sumAsAbsolute(points)
            , ()=>sumAsFixed(points)
            );
            const anchorBox = rect1(topLeft.left, topLeft.top, box.width, box.height);
            const layoutsLtr = anchorInfo.showAbove ? aboveOrBelow() : belowOrAbove();
            const layoutsRtl = anchorInfo.showAbove ? aboveOrBelowRtl() : belowOrAboveRtl();
            const layouts = get$5(elem, anchorInfo, layoutsLtr, layoutsRtl, layoutsLtr, layoutsRtl, Optional.none());
            return nu$4({
                anchorBox,
                bubble: anchorInfo.bubble.getOr(fallback1()),
                overrides: anchorInfo.overrides,
                layouts,
                placer: Optional.none()
            });
        })
    ;
    const placement$2 = (component, anchorInfo, origin)=>{
        const rootPoint = getRootPoint(component, origin, anchorInfo);
        return anchorInfo.node.filter(inBody).bind((target)=>{
            const rect = target.dom.getBoundingClientRect();
            const nodeBox = getBox(rect.left, rect.top, rect.width, rect.height);
            const elem = anchorInfo.node.getOr(component.element);
            return calcNewAnchor(nodeBox, rootPoint, anchorInfo, origin, elem);
        });
    };
    var NodeAnchor = [
        required$1('node'),
        required$1('root'),
        option$3('bubble'),
        schema$y(),
        defaulted('overrides', {}),
        defaulted('showAbove', false),
        output$1('placement', placement$2)
    ];
    const zeroWidth = '\uFEFF';
    const nbsp = '\xA0';
    const create$2 = (start, soffset, finish, foffset)=>({
            start,
            soffset,
            finish,
            foffset
        })
    ;
    const SimRange = {
        create: create$2
    };
    const adt$6 = Adt.generate([
        {
            before: [
                'element'
            ]
        },
        {
            on: [
                'element',
                'offset'
            ]
        },
        {
            after: [
                'element'
            ]
        }
    ]);
    const cata = (subject, onBefore, onOn, onAfter)=>subject.fold(onBefore, onOn, onAfter)
    ;
    const getStart$1 = (situ)=>situ.fold(identity, identity, identity)
    ;
    const before1 = adt$6.before;
    const on$1 = adt$6.on;
    const after$1 = adt$6.after;
    const Situ = {
        before: before1,
        on: on$1,
        after: after$1,
        cata,
        getStart: getStart$1
    };
    const adt$5 = Adt.generate([
        {
            domRange: [
                'rng'
            ]
        },
        {
            relative: [
                'startSitu',
                'finishSitu'
            ]
        },
        {
            exact: [
                'start',
                'soffset',
                'finish',
                'foffset'
            ]
        }
    ]);
    const exactFromRange = (simRange)=>adt$5.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset)
    ;
    const getStart = (selection)=>selection.match({
            domRange: (rng)=>SugarElement.fromDom(rng.startContainer)
            ,
            relative: (startSitu, _finishSitu)=>Situ.getStart(startSitu)
            ,
            exact: (start, _soffset, _finish, _foffset)=>start
        })
    ;
    const domRange = adt$5.domRange;
    const relative = adt$5.relative;
    const exact = adt$5.exact;
    const getWin = (selection)=>{
        const start = getStart(selection);
        return defaultView(start);
    };
    const range$1 = SimRange.create;
    const SimSelection = {
        domRange,
        relative,
        exact,
        exactFromRange,
        getWin,
        range: range$1
    };
    const setStart = (rng, situ)=>{
        situ.fold((e)=>{
            rng.setStartBefore(e.dom);
        }, (e, o)=>{
            rng.setStart(e.dom, o);
        }, (e)=>{
            rng.setStartAfter(e.dom);
        });
    };
    const setFinish = (rng, situ)=>{
        situ.fold((e)=>{
            rng.setEndBefore(e.dom);
        }, (e, o)=>{
            rng.setEnd(e.dom, o);
        }, (e)=>{
            rng.setEndAfter(e.dom);
        });
    };
    const relativeToNative = (win, startSitu, finishSitu)=>{
        const range = win.document.createRange();
        setStart(range, startSitu);
        setFinish(range, finishSitu);
        return range;
    };
    const exactToNative = (win, start, soffset, finish, foffset)=>{
        const rng = win.document.createRange();
        rng.setStart(start.dom, soffset);
        rng.setEnd(finish.dom, foffset);
        return rng;
    };
    const toRect = (rect)=>({
            left: rect.left,
            top: rect.top,
            right: rect.right,
            bottom: rect.bottom,
            width: rect.width,
            height: rect.height
        })
    ;
    const getFirstRect$1 = (rng)=>{
        const rects = rng.getClientRects();
        const rect = rects.length > 0 ? rects[0] : rng.getBoundingClientRect();
        return rect.width > 0 || rect.height > 0 ? Optional.some(rect).map(toRect) : Optional.none();
    };
    const getBounds$2 = (rng)=>{
        const rect = rng.getBoundingClientRect();
        return rect.width > 0 || rect.height > 0 ? Optional.some(rect).map(toRect) : Optional.none();
    };
    const adt$4 = Adt.generate([
        {
            ltr: [
                'start',
                'soffset',
                'finish',
                'foffset'
            ]
        },
        {
            rtl: [
                'start',
                'soffset',
                'finish',
                'foffset'
            ]
        }
    ]);
    const fromRange = (win, type, range)=>type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset)
    ;
    const getRanges = (win, selection)=>selection.match({
            domRange: (rng)=>{
                return {
                    ltr: constant$1(rng),
                    rtl: Optional.none
                };
            },
            relative: (startSitu, finishSitu)=>{
                return {
                    ltr: cached(()=>relativeToNative(win, startSitu, finishSitu)
                    ),
                    rtl: cached(()=>Optional.some(relativeToNative(win, finishSitu, startSitu))
                    )
                };
            },
            exact: (start, soffset, finish, foffset)=>{
                return {
                    ltr: cached(()=>exactToNative(win, start, soffset, finish, foffset)
                    ),
                    rtl: cached(()=>Optional.some(exactToNative(win, finish, foffset, start, soffset))
                    )
                };
            }
        })
    ;
    const doDiagnose = (win, ranges)=>{
        const rng = ranges.ltr();
        if (rng.collapsed) {
            const reversed = ranges.rtl().filter((rev)=>rev.collapsed === false
            );
            return reversed.map((rev)=>adt$4.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)
            ).getOrThunk(()=>fromRange(win, adt$4.ltr, rng)
            );
        } else return fromRange(win, adt$4.ltr, rng);
    };
    const diagnose = (win, selection)=>{
        const ranges = getRanges(win, selection);
        return doDiagnose(win, ranges);
    };
    const asLtrRange = (win, selection)=>{
        const diagnosis = diagnose(win, selection);
        return diagnosis.match({
            ltr: (start, soffset, finish, foffset)=>{
                const rng = win.document.createRange();
                rng.setStart(start.dom, soffset);
                rng.setEnd(finish.dom, foffset);
                return rng;
            },
            rtl: (start, soffset, finish, foffset)=>{
                const rng = win.document.createRange();
                rng.setStart(finish.dom, foffset);
                rng.setEnd(start.dom, soffset);
                return rng;
            }
        });
    };
    adt$4.ltr;
    adt$4.rtl;
    const descendants = (scope, selector)=>all$3(selector, scope)
    ;
    const makeRange = (start, soffset, finish, foffset)=>{
        const doc = owner$4(start);
        const rng = doc.dom.createRange();
        rng.setStart(start.dom, soffset);
        rng.setEnd(finish.dom, foffset);
        return rng;
    };
    const after1 = (start, soffset, finish, foffset)=>{
        const r = makeRange(start, soffset, finish, foffset);
        const same = eq(start, finish) && soffset === foffset;
        return r.collapsed && !same;
    };
    const getNativeSelection = (win)=>Optional.from(win.getSelection())
    ;
    const readRange = (selection)=>{
        if (selection.rangeCount > 0) {
            const firstRng = selection.getRangeAt(0);
            const lastRng = selection.getRangeAt(selection.rangeCount - 1);
            return Optional.some(SimRange.create(SugarElement.fromDom(firstRng.startContainer), firstRng.startOffset, SugarElement.fromDom(lastRng.endContainer), lastRng.endOffset));
        } else return Optional.none();
    };
    const doGetExact = (selection)=>{
        if (selection.anchorNode === null || selection.focusNode === null) return readRange(selection);
        else {
            const anchor = SugarElement.fromDom(selection.anchorNode);
            const focus = SugarElement.fromDom(selection.focusNode);
            return after1(anchor, selection.anchorOffset, focus, selection.focusOffset) ? Optional.some(SimRange.create(anchor, selection.anchorOffset, focus, selection.focusOffset)) : readRange(selection);
        }
    };
    const getExact = (win)=>getNativeSelection(win).filter((sel)=>sel.rangeCount > 0
        ).bind(doGetExact)
    ;
    const getFirstRect = (win, selection)=>{
        const rng = asLtrRange(win, selection);
        return getFirstRect$1(rng);
    };
    const getBounds$1 = (win, selection)=>{
        const rng = asLtrRange(win, selection);
        return getBounds$2(rng);
    };
    const NodeValue = (is, name)=>{
        const get = (element)=>{
            if (!is(element)) throw new Error('Can only get ' + name + ' value of a ' + name + ' node');
            return getOption(element).getOr('');
        };
        const getOption = (element)=>is(element) ? Optional.from(element.dom.nodeValue) : Optional.none()
        ;
        const set = (element, value)=>{
            if (!is(element)) throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');
            element.dom.nodeValue = value;
        };
        return {
            get,
            getOption,
            set
        };
    };
    const api1 = NodeValue(isText, 'text');
    const get$4 = (element)=>api1.get(element)
    ;
    const point1 = (element, offset)=>({
            element,
            offset
        })
    ;
    const descendOnce$1 = (element, offset)=>{
        const children$1 = children1(element);
        if (children$1.length === 0) return point1(element, offset);
        else if (offset < children$1.length) return point1(children$1[offset], 0);
        else {
            const last = children$1[children$1.length - 1];
            const len = isText(last) ? get$4(last).length : children1(last).length;
            return point1(last, len);
        }
    };
    const descendOnce = (element, offset)=>isText(element) ? point1(element, offset) : descendOnce$1(element, offset)
    ;
    const getAnchorSelection = (win, anchorInfo)=>{
        const getSelection = anchorInfo.getSelection.getOrThunk(()=>()=>getExact(win)
        );
        return getSelection().map((sel)=>{
            const modStart = descendOnce(sel.start, sel.soffset);
            const modFinish = descendOnce(sel.finish, sel.foffset);
            return SimSelection.range(modStart.element, modStart.offset, modFinish.element, modFinish.offset);
        });
    };
    const placement$1 = (component, anchorInfo, origin)=>{
        const win = defaultView(anchorInfo.root).dom;
        const rootPoint = getRootPoint(component, origin, anchorInfo);
        const selectionBox = getAnchorSelection(win, anchorInfo).bind((sel)=>{
            const optRect = getBounds$1(win, SimSelection.exactFromRange(sel)).orThunk(()=>{
                const x = SugarElement.fromText(zeroWidth);
                before$1(sel.start, x);
                const rect = getFirstRect(win, SimSelection.exact(x, 0, x, 1));
                remove$5(x);
                return rect;
            });
            return optRect.bind((rawRect)=>getBox(rawRect.left, rawRect.top, rawRect.width, rawRect.height)
            );
        });
        const targetElement = getAnchorSelection(win, anchorInfo).bind((sel)=>isElement$1(sel.start) ? Optional.some(sel.start) : parentElement(sel.start)
        );
        const elem = targetElement.getOr(component.element);
        return calcNewAnchor(selectionBox, rootPoint, anchorInfo, origin, elem);
    };
    var SelectionAnchor = [
        option$3('getSelection'),
        required$1('root'),
        option$3('bubble'),
        schema$y(),
        defaulted('overrides', {}),
        defaulted('showAbove', false),
        output$1('placement', placement$1)
    ];
    const labelPrefix$1 = 'link-layout';
    const eastX = (anchor)=>anchor.x + anchor.width
    ;
    const westX = (anchor, element)=>anchor.x - element.width
    ;
    const northY$1 = (anchor, element)=>anchor.y - element.height + anchor.height
    ;
    const southY$1 = (anchor)=>anchor.y
    ;
    const southeast$1 = (anchor, element, bubbles)=>nu$6(eastX(anchor), southY$1(anchor), bubbles.southeast(), southeast$3(), 'southeast', boundsRestriction1(anchor, {
            left: 0,
            top: 2
        }), labelPrefix$1)
    ;
    const southwest$1 = (anchor, element, bubbles)=>nu$6(westX(anchor, element), southY$1(anchor), bubbles.southwest(), southwest$3(), 'southwest', boundsRestriction1(anchor, {
            right: 1,
            top: 2
        }), labelPrefix$1)
    ;
    const northeast$1 = (anchor, element, bubbles)=>nu$6(eastX(anchor), northY$1(anchor, element), bubbles.northeast(), northeast$3(), 'northeast', boundsRestriction1(anchor, {
            left: 0,
            bottom: 3
        }), labelPrefix$1)
    ;
    const northwest$1 = (anchor, element, bubbles)=>nu$6(westX(anchor, element), northY$1(anchor, element), bubbles.northwest(), northwest$3(), 'northwest', boundsRestriction1(anchor, {
            right: 1,
            bottom: 3
        }), labelPrefix$1)
    ;
    const all1 = ()=>[
            southeast$1,
            southwest$1,
            northeast$1,
            northwest$1
        ]
    ;
    const allRtl = ()=>[
            southwest$1,
            southeast$1,
            northwest$1,
            northeast$1
        ]
    ;
    const placement1 = (component, submenuInfo, origin)=>{
        const anchorBox = toBox(origin, submenuInfo.item.element);
        const layouts = get$5(component.element, submenuInfo, all1(), allRtl(), all1(), allRtl(), Optional.none());
        return Optional.some(nu$4({
            anchorBox,
            bubble: fallback1(),
            overrides: submenuInfo.overrides,
            layouts,
            placer: Optional.none()
        }));
    };
    var SubmenuAnchor = [
        required$1('item'),
        schema$y(),
        defaulted('overrides', {}),
        output$1('placement', placement1)
    ];
    var AnchorSchema = choose$1('type', {
        selection: SelectionAnchor,
        node: NodeAnchor,
        hotspot: HotspotAnchor,
        submenu: SubmenuAnchor,
        makeshift: MakeshiftAnchor
    });
    const TransitionSchema = [
        requiredArrayOf('classes', string),
        defaultedStringEnum('mode', 'all', [
            'all',
            'layout',
            'placement'
        ])
    ];
    const PositionSchema = [
        defaulted('useFixed', never),
        option$3('getBounds')
    ];
    const PlacementSchema = [
        requiredOf('anchor', AnchorSchema),
        optionObjOf('transition', TransitionSchema)
    ];
    const getFixedOrigin = ()=>{
        const html = document.documentElement;
        return fixed$11(0, 0, html.clientWidth, html.clientHeight);
    };
    const getRelativeOrigin = (component)=>{
        const position = absolute$3(component.element);
        const bounds = component.element.dom.getBoundingClientRect();
        return relative$1(position.left, position.top, bounds.width, bounds.height);
    };
    const place = (component, origin, anchoring, getBounds, placee, lastPlace, transition)=>{
        const anchor = box1(anchoring.anchorBox, origin);
        return simple(anchor, placee.element, anchoring.bubble, anchoring.layouts, lastPlace, getBounds, anchoring.overrides, transition);
    };
    const position$1 = (component, posConfig, posState, placee, placementSpec)=>{
        positionWithin(component, posConfig, posState, placee, placementSpec, Optional.none());
    };
    const positionWithin = (component, posConfig, posState, placee, placementSpec, boxElement)=>{
        const boundsBox = boxElement.map(box$1);
        return positionWithinBounds(component, posConfig, posState, placee, placementSpec, boundsBox);
    };
    const positionWithinBounds = (component, posConfig, posState, placee, placementSpec, bounds)=>{
        const placeeDetail = asRawOrDie$1('placement.info', objOf(PlacementSchema), placementSpec);
        const anchorage = placeeDetail.anchor;
        const element = placee.element;
        const placeeState = posState.get(placee.uid);
        preserve$1(()=>{
            set$8(element, 'position', 'fixed');
            const oldVisibility = getRaw(element, 'visibility');
            set$8(element, 'visibility', 'hidden');
            const origin = posConfig.useFixed() ? getFixedOrigin() : getRelativeOrigin(component);
            const placer = anchorage.placement;
            const getBounds = bounds.map(constant$1).or(posConfig.getBounds);
            placer(component, anchorage, origin).each((anchoring)=>{
                const doPlace = anchoring.placer.getOr(place);
                const newState = doPlace(component, origin, anchoring, getBounds, placee, placeeState, placeeDetail.transition);
                posState.set(placee.uid, newState);
            });
            oldVisibility.fold(()=>{
                remove$6(element, 'visibility');
            }, (vis)=>{
                set$8(element, 'visibility', vis);
            });
            if (getRaw(element, 'left').isNone() && getRaw(element, 'top').isNone() && getRaw(element, 'right').isNone() && getRaw(element, 'bottom').isNone() && is$11(getRaw(element, 'position'), 'fixed')) remove$6(element, 'position');
        }, element);
    };
    const getMode = (component, pConfig, _pState)=>pConfig.useFixed() ? 'fixed' : 'absolute'
    ;
    const reset$1 = (component, pConfig, posState, placee)=>{
        const element = placee.element;
        each$1([
            'position',
            'left',
            'right',
            'top',
            'bottom'
        ], (prop)=>remove$6(element, prop)
        );
        reset$2(element);
        posState.clear(placee.uid);
    };
    var PositionApis = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        position: position$1,
        positionWithin: positionWithin,
        positionWithinBounds: positionWithinBounds,
        getMode: getMode,
        reset: reset$1
    });
    const init$g = ()=>{
        let state = {};
        const set = (id, data)=>{
            state[id] = data;
        };
        const get = (id)=>get$g(state, id)
        ;
        const clear = (id)=>{
            if (isNonNullable(id)) delete state[id];
            else state = {};
        };
        return nu$8({
            readState: ()=>state
            ,
            clear,
            set,
            get
        });
    };
    var PositioningState = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        init: init$g
    });
    const Positioning = create$3({
        fields: PositionSchema,
        name: 'positioning',
        active: ActivePosition,
        apis: PositionApis,
        state: PositioningState
    });
    const isConnected = (comp)=>comp.getSystem().isConnected()
    ;
    const fireDetaching = (component)=>{
        emit(component, detachedFromDom());
        const children = component.components();
        each$1(children, fireDetaching);
    };
    const fireAttaching = (component)=>{
        const children = component.components();
        each$1(children, fireAttaching);
        emit(component, attachedToDom());
    };
    const virtualAttach = (parent, child)=>{
        parent.getSystem().addToWorld(child);
        if (inBody(parent.element)) fireAttaching(child);
    };
    const virtualDetach = (comp)=>{
        fireDetaching(comp);
        comp.getSystem().removeFromWorld(comp);
    };
    const attach$1 = (parent, child)=>{
        append$2(parent.element, child.element);
    };
    const detachChildren$1 = (component)=>{
        each$1(component.components(), (childComp)=>remove$5(childComp.element)
        );
        empty(component.element);
        component.syncComponents();
    };
    const replaceChildren = (component, newSpecs, buildNewChildren)=>{
        const subs = component.components();
        detachChildren$1(component);
        const newChildren = buildNewChildren(newSpecs);
        const deleted = difference(subs, newChildren);
        each$1(deleted, (comp)=>{
            fireDetaching(comp);
            component.getSystem().removeFromWorld(comp);
        });
        each$1(newChildren, (childComp)=>{
            if (!isConnected(childComp)) {
                component.getSystem().addToWorld(childComp);
                attach$1(component, childComp);
                if (inBody(component.element)) fireAttaching(childComp);
            } else attach$1(component, childComp);
        });
        component.syncComponents();
    };
    const virtualReplaceChildren = (component, newSpecs, buildNewChildren)=>{
        const subs = component.components();
        const existingComps = bind$3(newSpecs, (spec)=>getPremade(spec).toArray()
        );
        each$1(subs, (childComp)=>{
            if (!contains$2(existingComps, childComp)) virtualDetach(childComp);
        });
        const newChildren = buildNewChildren(newSpecs);
        const deleted = difference(subs, newChildren);
        each$1(deleted, (deletedComp)=>{
            if (isConnected(deletedComp)) virtualDetach(deletedComp);
        });
        each$1(newChildren, (childComp)=>{
            if (!isConnected(childComp)) virtualAttach(component, childComp);
        });
        component.syncComponents();
    };
    const attach1 = (parent, child)=>{
        attachWith(parent, child, append$2);
    };
    const attachWith = (parent, child, insertion)=>{
        parent.getSystem().addToWorld(child);
        insertion(parent.element, child.element);
        if (inBody(parent.element)) fireAttaching(child);
        parent.syncComponents();
    };
    const doDetach = (component)=>{
        fireDetaching(component);
        remove$5(component.element);
        component.getSystem().removeFromWorld(component);
    };
    const detach = (component)=>{
        const parent$1 = parent1(component.element).bind((p)=>component.getSystem().getByDom(p).toOptional()
        );
        doDetach(component);
        parent$1.each((p)=>{
            p.syncComponents();
        });
    };
    const detachChildren = (component)=>{
        const subs = component.components();
        each$1(subs, doDetach);
        empty(component.element);
        component.syncComponents();
    };
    const attachSystem = (element, guiSystem)=>{
        attachSystemWith(element, guiSystem, append$2);
    };
    const attachSystemAfter = (element, guiSystem)=>{
        attachSystemWith(element, guiSystem, after$2);
    };
    const attachSystemWith = (element, guiSystem, inserter)=>{
        inserter(element, guiSystem.element);
        const children$1 = children1(guiSystem.element);
        each$1(children$1, (child)=>{
            guiSystem.getByDom(child).each(fireAttaching);
        });
    };
    const detachSystem = (guiSystem)=>{
        const children$1 = children1(guiSystem.element);
        each$1(children$1, (child)=>{
            guiSystem.getByDom(child).each(fireDetaching);
        });
        remove$5(guiSystem.element);
    };
    const rebuild = (sandbox, sConfig, sState, data)=>{
        sState.get().each((_data)=>{
            detachChildren(sandbox);
        });
        const point = sConfig.getAttachPoint(sandbox);
        attach1(point, sandbox);
        const built = sandbox.getSystem().build(data);
        attach1(sandbox, built);
        sState.set(built);
        return built;
    };
    const open$1 = (sandbox, sConfig, sState, data)=>{
        const newState = rebuild(sandbox, sConfig, sState, data);
        sConfig.onOpen(sandbox, newState);
        return newState;
    };
    const setContent1 = (sandbox, sConfig, sState, data)=>sState.get().map(()=>rebuild(sandbox, sConfig, sState, data)
        )
    ;
    const openWhileCloaked = (sandbox, sConfig, sState, data, transaction)=>{
        cloak(sandbox, sConfig);
        open$1(sandbox, sConfig, sState, data);
        transaction();
        decloak(sandbox, sConfig);
    };
    const close$1 = (sandbox, sConfig, sState)=>{
        sState.get().each((data)=>{
            detachChildren(sandbox);
            detach(sandbox);
            sConfig.onClose(sandbox, data);
            sState.clear();
        });
    };
    const isOpen$1 = (_sandbox, _sConfig, sState)=>sState.isOpen()
    ;
    const isPartOf = (sandbox, sConfig, sState, queryElem)=>isOpen$1(sandbox, sConfig, sState) && sState.get().exists((data)=>sConfig.isPartOf(sandbox, data, queryElem)
        )
    ;
    const getState$2 = (_sandbox, _sConfig, sState)=>sState.get()
    ;
    const store1 = (sandbox, cssKey, attr, newValue)=>{
        getRaw(sandbox.element, cssKey).fold(()=>{
            remove$7(sandbox.element, attr);
        }, (v)=>{
            set$9(sandbox.element, attr, v);
        });
        set$8(sandbox.element, cssKey, newValue);
    };
    const restore = (sandbox, cssKey, attr)=>{
        getOpt1(sandbox.element, attr).fold(()=>remove$6(sandbox.element, cssKey)
        , (oldValue)=>set$8(sandbox.element, cssKey, oldValue)
        );
    };
    const cloak = (sandbox, sConfig, _sState)=>{
        const sink = sConfig.getAttachPoint(sandbox);
        set$8(sandbox.element, 'position', Positioning.getMode(sink));
        store1(sandbox, 'visibility', sConfig.cloakVisibilityAttr, 'hidden');
    };
    const hasPosition = (element)=>exists([
            'top',
            'left',
            'right',
            'bottom'
        ], (pos)=>getRaw(element, pos).isSome()
        )
    ;
    const decloak = (sandbox, sConfig, _sState)=>{
        if (!hasPosition(sandbox.element)) remove$6(sandbox.element, 'position');
        restore(sandbox, 'visibility', sConfig.cloakVisibilityAttr);
    };
    var SandboxApis = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        cloak: cloak,
        decloak: decloak,
        open: open$1,
        openWhileCloaked: openWhileCloaked,
        close: close$1,
        isOpen: isOpen$1,
        isPartOf: isPartOf,
        getState: getState$2,
        setContent: setContent1
    });
    const events$g = (sandboxConfig, sandboxState)=>derive$2([
            run$1(sandboxClose(), (sandbox, _simulatedEvent)=>{
                close$1(sandbox, sandboxConfig, sandboxState);
            })
        ])
    ;
    var ActiveSandbox = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        events: events$g
    });
    var SandboxSchema = [
        onHandler('onOpen'),
        onHandler('onClose'),
        required$1('isPartOf'),
        required$1('getAttachPoint'),
        defaulted('cloakVisibilityAttr', 'data-precloak-visibility')
    ];
    const init$f = ()=>{
        const contents = value$2();
        const readState = constant$1('not-implemented');
        return nu$8({
            readState,
            isOpen: contents.isSet,
            clear: contents.clear,
            set: contents.set,
            get: contents.get
        });
    };
    var SandboxState = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        init: init$f
    });
    const Sandboxing = create$3({
        fields: SandboxSchema,
        name: 'sandboxing',
        active: ActiveSandbox,
        apis: SandboxApis,
        state: SandboxState
    });
    const dismissPopups = constant$1('dismiss.popups');
    const repositionPopups = constant$1('reposition.popups');
    const mouseReleased = constant$1('mouse.released');
    const schema$x = objOfOnly([
        defaulted('isExtraPart', never),
        optionObjOf('fireEventInstead', [
            defaulted('event', dismissRequested())
        ])
    ]);
    const receivingChannel$1 = (rawSpec)=>{
        const detail = asRawOrDie$1('Dismissal', schema$x, rawSpec);
        return {
            [dismissPopups()]: {
                schema: objOfOnly([
                    required$1('target')
                ]),
                onReceive: (sandbox, data)=>{
                    if (Sandboxing.isOpen(sandbox)) {
                        const isPart = Sandboxing.isPartOf(sandbox, data.target) || detail.isExtraPart(sandbox, data.target);
                        if (!isPart) detail.fireEventInstead.fold(()=>Sandboxing.close(sandbox)
                        , (fe)=>emit(sandbox, fe.event)
                        );
                    }
                }
            }
        };
    };
    const schema$w = objOfOnly([
        optionObjOf('fireEventInstead', [
            defaulted('event', repositionRequested())
        ]),
        requiredFunction('doReposition')
    ]);
    const receivingChannel = (rawSpec)=>{
        const detail = asRawOrDie$1('Reposition', schema$w, rawSpec);
        return {
            [repositionPopups()]: {
                onReceive: (sandbox)=>{
                    if (Sandboxing.isOpen(sandbox)) detail.fireEventInstead.fold(()=>detail.doReposition(sandbox)
                    , (fe)=>emit(sandbox, fe.event)
                    );
                }
            }
        };
    };
    const onLoad$5 = (component, repConfig, repState)=>{
        repConfig.store.manager.onLoad(component, repConfig, repState);
    };
    const onUnload$2 = (component, repConfig, repState)=>{
        repConfig.store.manager.onUnload(component, repConfig, repState);
    };
    const setValue$3 = (component, repConfig, repState, data)=>{
        repConfig.store.manager.setValue(component, repConfig, repState, data);
    };
    const getValue$3 = (component, repConfig, repState)=>repConfig.store.manager.getValue(component, repConfig, repState)
    ;
    const getState$1 = (component, repConfig, repState)=>repState
    ;
    var RepresentApis = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        onLoad: onLoad$5,
        onUnload: onUnload$2,
        setValue: setValue$3,
        getValue: getValue$3,
        getState: getState$1
    });
    const events$f = (repConfig, repState)=>{
        const es = repConfig.resetOnDom ? [
            runOnAttached((comp, _se)=>{
                onLoad$5(comp, repConfig, repState);
            }),
            runOnDetached((comp, _se)=>{
                onUnload$2(comp, repConfig, repState);
            })
        ] : [
            loadEvent(repConfig, repState, onLoad$5)
        ];
        return derive$2(es);
    };
    var ActiveRepresenting = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        events: events$f
    });
    const memory$1 = ()=>{
        const data = Cell(null);
        const readState = ()=>({
                mode: 'memory',
                value: data.get()
            })
        ;
        const isNotSet = ()=>data.get() === null
        ;
        const clear = ()=>{
            data.set(null);
        };
        return nu$8({
            set: data.set,
            get: data.get,
            isNotSet,
            clear,
            readState
        });
    };
    const manual = ()=>{
        const readState = noop;
        return nu$8({
            readState
        });
    };
    const dataset1 = ()=>{
        const dataByValue = Cell({});
        const dataByText = Cell({});
        const readState = ()=>({
                mode: 'dataset',
                dataByValue: dataByValue.get(),
                dataByText: dataByText.get()
            })
        ;
        const clear = ()=>{
            dataByValue.set({});
            dataByText.set({});
        };
        const lookup = (itemString)=>get$g(dataByValue.get(), itemString).orThunk(()=>get$g(dataByText.get(), itemString)
            )
        ;
        const update = (items)=>{
            const currentDataByValue = dataByValue.get();
            const currentDataByText = dataByText.get();
            const newDataByValue = {};
            const newDataByText = {};
            each$1(items, (item)=>{
                newDataByValue[item.value] = item;
                get$g(item, 'meta').each((meta)=>{
                    get$g(meta, 'text').each((text)=>{
                        newDataByText[text] = item;
                    });
                });
            });
            dataByValue.set({
                ...currentDataByValue,
                ...newDataByValue
            });
            dataByText.set({
                ...currentDataByText,
                ...newDataByText
            });
        };
        return nu$8({
            readState,
            lookup,
            update,
            clear
        });
    };
    const init$e = (spec)=>spec.store.manager.state(spec)
    ;
    var RepresentState = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        memory: memory$1,
        dataset: dataset1,
        manual: manual,
        init: init$e
    });
    const setValue$2 = (component, repConfig, repState, data)=>{
        const store = repConfig.store;
        repState.update([
            data
        ]);
        store.setValue(component, data);
        repConfig.onSetValue(component, data);
    };
    const getValue$2 = (component, repConfig, repState)=>{
        const store = repConfig.store;
        const key = store.getDataKey(component);
        return repState.lookup(key).getOrThunk(()=>store.getFallbackEntry(key)
        );
    };
    const onLoad$4 = (component, repConfig, repState)=>{
        const store = repConfig.store;
        store.initialValue.each((data)=>{
            setValue$2(component, repConfig, repState, data);
        });
    };
    const onUnload$1 = (component, repConfig, repState)=>{
        repState.clear();
    };
    var DatasetStore = [
        option$3('initialValue'),
        required$1('getFallbackEntry'),
        required$1('getDataKey'),
        required$1('setValue'),
        output$1('manager', {
            setValue: setValue$2,
            getValue: getValue$2,
            onLoad: onLoad$4,
            onUnload: onUnload$1,
            state: dataset1
        })
    ];
    const getValue$1 = (component, repConfig, _repState)=>repConfig.store.getValue(component)
    ;
    const setValue$1 = (component, repConfig, _repState, data)=>{
        repConfig.store.setValue(component, data);
        repConfig.onSetValue(component, data);
    };
    const onLoad$3 = (component, repConfig, _repState)=>{
        repConfig.store.initialValue.each((data)=>{
            repConfig.store.setValue(component, data);
        });
    };
    var ManualStore = [
        required$1('getValue'),
        defaulted('setValue', noop),
        option$3('initialValue'),
        output$1('manager', {
            setValue: setValue$1,
            getValue: getValue$1,
            onLoad: onLoad$3,
            onUnload: noop,
            state: NoState.init
        })
    ];
    const setValue1 = (component, repConfig, repState, data)=>{
        repState.set(data);
        repConfig.onSetValue(component, data);
    };
    const getValue = (component, repConfig, repState)=>repState.get()
    ;
    const onLoad$2 = (component, repConfig, repState)=>{
        repConfig.store.initialValue.each((initVal)=>{
            if (repState.isNotSet()) repState.set(initVal);
        });
    };
    const onUnload = (component, repConfig, repState)=>{
        repState.clear();
    };
    var MemoryStore = [
        option$3('initialValue'),
        output$1('manager', {
            setValue: setValue1,
            getValue,
            onLoad: onLoad$2,
            onUnload,
            state: memory$1
        })
    ];
    var RepresentSchema = [
        defaultedOf('store', {
            mode: 'memory'
        }, choose$1('mode', {
            memory: MemoryStore,
            manual: ManualStore,
            dataset: DatasetStore
        })),
        onHandler('onSetValue'),
        defaulted('resetOnDom', false)
    ];
    const Representing = create$3({
        fields: RepresentSchema,
        name: 'representing',
        active: ActiveRepresenting,
        apis: RepresentApis,
        extra: {
            setValueFrom: (component, source)=>{
                const value = Representing.getValue(source);
                Representing.setValue(component, value);
            }
        },
        state: RepresentState
    });
    const field1 = (name, forbidden)=>defaultedObjOf(name, {}, map$2(forbidden, (f)=>forbid(f.name(), 'Cannot configure ' + f.name() + ' for ' + name)
        ).concat([
            customField('dump', identity)
        ]))
    ;
    const get$3 = (data)=>data.dump
    ;
    const augment = (data, original)=>({
            ...derive$1(original),
            ...data.dump
        })
    ;
    const SketchBehaviours = {
        field: field1,
        augment,
        get: get$3
    };
    const _placeholder = 'placeholder';
    const adt$3 = Adt.generate([
        {
            single: [
                'required',
                'valueThunk'
            ]
        },
        {
            multiple: [
                'required',
                'valueThunks'
            ]
        }
    ]);
    const isSubstituted = (spec)=>has$2(spec, 'uiType')
    ;
    const subPlaceholder = (owner, detail, compSpec, placeholders)=>{
        if (owner.exists((o)=>o !== compSpec.owner
        )) return adt$3.single(true, constant$1(compSpec));
        return get$g(placeholders, compSpec.name).fold(()=>{
            throw new Error('Unknown placeholder component: ' + compSpec.name + '\nKnown: [' + keys1(placeholders) + ']\nNamespace: ' + owner.getOr('none') + '\nSpec: ' + JSON.stringify(compSpec, null, 2));
        }, (newSpec)=>newSpec.replace()
        );
    };
    const scan = (owner, detail, compSpec, placeholders)=>{
        if (isSubstituted(compSpec) && compSpec.uiType === _placeholder) return subPlaceholder(owner, detail, compSpec, placeholders);
        else return adt$3.single(false, constant$1(compSpec));
    };
    const substitute = (owner, detail, compSpec, placeholders)=>{
        const base = scan(owner, detail, compSpec, placeholders);
        return base.fold((req, valueThunk)=>{
            const value = isSubstituted(compSpec) ? valueThunk(detail, compSpec.config, compSpec.validated) : valueThunk(detail);
            const childSpecs = get$g(value, 'components').getOr([]);
            const substituted = bind$3(childSpecs, (c)=>substitute(owner, detail, c, placeholders)
            );
            return [
                {
                    ...value,
                    components: substituted
                }
            ];
        }, (req, valuesThunk)=>{
            if (isSubstituted(compSpec)) {
                const values = valuesThunk(detail, compSpec.config, compSpec.validated);
                const preprocessor = compSpec.validated.preprocess.getOr(identity);
                return preprocessor(values);
            } else return valuesThunk(detail);
        });
    };
    const substituteAll = (owner, detail, components, placeholders)=>bind$3(components, (c)=>substitute(owner, detail, c, placeholders)
        )
    ;
    const oneReplace = (label, replacements)=>{
        let called = false;
        const used = ()=>called
        ;
        const replace = ()=>{
            if (called) throw new Error('Trying to use the same placeholder more than once: ' + label);
            called = true;
            return replacements;
        };
        const required = ()=>replacements.fold((req, _)=>req
            , (req, _)=>req
            )
        ;
        return {
            name: constant$1(label),
            required,
            used,
            replace
        };
    };
    const substitutePlaces = (owner, detail, components, placeholders)=>{
        const ps = map$1(placeholders, (ph, name)=>oneReplace(name, ph)
        );
        const outcome = substituteAll(owner, detail, components, ps);
        each(ps, (p)=>{
            if (p.used() === false && p.required()) throw new Error('Placeholder: ' + p.name() + ' was not found in components list\nNamespace: ' + owner.getOr('none') + '\nComponents: ' + JSON.stringify(detail.components, null, 2));
        });
        return outcome;
    };
    const single$2 = adt$3.single;
    const multiple = adt$3.multiple;
    const placeholder1 = constant$1(_placeholder);
    const adt$2 = Adt.generate([
        {
            required: [
                'data'
            ]
        },
        {
            external: [
                'data'
            ]
        },
        {
            optional: [
                'data'
            ]
        },
        {
            group: [
                'data'
            ]
        }
    ]);
    const fFactory = defaulted('factory', {
        sketch: identity
    });
    const fSchema = defaulted('schema', []);
    const fName = required$1('name');
    const fPname = field$1('pname', 'pname', defaultedThunk((typeSpec)=>'<alloy.' + generate$6(typeSpec.name) + '>'
    ), anyValue());
    const fGroupSchema = customField('schema', ()=>[
            option$3('preprocess')
        ]
    );
    const fDefaults = defaulted('defaults', constant$1({}));
    const fOverrides = defaulted('overrides', constant$1({}));
    const requiredSpec = objOf([
        fFactory,
        fSchema,
        fName,
        fPname,
        fDefaults,
        fOverrides
    ]);
    const externalSpec = objOf([
        fFactory,
        fSchema,
        fName,
        fDefaults,
        fOverrides
    ]);
    const optionalSpec = objOf([
        fFactory,
        fSchema,
        fName,
        fPname,
        fDefaults,
        fOverrides
    ]);
    const groupSpec = objOf([
        fFactory,
        fGroupSchema,
        fName,
        required$1('unit'),
        fPname,
        fDefaults,
        fOverrides
    ]);
    const asNamedPart = (part)=>{
        return part.fold(Optional.some, Optional.none, Optional.some, Optional.some);
    };
    const name$2 = (part)=>{
        const get = (data)=>data.name
        ;
        return part.fold(get, get, get, get);
    };
    const asCommon = (part)=>{
        return part.fold(identity, identity, identity, identity);
    };
    const convert = (adtConstructor, partSchema)=>(spec)=>{
            const data = asRawOrDie$1('Converting part type', partSchema, spec);
            return adtConstructor(data);
        }
    ;
    const required1 = convert(adt$2.required, requiredSpec);
    const external = convert(adt$2.external, externalSpec);
    const optional1 = convert(adt$2.optional, optionalSpec);
    const group1 = convert(adt$2.group, groupSpec);
    const original1 = constant$1('entirety');
    var PartType = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        required: required1,
        external: external,
        optional: optional1,
        group: group1,
        asNamedPart: asNamedPart,
        name: name$2,
        asCommon: asCommon,
        original: original1
    });
    const combine = (detail, data, partSpec, partValidated)=>deepMerge(data.defaults(detail, partSpec, partValidated), partSpec, {
            uid: detail.partUids[data.name]
        }, data.overrides(detail, partSpec, partValidated))
    ;
    const subs1 = (owner, detail1, parts)=>{
        const internals = {};
        const externals = {};
        each$1(parts, (part)=>{
            part.fold((data)=>{
                internals[data.pname] = single$2(true, (detail, partSpec, partValidated)=>data.factory.sketch(combine(detail, data, partSpec, partValidated))
                );
            }, (data)=>{
                const partSpec = detail1.parts[data.name];
                externals[data.name] = constant$1(data.factory.sketch(combine(detail1, data, partSpec[original1()]), partSpec));
            }, (data)=>{
                internals[data.pname] = single$2(false, (detail, partSpec, partValidated)=>data.factory.sketch(combine(detail, data, partSpec, partValidated))
                );
            }, (data)=>{
                internals[data.pname] = multiple(true, (detail, _partSpec, _partValidated)=>{
                    const units = detail[data.name];
                    return map$2(units, (u)=>data.factory.sketch(deepMerge(data.defaults(detail, u, _partValidated), u, data.overrides(detail, u)))
                    );
                });
            });
        });
        return {
            internals: constant$1(internals),
            externals: constant$1(externals)
        };
    };
    const generate$3 = (owner, parts)=>{
        const r = {};
        each$1(parts, (part)=>{
            asNamedPart(part).each((np)=>{
                const g = doGenerateOne(owner, np.pname);
                r[np.name] = (config)=>{
                    const validated = asRawOrDie$1('Part: ' + np.name + ' in ' + owner, objOf(np.schema), config);
                    return {
                        ...g,
                        config,
                        validated
                    };
                };
            });
        });
        return r;
    };
    const doGenerateOne = (owner, pname)=>({
            uiType: placeholder1(),
            owner,
            name: pname
        })
    ;
    const generateOne$1 = (owner, pname, config)=>({
            uiType: placeholder1(),
            owner,
            name: pname,
            config,
            validated: {}
        })
    ;
    const schemas = (parts)=>bind$3(parts, (part)=>part.fold(Optional.none, Optional.some, Optional.none, Optional.none).map((data)=>requiredObjOf(data.name, data.schema.concat([
                    snapshot(original1())
                ]))
            ).toArray()
        )
    ;
    const names = (parts)=>map$2(parts, name$2)
    ;
    const substitutes = (owner, detail, parts)=>subs1(owner, detail, parts)
    ;
    const components$1 = (owner, detail, internals)=>substitutePlaces(Optional.some(owner), detail, detail.components, internals)
    ;
    const getPart = (component, detail, partKey)=>{
        const uid = detail.partUids[partKey];
        return component.getSystem().getByUid(uid).toOptional();
    };
    const getPartOrDie = (component, detail, partKey)=>getPart(component, detail, partKey).getOrDie('Could not find part: ' + partKey)
    ;
    const getParts = (component, detail, partKeys)=>{
        const r = {};
        const uids = detail.partUids;
        const system = component.getSystem();
        each$1(partKeys, (pk)=>{
            r[pk] = constant$1(system.getByUid(uids[pk]));
        });
        return r;
    };
    const getAllParts = (component, detail)=>{
        const system = component.getSystem();
        return map$1(detail.partUids, (pUid, _k)=>constant$1(system.getByUid(pUid))
        );
    };
    const getAllPartNames = (detail)=>keys1(detail.partUids)
    ;
    const getPartsOrDie = (component, detail, partKeys)=>{
        const r = {};
        const uids = detail.partUids;
        const system = component.getSystem();
        each$1(partKeys, (pk)=>{
            r[pk] = constant$1(system.getByUid(uids[pk]).getOrDie());
        });
        return r;
    };
    const defaultUids = (baseUid, partTypes)=>{
        const partNames = names(partTypes);
        return wrapAll(map$2(partNames, (pn)=>({
                key: pn,
                value: baseUid + '-' + pn
            })
        ));
    };
    const defaultUidsSchema = (partTypes)=>field$1('partUids', 'partUids', mergeWithThunk((spec)=>defaultUids(spec.uid, partTypes)
        ), anyValue())
    ;
    var AlloyParts = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        generate: generate$3,
        generateOne: generateOne$1,
        schemas: schemas,
        names: names,
        substitutes: substitutes,
        components: components$1,
        defaultUids: defaultUids,
        defaultUidsSchema: defaultUidsSchema,
        getAllParts: getAllParts,
        getAllPartNames: getAllPartNames,
        getPart: getPart,
        getPartOrDie: getPartOrDie,
        getParts: getParts,
        getPartsOrDie: getPartsOrDie
    });
    const base1 = (partSchemas, partUidsSchemas)=>{
        const ps = partSchemas.length > 0 ? [
            requiredObjOf('parts', partSchemas)
        ] : [];
        return ps.concat([
            required$1('uid'),
            defaulted('dom', {}),
            defaulted('components', []),
            snapshot('originalSpec'),
            defaulted('debug.sketcher', {})
        ]).concat(partUidsSchemas);
    };
    const asRawOrDie = (label, schema, spec, partSchemas, partUidsSchemas)=>{
        const baseS = base1(partSchemas, partUidsSchemas);
        return asRawOrDie$1(label + ' [SpecSchema]', objOfOnly(baseS.concat(schema)), spec);
    };
    const single$1 = (owner, schema, factory, spec)=>{
        const specWithUid = supplyUid(spec);
        const detail = asRawOrDie(owner, schema, specWithUid, [], []);
        return factory(detail, specWithUid);
    };
    const composite$1 = (owner, schema, partTypes, factory, spec)=>{
        const specWithUid = supplyUid(spec);
        const partSchemas = schemas(partTypes);
        const partUidsSchema = defaultUidsSchema(partTypes);
        const detail = asRawOrDie(owner, schema, specWithUid, partSchemas, [
            partUidsSchema
        ]);
        const subs = substitutes(owner, detail, partTypes);
        const components = components$1(owner, detail, subs.internals());
        return factory(detail, components, specWithUid, subs.externals());
    };
    const hasUid = (spec)=>has$2(spec, 'uid')
    ;
    const supplyUid = (spec)=>{
        return hasUid(spec) ? spec : {
            ...spec,
            uid: generate$5('uid')
        };
    };
    const isSketchSpec = (spec)=>{
        return spec.uid !== undefined;
    };
    const singleSchema = objOfOnly([
        required$1('name'),
        required$1('factory'),
        required$1('configFields'),
        defaulted('apis', {}),
        defaulted('extraApis', {})
    ]);
    const compositeSchema = objOfOnly([
        required$1('name'),
        required$1('factory'),
        required$1('configFields'),
        required$1('partFields'),
        defaulted('apis', {}),
        defaulted('extraApis', {})
    ]);
    const single = (rawConfig)=>{
        const config = asRawOrDie$1('Sketcher for ' + rawConfig.name, singleSchema, rawConfig);
        const sketch = (spec)=>single$1(config.name, config.configFields, config.factory, spec)
        ;
        const apis = map$1(config.apis, makeApi);
        const extraApis = map$1(config.extraApis, (f, k)=>markAsExtraApi(f, k)
        );
        return {
            name: config.name,
            configFields: config.configFields,
            sketch,
            ...apis,
            ...extraApis
        };
    };
    const composite = (rawConfig)=>{
        const config = asRawOrDie$1('Sketcher for ' + rawConfig.name, compositeSchema, rawConfig);
        const sketch = (spec)=>composite$1(config.name, config.configFields, config.partFields, config.factory, spec)
        ;
        const parts = generate$3(config.name, config.partFields);
        const apis = map$1(config.apis, makeApi);
        const extraApis = map$1(config.extraApis, (f, k)=>markAsExtraApi(f, k)
        );
        return {
            name: config.name,
            partFields: config.partFields,
            configFields: config.configFields,
            sketch,
            parts,
            ...apis,
            ...extraApis
        };
    };
    const inside = (target)=>isTag('input')(target) && get$f(target, 'type') !== 'radio' || isTag('textarea')(target)
    ;
    const getCurrent = (component, composeConfig, _composeState)=>composeConfig.find(component)
    ;
    var ComposeApis = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        getCurrent: getCurrent
    });
    const ComposeSchema = [
        required$1('find')
    ];
    const Composing = create$3({
        fields: ComposeSchema,
        name: 'composing',
        apis: ComposeApis
    });
    const nativeDisabled = [
        'input',
        'button',
        'textarea',
        'select'
    ];
    const onLoad$1 = (component, disableConfig, disableState)=>{
        const f = disableConfig.disabled() ? disable : enable;
        f(component, disableConfig);
    };
    const hasNative = (component, config)=>config.useNative === true && contains$2(nativeDisabled, name$3(component.element))
    ;
    const nativeIsDisabled = (component)=>has$1(component.element, 'disabled')
    ;
    const nativeDisable = (component)=>{
        set$9(component.element, 'disabled', 'disabled');
    };
    const nativeEnable = (component)=>{
        remove$7(component.element, 'disabled');
    };
    const ariaIsDisabled = (component)=>get$f(component.element, 'aria-disabled') === 'true'
    ;
    const ariaDisable = (component)=>{
        set$9(component.element, 'aria-disabled', 'true');
    };
    const ariaEnable = (component)=>{
        set$9(component.element, 'aria-disabled', 'false');
    };
    const disable = (component, disableConfig, _disableState)=>{
        disableConfig.disableClass.each((disableClass)=>{
            add$2(component.element, disableClass);
        });
        const f = hasNative(component, disableConfig) ? nativeDisable : ariaDisable;
        f(component);
        disableConfig.onDisabled(component);
    };
    const enable = (component, disableConfig, _disableState)=>{
        disableConfig.disableClass.each((disableClass)=>{
            remove$2(component.element, disableClass);
        });
        const f = hasNative(component, disableConfig) ? nativeEnable : ariaEnable;
        f(component);
        disableConfig.onEnabled(component);
    };
    const isDisabled1 = (component, disableConfig)=>hasNative(component, disableConfig) ? nativeIsDisabled(component) : ariaIsDisabled(component)
    ;
    const set$4 = (component, disableConfig, disableState, disabled)=>{
        const f = disabled ? disable : enable;
        f(component, disableConfig);
    };
    var DisableApis = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        enable: enable,
        disable: disable,
        isDisabled: isDisabled1,
        onLoad: onLoad$1,
        set: set$4
    });
    const exhibit$5 = (base, disableConfig)=>nu$7({
            classes: disableConfig.disabled() ? disableConfig.disableClass.toArray() : []
        })
    ;
    const events$e = (disableConfig, disableState)=>derive$2([
            abort1(execute$5(), (component, _simulatedEvent)=>isDisabled1(component, disableConfig)
            ),
            loadEvent(disableConfig, disableState, onLoad$1)
        ])
    ;
    var ActiveDisable = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        exhibit: exhibit$5,
        events: events$e
    });
    var DisableSchema = [
        defaultedFunction('disabled', never),
        defaulted('useNative', true),
        option$3('disableClass'),
        onHandler('onDisabled'),
        onHandler('onEnabled')
    ];
    const Disabling = create$3({
        fields: DisableSchema,
        name: 'disabling',
        active: ActiveDisable,
        apis: DisableApis
    });
    const dehighlightAllExcept = (component, hConfig, hState, skip)=>{
        const highlighted = descendants(component.element, '.' + hConfig.highlightClass);
        each$1(highlighted, (h)=>{
            if (!exists(skip, (skipComp)=>skipComp.element === h
            )) {
                remove$2(h, hConfig.highlightClass);
                component.getSystem().getByDom(h).each((target)=>{
                    hConfig.onDehighlight(component, target);
                    emit(target, dehighlight$1());
                });
            }
        });
    };
    const dehighlightAll = (component, hConfig, hState)=>dehighlightAllExcept(component, hConfig, hState, [])
    ;
    const dehighlight = (component, hConfig, hState, target)=>{
        if (isHighlighted(component, hConfig, hState, target)) {
            remove$2(target.element, hConfig.highlightClass);
            hConfig.onDehighlight(component, target);
            emit(target, dehighlight$1());
        }
    };
    const highlight = (component, hConfig, hState, target)=>{
        dehighlightAllExcept(component, hConfig, hState, [
            target
        ]);
        if (!isHighlighted(component, hConfig, hState, target)) {
            add$2(target.element, hConfig.highlightClass);
            hConfig.onHighlight(component, target);
            emit(target, highlight$1());
        }
    };
    const highlightFirst = (component, hConfig, hState)=>{
        getFirst(component, hConfig).each((firstComp)=>{
            highlight(component, hConfig, hState, firstComp);
        });
    };
    const highlightLast = (component, hConfig, hState)=>{
        getLast(component, hConfig).each((lastComp)=>{
            highlight(component, hConfig, hState, lastComp);
        });
    };
    const highlightAt = (component, hConfig, hState, index)=>{
        getByIndex(component, hConfig, hState, index).fold((err)=>{
            throw err;
        }, (firstComp)=>{
            highlight(component, hConfig, hState, firstComp);
        });
    };
    const highlightBy = (component, hConfig, hState, predicate)=>{
        const candidates = getCandidates(component, hConfig);
        const targetComp = find$5(candidates, predicate);
        targetComp.each((c)=>{
            highlight(component, hConfig, hState, c);
        });
    };
    const isHighlighted = (component, hConfig, hState, queryTarget)=>has(queryTarget.element, hConfig.highlightClass)
    ;
    const getHighlighted = (component, hConfig, _hState)=>descendant(component.element, '.' + hConfig.highlightClass).bind((e)=>component.getSystem().getByDom(e).toOptional()
        )
    ;
    const getByIndex = (component, hConfig, hState, index)=>{
        const items = descendants(component.element, '.' + hConfig.itemClass);
        return Optional.from(items[index]).fold(()=>Result.error(new Error('No element found with index ' + index))
        , component.getSystem().getByDom);
    };
    const getFirst = (component, hConfig, _hState)=>descendant(component.element, '.' + hConfig.itemClass).bind((e)=>component.getSystem().getByDom(e).toOptional()
        )
    ;
    const getLast = (component, hConfig, _hState)=>{
        const items = descendants(component.element, '.' + hConfig.itemClass);
        const last = items.length > 0 ? Optional.some(items[items.length - 1]) : Optional.none();
        return last.bind((c)=>component.getSystem().getByDom(c).toOptional()
        );
    };
    const getDelta$2 = (component, hConfig, hState, delta)=>{
        const items = descendants(component.element, '.' + hConfig.itemClass);
        const current = findIndex$1(items, (item)=>has(item, hConfig.highlightClass)
        );
        return current.bind((selected)=>{
            const dest = cycleBy(selected, delta, 0, items.length - 1);
            return component.getSystem().getByDom(items[dest]).toOptional();
        });
    };
    const getPrevious = (component, hConfig, hState)=>getDelta$2(component, hConfig, hState, -1)
    ;
    const getNext = (component, hConfig, hState)=>getDelta$2(component, hConfig, hState, 1)
    ;
    const getCandidates = (component, hConfig, _hState)=>{
        const items = descendants(component.element, '.' + hConfig.itemClass);
        return cat(map$2(items, (i)=>component.getSystem().getByDom(i).toOptional()
        ));
    };
    var HighlightApis = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        dehighlightAll: dehighlightAll,
        dehighlight: dehighlight,
        highlight: highlight,
        highlightFirst: highlightFirst,
        highlightLast: highlightLast,
        highlightAt: highlightAt,
        highlightBy: highlightBy,
        isHighlighted: isHighlighted,
        getHighlighted: getHighlighted,
        getFirst: getFirst,
        getLast: getLast,
        getPrevious: getPrevious,
        getNext: getNext,
        getCandidates: getCandidates
    });
    var HighlightSchema = [
        required$1('highlightClass'),
        required$1('itemClass'),
        onHandler('onHighlight'),
        onHandler('onDehighlight')
    ];
    const Highlighting = create$3({
        fields: HighlightSchema,
        name: 'highlighting',
        apis: HighlightApis
    });
    const BACKSPACE = [
        8
    ];
    const TAB = [
        9
    ];
    const ENTER = [
        13
    ];
    const ESCAPE = [
        27
    ];
    const SPACE = [
        32
    ];
    const LEFT = [
        37
    ];
    const UP = [
        38
    ];
    const RIGHT = [
        39
    ];
    const DOWN = [
        40
    ];
    const cyclePrev = (values, index, predicate)=>{
        const before = reverse(values.slice(0, index));
        const after = reverse(values.slice(index + 1));
        return find$5(before.concat(after), predicate);
    };
    const tryPrev = (values, index, predicate)=>{
        const before = reverse(values.slice(0, index));
        return find$5(before, predicate);
    };
    const cycleNext = (values, index, predicate)=>{
        const before = values.slice(0, index);
        const after = values.slice(index + 1);
        return find$5(after.concat(before), predicate);
    };
    const tryNext = (values, index, predicate)=>{
        const after = values.slice(index + 1);
        return find$5(after, predicate);
    };
    const inSet = (keys)=>(event)=>{
            const raw = event.raw;
            return contains$2(keys, raw.which);
        }
    ;
    const and = (preds)=>(event)=>forall(preds, (pred)=>pred(event)
            )
    ;
    const isShift = (event)=>{
        const raw = event.raw;
        return raw.shiftKey === true;
    };
    const isControl = (event)=>{
        const raw = event.raw;
        return raw.ctrlKey === true;
    };
    const isNotShift = not(isShift);
    const rule1 = (matches, action)=>({
            matches,
            classification: action
        })
    ;
    const choose1 = (transitions, event)=>{
        const transition = find$5(transitions, (t)=>t.matches(event)
        );
        return transition.map((t)=>t.classification
        );
    };
    const reportFocusShifting = (component, prevFocus, newFocus)=>{
        const noChange = prevFocus.exists((p)=>newFocus.exists((n)=>eq(n, p)
            )
        );
        if (!noChange) emitWith(component, focusShifted(), {
            prevFocus,
            newFocus
        });
    };
    const dom$2 = ()=>{
        const get = (component)=>search1(component.element)
        ;
        const set = (component, focusee)=>{
            const prevFocus = get(component);
            component.getSystem().triggerFocus(focusee, component.element);
            const newFocus = get(component);
            reportFocusShifting(component, prevFocus, newFocus);
        };
        return {
            get,
            set
        };
    };
    const highlights = ()=>{
        const get = (component)=>Highlighting.getHighlighted(component).map((item)=>item.element
            )
        ;
        const set = (component, element)=>{
            const prevFocus = get(component);
            component.getSystem().getByDom(element).fold(noop, (item)=>{
                Highlighting.highlight(component, item);
            });
            const newFocus = get(component);
            reportFocusShifting(component, prevFocus, newFocus);
        };
        return {
            get,
            set
        };
    };
    var FocusInsideModes1;
    (function(FocusInsideModes) {
        FocusInsideModes['OnFocusMode'] = 'onFocus';
        FocusInsideModes['OnEnterOrSpaceMode'] = 'onEnterOrSpace';
        FocusInsideModes['OnApiMode'] = 'onApi';
    })(FocusInsideModes1 || (FocusInsideModes1 = {}));
    const typical = (infoSchema, stateInit, getKeydownRules, getKeyupRules, optFocusIn)=>{
        const schema = ()=>infoSchema.concat([
                defaulted('focusManager', dom$2()),
                defaultedOf('focusInside', 'onFocus', valueOf((val)=>contains$2([
                        'onFocus',
                        'onEnterOrSpace',
                        'onApi'
                    ], val) ? Result.value(val) : Result.error('Invalid value for focusInside')
                )),
                output$1('handler', me),
                output$1('state', stateInit),
                output$1('sendFocusIn', optFocusIn)
            ])
        ;
        const processKey = (component, simulatedEvent, getRules, keyingConfig, keyingState)=>{
            const rules = getRules(component, simulatedEvent, keyingConfig, keyingState);
            return choose1(rules, simulatedEvent.event).bind((rule)=>rule(component, simulatedEvent, keyingConfig, keyingState)
            );
        };
        const toEvents = (keyingConfig, keyingState)=>{
            const onFocusHandler = keyingConfig.focusInside !== FocusInsideModes1.OnFocusMode ? Optional.none() : optFocusIn(keyingConfig).map((focusIn)=>run$1(focus$4(), (component, simulatedEvent)=>{
                    focusIn(component, keyingConfig, keyingState);
                    simulatedEvent.stop();
                })
            );
            const tryGoInsideComponent = (component, simulatedEvent)=>{
                const isEnterOrSpace = inSet(SPACE.concat(ENTER))(simulatedEvent.event);
                if (keyingConfig.focusInside === FocusInsideModes1.OnEnterOrSpaceMode && isEnterOrSpace && isSource(component, simulatedEvent)) optFocusIn(keyingConfig).each((focusIn)=>{
                    focusIn(component, keyingConfig, keyingState);
                    simulatedEvent.stop();
                });
            };
            const keyboardEvents = [
                run$1(keydown(), (component, simulatedEvent)=>{
                    processKey(component, simulatedEvent, getKeydownRules, keyingConfig, keyingState).fold(()=>{
                        tryGoInsideComponent(component, simulatedEvent);
                    }, (_)=>{
                        simulatedEvent.stop();
                    });
                }),
                run$1(keyup(), (component, simulatedEvent)=>{
                    processKey(component, simulatedEvent, getKeyupRules, keyingConfig, keyingState).each((_)=>{
                        simulatedEvent.stop();
                    });
                })
            ];
            return derive$2(onFocusHandler.toArray().concat(keyboardEvents));
        };
        const me = {
            schema,
            processKey,
            toEvents
        };
        return me;
    };
    const create$1 = (cyclicField)=>{
        const schema = [
            option$3('onEscape'),
            option$3('onEnter'),
            defaulted('selector', '[data-alloy-tabstop="true"]:not(:disabled)'),
            defaulted('firstTabstop', 0),
            defaulted('useTabstopAt', always),
            option$3('visibilitySelector')
        ].concat([
            cyclicField
        ]);
        const isVisible = (tabbingConfig, element)=>{
            const target = tabbingConfig.visibilitySelector.bind((sel)=>closest$1(element, sel)
            ).getOr(element);
            return get$d(target) > 0;
        };
        const findInitial = (component, tabbingConfig)=>{
            const tabstops = descendants(component.element, tabbingConfig.selector);
            const visibles = filter$2(tabstops, (elem)=>isVisible(tabbingConfig, elem)
            );
            return Optional.from(visibles[tabbingConfig.firstTabstop]);
        };
        const findCurrent = (component, tabbingConfig)=>tabbingConfig.focusManager.get(component).bind((elem)=>closest$1(elem, tabbingConfig.selector)
            )
        ;
        const isTabstop = (tabbingConfig, element)=>isVisible(tabbingConfig, element) && tabbingConfig.useTabstopAt(element)
        ;
        const focusIn = (component, tabbingConfig, _tabbingState)=>{
            findInitial(component, tabbingConfig).each((target)=>{
                tabbingConfig.focusManager.set(component, target);
            });
        };
        const goFromTabstop = (component, tabstops, stopIndex, tabbingConfig, cycle)=>cycle(tabstops, stopIndex, (elem)=>isTabstop(tabbingConfig, elem)
            ).fold(()=>tabbingConfig.cyclic ? Optional.some(true) : Optional.none()
            , (target)=>{
                tabbingConfig.focusManager.set(component, target);
                return Optional.some(true);
            })
        ;
        const go = (component, _simulatedEvent, tabbingConfig, cycle)=>{
            const tabstops = descendants(component.element, tabbingConfig.selector);
            return findCurrent(component, tabbingConfig).bind((tabstop)=>{
                const optStopIndex = findIndex$1(tabstops, curry(eq, tabstop));
                return optStopIndex.bind((stopIndex)=>goFromTabstop(component, tabstops, stopIndex, tabbingConfig, cycle)
                );
            });
        };
        const goBackwards = (component, simulatedEvent, tabbingConfig)=>{
            const navigate = tabbingConfig.cyclic ? cyclePrev : tryPrev;
            return go(component, simulatedEvent, tabbingConfig, navigate);
        };
        const goForwards = (component, simulatedEvent, tabbingConfig)=>{
            const navigate = tabbingConfig.cyclic ? cycleNext : tryNext;
            return go(component, simulatedEvent, tabbingConfig, navigate);
        };
        const execute = (component, simulatedEvent, tabbingConfig)=>tabbingConfig.onEnter.bind((f)=>f(component, simulatedEvent)
            )
        ;
        const exit = (component, simulatedEvent, tabbingConfig)=>tabbingConfig.onEscape.bind((f)=>f(component, simulatedEvent)
            )
        ;
        const getKeydownRules = constant$1([
            rule1(and([
                isShift,
                inSet(TAB)
            ]), goBackwards),
            rule1(inSet(TAB), goForwards),
            rule1(inSet(ESCAPE), exit),
            rule1(and([
                isNotShift,
                inSet(ENTER)
            ]), execute)
        ]);
        const getKeyupRules = constant$1([]);
        return typical(schema, NoState.init, getKeydownRules, getKeyupRules, ()=>Optional.some(focusIn)
        );
    };
    var AcyclicType = create$1(customField('cyclic', never));
    var CyclicType = create$1(customField('cyclic', always));
    const doDefaultExecute = (component, _simulatedEvent, focused)=>{
        dispatch(component, focused, execute$5());
        return Optional.some(true);
    };
    const defaultExecute = (component, simulatedEvent, focused)=>{
        const isComplex = inside(focused) && inSet(SPACE)(simulatedEvent.event);
        return isComplex ? Optional.none() : doDefaultExecute(component, simulatedEvent, focused);
    };
    const stopEventForFirefox = (_component, _simulatedEvent)=>Optional.some(true)
    ;
    const schema$v = [
        defaulted('execute', defaultExecute),
        defaulted('useSpace', false),
        defaulted('useEnter', true),
        defaulted('useControlEnter', false),
        defaulted('useDown', false)
    ];
    const execute$4 = (component, simulatedEvent, executeConfig)=>executeConfig.execute(component, simulatedEvent, component.element)
    ;
    const getKeydownRules$5 = (component, _simulatedEvent, executeConfig, _executeState)=>{
        const spaceExec = executeConfig.useSpace && !inside(component.element) ? SPACE : [];
        const enterExec = executeConfig.useEnter ? ENTER : [];
        const downExec = executeConfig.useDown ? DOWN : [];
        const execKeys = spaceExec.concat(enterExec).concat(downExec);
        return [
            rule1(inSet(execKeys), execute$4)
        ].concat(executeConfig.useControlEnter ? [
            rule1(and([
                isControl,
                inSet(ENTER)
            ]), execute$4)
        ] : []);
    };
    const getKeyupRules$5 = (component, _simulatedEvent, executeConfig, _executeState)=>executeConfig.useSpace && !inside(component.element) ? [
            rule1(inSet(SPACE), stopEventForFirefox)
        ] : []
    ;
    var ExecutionType = typical(schema$v, NoState.init, getKeydownRules$5, getKeyupRules$5, ()=>Optional.none()
    );
    const flatgrid$1 = ()=>{
        const dimensions = value$2();
        const setGridSize = (numRows, numColumns)=>{
            dimensions.set({
                numRows,
                numColumns
            });
        };
        const getNumRows = ()=>dimensions.get().map((d)=>d.numRows
            )
        ;
        const getNumColumns = ()=>dimensions.get().map((d)=>d.numColumns
            )
        ;
        return nu$8({
            readState: ()=>dimensions.get().map((d)=>({
                        numRows: String(d.numRows),
                        numColumns: String(d.numColumns)
                    })
                ).getOr({
                    numRows: '?',
                    numColumns: '?'
                })
            ,
            setGridSize,
            getNumRows,
            getNumColumns
        });
    };
    const init$d = (spec)=>spec.state(spec)
    ;
    var KeyingState = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        flatgrid: flatgrid$1,
        init: init$d
    });
    const useH = (movement)=>(component, simulatedEvent, config, state)=>{
            const move = movement(component.element);
            return use(move, component, simulatedEvent, config, state);
        }
    ;
    const west$1 = (moveLeft, moveRight)=>{
        const movement = onDirection(moveLeft, moveRight);
        return useH(movement);
    };
    const east$1 = (moveLeft, moveRight)=>{
        const movement = onDirection(moveRight, moveLeft);
        return useH(movement);
    };
    const useV = (move)=>(component, simulatedEvent, config, state)=>use(move, component, simulatedEvent, config, state)
    ;
    const use = (move, component, simulatedEvent, config, state)=>{
        const outcome = config.focusManager.get(component).bind((focused)=>move(component.element, focused, config, state)
        );
        return outcome.map((newFocus)=>{
            config.focusManager.set(component, newFocus);
            return true;
        });
    };
    const north$1 = useV;
    const south$1 = useV;
    const move$1 = useV;
    const isHidden$1 = (dom)=>dom.offsetWidth <= 0 && dom.offsetHeight <= 0
    ;
    const isVisible1 = (element)=>!isHidden$1(element.dom)
    ;
    const locate = (candidates, predicate)=>findIndex$1(candidates, predicate).map((index)=>({
                index,
                candidates
            })
        )
    ;
    const locateVisible = (container, current, selector)=>{
        const predicate = (x)=>eq(x, current)
        ;
        const candidates = descendants(container, selector);
        const visible = filter$2(candidates, isVisible1);
        return locate(visible, predicate);
    };
    const findIndex = (elements, target)=>findIndex$1(elements, (elem)=>eq(target, elem)
        )
    ;
    const withGrid = (values, index, numCols, f)=>{
        const oldRow = Math.floor(index / numCols);
        const oldColumn = index % numCols;
        return f(oldRow, oldColumn).bind((address)=>{
            const newIndex = address.row * numCols + address.column;
            return newIndex >= 0 && newIndex < values.length ? Optional.some(values[newIndex]) : Optional.none();
        });
    };
    const cycleHorizontal$1 = (values, index, numRows, numCols, delta)=>withGrid(values, index, numCols, (oldRow, oldColumn)=>{
            const onLastRow = oldRow === numRows - 1;
            const colsInRow = onLastRow ? values.length - oldRow * numCols : numCols;
            const newColumn = cycleBy(oldColumn, delta, 0, colsInRow - 1);
            return Optional.some({
                row: oldRow,
                column: newColumn
            });
        })
    ;
    const cycleVertical$1 = (values, index, numRows, numCols, delta)=>withGrid(values, index, numCols, (oldRow, oldColumn)=>{
            const newRow = cycleBy(oldRow, delta, 0, numRows - 1);
            const onLastRow = newRow === numRows - 1;
            const colsInRow = onLastRow ? values.length - newRow * numCols : numCols;
            const newCol = clamp(oldColumn, 0, colsInRow - 1);
            return Optional.some({
                row: newRow,
                column: newCol
            });
        })
    ;
    const cycleRight$1 = (values, index, numRows, numCols)=>cycleHorizontal$1(values, index, numRows, numCols, 1)
    ;
    const cycleLeft$1 = (values, index, numRows, numCols)=>cycleHorizontal$1(values, index, numRows, numCols, -1)
    ;
    const cycleUp$1 = (values, index, numRows, numCols)=>cycleVertical$1(values, index, numRows, numCols, -1)
    ;
    const cycleDown$1 = (values, index, numRows, numCols)=>cycleVertical$1(values, index, numRows, numCols, 1)
    ;
    const schema$u = [
        required$1('selector'),
        defaulted('execute', defaultExecute),
        onKeyboardHandler('onEscape'),
        defaulted('captureTab', false),
        initSize()
    ];
    const focusIn$3 = (component, gridConfig, _gridState)=>{
        descendant(component.element, gridConfig.selector).each((first)=>{
            gridConfig.focusManager.set(component, first);
        });
    };
    const findCurrent$1 = (component, gridConfig)=>gridConfig.focusManager.get(component).bind((elem)=>closest$1(elem, gridConfig.selector)
        )
    ;
    const execute$3 = (component, simulatedEvent, gridConfig, _gridState)=>findCurrent$1(component, gridConfig).bind((focused)=>gridConfig.execute(component, simulatedEvent, focused)
        )
    ;
    const doMove$2 = (cycle)=>(element, focused, gridConfig, gridState)=>locateVisible(element, focused, gridConfig.selector).bind((identified)=>cycle(identified.candidates, identified.index, gridState.getNumRows().getOr(gridConfig.initSize.numRows), gridState.getNumColumns().getOr(gridConfig.initSize.numColumns))
            )
    ;
    const handleTab = (_component, _simulatedEvent, gridConfig)=>gridConfig.captureTab ? Optional.some(true) : Optional.none()
    ;
    const doEscape$1 = (component, simulatedEvent, gridConfig)=>gridConfig.onEscape(component, simulatedEvent)
    ;
    const moveLeft$3 = doMove$2(cycleLeft$1);
    const moveRight$3 = doMove$2(cycleRight$1);
    const moveNorth$1 = doMove$2(cycleUp$1);
    const moveSouth$1 = doMove$2(cycleDown$1);
    const getKeydownRules$4 = constant$1([
        rule1(inSet(LEFT), west$1(moveLeft$3, moveRight$3)),
        rule1(inSet(RIGHT), east$1(moveLeft$3, moveRight$3)),
        rule1(inSet(UP), north$1(moveNorth$1)),
        rule1(inSet(DOWN), south$1(moveSouth$1)),
        rule1(and([
            isShift,
            inSet(TAB)
        ]), handleTab),
        rule1(and([
            isNotShift,
            inSet(TAB)
        ]), handleTab),
        rule1(inSet(ESCAPE), doEscape$1),
        rule1(inSet(SPACE.concat(ENTER)), execute$3)
    ]);
    const getKeyupRules$4 = constant$1([
        rule1(inSet(SPACE), stopEventForFirefox)
    ]);
    var FlatgridType = typical(schema$u, flatgrid$1, getKeydownRules$4, getKeyupRules$4, ()=>Optional.some(focusIn$3)
    );
    const horizontal = (container, selector, current, delta)=>{
        const isDisabledButton = (candidate)=>name$3(candidate) === 'button' && get$f(candidate, 'disabled') === 'disabled'
        ;
        const tryCycle = (initial, index, candidates)=>{
            const newIndex = cycleBy(index, delta, 0, candidates.length - 1);
            if (newIndex === initial) return Optional.none();
            else return isDisabledButton(candidates[newIndex]) ? tryCycle(initial, newIndex, candidates) : Optional.from(candidates[newIndex]);
        };
        return locateVisible(container, current, selector).bind((identified)=>{
            const index = identified.index;
            const candidates = identified.candidates;
            return tryCycle(index, index, candidates);
        });
    };
    const schema$t = [
        required$1('selector'),
        defaulted('getInitial', Optional.none),
        defaulted('execute', defaultExecute),
        onKeyboardHandler('onEscape'),
        defaulted('executeOnMove', false),
        defaulted('allowVertical', true)
    ];
    const findCurrent1 = (component, flowConfig)=>flowConfig.focusManager.get(component).bind((elem)=>closest$1(elem, flowConfig.selector)
        )
    ;
    const execute$2 = (component, simulatedEvent, flowConfig)=>findCurrent1(component, flowConfig).bind((focused)=>flowConfig.execute(component, simulatedEvent, focused)
        )
    ;
    const focusIn$2 = (component, flowConfig, _state)=>{
        flowConfig.getInitial(component).orThunk(()=>descendant(component.element, flowConfig.selector)
        ).each((first)=>{
            flowConfig.focusManager.set(component, first);
        });
    };
    const moveLeft$2 = (element, focused, info)=>horizontal(element, info.selector, focused, -1)
    ;
    const moveRight$2 = (element, focused, info)=>horizontal(element, info.selector, focused, 1)
    ;
    const doMove$1 = (movement)=>(component, simulatedEvent, flowConfig, flowState)=>movement(component, simulatedEvent, flowConfig, flowState).bind(()=>flowConfig.executeOnMove ? execute$2(component, simulatedEvent, flowConfig) : Optional.some(true)
            )
    ;
    const doEscape = (component, simulatedEvent, flowConfig)=>flowConfig.onEscape(component, simulatedEvent)
    ;
    const getKeydownRules$3 = (_component, _se, flowConfig, _flowState)=>{
        const westMovers = LEFT.concat(flowConfig.allowVertical ? UP : []);
        const eastMovers = RIGHT.concat(flowConfig.allowVertical ? DOWN : []);
        return [
            rule1(inSet(westMovers), doMove$1(west$1(moveLeft$2, moveRight$2))),
            rule1(inSet(eastMovers), doMove$1(east$1(moveLeft$2, moveRight$2))),
            rule1(inSet(ENTER), execute$2),
            rule1(inSet(SPACE), execute$2),
            rule1(inSet(ESCAPE), doEscape)
        ];
    };
    const getKeyupRules$3 = constant$1([
        rule1(inSet(SPACE), stopEventForFirefox)
    ]);
    var FlowType = typical(schema$t, NoState.init, getKeydownRules$3, getKeyupRules$3, ()=>Optional.some(focusIn$2)
    );
    const toCell = (matrix, rowIndex, columnIndex)=>Optional.from(matrix[rowIndex]).bind((row)=>Optional.from(row[columnIndex]).map((cell)=>({
                    rowIndex,
                    columnIndex,
                    cell
                })
            )
        )
    ;
    const cycleHorizontal = (matrix, rowIndex, startCol, deltaCol)=>{
        const row = matrix[rowIndex];
        const colsInRow = row.length;
        const newColIndex = cycleBy(startCol, deltaCol, 0, colsInRow - 1);
        return toCell(matrix, rowIndex, newColIndex);
    };
    const cycleVertical = (matrix, colIndex, startRow, deltaRow)=>{
        const nextRowIndex = cycleBy(startRow, deltaRow, 0, matrix.length - 1);
        const colsInNextRow = matrix[nextRowIndex].length;
        const nextColIndex = clamp(colIndex, 0, colsInNextRow - 1);
        return toCell(matrix, nextRowIndex, nextColIndex);
    };
    const moveHorizontal = (matrix, rowIndex, startCol, deltaCol)=>{
        const row = matrix[rowIndex];
        const colsInRow = row.length;
        const newColIndex = clamp(startCol + deltaCol, 0, colsInRow - 1);
        return toCell(matrix, rowIndex, newColIndex);
    };
    const moveVertical = (matrix, colIndex, startRow, deltaRow)=>{
        const nextRowIndex = clamp(startRow + deltaRow, 0, matrix.length - 1);
        const colsInNextRow = matrix[nextRowIndex].length;
        const nextColIndex = clamp(colIndex, 0, colsInNextRow - 1);
        return toCell(matrix, nextRowIndex, nextColIndex);
    };
    const cycleRight = (matrix, startRow, startCol)=>cycleHorizontal(matrix, startRow, startCol, 1)
    ;
    const cycleLeft = (matrix, startRow, startCol)=>cycleHorizontal(matrix, startRow, startCol, -1)
    ;
    const cycleUp = (matrix, startRow, startCol)=>cycleVertical(matrix, startCol, startRow, -1)
    ;
    const cycleDown = (matrix, startRow, startCol)=>cycleVertical(matrix, startCol, startRow, 1)
    ;
    const moveLeft$1 = (matrix, startRow, startCol)=>moveHorizontal(matrix, startRow, startCol, -1)
    ;
    const moveRight$1 = (matrix, startRow, startCol)=>moveHorizontal(matrix, startRow, startCol, 1)
    ;
    const moveUp$1 = (matrix, startRow, startCol)=>moveVertical(matrix, startCol, startRow, -1)
    ;
    const moveDown$1 = (matrix, startRow, startCol)=>moveVertical(matrix, startCol, startRow, 1)
    ;
    const schema$s = [
        requiredObjOf('selectors', [
            required$1('row'),
            required$1('cell')
        ]),
        defaulted('cycles', true),
        defaulted('previousSelector', Optional.none),
        defaulted('execute', defaultExecute)
    ];
    const focusIn$1 = (component, matrixConfig, _state)=>{
        const focused = matrixConfig.previousSelector(component).orThunk(()=>{
            const selectors = matrixConfig.selectors;
            return descendant(component.element, selectors.cell);
        });
        focused.each((cell)=>{
            matrixConfig.focusManager.set(component, cell);
        });
    };
    const execute$1 = (component, simulatedEvent, matrixConfig)=>search1(component.element).bind((focused)=>matrixConfig.execute(component, simulatedEvent, focused)
        )
    ;
    const toMatrix = (rows, matrixConfig)=>map$2(rows, (row)=>descendants(row, matrixConfig.selectors.cell)
        )
    ;
    const doMove = (ifCycle, ifMove)=>(element, focused, matrixConfig)=>{
            const move = matrixConfig.cycles ? ifCycle : ifMove;
            return closest$1(focused, matrixConfig.selectors.row).bind((inRow)=>{
                const cellsInRow = descendants(inRow, matrixConfig.selectors.cell);
                return findIndex(cellsInRow, focused).bind((colIndex)=>{
                    const allRows = descendants(element, matrixConfig.selectors.row);
                    return findIndex(allRows, inRow).bind((rowIndex)=>{
                        const matrix = toMatrix(allRows, matrixConfig);
                        return move(matrix, rowIndex, colIndex).map((next)=>next.cell
                        );
                    });
                });
            });
        }
    ;
    const moveLeft1 = doMove(cycleLeft, moveLeft$1);
    const moveRight1 = doMove(cycleRight, moveRight$1);
    const moveNorth = doMove(cycleUp, moveUp$1);
    const moveSouth = doMove(cycleDown, moveDown$1);
    const getKeydownRules$2 = constant$1([
        rule1(inSet(LEFT), west$1(moveLeft1, moveRight1)),
        rule1(inSet(RIGHT), east$1(moveLeft1, moveRight1)),
        rule1(inSet(UP), north$1(moveNorth)),
        rule1(inSet(DOWN), south$1(moveSouth)),
        rule1(inSet(SPACE.concat(ENTER)), execute$1)
    ]);
    const getKeyupRules$2 = constant$1([
        rule1(inSet(SPACE), stopEventForFirefox)
    ]);
    var MatrixType = typical(schema$s, NoState.init, getKeydownRules$2, getKeyupRules$2, ()=>Optional.some(focusIn$1)
    );
    const schema$r = [
        required$1('selector'),
        defaulted('execute', defaultExecute),
        defaulted('moveOnTab', false)
    ];
    const execute1 = (component, simulatedEvent, menuConfig)=>menuConfig.focusManager.get(component).bind((focused)=>menuConfig.execute(component, simulatedEvent, focused)
        )
    ;
    const focusIn1 = (component, menuConfig, _state)=>{
        descendant(component.element, menuConfig.selector).each((first)=>{
            menuConfig.focusManager.set(component, first);
        });
    };
    const moveUp = (element, focused, info)=>horizontal(element, info.selector, focused, -1)
    ;
    const moveDown = (element, focused, info)=>horizontal(element, info.selector, focused, 1)
    ;
    const fireShiftTab = (component, simulatedEvent, menuConfig, menuState)=>menuConfig.moveOnTab ? move$1(moveUp)(component, simulatedEvent, menuConfig, menuState) : Optional.none()
    ;
    const fireTab = (component, simulatedEvent, menuConfig, menuState)=>menuConfig.moveOnTab ? move$1(moveDown)(component, simulatedEvent, menuConfig, menuState) : Optional.none()
    ;
    const getKeydownRules$1 = constant$1([
        rule1(inSet(UP), move$1(moveUp)),
        rule1(inSet(DOWN), move$1(moveDown)),
        rule1(and([
            isShift,
            inSet(TAB)
        ]), fireShiftTab),
        rule1(and([
            isNotShift,
            inSet(TAB)
        ]), fireTab),
        rule1(inSet(ENTER), execute1),
        rule1(inSet(SPACE), execute1)
    ]);
    const getKeyupRules$1 = constant$1([
        rule1(inSet(SPACE), stopEventForFirefox)
    ]);
    var MenuType = typical(schema$r, NoState.init, getKeydownRules$1, getKeyupRules$1, ()=>Optional.some(focusIn1)
    );
    const schema$q = [
        onKeyboardHandler('onSpace'),
        onKeyboardHandler('onEnter'),
        onKeyboardHandler('onShiftEnter'),
        onKeyboardHandler('onLeft'),
        onKeyboardHandler('onRight'),
        onKeyboardHandler('onTab'),
        onKeyboardHandler('onShiftTab'),
        onKeyboardHandler('onUp'),
        onKeyboardHandler('onDown'),
        onKeyboardHandler('onEscape'),
        defaulted('stopSpaceKeyup', false),
        option$3('focusIn')
    ];
    const getKeydownRules1 = (component, simulatedEvent, specialInfo)=>[
            rule1(inSet(SPACE), specialInfo.onSpace),
            rule1(and([
                isNotShift,
                inSet(ENTER)
            ]), specialInfo.onEnter),
            rule1(and([
                isShift,
                inSet(ENTER)
            ]), specialInfo.onShiftEnter),
            rule1(and([
                isShift,
                inSet(TAB)
            ]), specialInfo.onShiftTab),
            rule1(and([
                isNotShift,
                inSet(TAB)
            ]), specialInfo.onTab),
            rule1(inSet(UP), specialInfo.onUp),
            rule1(inSet(DOWN), specialInfo.onDown),
            rule1(inSet(LEFT), specialInfo.onLeft),
            rule1(inSet(RIGHT), specialInfo.onRight),
            rule1(inSet(SPACE), specialInfo.onSpace),
            rule1(inSet(ESCAPE), specialInfo.onEscape)
        ]
    ;
    const getKeyupRules1 = (component, simulatedEvent, specialInfo)=>specialInfo.stopSpaceKeyup ? [
            rule1(inSet(SPACE), stopEventForFirefox)
        ] : []
    ;
    var SpecialType = typical(schema$q, NoState.init, getKeydownRules1, getKeyupRules1, (specialInfo)=>specialInfo.focusIn
    );
    const acyclic = AcyclicType.schema();
    const cyclic = CyclicType.schema();
    const flow = FlowType.schema();
    const flatgrid = FlatgridType.schema();
    const matrix1 = MatrixType.schema();
    const execution = ExecutionType.schema();
    const menu1 = MenuType.schema();
    const special = SpecialType.schema();
    var KeyboardBranches = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        acyclic: acyclic,
        cyclic: cyclic,
        flow: flow,
        flatgrid: flatgrid,
        matrix: matrix1,
        execution: execution,
        menu: menu1,
        special: special
    });
    const isFlatgridState = (keyState)=>hasNonNullableKey(keyState, 'setGridSize')
    ;
    const Keying = createModes({
        branchKey: 'mode',
        branches: KeyboardBranches,
        name: 'keying',
        active: {
            events: (keyingConfig, keyingState)=>{
                const handler = keyingConfig.handler;
                return handler.toEvents(keyingConfig, keyingState);
            }
        },
        apis: {
            focusIn: (component, keyConfig, keyState)=>{
                keyConfig.sendFocusIn(keyConfig).fold(()=>{
                    component.getSystem().triggerFocus(component.element, component.element);
                }, (sendFocusIn)=>{
                    sendFocusIn(component, keyConfig, keyState);
                });
            },
            setGridSize: (component, keyConfig, keyState, numRows, numColumns)=>{
                if (!isFlatgridState(keyState)) console.error('Layout does not support setGridSize');
                else keyState.setGridSize(numRows, numColumns);
            }
        },
        state: KeyingState
    });
    const withoutReuse = (parent, data)=>{
        preserve$1(()=>{
            replaceChildren(parent, data, ()=>map$2(data, parent.getSystem().build)
            );
        }, parent.element);
    };
    const withReuse = (parent, data)=>{
        preserve$1(()=>{
            virtualReplaceChildren(parent, data, ()=>{
                return patchSpecChildren(parent.element, data, parent.getSystem().buildOrPatch);
            });
        }, parent.element);
    };
    const virtualReplace = (component, replacee, replaceeIndex, childSpec)=>{
        virtualDetach(replacee);
        const child = patchSpecChild(component.element, replaceeIndex, childSpec, component.getSystem().buildOrPatch);
        virtualAttach(component, child);
        component.syncComponents();
    };
    const insert = (component, insertion, childSpec)=>{
        const child = component.getSystem().build(childSpec);
        attachWith(component, child, insertion);
    };
    const replace1 = (component, replacee, replaceeIndex, childSpec)=>{
        detach(replacee);
        insert(component, (p, c)=>appendAt(p, c, replaceeIndex)
        , childSpec);
    };
    const set$3 = (component, replaceConfig, replaceState, data)=>{
        const replacer = replaceConfig.reuseDom ? withReuse : withoutReuse;
        return replacer(component, data);
    };
    const append = (component, replaceConfig, replaceState, appendee)=>{
        insert(component, append$2, appendee);
    };
    const prepend = (component, replaceConfig, replaceState, prependee)=>{
        insert(component, prepend$1, prependee);
    };
    const remove1 = (component, replaceConfig, replaceState, removee)=>{
        const children = contents1(component);
        const foundChild = find$5(children, (child)=>eq(removee.element, child.element)
        );
        foundChild.each(detach);
    };
    const contents1 = (component, _replaceConfig)=>component.components()
    ;
    const replaceAt = (component, replaceConfig, replaceState, replaceeIndex, replacer1)=>{
        const children = contents1(component);
        return Optional.from(children[replaceeIndex]).map((replacee)=>{
            replacer1.fold(()=>detach(replacee)
            , (r)=>{
                const replacer = replaceConfig.reuseDom ? virtualReplace : replace1;
                replacer(component, replacee, replaceeIndex, r);
            });
            return replacee;
        });
    };
    const replaceBy = (component, replaceConfig, replaceState, replaceePred, replacer)=>{
        const children = contents1(component);
        return findIndex$1(children, replaceePred).bind((replaceeIndex)=>replaceAt(component, replaceConfig, replaceState, replaceeIndex, replacer)
        );
    };
    var ReplaceApis = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        append: append,
        prepend: prepend,
        remove: remove1,
        replaceAt: replaceAt,
        replaceBy: replaceBy,
        set: set$3,
        contents: contents1
    });
    const Replacing = create$3({
        fields: [
            defaultedBoolean('reuseDom', true)
        ],
        name: 'replacing',
        apis: ReplaceApis
    });
    const events$d = (name, eventHandlers)=>{
        const events = derive$2(eventHandlers);
        return create$3({
            fields: [
                required$1('enabled')
            ],
            name,
            active: {
                events: constant$1(events)
            }
        });
    };
    const config1 = (name, eventHandlers)=>{
        const me = events$d(name, eventHandlers);
        return {
            key: name,
            value: {
                config: {},
                me,
                configAsRaw: constant$1({}),
                initialConfig: {},
                state: NoState
            }
        };
    };
    const focus$2 = (component, focusConfig)=>{
        if (!focusConfig.ignore) {
            focus$3(component.element);
            focusConfig.onFocus(component);
        }
    };
    const blur = (component, focusConfig)=>{
        if (!focusConfig.ignore) blur$1(component.element);
    };
    const isFocused = (component)=>hasFocus1(component.element)
    ;
    var FocusApis = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        focus: focus$2,
        blur: blur,
        isFocused: isFocused
    });
    const exhibit$4 = (base, focusConfig)=>{
        const mod = focusConfig.ignore ? {} : {
            attributes: {
                tabindex: '-1'
            }
        };
        return nu$7(mod);
    };
    const events$c = (focusConfig)=>derive$2([
            run$1(focus$4(), (component, simulatedEvent)=>{
                focus$2(component, focusConfig);
                simulatedEvent.stop();
            })
        ].concat(focusConfig.stopMousedown ? [
            run$1(mousedown(), (_, simulatedEvent)=>{
                simulatedEvent.event.prevent();
            })
        ] : []))
    ;
    var ActiveFocus = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        exhibit: exhibit$4,
        events: events$c
    });
    var FocusSchema = [
        onHandler('onFocus'),
        defaulted('stopMousedown', false),
        defaulted('ignore', false)
    ];
    const Focusing = create$3({
        fields: FocusSchema,
        name: 'focusing',
        active: ActiveFocus,
        apis: FocusApis
    });
    const SetupBehaviourCellState = (initialState)=>{
        const init = ()=>{
            const cell = Cell(initialState);
            const get = ()=>cell.get()
            ;
            const set = (newState)=>cell.set(newState)
            ;
            const clear = ()=>cell.set(initialState)
            ;
            const readState = ()=>cell.get()
            ;
            return {
                get,
                set,
                clear,
                readState
            };
        };
        return {
            init
        };
    };
    const updateAriaState = (component, toggleConfig, toggleState)=>{
        const ariaInfo = toggleConfig.aria;
        ariaInfo.update(component, ariaInfo, toggleState.get());
    };
    const updateClass = (component, toggleConfig, toggleState)=>{
        toggleConfig.toggleClass.each((toggleClass)=>{
            if (toggleState.get()) add$2(component.element, toggleClass);
            else remove$2(component.element, toggleClass);
        });
    };
    const toggle$2 = (component, toggleConfig, toggleState)=>{
        set$2(component, toggleConfig, toggleState, !toggleState.get());
    };
    const on1 = (component, toggleConfig, toggleState)=>{
        toggleState.set(true);
        updateClass(component, toggleConfig, toggleState);
        updateAriaState(component, toggleConfig, toggleState);
    };
    const off = (component, toggleConfig, toggleState)=>{
        toggleState.set(false);
        updateClass(component, toggleConfig, toggleState);
        updateAriaState(component, toggleConfig, toggleState);
    };
    const set$2 = (component, toggleConfig, toggleState, state)=>{
        const action = state ? on1 : off;
        action(component, toggleConfig, toggleState);
    };
    const isOn = (component, toggleConfig, toggleState)=>toggleState.get()
    ;
    const onLoad = (component, toggleConfig, toggleState)=>{
        set$2(component, toggleConfig, toggleState, toggleConfig.selected);
    };
    var ToggleApis = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        onLoad: onLoad,
        toggle: toggle$2,
        isOn: isOn,
        on: on1,
        off: off,
        set: set$2
    });
    const exhibit$3 = ()=>nu$7({})
    ;
    const events$b = (toggleConfig, toggleState)=>{
        const execute = executeEvent(toggleConfig, toggleState, toggle$2);
        const load = loadEvent(toggleConfig, toggleState, onLoad);
        return derive$2(flatten1([
            toggleConfig.toggleOnExecute ? [
                execute
            ] : [],
            [
                load
            ]
        ]));
    };
    var ActiveToggle = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        exhibit: exhibit$3,
        events: events$b
    });
    const updatePressed = (component, ariaInfo, status)=>{
        set$9(component.element, 'aria-pressed', status);
        if (ariaInfo.syncWithExpanded) updateExpanded(component, ariaInfo, status);
    };
    const updateSelected = (component, ariaInfo, status)=>{
        set$9(component.element, 'aria-selected', status);
    };
    const updateChecked = (component, ariaInfo, status)=>{
        set$9(component.element, 'aria-checked', status);
    };
    const updateExpanded = (component, ariaInfo, status)=>{
        set$9(component.element, 'aria-expanded', status);
    };
    var ToggleSchema = [
        defaulted('selected', false),
        option$3('toggleClass'),
        defaulted('toggleOnExecute', true),
        defaultedOf('aria', {
            mode: 'none'
        }, choose$1('mode', {
            pressed: [
                defaulted('syncWithExpanded', false),
                output$1('update', updatePressed)
            ],
            checked: [
                output$1('update', updateChecked)
            ],
            expanded: [
                output$1('update', updateExpanded)
            ],
            selected: [
                output$1('update', updateSelected)
            ],
            none: [
                output$1('update', noop)
            ]
        }))
    ];
    const Toggling = create$3({
        fields: ToggleSchema,
        name: 'toggling',
        active: ActiveToggle,
        apis: ToggleApis,
        state: SetupBehaviourCellState(false)
    });
    const pointerEvents1 = ()=>{
        const onClick = (component, simulatedEvent)=>{
            simulatedEvent.stop();
            emitExecute1(component);
        };
        return [
            run$1(click(), onClick),
            run$1(tap(), onClick),
            cutter1(touchstart()),
            cutter1(mousedown())
        ];
    };
    const events$a = (optAction)=>{
        const executeHandler = (action)=>runOnExecute$1((component, simulatedEvent)=>{
                action(component);
                simulatedEvent.stop();
            })
        ;
        return derive$2(flatten1([
            optAction.map(executeHandler).toArray(),
            pointerEvents1()
        ]));
    };
    const hoverEvent = 'alloy.item-hover';
    const focusEvent = 'alloy.item-focus';
    const onHover = (item)=>{
        if (search1(item.element).isNone() || Focusing.isFocused(item)) {
            if (!Focusing.isFocused(item)) Focusing.focus(item);
            emitWith(item, hoverEvent, {
                item
            });
        }
    };
    const onFocus$1 = (item)=>{
        emitWith(item, focusEvent, {
            item
        });
    };
    const hover = constant$1(hoverEvent);
    const focus$1 = constant$1(focusEvent);
    const builder$2 = (detail)=>({
            dom: detail.dom,
            domModification: {
                ...detail.domModification,
                attributes: {
                    'role': detail.toggling.isSome() ? 'menuitemcheckbox' : 'menuitem',
                    ...detail.domModification.attributes,
                    'aria-haspopup': detail.hasSubmenu,
                    ...detail.hasSubmenu ? {
                        'aria-expanded': false
                    } : {}
                }
            },
            behaviours: SketchBehaviours.augment(detail.itemBehaviours, [
                detail.toggling.fold(Toggling.revoke, (tConfig)=>Toggling.config({
                        aria: {
                            mode: 'checked'
                        },
                        ...tConfig
                    })
                ),
                Focusing.config({
                    ignore: detail.ignoreFocus,
                    stopMousedown: detail.ignoreFocus,
                    onFocus: (component)=>{
                        onFocus$1(component);
                    }
                }),
                Keying.config({
                    mode: 'execution'
                }),
                Representing.config({
                    store: {
                        mode: 'memory',
                        initialValue: detail.data
                    }
                }),
                config1('item-type-events', [
                    ...pointerEvents1(),
                    run$1(mouseover(), onHover),
                    run$1(focusItem(), Focusing.focus)
                ])
            ]),
            components: detail.components,
            eventOrder: detail.eventOrder
        })
    ;
    const schema$p = [
        required$1('data'),
        required$1('components'),
        required$1('dom'),
        defaulted('hasSubmenu', false),
        option$3('toggling'),
        SketchBehaviours.field('itemBehaviours', [
            Toggling,
            Focusing,
            Keying,
            Representing
        ]),
        defaulted('ignoreFocus', false),
        defaulted('domModification', {}),
        output$1('builder', builder$2),
        defaulted('eventOrder', {})
    ];
    const builder$1 = (detail)=>({
            dom: detail.dom,
            components: detail.components,
            events: derive$2([
                stopper1(focusItem())
            ])
        })
    ;
    const schema$o = [
        required$1('dom'),
        required$1('components'),
        output$1('builder', builder$1)
    ];
    const owner$2 = constant$1('item-widget');
    const parts$h = constant$1([
        required1({
            name: 'widget',
            overrides: (detail)=>{
                return {
                    behaviours: derive$1([
                        Representing.config({
                            store: {
                                mode: 'manual',
                                getValue: (_component)=>{
                                    return detail.data;
                                },
                                setValue: noop
                            }
                        })
                    ])
                };
            }
        })
    ]);
    const builder1 = (detail)=>{
        const subs = substitutes(owner$2(), detail, parts$h());
        const components = components$1(owner$2(), detail, subs.internals());
        const focusWidget = (component)=>getPart(component, detail, 'widget').map((widget)=>{
                Keying.focusIn(widget);
                return widget;
            })
        ;
        const onHorizontalArrow = (component, simulatedEvent)=>inside(simulatedEvent.event.target) ? Optional.none() : (()=>{
                if (detail.autofocus) {
                    simulatedEvent.setSource(component.element);
                    return Optional.none();
                } else return Optional.none();
            })()
        ;
        return {
            dom: detail.dom,
            components,
            domModification: detail.domModification,
            events: derive$2([
                runOnExecute$1((component, simulatedEvent)=>{
                    focusWidget(component).each((_widget)=>{
                        simulatedEvent.stop();
                    });
                }),
                run$1(mouseover(), onHover),
                run$1(focusItem(), (component, _simulatedEvent)=>{
                    if (detail.autofocus) focusWidget(component);
                    else Focusing.focus(component);
                })
            ]),
            behaviours: SketchBehaviours.augment(detail.widgetBehaviours, [
                Representing.config({
                    store: {
                        mode: 'memory',
                        initialValue: detail.data
                    }
                }),
                Focusing.config({
                    ignore: detail.ignoreFocus,
                    onFocus: (component)=>{
                        onFocus$1(component);
                    }
                }),
                Keying.config({
                    mode: 'special',
                    focusIn: detail.autofocus ? (component)=>{
                        focusWidget(component);
                    } : revoke1(),
                    onLeft: onHorizontalArrow,
                    onRight: onHorizontalArrow,
                    onEscape: (component, simulatedEvent)=>{
                        if (!Focusing.isFocused(component) && !detail.autofocus) {
                            Focusing.focus(component);
                            return Optional.some(true);
                        } else if (detail.autofocus) {
                            simulatedEvent.setSource(component.element);
                            return Optional.none();
                        } else return Optional.none();
                    }
                })
            ])
        };
    };
    const schema$n = [
        required$1('uid'),
        required$1('data'),
        required$1('components'),
        required$1('dom'),
        defaulted('autofocus', false),
        defaulted('ignoreFocus', false),
        SketchBehaviours.field('widgetBehaviours', [
            Representing,
            Focusing,
            Keying
        ]),
        defaulted('domModification', {}),
        defaultUidsSchema(parts$h()),
        output$1('builder', builder1)
    ];
    const itemSchema$2 = choose$1('type', {
        widget: schema$n,
        item: schema$p,
        separator: schema$o
    });
    const configureGrid = (detail, movementInfo)=>({
            mode: 'flatgrid',
            selector: '.' + detail.markers.item,
            initSize: {
                numColumns: movementInfo.initSize.numColumns,
                numRows: movementInfo.initSize.numRows
            },
            focusManager: detail.focusManager
        })
    ;
    const configureMatrix = (detail, movementInfo)=>({
            mode: 'matrix',
            selectors: {
                row: movementInfo.rowSelector,
                cell: '.' + detail.markers.item
            },
            focusManager: detail.focusManager
        })
    ;
    const configureMenu = (detail, movementInfo)=>({
            mode: 'menu',
            selector: '.' + detail.markers.item,
            moveOnTab: movementInfo.moveOnTab,
            focusManager: detail.focusManager
        })
    ;
    const parts$g = constant$1([
        group1({
            factory: {
                sketch: (spec)=>{
                    const itemInfo = asRawOrDie$1('menu.spec item', itemSchema$2, spec);
                    return itemInfo.builder(itemInfo);
                }
            },
            name: 'items',
            unit: 'item',
            defaults: (detail, u)=>{
                return has$2(u, 'uid') ? u : {
                    ...u,
                    uid: generate$5('item')
                };
            },
            overrides: (detail, u)=>{
                return {
                    type: u.type,
                    ignoreFocus: detail.fakeFocus,
                    domModification: {
                        classes: [
                            detail.markers.item
                        ]
                    }
                };
            }
        })
    ]);
    const schema$m = constant$1([
        required$1('value'),
        required$1('items'),
        required$1('dom'),
        required$1('components'),
        defaulted('eventOrder', {}),
        field1('menuBehaviours', [
            Highlighting,
            Representing,
            Composing,
            Keying
        ]),
        defaultedOf('movement', {
            mode: 'menu',
            moveOnTab: true
        }, choose$1('mode', {
            grid: [
                initSize(),
                output$1('config', configureGrid)
            ],
            matrix: [
                output$1('config', configureMatrix),
                required$1('rowSelector')
            ],
            menu: [
                defaulted('moveOnTab', true),
                output$1('config', configureMenu)
            ]
        })),
        itemMarkers(),
        defaulted('fakeFocus', false),
        defaulted('focusManager', dom$2()),
        onHandler('onHighlight')
    ]);
    const focus1 = constant$1('alloy.menu-focus');
    const make$7 = (detail, components, _spec, _externals)=>({
            uid: detail.uid,
            dom: detail.dom,
            markers: detail.markers,
            behaviours: augment(detail.menuBehaviours, [
                Highlighting.config({
                    highlightClass: detail.markers.selectedItem,
                    itemClass: detail.markers.item,
                    onHighlight: detail.onHighlight
                }),
                Representing.config({
                    store: {
                        mode: 'memory',
                        initialValue: detail.value
                    }
                }),
                Composing.config({
                    find: Optional.some
                }),
                Keying.config(detail.movement.config(detail, detail.movement))
            ]),
            events: derive$2([
                run$1(focus$1(), (menu, simulatedEvent)=>{
                    const event = simulatedEvent.event;
                    menu.getSystem().getByDom(event.target).each((item)=>{
                        Highlighting.highlight(menu, item);
                        simulatedEvent.stop();
                        emitWith(menu, focus1(), {
                            menu,
                            item
                        });
                    });
                }),
                run$1(hover(), (menu, simulatedEvent)=>{
                    const item = simulatedEvent.event.item;
                    Highlighting.highlight(menu, item);
                })
            ]),
            components,
            eventOrder: detail.eventOrder,
            domModification: {
                attributes: {
                    role: 'menu'
                }
            }
        })
    ;
    const Menu = composite({
        name: 'Menu',
        configFields: schema$m(),
        partFields: parts$g(),
        factory: make$7
    });
    const transpose$1 = (obj)=>tupleMap(obj, (v, k)=>({
                k: v,
                v: k
            })
        )
    ;
    const trace = (items, byItem, byMenu, finish)=>get$g(byMenu, finish).bind((triggerItem)=>get$g(items, triggerItem).bind((triggerMenu)=>{
                const rest = trace(items, byItem, byMenu, triggerMenu);
                return Optional.some([
                    triggerMenu
                ].concat(rest));
            })
        ).getOr([])
    ;
    const generate$2 = (menus, expansions)=>{
        const items = {};
        each(menus, (menuItems, menu)=>{
            each$1(menuItems, (item)=>{
                items[item] = menu;
            });
        });
        const byItem = expansions;
        const byMenu = transpose$1(expansions);
        const menuPaths = map$1(byMenu, (_triggerItem, submenu)=>[
                submenu
            ].concat(trace(items, byItem, byMenu, submenu))
        );
        return map$1(items, (menu)=>get$g(menuPaths, menu).getOr([
                menu
            ])
        );
    };
    const init$c = ()=>{
        const expansions = Cell({});
        const menus = Cell({});
        const paths = Cell({});
        const primary = value$2();
        const directory = Cell({});
        const clear = ()=>{
            expansions.set({});
            menus.set({});
            paths.set({});
            primary.clear();
        };
        const isClear = ()=>primary.get().isNone()
        ;
        const setMenuBuilt = (menuName, built)=>{
            menus.set({
                ...menus.get(),
                [menuName]: {
                    type: 'prepared',
                    menu: built
                }
            });
        };
        const setContents = (sPrimary, sMenus, sExpansions, dir)=>{
            primary.set(sPrimary);
            expansions.set(sExpansions);
            menus.set(sMenus);
            directory.set(dir);
            const sPaths = generate$2(dir, sExpansions);
            paths.set(sPaths);
        };
        const getTriggeringItem = (menuValue)=>find$4(expansions.get(), (v, _k)=>v === menuValue
            )
        ;
        const getTriggerData = (menuValue, getItemByValue, path)=>getPreparedMenu(menuValue).bind((menu)=>getTriggeringItem(menuValue).bind((triggeringItemValue)=>getItemByValue(triggeringItemValue).map((triggeredItem)=>({
                            triggeredMenu: menu,
                            triggeringItem: triggeredItem,
                            triggeringPath: path
                        })
                    )
                )
            )
        ;
        const getTriggeringPath = (itemValue, getItemByValue)=>{
            const extraPath = filter$2(lookupItem(itemValue).toArray(), (menuValue)=>getPreparedMenu(menuValue).isSome()
            );
            return get$g(paths.get(), itemValue).bind((path)=>{
                const revPath = reverse(extraPath.concat(path));
                const triggers = bind$3(revPath, (menuValue, menuIndex)=>getTriggerData(menuValue, getItemByValue, revPath.slice(0, menuIndex + 1)).fold(()=>is$11(primary.get(), menuValue) ? [] : [
                            Optional.none()
                        ]
                    , (data)=>[
                            Optional.some(data)
                        ]
                    )
                );
                return sequence1(triggers);
            });
        };
        const expand = (itemValue)=>get$g(expansions.get(), itemValue).map((menu)=>{
                const current = get$g(paths.get(), itemValue).getOr([]);
                return [
                    menu
                ].concat(current);
            })
        ;
        const collapse = (itemValue)=>get$g(paths.get(), itemValue).bind((path)=>path.length > 1 ? Optional.some(path.slice(1)) : Optional.none()
            )
        ;
        const refresh = (itemValue)=>get$g(paths.get(), itemValue)
        ;
        const getPreparedMenu = (menuValue)=>lookupMenu(menuValue).bind(extractPreparedMenu)
        ;
        const lookupMenu = (menuValue)=>get$g(menus.get(), menuValue)
        ;
        const lookupItem = (itemValue)=>get$g(expansions.get(), itemValue)
        ;
        const otherMenus = (path)=>{
            const menuValues = directory.get();
            return difference(keys1(menuValues), path);
        };
        const getPrimary = ()=>primary.get().bind(getPreparedMenu)
        ;
        const getMenus = ()=>menus.get()
        ;
        return {
            setMenuBuilt,
            setContents,
            expand,
            refresh,
            collapse,
            lookupMenu,
            lookupItem,
            otherMenus,
            getPrimary,
            getMenus,
            clear,
            isClear,
            getTriggeringPath
        };
    };
    const extractPreparedMenu = (prep)=>prep.type === 'prepared' ? Optional.some(prep.menu) : Optional.none()
    ;
    const LayeredState = {
        init: init$c,
        extractPreparedMenu
    };
    const make$6 = (detail, _rawUiSpec)=>{
        const submenuParentItems = value$2();
        const buildMenus = (container, primaryName, menus)=>map$1(menus, (spec, name)=>{
                const makeSketch = ()=>Menu.sketch({
                        ...spec,
                        value: name,
                        markers: detail.markers,
                        fakeFocus: detail.fakeFocus,
                        onHighlight: detail.onHighlight,
                        focusManager: detail.fakeFocus ? highlights() : dom$2()
                    })
                ;
                return name === primaryName ? {
                    type: 'prepared',
                    menu: container.getSystem().build(makeSketch())
                } : {
                    type: 'notbuilt',
                    nbMenu: makeSketch
                };
            })
        ;
        const layeredState = LayeredState.init();
        const setup = (container)=>{
            const componentMap = buildMenus(container, detail.data.primary, detail.data.menus);
            const directory = toDirectory();
            layeredState.setContents(detail.data.primary, componentMap, detail.data.expansions, directory);
            return layeredState.getPrimary();
        };
        const getItemValue = (item)=>Representing.getValue(item).value
        ;
        const getItemByValue = (_container, menus, itemValue)=>findMap(menus, (menu)=>{
                if (!menu.getSystem().isConnected()) return Optional.none();
                const candidates = Highlighting.getCandidates(menu);
                return find$5(candidates, (c)=>getItemValue(c) === itemValue
                );
            })
        ;
        const toDirectory = (_container)=>map$1(detail.data.menus, (data, _menuName)=>bind$3(data.items, (item)=>item.type === 'separator' ? [] : [
                        item.data.value
                    ]
                )
            )
        ;
        const setActiveMenu = (container, menu)=>{
            Highlighting.highlight(container, menu);
            Highlighting.getHighlighted(menu).orThunk(()=>Highlighting.getFirst(menu)
            ).each((item)=>{
                dispatch(container, item.element, focusItem());
            });
        };
        const getMenus = (state, menuValues)=>cat(map$2(menuValues, (mv)=>state.lookupMenu(mv).bind((prep)=>prep.type === 'prepared' ? Optional.some(prep.menu) : Optional.none()
                )
            ))
        ;
        const closeOthers = (container, state, path)=>{
            const others = getMenus(state, state.otherMenus(path));
            each$1(others, (o)=>{
                remove$1(o.element, [
                    detail.markers.backgroundMenu
                ]);
                if (!detail.stayInDom) Replacing.remove(container, o);
            });
        };
        const getSubmenuParents = (container)=>submenuParentItems.get().getOrThunk(()=>{
                const r = {};
                const items = descendants(container.element, `.${detail.markers.item}`);
                const parentItems = filter$2(items, (i)=>get$f(i, 'aria-haspopup') === 'true'
                );
                each$1(parentItems, (i)=>{
                    container.getSystem().getByDom(i).each((itemComp)=>{
                        const key = getItemValue(itemComp);
                        r[key] = itemComp;
                    });
                });
                submenuParentItems.set(r);
                return r;
            })
        ;
        const updateAriaExpansions = (container, path)=>{
            const parentItems = getSubmenuParents(container);
            each(parentItems, (v, k)=>{
                const expanded = contains$2(path, k);
                set$9(v.element, 'aria-expanded', expanded);
            });
        };
        const updateMenuPath = (container, state, path)=>Optional.from(path[0]).bind((latestMenuName)=>state.lookupMenu(latestMenuName).bind((menuPrep)=>{
                    if (menuPrep.type === 'notbuilt') return Optional.none();
                    else {
                        const activeMenu = menuPrep.menu;
                        const rest = getMenus(state, path.slice(1));
                        each$1(rest, (r)=>{
                            add$2(r.element, detail.markers.backgroundMenu);
                        });
                        if (!inBody(activeMenu.element)) Replacing.append(container, premade(activeMenu));
                        remove$1(activeMenu.element, [
                            detail.markers.backgroundMenu
                        ]);
                        setActiveMenu(container, activeMenu);
                        closeOthers(container, state, path);
                        return Optional.some(activeMenu);
                    }
                })
            )
        ;
        let ExpandHighlightDecision1;
        (function(ExpandHighlightDecision) {
            ExpandHighlightDecision[ExpandHighlightDecision['HighlightSubmenu'] = 0] = 'HighlightSubmenu';
            ExpandHighlightDecision[ExpandHighlightDecision['HighlightParent'] = 1] = 'HighlightParent';
        })(ExpandHighlightDecision1 || (ExpandHighlightDecision1 = {}));
        const buildIfRequired = (container, menuName, menuPrep)=>{
            if (menuPrep.type === 'notbuilt') {
                const menu = container.getSystem().build(menuPrep.nbMenu());
                layeredState.setMenuBuilt(menuName, menu);
                return menu;
            } else return menuPrep.menu;
        };
        const expandRight = (container, item, decision = ExpandHighlightDecision1.HighlightSubmenu)=>{
            if (item.hasConfigured(Disabling) && Disabling.isDisabled(item)) return Optional.some(item);
            else {
                const value = getItemValue(item);
                return layeredState.expand(value).bind((path)=>{
                    updateAriaExpansions(container, path);
                    return Optional.from(path[0]).bind((menuName)=>layeredState.lookupMenu(menuName).bind((activeMenuPrep)=>{
                            const activeMenu = buildIfRequired(container, menuName, activeMenuPrep);
                            if (!inBody(activeMenu.element)) Replacing.append(container, premade(activeMenu));
                            detail.onOpenSubmenu(container, item, activeMenu, reverse(path));
                            if (decision === ExpandHighlightDecision1.HighlightSubmenu) {
                                Highlighting.highlightFirst(activeMenu);
                                return updateMenuPath(container, layeredState, path);
                            } else {
                                Highlighting.dehighlightAll(activeMenu);
                                return Optional.some(item);
                            }
                        })
                    );
                });
            }
        };
        const collapseLeft = (container, item)=>{
            const value = getItemValue(item);
            return layeredState.collapse(value).bind((path)=>{
                updateAriaExpansions(container, path);
                return updateMenuPath(container, layeredState, path).map((activeMenu)=>{
                    detail.onCollapseMenu(container, item, activeMenu);
                    return activeMenu;
                });
            });
        };
        const updateView = (container, item)=>{
            const value = getItemValue(item);
            return layeredState.refresh(value).bind((path)=>{
                updateAriaExpansions(container, path);
                return updateMenuPath(container, layeredState, path);
            });
        };
        const onRight = (container, item)=>inside(item.element) ? Optional.none() : expandRight(container, item, ExpandHighlightDecision1.HighlightSubmenu)
        ;
        const onLeft = (container, item)=>inside(item.element) ? Optional.none() : collapseLeft(container, item)
        ;
        const onEscape = (container, item)=>collapseLeft(container, item).orThunk(()=>detail.onEscape(container, item).map(()=>container
                )
            )
        ;
        const keyOnItem = (f)=>(container, simulatedEvent)=>closest$1(simulatedEvent.getSource(), '.' + detail.markers.item).bind((target)=>container.getSystem().getByDom(target).toOptional().bind((item)=>f(container, item).map(always)
                    )
                )
        ;
        const events = derive$2([
            run$1(focus1(), (sandbox, simulatedEvent)=>{
                const item = simulatedEvent.event.item;
                layeredState.lookupItem(getItemValue(item)).each(()=>{
                    const menu = simulatedEvent.event.menu;
                    Highlighting.highlight(sandbox, menu);
                    const value = getItemValue(simulatedEvent.event.item);
                    layeredState.refresh(value).each((path)=>closeOthers(sandbox, layeredState, path)
                    );
                });
            }),
            runOnExecute$1((component, simulatedEvent)=>{
                const target = simulatedEvent.event.target;
                component.getSystem().getByDom(target).each((item)=>{
                    const itemValue = getItemValue(item);
                    if (itemValue.indexOf('collapse-item') === 0) collapseLeft(component, item);
                    expandRight(component, item, ExpandHighlightDecision1.HighlightSubmenu).fold(()=>{
                        detail.onExecute(component, item);
                    }, noop);
                });
            }),
            runOnAttached((container, _simulatedEvent)=>{
                setup(container).each((primary)=>{
                    Replacing.append(container, premade(primary));
                    detail.onOpenMenu(container, primary);
                    if (detail.highlightImmediately) setActiveMenu(container, primary);
                });
            })
        ].concat(detail.navigateOnHover ? [
            run$1(hover(), (sandbox, simulatedEvent)=>{
                const item = simulatedEvent.event.item;
                updateView(sandbox, item);
                expandRight(sandbox, item, ExpandHighlightDecision1.HighlightParent);
                detail.onHover(sandbox, item);
            })
        ] : []));
        const getActiveItem = (container)=>Highlighting.getHighlighted(container).bind(Highlighting.getHighlighted)
        ;
        const collapseMenuApi = (container)=>{
            getActiveItem(container).each((currentItem)=>{
                collapseLeft(container, currentItem);
            });
        };
        const highlightPrimary = (container)=>{
            layeredState.getPrimary().each((primary)=>{
                setActiveMenu(container, primary);
            });
        };
        const extractMenuFromContainer = (container)=>Optional.from(container.components()[0]).filter((comp)=>get$f(comp.element, 'role') === 'menu'
            )
        ;
        const repositionMenus = (container)=>{
            const maybeActivePrimary = layeredState.getPrimary().bind((primary)=>getActiveItem(container).bind((currentItem)=>{
                    const itemValue = getItemValue(currentItem);
                    const allMenus = values1(layeredState.getMenus());
                    const preparedMenus = cat(map$2(allMenus, LayeredState.extractPreparedMenu));
                    return layeredState.getTriggeringPath(itemValue, (v)=>getItemByValue(container, preparedMenus, v)
                    );
                }).map((triggeringPath)=>({
                        primary,
                        triggeringPath
                    })
                )
            );
            maybeActivePrimary.fold(()=>{
                extractMenuFromContainer(container).each((primaryMenu)=>{
                    detail.onRepositionMenu(container, primaryMenu, []);
                });
            }, ({ primary , triggeringPath  })=>{
                detail.onRepositionMenu(container, primary, triggeringPath);
            });
        };
        const apis = {
            collapseMenu: collapseMenuApi,
            highlightPrimary,
            repositionMenus
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            markers: detail.markers,
            behaviours: augment(detail.tmenuBehaviours, [
                Keying.config({
                    mode: 'special',
                    onRight: keyOnItem(onRight),
                    onLeft: keyOnItem(onLeft),
                    onEscape: keyOnItem(onEscape),
                    focusIn: (container, _keyInfo)=>{
                        layeredState.getPrimary().each((primary)=>{
                            dispatch(container, primary.element, focusItem());
                        });
                    }
                }),
                Highlighting.config({
                    highlightClass: detail.markers.selectedMenu,
                    itemClass: detail.markers.menu
                }),
                Composing.config({
                    find: (container)=>{
                        return Highlighting.getHighlighted(container);
                    }
                }),
                Replacing.config({})
            ]),
            eventOrder: detail.eventOrder,
            apis,
            events
        };
    };
    const collapseItem$1 = constant$1('collapse-item');
    const tieredData = (primary, menus, expansions)=>({
            primary,
            menus,
            expansions
        })
    ;
    const singleData = (name, menu)=>({
            primary: name,
            menus: wrap$1(name, menu),
            expansions: {}
        })
    ;
    const collapseItem = (text)=>({
            value: generate$6(collapseItem$1()),
            meta: {
                text
            }
        })
    ;
    const tieredMenu = single({
        name: 'TieredMenu',
        configFields: [
            onStrictKeyboardHandler('onExecute'),
            onStrictKeyboardHandler('onEscape'),
            onStrictHandler('onOpenMenu'),
            onStrictHandler('onOpenSubmenu'),
            onHandler('onRepositionMenu'),
            onHandler('onCollapseMenu'),
            defaulted('highlightImmediately', true),
            requiredObjOf('data', [
                required$1('primary'),
                required$1('menus'),
                required$1('expansions')
            ]),
            defaulted('fakeFocus', false),
            onHandler('onHighlight'),
            onHandler('onHover'),
            tieredMenuMarkers(),
            required$1('dom'),
            defaulted('navigateOnHover', true),
            defaulted('stayInDom', false),
            field1('tmenuBehaviours', [
                Keying,
                Highlighting,
                Composing,
                Replacing
            ]),
            defaulted('eventOrder', {})
        ],
        apis: {
            collapseMenu: (apis, tmenu)=>{
                apis.collapseMenu(tmenu);
            },
            highlightPrimary: (apis, tmenu)=>{
                apis.highlightPrimary(tmenu);
            },
            repositionMenus: (apis, tmenu)=>{
                apis.repositionMenus(tmenu);
            }
        },
        factory: make$6,
        extraApis: {
            tieredData,
            singleData,
            collapseItem
        }
    });
    const makeMenu = (detail, menuSandbox, placementSpec, menuSpec, getBounds)=>{
        const lazySink = ()=>detail.lazySink(menuSandbox)
        ;
        const layouts = menuSpec.type === 'horizontal' ? {
            layouts: {
                onLtr: ()=>belowOrAbove()
                ,
                onRtl: ()=>belowOrAboveRtl()
            }
        } : {};
        const isFirstTierSubmenu = (triggeringPaths)=>triggeringPaths.length === 2
        ;
        const getSubmenuLayouts = (triggeringPaths)=>isFirstTierSubmenu(triggeringPaths) ? layouts : {}
        ;
        return tieredMenu.sketch({
            dom: {
                tag: 'div'
            },
            data: menuSpec.data,
            markers: menuSpec.menu.markers,
            highlightImmediately: menuSpec.menu.highlightImmediately,
            onEscape: ()=>{
                Sandboxing.close(menuSandbox);
                detail.onEscape.map((handler)=>handler(menuSandbox)
                );
                return Optional.some(true);
            },
            onExecute: ()=>{
                return Optional.some(true);
            },
            onOpenMenu: (tmenu, menu)=>{
                Positioning.positionWithinBounds(lazySink().getOrDie(), menu, placementSpec, getBounds());
            },
            onOpenSubmenu: (tmenu, item, submenu, triggeringPaths)=>{
                const sink = lazySink().getOrDie();
                Positioning.position(sink, submenu, {
                    anchor: {
                        type: 'submenu',
                        item,
                        ...getSubmenuLayouts(triggeringPaths)
                    }
                });
            },
            onRepositionMenu: (tmenu, primaryMenu, submenuTriggers)=>{
                const sink = lazySink().getOrDie();
                Positioning.positionWithinBounds(sink, primaryMenu, placementSpec, getBounds());
                each$1(submenuTriggers, (st)=>{
                    const submenuLayouts = getSubmenuLayouts(st.triggeringPath);
                    Positioning.position(sink, st.triggeredMenu, {
                        anchor: {
                            type: 'submenu',
                            item: st.triggeringItem,
                            ...submenuLayouts
                        }
                    });
                });
            }
        });
    };
    const factory$m = (detail, spec)=>{
        const isPartOfRelated = (sandbox, queryElem)=>{
            const related = detail.getRelated(sandbox);
            return related.exists((rel)=>isPartOf$1(rel, queryElem)
            );
        };
        const setContent = (sandbox, thing)=>{
            Sandboxing.setContent(sandbox, thing);
        };
        const showAt = (sandbox, thing, placementSpec)=>{
            showWithin(sandbox, thing, placementSpec, Optional.none());
        };
        const showWithin = (sandbox, thing, placementSpec, boxElement)=>{
            showWithinBounds(sandbox, thing, placementSpec, ()=>boxElement.map((elem)=>box$1(elem)
                )
            );
        };
        const showWithinBounds = (sandbox, thing, placementSpec, getBounds)=>{
            const sink = detail.lazySink(sandbox).getOrDie();
            Sandboxing.openWhileCloaked(sandbox, thing, ()=>Positioning.positionWithinBounds(sink, sandbox, placementSpec, getBounds())
            );
            Representing.setValue(sandbox, Optional.some({
                mode: 'position',
                config: placementSpec,
                getBounds
            }));
        };
        const showMenuAt = (sandbox, placementSpec, menuSpec)=>{
            showMenuWithinBounds(sandbox, placementSpec, menuSpec, Optional.none);
        };
        const showMenuWithinBounds = (sandbox, placementSpec, menuSpec, getBounds)=>{
            const menu = makeMenu(detail, sandbox, placementSpec, menuSpec, getBounds);
            Sandboxing.open(sandbox, menu);
            Representing.setValue(sandbox, Optional.some({
                mode: 'menu',
                menu
            }));
        };
        const hide = (sandbox)=>{
            if (Sandboxing.isOpen(sandbox)) {
                Representing.setValue(sandbox, Optional.none());
                Sandboxing.close(sandbox);
            }
        };
        const getContent = (sandbox)=>Sandboxing.getState(sandbox)
        ;
        const reposition = (sandbox)=>{
            if (Sandboxing.isOpen(sandbox)) Representing.getValue(sandbox).each((state)=>{
                switch(state.mode){
                    case 'menu':
                        Sandboxing.getState(sandbox).each(tieredMenu.repositionMenus);
                        break;
                    case 'position':
                        const sink = detail.lazySink(sandbox).getOrDie();
                        Positioning.positionWithinBounds(sink, sandbox, state.config, state.getBounds());
                        break;
                }
            });
        };
        const apis = {
            setContent,
            showAt,
            showWithin,
            showWithinBounds,
            showMenuAt,
            showMenuWithinBounds,
            hide,
            getContent,
            reposition,
            isOpen: Sandboxing.isOpen
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            behaviours: augment(detail.inlineBehaviours, [
                Sandboxing.config({
                    isPartOf: (sandbox, data, queryElem)=>{
                        return isPartOf$1(data, queryElem) || isPartOfRelated(sandbox, queryElem);
                    },
                    getAttachPoint: (sandbox)=>{
                        return detail.lazySink(sandbox).getOrDie();
                    },
                    onOpen: (sandbox)=>{
                        detail.onShow(sandbox);
                    },
                    onClose: (sandbox)=>{
                        detail.onHide(sandbox);
                    }
                }),
                Representing.config({
                    store: {
                        mode: 'memory',
                        initialValue: Optional.none()
                    }
                }),
                Receiving.config({
                    channels: {
                        ...receivingChannel$1({
                            isExtraPart: spec.isExtraPart,
                            ...detail.fireDismissalEventInstead.map((fe)=>({
                                    fireEventInstead: {
                                        event: fe.event
                                    }
                                })
                            ).getOr({})
                        }),
                        ...receivingChannel({
                            ...detail.fireRepositionEventInstead.map((fe)=>({
                                    fireEventInstead: {
                                        event: fe.event
                                    }
                                })
                            ).getOr({}),
                            doReposition: reposition
                        })
                    }
                })
            ]),
            eventOrder: detail.eventOrder,
            apis
        };
    };
    const InlineView = single({
        name: 'InlineView',
        configFields: [
            required$1('lazySink'),
            onHandler('onShow'),
            onHandler('onHide'),
            optionFunction('onEscape'),
            field1('inlineBehaviours', [
                Sandboxing,
                Representing,
                Receiving
            ]),
            optionObjOf('fireDismissalEventInstead', [
                defaulted('event', dismissRequested())
            ]),
            optionObjOf('fireRepositionEventInstead', [
                defaulted('event', repositionRequested())
            ]),
            defaulted('getRelated', Optional.none),
            defaulted('isExtraPart', never),
            defaulted('eventOrder', Optional.none)
        ],
        factory: factory$m,
        apis: {
            showAt: (apis, component, anchor, thing)=>{
                apis.showAt(component, anchor, thing);
            },
            showWithin: (apis, component, anchor, thing, boxElement)=>{
                apis.showWithin(component, anchor, thing, boxElement);
            },
            showWithinBounds: (apis, component, anchor, thing, bounds)=>{
                apis.showWithinBounds(component, anchor, thing, bounds);
            },
            showMenuAt: (apis, component, anchor, menuSpec)=>{
                apis.showMenuAt(component, anchor, menuSpec);
            },
            showMenuWithinBounds: (apis, component, anchor, menuSpec, bounds)=>{
                apis.showMenuWithinBounds(component, anchor, menuSpec, bounds);
            },
            hide: (apis, component)=>{
                apis.hide(component);
            },
            isOpen: (apis, component)=>apis.isOpen(component)
            ,
            getContent: (apis, component)=>apis.getContent(component)
            ,
            setContent: (apis, component, thing)=>{
                apis.setContent(component, thing);
            },
            reposition: (apis, component)=>{
                apis.reposition(component);
            }
        }
    });
    var global$9 = tinymce.util.Tools.resolve('tinymce.util.Delay');
    const factory$l = (detail)=>{
        const events = events$a(detail.action);
        const tag = detail.dom.tag;
        const lookupAttr = (attr)=>get$g(detail.dom, 'attributes').bind((attrs)=>get$g(attrs, attr)
            )
        ;
        const getModAttributes = ()=>{
            if (tag === 'button') {
                const type = lookupAttr('type').getOr('button');
                const roleAttrs = lookupAttr('role').map((role)=>({
                        role
                    })
                ).getOr({});
                return {
                    type,
                    ...roleAttrs
                };
            } else {
                const role = lookupAttr('role').getOr('button');
                return {
                    role
                };
            }
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components: detail.components,
            events,
            behaviours: SketchBehaviours.augment(detail.buttonBehaviours, [
                Focusing.config({}),
                Keying.config({
                    mode: 'execution',
                    useSpace: true,
                    useEnter: true
                })
            ]),
            domModification: {
                attributes: getModAttributes()
            },
            eventOrder: detail.eventOrder
        };
    };
    const Button = single({
        name: 'Button',
        factory: factory$l,
        configFields: [
            defaulted('uid', undefined),
            required$1('dom'),
            defaulted('components', []),
            SketchBehaviours.field('buttonBehaviours', [
                Focusing,
                Keying
            ]),
            option$3('action'),
            option$3('role'),
            defaulted('eventOrder', {})
        ]
    });
    const record1 = (spec)=>{
        const uid = isSketchSpec(spec) && hasNonNullableKey(spec, 'uid') ? spec.uid : generate$5('memento');
        const get = (anyInSystem)=>anyInSystem.getSystem().getByUid(uid).getOrDie()
        ;
        const getOpt = (anyInSystem)=>anyInSystem.getSystem().getByUid(uid).toOptional()
        ;
        const asSpec = ()=>({
                ...spec,
                uid
            })
        ;
        return {
            get,
            getOpt,
            asSpec
        };
    };
    var global$8 = tinymce.util.Tools.resolve('tinymce.util.I18n');
    const rtlTransform = {
        'indent': true,
        'outdent': true,
        'table-insert-column-after': true,
        'table-insert-column-before': true,
        'paste-column-after': true,
        'paste-column-before': true,
        'unordered-list': true,
        'list-bull-circle': true,
        'list-bull-default': true,
        'list-bull-square': true
    };
    const defaultIconName = 'temporary-placeholder';
    const defaultIcon = (icons)=>()=>get$g(icons, defaultIconName).getOr('!not found!')
    ;
    const getIconName = (name, icons)=>{
        const lcName = name.toLowerCase();
        if (global$8.isRtl()) {
            const rtlName = ensureTrailing(lcName, '-rtl');
            return has$2(icons, rtlName) ? rtlName : lcName;
        } else return lcName;
    };
    const lookupIcon = (name, icons)=>get$g(icons, getIconName(name, icons))
    ;
    const get$2 = (name, iconProvider)=>{
        const icons = iconProvider();
        return lookupIcon(name, icons).getOrThunk(defaultIcon(icons));
    };
    const getOr = (name, iconProvider, fallbackIcon)=>{
        const icons = iconProvider();
        return lookupIcon(name, icons).or(fallbackIcon).getOrThunk(defaultIcon(icons));
    };
    const needsRtlTransform = (iconName)=>global$8.isRtl() ? has$2(rtlTransform, iconName) : false
    ;
    const addFocusableBehaviour = ()=>config1('add-focusable', [
            runOnAttached((comp)=>{
                child1(comp.element, 'svg').each((svg)=>set$9(svg, 'focusable', 'false')
                );
            })
        ])
    ;
    const renderIcon$2 = (spec, iconName, icons, fallbackIcon)=>{
        var _a, _b;
        const rtlIconClasses = needsRtlTransform(iconName) ? [
            'tox-icon--flip'
        ] : [];
        const iconHtml = get$g(icons, getIconName(iconName, icons)).or(fallbackIcon).getOrThunk(defaultIcon(icons));
        return {
            dom: {
                tag: spec.tag,
                attributes: (_a = spec.attributes) !== null && _a !== void 0 ? _a : {},
                classes: spec.classes.concat(rtlIconClasses),
                innerHtml: iconHtml
            },
            behaviours: derive$1([
                ...(_b = spec.behaviours) !== null && _b !== void 0 ? _b : [],
                addFocusableBehaviour()
            ])
        };
    };
    const render$3 = (iconName, spec, iconProvider, fallbackIcon = Optional.none())=>renderIcon$2(spec, iconName, iconProvider(), fallbackIcon)
    ;
    const renderFirst = (iconNames, spec, iconProvider)=>{
        const icons = iconProvider();
        const iconName = find$5(iconNames, (name)=>has$2(icons, getIconName(name, icons))
        );
        return renderIcon$2(spec, iconName.getOr(defaultIconName), icons, Optional.none());
    };
    const notificationIconMap = {
        success: 'checkmark',
        error: 'warning',
        err: 'error',
        warning: 'warning',
        warn: 'warning',
        info: 'info'
    };
    const factory$k = (detail)=>{
        const memBannerText = record1({
            dom: {
                tag: 'p',
                innerHtml: detail.translationProvider(detail.text)
            },
            behaviours: derive$1([
                Replacing.config({})
            ])
        });
        const renderPercentBar = (percent)=>({
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-bar'
                    ],
                    styles: {
                        width: `${percent}%`
                    }
                }
            })
        ;
        const renderPercentText = (percent)=>({
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-text'
                    ],
                    innerHtml: `${percent}%`
                }
            })
        ;
        const memBannerProgress = record1({
            dom: {
                tag: 'div',
                classes: detail.progress ? [
                    'tox-progress-bar',
                    'tox-progress-indicator'
                ] : [
                    'tox-progress-bar'
                ]
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: [
                            'tox-bar-container'
                        ]
                    },
                    components: [
                        renderPercentBar(0)
                    ]
                },
                renderPercentText(0)
            ],
            behaviours: derive$1([
                Replacing.config({})
            ])
        });
        const updateProgress = (comp, percent)=>{
            if (comp.getSystem().isConnected()) memBannerProgress.getOpt(comp).each((progress)=>{
                Replacing.set(progress, [
                    {
                        dom: {
                            tag: 'div',
                            classes: [
                                'tox-bar-container'
                            ]
                        },
                        components: [
                            renderPercentBar(percent)
                        ]
                    },
                    renderPercentText(percent)
                ]);
            });
        };
        const updateText = (comp, text)=>{
            if (comp.getSystem().isConnected()) {
                const banner = memBannerText.get(comp);
                Replacing.set(banner, [
                    text$1(text)
                ]);
            }
        };
        const apis = {
            updateProgress,
            updateText
        };
        const iconChoices = flatten1([
            detail.icon.toArray(),
            detail.level.toArray(),
            detail.level.bind((level)=>Optional.from(notificationIconMap[level])
            ).toArray()
        ]);
        const memButton = record1(Button.sketch({
            dom: {
                tag: 'button',
                classes: [
                    'tox-notification__dismiss',
                    'tox-button',
                    'tox-button--naked',
                    'tox-button--icon'
                ]
            },
            components: [
                render$3('close', {
                    tag: 'div',
                    classes: [
                        'tox-icon'
                    ],
                    attributes: {
                        'aria-label': detail.translationProvider('Close')
                    }
                }, detail.iconProvider)
            ],
            action: (comp)=>{
                detail.onAction(comp);
            }
        }));
        const notificationIconSpec = renderFirst(iconChoices, {
            tag: 'div',
            classes: [
                'tox-notification__icon'
            ]
        }, detail.iconProvider);
        const notificationBodySpec = {
            dom: {
                tag: 'div',
                classes: [
                    'tox-notification__body'
                ]
            },
            components: [
                memBannerText.asSpec()
            ],
            behaviours: derive$1([
                Replacing.config({})
            ])
        };
        const components = [
            notificationIconSpec,
            notificationBodySpec
        ];
        return {
            uid: detail.uid,
            dom: {
                tag: 'div',
                attributes: {
                    role: 'alert'
                },
                classes: detail.level.map((level)=>[
                        'tox-notification',
                        'tox-notification--in',
                        `tox-notification--${level}`
                    ]
                ).getOr([
                    'tox-notification',
                    'tox-notification--in'
                ])
            },
            behaviours: derive$1([
                Focusing.config({}),
                config1('notification-events', [
                    run$1(focusin(), (comp)=>{
                        memButton.getOpt(comp).each(Focusing.focus);
                    })
                ])
            ]),
            components: components.concat(detail.progress ? [
                memBannerProgress.asSpec()
            ] : []).concat(!detail.closeButton ? [] : [
                memButton.asSpec()
            ]),
            apis
        };
    };
    const Notification = single({
        name: 'Notification',
        factory: factory$k,
        configFields: [
            option$3('level'),
            required$1('progress'),
            required$1('icon'),
            required$1('onAction'),
            required$1('text'),
            required$1('iconProvider'),
            required$1('translationProvider'),
            defaultedBoolean('closeButton', true)
        ],
        apis: {
            updateProgress: (apis, comp, percent)=>{
                apis.updateProgress(comp, percent);
            },
            updateText: (apis, comp, text)=>{
                apis.updateText(comp, text);
            }
        }
    });
    var NotificationManagerImpl = (editor, extras, uiMothership)=>{
        const sharedBackstage = extras.backstage.shared;
        const getBounds = ()=>{
            const contentArea = box$1(SugarElement.fromDom(editor.getContentAreaContainer()));
            const win$1 = win1();
            const x = clamp(win$1.x, contentArea.x, contentArea.right);
            const y = clamp(win$1.y, contentArea.y, contentArea.bottom);
            const right = Math.max(contentArea.right, win$1.right);
            const bottom = Math.max(contentArea.bottom, win$1.bottom);
            return Optional.some(bounds1(x, y, right - x, bottom - y));
        };
        const open = (settings, closeCallback)=>{
            const close = ()=>{
                closeCallback();
                InlineView.hide(notificationWrapper);
            };
            const notification = build$1(Notification.sketch({
                text: settings.text,
                level: contains$2([
                    'success',
                    'error',
                    'warning',
                    'warn',
                    'info'
                ], settings.type) ? settings.type : undefined,
                progress: settings.progressBar === true,
                icon: Optional.from(settings.icon),
                closeButton: settings.closeButton,
                onAction: close,
                iconProvider: sharedBackstage.providers.icons,
                translationProvider: sharedBackstage.providers.translate
            }));
            const notificationWrapper = build$1(InlineView.sketch({
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-notifications-container'
                    ]
                },
                lazySink: sharedBackstage.getSink,
                fireDismissalEventInstead: {},
                ...sharedBackstage.header.isPositionedAtTop() ? {} : {
                    fireRepositionEventInstead: {}
                }
            }));
            uiMothership.add(notificationWrapper);
            if (settings.timeout > 0) global$9.setEditorTimeout(editor, ()=>{
                close();
            }, settings.timeout);
            const reposition = ()=>{
                const notificationSpec = premade(notification);
                const anchorOverrides = {
                    maxHeightFunction: expandable$1()
                };
                const allNotifications = editor.notificationManager.getNotifications();
                if (allNotifications[0] === thisNotification) {
                    const anchor = {
                        ...sharedBackstage.anchors.banner(),
                        overrides: anchorOverrides
                    };
                    InlineView.showWithinBounds(notificationWrapper, notificationSpec, {
                        anchor
                    }, getBounds);
                } else indexOf(allNotifications, thisNotification).each((idx)=>{
                    const previousNotification = allNotifications[idx - 1].getEl();
                    const nodeAnchor = {
                        type: 'node',
                        root: body1(),
                        node: Optional.some(SugarElement.fromDom(previousNotification)),
                        overrides: anchorOverrides,
                        layouts: {
                            onRtl: ()=>[
                                    south$2
                                ]
                            ,
                            onLtr: ()=>[
                                    south$2
                                ]
                        }
                    };
                    InlineView.showWithinBounds(notificationWrapper, notificationSpec, {
                        anchor: nodeAnchor
                    }, getBounds);
                });
            };
            const thisNotification = {
                close,
                reposition,
                text: (nuText)=>{
                    Notification.updateText(notification, nuText);
                },
                settings,
                getEl: ()=>notification.element.dom
                ,
                progressBar: {
                    value: (percent)=>{
                        Notification.updateProgress(notification, percent);
                    }
                }
            };
            return thisNotification;
        };
        const close2 = (notification)=>{
            notification.close();
        };
        const getArgs = (notification)=>{
            return notification.settings;
        };
        return {
            open,
            close: close2,
            getArgs
        };
    };
    var global$7 = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils');
    var global$6 = tinymce.util.Tools.resolve('tinymce.EditorManager');
    var global$5 = tinymce.util.Tools.resolve('tinymce.Env');
    var ToolbarMode$1;
    (function(ToolbarMode) {
        ToolbarMode['default'] = 'wrap';
        ToolbarMode['floating'] = 'floating';
        ToolbarMode['sliding'] = 'sliding';
        ToolbarMode['scrolling'] = 'scrolling';
    })(ToolbarMode$1 || (ToolbarMode$1 = {}));
    var ToolbarLocation$1;
    (function(ToolbarLocation) {
        ToolbarLocation['auto'] = 'auto';
        ToolbarLocation['top'] = 'top';
        ToolbarLocation['bottom'] = 'bottom';
    })(ToolbarLocation$1 || (ToolbarLocation$1 = {}));
    const option$2 = (name)=>(editor)=>editor.options.get(name)
    ;
    const wrapOptional = (fn)=>(editor)=>Optional.from(fn(editor))
    ;
    const register$e = (editor)=>{
        const isPhone = global$5.deviceType.isPhone();
        const isMobile = global$5.deviceType.isTablet() || isPhone;
        const registerOption = editor.options.register;
        const stringOrFalseProcessor = (value)=>isString(value) || value === false
        ;
        const stringOrNumberProcessor = (value)=>isString(value) || isNumber(value)
        ;
        registerOption('skin', {
            processor: (value)=>isString(value) || value === false
            ,
            default: 'oxide'
        });
        registerOption('skin_url', {
            processor: 'string'
        });
        registerOption('height', {
            processor: stringOrNumberProcessor,
            default: Math.max(editor.getElement().offsetHeight, 400)
        });
        registerOption('width', {
            processor: stringOrNumberProcessor,
            default: global$7.DOM.getStyle(editor.getElement(), 'width')
        });
        registerOption('min_height', {
            processor: 'number',
            default: 100
        });
        registerOption('min_width', {
            processor: 'number'
        });
        registerOption('max_height', {
            processor: 'number'
        });
        registerOption('max_width', {
            processor: 'number'
        });
        registerOption('style_formats', {
            processor: 'object[]'
        });
        registerOption('style_formats_merge', {
            processor: 'boolean',
            default: false
        });
        registerOption('style_formats_autohide', {
            processor: 'boolean',
            default: false
        });
        registerOption('line_height_formats', {
            processor: 'string',
            default: '1 1.1 1.2 1.3 1.4 1.5 2'
        });
        registerOption('font_family_formats', {
            processor: 'string',
            default: "Andale Mono=andale mono,monospace;Arial=arial,helvetica,sans-serif;Arial Black=arial black,sans-serif;Book Antiqua=book antiqua,palatino,serif;Comic Sans MS=comic sans ms,sans-serif;Courier New=courier new,courier,monospace;Georgia=georgia,palatino,serif;Helvetica=helvetica,arial,sans-serif;Impact=impact,sans-serif;Symbol=symbol;Tahoma=tahoma,arial,helvetica,sans-serif;Terminal=terminal,monaco,monospace;Times New Roman=times new roman,times,serif;Trebuchet MS=trebuchet ms,geneva,sans-serif;Verdana=verdana,geneva,sans-serif;Webdings=webdings;Wingdings=wingdings,zapf dingbats"
        });
        registerOption('font_size_formats', {
            processor: 'string',
            default: '8pt 10pt 12pt 14pt 18pt 24pt 36pt'
        });
        registerOption('block_formats', {
            processor: 'string',
            default: "Paragraph=p;Heading 1=h1;Heading 2=h2;Heading 3=h3;Heading 4=h4;Heading 5=h5;Heading 6=h6;Preformatted=pre"
        });
        registerOption('content_langs', {
            processor: 'object[]'
        });
        registerOption('removed_menuitems', {
            processor: 'string',
            default: ''
        });
        registerOption('menubar', {
            processor: (value)=>isString(value) || isBoolean(value)
            ,
            default: !isPhone
        });
        registerOption('menu', {
            processor: 'object',
            default: {}
        });
        registerOption('toolbar', {
            processor: (value)=>{
                if (isBoolean(value) || isString(value) || isArray(value)) return {
                    value,
                    valid: true
                };
                else return {
                    valid: false,
                    message: 'Must be a boolean, string or array.'
                };
            },
            default: true
        });
        range$2(9, (num)=>{
            registerOption('toolbar' + (num + 1), {
                processor: 'string'
            });
        });
        registerOption('toolbar_mode', {
            processor: 'string',
            default: isMobile ? 'scrolling' : 'floating'
        });
        registerOption('toolbar_groups', {
            processor: 'object',
            default: {}
        });
        registerOption('toolbar_location', {
            processor: 'string',
            default: ToolbarLocation$1.auto
        });
        registerOption('toolbar_persist', {
            processor: 'boolean',
            default: false
        });
        registerOption('toolbar_sticky', {
            processor: 'boolean',
            default: editor.inline
        });
        registerOption('toolbar_sticky_offset', {
            processor: 'number',
            default: 0
        });
        registerOption('fixed_toolbar_container', {
            processor: 'string',
            default: ''
        });
        registerOption('fixed_toolbar_container_target', {
            processor: 'object'
        });
        registerOption('file_picker_callback', {
            processor: 'function'
        });
        registerOption('file_picker_validator_handler', {
            processor: 'function'
        });
        registerOption('file_picker_types', {
            processor: 'string'
        });
        registerOption('typeahead_urls', {
            processor: 'boolean',
            default: true
        });
        registerOption('anchor_top', {
            processor: stringOrFalseProcessor,
            default: '#top'
        });
        registerOption('anchor_bottom', {
            processor: stringOrFalseProcessor,
            default: '#bottom'
        });
        registerOption('draggable_modal', {
            processor: 'boolean',
            default: false
        });
        registerOption('statusbar', {
            processor: 'boolean',
            default: true
        });
        registerOption('elementpath', {
            processor: 'boolean',
            default: true
        });
        registerOption('branding', {
            processor: 'boolean',
            default: true
        });
        registerOption('resize', {
            processor: (value)=>value === 'both' || isBoolean(value)
            ,
            default: !global$5.deviceType.isTouch()
        });
    };
    const isReadOnly = option$2('readonly');
    const getHeightOption = option$2('height');
    const getWidthOption = option$2('width');
    const getMinWidthOption = wrapOptional(option$2('min_width'));
    const getMinHeightOption = wrapOptional(option$2('min_height'));
    const getMaxWidthOption = wrapOptional(option$2('max_width'));
    const getMaxHeightOption = wrapOptional(option$2('max_height'));
    const getUserStyleFormats = wrapOptional(option$2('style_formats'));
    const shouldMergeStyleFormats = option$2('style_formats_merge');
    const shouldAutoHideStyleFormats = option$2('style_formats_autohide');
    const getContentLanguages = option$2('content_langs');
    const getRemovedMenuItems = option$2('removed_menuitems');
    const getToolbarMode = option$2('toolbar_mode');
    const getToolbarGroups = option$2('toolbar_groups');
    const getToolbarLocation = option$2('toolbar_location');
    const fixedContainerSelector = option$2('fixed_toolbar_container');
    const fixedToolbarContainerTarget = option$2('fixed_toolbar_container_target');
    const isToolbarPersist = option$2('toolbar_persist');
    const getStickyToolbarOffset = option$2('toolbar_sticky_offset');
    const getMenubar = option$2('menubar');
    const getToolbar = option$2('toolbar');
    const getFilePickerCallback = option$2('file_picker_callback');
    const getFilePickerValidatorHandler = option$2('file_picker_validator_handler');
    const getFilePickerTypes = option$2('file_picker_types');
    const useTypeaheadUrls = option$2('typeahead_urls');
    const getAnchorTop = option$2('anchor_top');
    const getAnchorBottom = option$2('anchor_bottom');
    const isDraggableModal$1 = option$2('draggable_modal');
    const useStatusBar = option$2('statusbar');
    const useElementPath = option$2('elementpath');
    const useBranding = option$2('branding');
    const getResize = option$2('resize');
    const getPasteAsText = option$2('paste_as_text');
    const isSkinDisabled = (editor)=>editor.options.get('skin') === false
    ;
    const isMenubarEnabled = (editor)=>editor.options.get('menubar') !== false
    ;
    const getSkinUrl = (editor)=>{
        const skinUrl = editor.options.get('skin_url');
        if (isSkinDisabled(editor)) return skinUrl;
        else {
            if (skinUrl) return editor.documentBaseURI.toAbsolute(skinUrl);
            else {
                const skin = editor.options.get('skin');
                return global$6.baseURL + '/skins/ui/' + skin;
            }
        }
    };
    const getLineHeightFormats = (editor)=>editor.options.get('line_height_formats').split(' ')
    ;
    const isToolbarEnabled = (editor)=>{
        const toolbar = getToolbar(editor);
        const isToolbarString = isString(toolbar);
        const isToolbarObjectArray = isArray(toolbar) && toolbar.length > 0;
        return !isMultipleToolbars(editor) && (isToolbarObjectArray || isToolbarString || toolbar === true);
    };
    const getMultipleToolbarsOption = (editor)=>{
        const toolbars = range$2(9, (num)=>editor.options.get('toolbar' + (num + 1))
        );
        const toolbarArray = filter$2(toolbars, isString);
        return someIf(toolbarArray.length > 0, toolbarArray);
    };
    const isMultipleToolbars = (editor)=>getMultipleToolbarsOption(editor).fold(()=>{
            const toolbar = getToolbar(editor);
            return isArrayOf(toolbar, isString) && toolbar.length > 0;
        }, always)
    ;
    const isToolbarLocationBottom = (editor)=>getToolbarLocation(editor) === ToolbarLocation$1.bottom
    ;
    const fixedContainerTarget = (editor)=>{
        if (!editor.inline) return Optional.none();
        const selector = fixedContainerSelector(editor);
        if (selector.length > 0) return descendant(body1(), selector);
        const element = fixedToolbarContainerTarget(editor);
        if (isNonNullable(element)) return Optional.some(SugarElement.fromDom(element));
        return Optional.none();
    };
    const useFixedContainer = (editor)=>editor.inline && fixedContainerTarget(editor).isSome()
    ;
    const getUiContainer = (editor)=>{
        const fixedContainer = fixedContainerTarget(editor);
        return fixedContainer.getOrThunk(()=>getContentContainer(getRootNode(SugarElement.fromDom(editor.getElement())))
        );
    };
    const isDistractionFree = (editor)=>editor.inline && !isMenubarEnabled(editor) && !isToolbarEnabled(editor) && !isMultipleToolbars(editor)
    ;
    const isStickyToolbar1 = (editor)=>{
        const isStickyToolbar = editor.options.get('toolbar_sticky');
        return (isStickyToolbar || editor.inline) && !useFixedContainer(editor) && !isDistractionFree(editor);
    };
    const getMenus1 = (editor)=>{
        const menu2 = editor.options.get('menu');
        return map$1(menu2, (menu)=>({
                ...menu,
                items: menu.items
            })
        );
    };
    var Options = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        get ToolbarMode () {
            return ToolbarMode$1;
        },
        get ToolbarLocation () {
            return ToolbarLocation$1;
        },
        register: register$e,
        getSkinUrl: getSkinUrl,
        isReadOnly: isReadOnly,
        isSkinDisabled: isSkinDisabled,
        getHeightOption: getHeightOption,
        getWidthOption: getWidthOption,
        getMinWidthOption: getMinWidthOption,
        getMinHeightOption: getMinHeightOption,
        getMaxWidthOption: getMaxWidthOption,
        getMaxHeightOption: getMaxHeightOption,
        getUserStyleFormats: getUserStyleFormats,
        shouldMergeStyleFormats: shouldMergeStyleFormats,
        shouldAutoHideStyleFormats: shouldAutoHideStyleFormats,
        getLineHeightFormats: getLineHeightFormats,
        getContentLanguages: getContentLanguages,
        getRemovedMenuItems: getRemovedMenuItems,
        isMenubarEnabled: isMenubarEnabled,
        isMultipleToolbars: isMultipleToolbars,
        isToolbarEnabled: isToolbarEnabled,
        isToolbarPersist: isToolbarPersist,
        getMultipleToolbarsOption: getMultipleToolbarsOption,
        getUiContainer: getUiContainer,
        useFixedContainer: useFixedContainer,
        getToolbarMode: getToolbarMode,
        isDraggableModal: isDraggableModal$1,
        isDistractionFree: isDistractionFree,
        isStickyToolbar: isStickyToolbar1,
        getStickyToolbarOffset: getStickyToolbarOffset,
        getToolbarLocation: getToolbarLocation,
        isToolbarLocationBottom: isToolbarLocationBottom,
        getToolbarGroups: getToolbarGroups,
        getMenus: getMenus1,
        getMenubar: getMenubar,
        getToolbar: getToolbar,
        getFilePickerCallback: getFilePickerCallback,
        getFilePickerTypes: getFilePickerTypes,
        useTypeaheadUrls: useTypeaheadUrls,
        getAnchorTop: getAnchorTop,
        getAnchorBottom: getAnchorBottom,
        getFilePickerValidatorHandler: getFilePickerValidatorHandler,
        useStatusBar: useStatusBar,
        useElementPath: useElementPath,
        useBranding: useBranding,
        getResize: getResize,
        getPasteAsText: getPasteAsText
    });
    const autocompleteSelector = '[data-mce-autocompleter]';
    const detect = (elm)=>closest$1(elm, autocompleteSelector)
    ;
    const findIn = (elm)=>descendant(elm, autocompleteSelector)
    ;
    const setup$e = (api, editor)=>{
        const redirectKeyToItem = (item, e)=>{
            emitWith(item, keydown(), {
                raw: e
            });
        };
        const getItem = ()=>api.getView().bind(Highlighting.getHighlighted)
        ;
        editor.on('keydown', (e)=>{
            const keyCode = e.which;
            if (!api.isActive()) return;
            if (api.isMenuOpen()) {
                if (keyCode === 13) {
                    getItem().each(emitExecute1);
                    e.preventDefault();
                } else if (keyCode === 40) {
                    getItem().fold(()=>{
                        api.getView().each(Highlighting.highlightFirst);
                    }, (item)=>{
                        redirectKeyToItem(item, e);
                    });
                    e.preventDefault();
                    e.stopImmediatePropagation();
                } else if (keyCode === 37 || keyCode === 38 || keyCode === 39) getItem().each((item)=>{
                    redirectKeyToItem(item, e);
                    e.preventDefault();
                    e.stopImmediatePropagation();
                });
            } else if (keyCode === 13 || keyCode === 38 || keyCode === 40) api.cancelIfNecessary();
        });
        editor.on('NodeChange', (e)=>{
            if (api.isActive() && !api.isProcessingAction() && detect(SugarElement.fromDom(e.element)).isNone()) api.cancelIfNecessary();
        });
    };
    const AutocompleterEditorEvents = {
        setup: setup$e
    };
    var ItemResponse1;
    (function(ItemResponse) {
        ItemResponse[ItemResponse['CLOSE_ON_EXECUTE'] = 0] = 'CLOSE_ON_EXECUTE';
        ItemResponse[ItemResponse['BUBBLE_TO_SANDBOX'] = 1] = 'BUBBLE_TO_SANDBOX';
    })(ItemResponse1 || (ItemResponse1 = {}));
    var ItemResponse$1 = ItemResponse1;
    const navClass = 'tox-menu-nav__js';
    const selectableClass = 'tox-collection__item';
    const colorClass = 'tox-swatch';
    const presetClasses = {
        normal: navClass,
        color: colorClass
    };
    const tickedClass = 'tox-collection__item--enabled';
    const groupHeadingClass = 'tox-collection__group-heading';
    const iconClass = 'tox-collection__item-icon';
    const textClass = 'tox-collection__item-label';
    const accessoryClass = 'tox-collection__item-accessory';
    const caretClass = 'tox-collection__item-caret';
    const checkmarkClass = 'tox-collection__item-checkmark';
    const activeClass = 'tox-collection__item--active';
    const containerClass = 'tox-collection__item-container';
    const containerColumnClass = 'tox-collection__item-container--column';
    const containerRowClass = 'tox-collection__item-container--row';
    const containerAlignRightClass = 'tox-collection__item-container--align-right';
    const containerAlignLeftClass = 'tox-collection__item-container--align-left';
    const containerValignTopClass = 'tox-collection__item-container--valign-top';
    const containerValignMiddleClass = 'tox-collection__item-container--valign-middle';
    const containerValignBottomClass = 'tox-collection__item-container--valign-bottom';
    const classForPreset = (presets)=>get$g(presetClasses, presets).getOr(navClass)
    ;
    const forMenu = (presets)=>{
        if (presets === 'color') return 'tox-swatches';
        else return 'tox-menu';
    };
    const classes1 = (presets)=>({
            backgroundMenu: 'tox-background-menu',
            selectedMenu: 'tox-selected-menu',
            selectedItem: 'tox-collection__item--active',
            hasIcons: 'tox-menu--has-icons',
            menu: forMenu(presets),
            tieredMenu: 'tox-tiered-menu'
        })
    ;
    const markers = (presets)=>{
        const menuClasses = classes1(presets);
        return {
            backgroundMenu: menuClasses.backgroundMenu,
            selectedMenu: menuClasses.selectedMenu,
            menu: menuClasses.menu,
            selectedItem: menuClasses.selectedItem,
            item: classForPreset(presets)
        };
    };
    const dom$1 = (hasIcons, columns, presets)=>{
        const menuClasses = classes1(presets);
        return {
            tag: 'div',
            classes: flatten1([
                [
                    menuClasses.menu,
                    `tox-menu-${columns}-column`
                ],
                hasIcons ? [
                    menuClasses.hasIcons
                ] : []
            ])
        };
    };
    const components1 = [
        Menu.parts.items({})
    ];
    const part1 = (hasIcons, columns, presets)=>{
        const menuClasses = classes1(presets);
        const d = {
            tag: 'div',
            classes: flatten1([
                [
                    menuClasses.tieredMenu
                ]
            ])
        };
        return {
            dom: d,
            markers: markers(presets)
        };
    };
    const chunk = (rowDom, numColumns)=>(items)=>{
            const chunks = chunk$1(items, numColumns);
            return map$2(chunks, (c)=>({
                    dom: rowDom,
                    components: c
                })
            );
        }
    ;
    const forSwatch = (columns)=>({
            dom: {
                tag: 'div',
                classes: [
                    'tox-menu',
                    'tox-swatches-menu'
                ]
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: [
                            'tox-swatches'
                        ]
                    },
                    components: [
                        Menu.parts.items({
                            preprocess: columns !== 'auto' ? chunk({
                                tag: 'div',
                                classes: [
                                    'tox-swatches__row'
                                ]
                            }, columns) : identity
                        })
                    ]
                }
            ]
        })
    ;
    const forToolbar = (columns)=>({
            dom: {
                tag: 'div',
                classes: [
                    'tox-menu',
                    'tox-collection',
                    'tox-collection--toolbar',
                    'tox-collection--toolbar-lg'
                ]
            },
            components: [
                Menu.parts.items({
                    preprocess: chunk({
                        tag: 'div',
                        classes: [
                            'tox-collection__group'
                        ]
                    }, columns)
                })
            ]
        })
    ;
    const preprocessCollection = (items, isSeparator)=>{
        const allSplits = [];
        let currentSplit = [];
        each$1(items, (item, i)=>{
            if (isSeparator(item, i)) {
                if (currentSplit.length > 0) allSplits.push(currentSplit);
                currentSplit = [];
                if (has$2(item.dom, 'innerHtml') || item.components.length > 0) currentSplit.push(item);
            } else currentSplit.push(item);
        });
        if (currentSplit.length > 0) allSplits.push(currentSplit);
        return map$2(allSplits, (s)=>({
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-collection__group'
                    ]
                },
                components: s
            })
        );
    };
    const forCollection = (columns, initItems, _hasIcons = true)=>({
            dom: {
                tag: 'div',
                classes: [
                    'tox-menu',
                    'tox-collection'
                ].concat(columns === 1 ? [
                    'tox-collection--list'
                ] : [
                    'tox-collection--grid'
                ])
            },
            components: [
                Menu.parts.items({
                    preprocess: (items)=>{
                        if (columns !== 'auto' && columns > 1) return chunk({
                            tag: 'div',
                            classes: [
                                'tox-collection__group'
                            ]
                        }, columns)(items);
                        else return preprocessCollection(items, (_item, i)=>initItems[i].type === 'separator'
                        );
                    }
                })
            ]
        })
    ;
    const forHorizontalCollection = (initItems, _hasIcons = true)=>({
            dom: {
                tag: 'div',
                classes: [
                    'tox-collection',
                    'tox-collection--horizontal'
                ]
            },
            components: [
                Menu.parts.items({
                    preprocess: (items)=>preprocessCollection(items, (_item, i)=>initItems[i].type === 'separator'
                        )
                })
            ]
        })
    ;
    const menuHasIcons1 = (xs)=>exists(xs, (item)=>'icon' in item && item.icon !== undefined
        )
    ;
    const handleError = (error)=>{
        console.error(formatError(error));
        console.log(error);
        return Optional.none();
    };
    const createHorizontalPartialMenuWithAlloyItems = (value, _hasIcons, items, _columns, _presets)=>{
        const structure = forHorizontalCollection(items);
        return {
            value,
            dom: structure.dom,
            components: structure.components,
            items
        };
    };
    const createPartialMenuWithAlloyItems = (value, hasIcons, items, columns, presets)=>{
        if (presets === 'color') {
            const structure = forSwatch(columns);
            return {
                value,
                dom: structure.dom,
                components: structure.components,
                items
            };
        }
        if (presets === 'normal' && columns === 'auto') {
            const structure = forCollection(columns, items);
            return {
                value,
                dom: structure.dom,
                components: structure.components,
                items
            };
        }
        if (presets === 'normal' && columns === 1) {
            const structure = forCollection(1, items);
            return {
                value,
                dom: structure.dom,
                components: structure.components,
                items
            };
        }
        if (presets === 'normal') {
            const structure = forCollection(columns, items);
            return {
                value,
                dom: structure.dom,
                components: structure.components,
                items
            };
        }
        if (presets === 'listpreview' && columns !== 'auto') {
            const structure = forToolbar(columns);
            return {
                value,
                dom: structure.dom,
                components: structure.components,
                items
            };
        }
        return {
            value,
            dom: dom$1(hasIcons, columns, presets),
            components: components1,
            items
        };
    };
    const type1 = requiredString('type');
    const name$1 = requiredString('name');
    const label1 = requiredString('label');
    const text1 = requiredString('text');
    const title1 = requiredString('title');
    const icon1 = requiredString('icon');
    const value$1 = requiredString('value');
    const fetch$1 = requiredFunction('fetch');
    const getSubmenuItems = requiredFunction('getSubmenuItems');
    const onAction1 = requiredFunction('onAction');
    const onItemAction1 = requiredFunction('onItemAction');
    const onSetup1 = defaultedFunction('onSetup', ()=>noop
    );
    const optionalName = optionString('name');
    const optionalText = optionString('text');
    const optionalIcon = optionString('icon');
    const optionalTooltip = optionString('tooltip');
    const optionalLabel = optionString('label');
    const optionalShortcut = optionString('shortcut');
    const optionalSelect = optionFunction('select');
    const active1 = defaultedBoolean('active', false);
    const borderless = defaultedBoolean('borderless', false);
    const enabled = defaultedBoolean('enabled', true);
    const primary1 = defaultedBoolean('primary', false);
    const defaultedColumns = (num)=>defaulted('columns', num)
    ;
    const defaultedMeta = defaulted('meta', {});
    const defaultedOnAction = defaultedFunction('onAction', noop);
    const defaultedType = (type)=>defaultedString('type', type)
    ;
    const generatedName = (namePrefix)=>field$1('name', 'name', defaultedThunk(()=>generate$6(`${namePrefix}-name`)
        ), string)
    ;
    const generatedValue = (valuePrefix)=>field$1('value', 'value', defaultedThunk(()=>generate$6(`${valuePrefix}-value`)
        ), anyValue())
    ;
    const separatorMenuItemSchema = objOf([
        type1,
        optionalText
    ]);
    const createSeparatorMenuItem = (spec)=>asRaw('separatormenuitem', separatorMenuItemSchema, spec)
    ;
    const autocompleterItemSchema = objOf([
        defaultedType('autocompleteitem'),
        active1,
        enabled,
        defaultedMeta,
        value$1,
        optionalText,
        optionalIcon
    ]);
    const createSeparatorItem = (spec)=>asRaw('Autocompleter.Separator', separatorMenuItemSchema, spec)
    ;
    const createAutocompleterItem = (spec)=>asRaw('Autocompleter.Item', autocompleterItemSchema, spec)
    ;
    const baseToolbarButtonFields = [
        enabled,
        optionalTooltip,
        optionalIcon,
        optionalText,
        onSetup1
    ];
    const toolbarButtonSchema = objOf([
        type1,
        onAction1
    ].concat(baseToolbarButtonFields));
    const createToolbarButton = (spec)=>asRaw('toolbarbutton', toolbarButtonSchema, spec)
    ;
    const baseToolbarToggleButtonFields = [
        active1
    ].concat(baseToolbarButtonFields);
    const toggleButtonSchema = objOf(baseToolbarToggleButtonFields.concat([
        type1,
        onAction1
    ]));
    const createToggleButton = (spec)=>asRaw('ToggleButton', toggleButtonSchema, spec)
    ;
    const contextBarFields = [
        defaultedFunction('predicate', never),
        defaultedStringEnum('scope', 'node', [
            'node',
            'editor'
        ]),
        defaultedStringEnum('position', 'selection', [
            'node',
            'selection',
            'line'
        ])
    ];
    const contextButtonFields = baseToolbarButtonFields.concat([
        defaultedType('contextformbutton'),
        primary1,
        onAction1,
        customField('original', identity)
    ]);
    const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([
        defaultedType('contextformbutton'),
        primary1,
        onAction1,
        customField('original', identity)
    ]);
    const launchButtonFields = baseToolbarButtonFields.concat([
        defaultedType('contextformbutton')
    ]);
    const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([
        defaultedType('contextformtogglebutton')
    ]);
    const toggleOrNormal = choose$1('type', {
        contextformbutton: contextButtonFields,
        contextformtogglebutton: contextToggleButtonFields
    });
    const contextFormSchema = objOf([
        defaultedType('contextform'),
        defaultedFunction('initValue', constant$1('')),
        optionalLabel,
        requiredArrayOf('commands', toggleOrNormal),
        optionOf('launch', choose$1('type', {
            contextformbutton: launchButtonFields,
            contextformtogglebutton: launchToggleButtonFields
        }))
    ].concat(contextBarFields));
    const createContextForm = (spec)=>asRaw('ContextForm', contextFormSchema, spec)
    ;
    const contextToolbarSchema = objOf([
        defaultedType('contexttoolbar'),
        requiredString('items')
    ].concat(contextBarFields));
    const createContextToolbar = (spec)=>asRaw('ContextToolbar', contextToolbarSchema, spec)
    ;
    const cardImageFields = [
        type1,
        requiredString('src'),
        optionString('alt'),
        defaultedArrayOf('classes', [], string)
    ];
    const cardImageSchema = objOf(cardImageFields);
    const cardTextFields = [
        type1,
        text1,
        optionalName,
        defaultedArrayOf('classes', [
            'tox-collection__item-label'
        ], string)
    ];
    const cardTextSchema = objOf(cardTextFields);
    const itemSchema$1 = valueThunk1(()=>choose$2('type', {
            cardimage: cardImageSchema,
            cardtext: cardTextSchema,
            cardcontainer: cardContainerSchema
        })
    );
    const cardContainerSchema = objOf([
        type1,
        defaultedString('direction', 'horizontal'),
        defaultedString('align', 'left'),
        defaultedString('valign', 'middle'),
        requiredArrayOf('items', itemSchema$1)
    ]);
    const commonMenuItemFields = [
        enabled,
        optionalText,
        optionalShortcut,
        generatedValue('menuitem'),
        defaultedMeta
    ];
    const cardMenuItemSchema = objOf([
        type1,
        optionalLabel,
        requiredArrayOf('items', itemSchema$1),
        onSetup1,
        defaultedOnAction
    ].concat(commonMenuItemFields));
    const createCardMenuItem = (spec)=>asRaw('cardmenuitem', cardMenuItemSchema, spec)
    ;
    const choiceMenuItemSchema = objOf([
        type1,
        active1,
        optionalIcon
    ].concat(commonMenuItemFields));
    const createChoiceMenuItem = (spec)=>asRaw('choicemenuitem', choiceMenuItemSchema, spec)
    ;
    const baseFields = [
        type1,
        requiredString('fancytype'),
        defaultedOnAction
    ];
    const insertTableFields = [
        defaulted('initData', {})
    ].concat(baseFields);
    const colorSwatchFields = [
        defaultedObjOf('initData', {}, [
            defaultedBoolean('allowCustomColors', true),
            optionArrayOf('colors', anyValue())
        ])
    ].concat(baseFields);
    const fancyMenuItemSchema = choose$1('fancytype', {
        inserttable: insertTableFields,
        colorswatch: colorSwatchFields
    });
    const createFancyMenuItem = (spec)=>asRaw('fancymenuitem', fancyMenuItemSchema, spec)
    ;
    const menuItemSchema = objOf([
        type1,
        onSetup1,
        defaultedOnAction,
        optionalIcon
    ].concat(commonMenuItemFields));
    const createMenuItem = (spec)=>asRaw('menuitem', menuItemSchema, spec)
    ;
    const nestedMenuItemSchema = objOf([
        type1,
        getSubmenuItems,
        onSetup1,
        optionalIcon
    ].concat(commonMenuItemFields));
    const createNestedMenuItem = (spec)=>asRaw('nestedmenuitem', nestedMenuItemSchema, spec)
    ;
    const toggleMenuItemSchema = objOf([
        type1,
        optionalIcon,
        active1,
        onSetup1,
        onAction1
    ].concat(commonMenuItemFields));
    const createToggleMenuItem = (spec)=>asRaw('togglemenuitem', toggleMenuItemSchema, spec)
    ;
    const detectSize = (comp, margin, selectorClass)=>{
        const descendants$1 = descendants(comp.element, '.' + selectorClass);
        if (descendants$1.length > 0) {
            const columnLength = findIndex$1(descendants$1, (c)=>{
                const thisTop = c.dom.getBoundingClientRect().top;
                const cTop = descendants$1[0].dom.getBoundingClientRect().top;
                return Math.abs(thisTop - cTop) > margin;
            }).getOr(descendants$1.length);
            return Optional.some({
                numColumns: columnLength,
                numRows: Math.ceil(descendants$1.length / columnLength)
            });
        } else return Optional.none();
    };
    const namedEvents = (name, handlers)=>derive$1([
            config1(name, handlers)
        ])
    ;
    const unnamedEvents = (handlers)=>namedEvents(generate$6('unnamed-events'), handlers)
    ;
    const SimpleBehaviours = {
        namedEvents,
        unnamedEvents
    };
    const ExclusivityChannel = generate$6('tooltip.exclusive');
    const ShowTooltipEvent = generate$6('tooltip.show');
    const HideTooltipEvent = generate$6('tooltip.hide');
    const hideAllExclusive = (component, _tConfig, _tState)=>{
        component.getSystem().broadcastOn([
            ExclusivityChannel
        ], {});
    };
    const setComponents = (component, tConfig, tState, specs)=>{
        tState.getTooltip().each((tooltip)=>{
            if (tooltip.getSystem().isConnected()) Replacing.set(tooltip, specs);
        });
    };
    var TooltippingApis = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        hideAllExclusive: hideAllExclusive,
        setComponents: setComponents
    });
    const events$9 = (tooltipConfig, state)=>{
        const hide = (comp)=>{
            state.getTooltip().each((p)=>{
                detach(p);
                tooltipConfig.onHide(comp, p);
                state.clearTooltip();
            });
            state.clearTimer();
        };
        const show = (comp)=>{
            if (!state.isShowing()) {
                hideAllExclusive(comp);
                const sink = tooltipConfig.lazySink(comp).getOrDie();
                const popup = comp.getSystem().build({
                    dom: tooltipConfig.tooltipDom,
                    components: tooltipConfig.tooltipComponents,
                    events: derive$2(tooltipConfig.mode === 'normal' ? [
                        run$1(mouseover(), (_)=>{
                            emit(comp, ShowTooltipEvent);
                        }),
                        run$1(mouseout(), (_)=>{
                            emit(comp, HideTooltipEvent);
                        })
                    ] : []),
                    behaviours: derive$1([
                        Replacing.config({})
                    ])
                });
                state.setTooltip(popup);
                attach1(sink, popup);
                tooltipConfig.onShow(comp, popup);
                Positioning.position(sink, popup, {
                    anchor: tooltipConfig.anchor(comp)
                });
            }
        };
        return derive$2(flatten1([
            [
                run$1(ShowTooltipEvent, (comp)=>{
                    state.resetTimer(()=>{
                        show(comp);
                    }, tooltipConfig.delay);
                }),
                run$1(HideTooltipEvent, (comp)=>{
                    state.resetTimer(()=>{
                        hide(comp);
                    }, tooltipConfig.delay);
                }),
                run$1(receive(), (comp, message)=>{
                    const receivingData = message;
                    if (!receivingData.universal) {
                        if (contains$2(receivingData.channels, ExclusivityChannel)) hide(comp);
                    }
                }),
                runOnDetached((comp)=>{
                    hide(comp);
                })
            ],
            tooltipConfig.mode === 'normal' ? [
                run$1(focusin(), (comp)=>{
                    emit(comp, ShowTooltipEvent);
                }),
                run$1(postBlur(), (comp)=>{
                    emit(comp, HideTooltipEvent);
                }),
                run$1(mouseover(), (comp)=>{
                    emit(comp, ShowTooltipEvent);
                }),
                run$1(mouseout(), (comp)=>{
                    emit(comp, HideTooltipEvent);
                })
            ] : [
                run$1(highlight$1(), (comp, _se)=>{
                    emit(comp, ShowTooltipEvent);
                }),
                run$1(dehighlight$1(), (comp)=>{
                    emit(comp, HideTooltipEvent);
                })
            ]
        ]));
    };
    var ActiveTooltipping = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        events: events$9
    });
    var TooltippingSchema = [
        required$1('lazySink'),
        required$1('tooltipDom'),
        defaulted('exclusive', true),
        defaulted('tooltipComponents', []),
        defaulted('delay', 300),
        defaultedStringEnum('mode', 'normal', [
            'normal',
            'follow-highlight'
        ]),
        defaulted('anchor', (comp)=>({
                type: 'hotspot',
                hotspot: comp,
                layouts: {
                    onLtr: constant$1([
                        south$2,
                        north$2,
                        southeast$2,
                        northeast$2,
                        southwest$2,
                        northwest$2
                    ]),
                    onRtl: constant$1([
                        south$2,
                        north$2,
                        southeast$2,
                        northeast$2,
                        southwest$2,
                        northwest$2
                    ])
                }
            })
        ),
        onHandler('onHide'),
        onHandler('onShow')
    ];
    const init$b = ()=>{
        const timer = value$2();
        const popup = value$2();
        const clearTimer = ()=>{
            timer.on(clearTimeout);
        };
        const resetTimer = (f, delay)=>{
            clearTimer();
            timer.set(setTimeout(f, delay));
        };
        const readState = constant$1('not-implemented');
        return nu$8({
            getTooltip: popup.get,
            isShowing: popup.isSet,
            setTooltip: popup.set,
            clearTooltip: popup.clear,
            clearTimer,
            resetTimer,
            readState
        });
    };
    var TooltippingState = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        init: init$b
    });
    const Tooltipping = create$3({
        fields: TooltippingSchema,
        name: 'tooltipping',
        active: ActiveTooltipping,
        state: TooltippingState,
        apis: TooltippingApis
    });
    const escape = (text)=>text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
    ;
    const ReadOnlyChannel = 'silver.readonly';
    const ReadOnlyDataSchema = objOf([
        requiredBoolean('readonly')
    ]);
    const broadcastReadonly = (uiComponents, readonly)=>{
        const outerContainer = uiComponents.outerContainer;
        const target = outerContainer.element;
        if (readonly) {
            uiComponents.mothership.broadcastOn([
                dismissPopups()
            ], {
                target
            });
            uiComponents.uiMothership.broadcastOn([
                dismissPopups()
            ], {
                target
            });
        }
        uiComponents.mothership.broadcastOn([
            ReadOnlyChannel
        ], {
            readonly
        });
        uiComponents.uiMothership.broadcastOn([
            ReadOnlyChannel
        ], {
            readonly
        });
    };
    const setupReadonlyModeSwitch = (editor, uiComponents)=>{
        editor.on('init', ()=>{
            if (editor.mode.isReadOnly()) broadcastReadonly(uiComponents, true);
        });
        editor.on('SwitchMode', ()=>broadcastReadonly(uiComponents, editor.mode.isReadOnly())
        );
        if (isReadOnly(editor)) editor.mode.set('readonly');
    };
    const receivingConfig = ()=>Receiving.config({
            channels: {
                [ReadOnlyChannel]: {
                    schema: ReadOnlyDataSchema,
                    onReceive: (comp, data)=>{
                        Disabling.set(comp, data.readonly);
                    }
                }
            }
        })
    ;
    const item1 = (disabled)=>Disabling.config({
            disabled,
            disableClass: 'tox-collection__item--state-disabled'
        })
    ;
    const button1 = (disabled)=>Disabling.config({
            disabled
        })
    ;
    const splitButton = (disabled)=>Disabling.config({
            disabled,
            disableClass: 'tox-tbtn--disabled'
        })
    ;
    const toolbarButton = (disabled)=>Disabling.config({
            disabled,
            disableClass: 'tox-tbtn--disabled',
            useNative: false
        })
    ;
    const DisablingConfigs = {
        item: item1,
        button: button1,
        splitButton,
        toolbarButton
    };
    const runWithApi = (info, comp)=>{
        const api = info.getApi(comp);
        return (f)=>{
            f(api);
        };
    };
    const onControlAttached = (info, editorOffCell)=>runOnAttached((comp)=>{
            const run = runWithApi(info, comp);
            run((api)=>{
                const onDestroy = info.onSetup(api);
                if (isFunction(onDestroy)) editorOffCell.set(onDestroy);
            });
        })
    ;
    const onControlDetached = (getApi, editorOffCell)=>runOnDetached((comp)=>runWithApi(getApi, comp)(editorOffCell.get())
        )
    ;
    const onMenuItemExecute = (info, itemResponse)=>runOnExecute$1((comp, simulatedEvent)=>{
            runWithApi(info, comp)(info.onAction);
            if (!info.triggersSubmenu && itemResponse === ItemResponse$1.CLOSE_ON_EXECUTE) {
                if (comp.getSystem().isConnected()) emit(comp, sandboxClose());
                simulatedEvent.stop();
            }
        })
    ;
    const menuItemEventOrder = {
        [execute$5()]: [
            'disabling',
            'alloy.base.behaviour',
            'toggling',
            'item-events'
        ]
    };
    const componentRenderPipeline = cat;
    const renderCommonItem = (spec, structure, itemResponse, providersbackstage)=>{
        const editorOffCell = Cell(noop);
        return {
            type: 'item',
            dom: structure.dom,
            components: componentRenderPipeline(structure.optComponents),
            data: spec.data,
            eventOrder: menuItemEventOrder,
            hasSubmenu: spec.triggersSubmenu,
            itemBehaviours: derive$1([
                config1('item-events', [
                    onMenuItemExecute(spec, itemResponse),
                    onControlAttached(spec, editorOffCell),
                    onControlDetached(spec, editorOffCell)
                ]),
                DisablingConfigs.item(()=>!spec.enabled || providersbackstage.isDisabled()
                ),
                receivingConfig(),
                Replacing.config({})
            ].concat(spec.itemBehaviours))
        };
    };
    const buildData = (source)=>({
            value: source.value,
            meta: {
                text: source.text.getOr(''),
                ...source.meta
            }
        })
    ;
    const convertText = (source)=>{
        const isMac = global$5.os.isMacOS() || global$5.os.isiOS();
        const mac = {
            alt: '\u2325',
            ctrl: '\u2303',
            shift: '\u21E7',
            meta: '\u2318',
            access: '\u2303\u2325'
        };
        const other = {
            meta: 'Ctrl',
            access: 'Shift+Alt'
        };
        const replace = isMac ? mac : other;
        const shortcut = source.split('+');
        const updated = map$2(shortcut, (segment)=>{
            const search = segment.toLowerCase().trim();
            return has$2(replace, search) ? replace[search] : segment;
        });
        return isMac ? updated.join('') : updated.join('+');
    };
    const renderIcon$1 = (name, icons, classes = [
        iconClass
    ])=>render$3(name, {
            tag: 'div',
            classes
        }, icons)
    ;
    const renderText1 = (text)=>({
            dom: {
                tag: 'div',
                classes: [
                    textClass
                ]
            },
            components: [
                text$1(global$8.translate(text))
            ]
        })
    ;
    const renderHtml = (html, classes)=>({
            dom: {
                tag: 'div',
                classes,
                innerHtml: html
            }
        })
    ;
    const renderStyledText = (style, text)=>({
            dom: {
                tag: 'div',
                classes: [
                    textClass
                ]
            },
            components: [
                {
                    dom: {
                        tag: style.tag,
                        styles: style.styles
                    },
                    components: [
                        text$1(global$8.translate(text))
                    ]
                }
            ]
        })
    ;
    const renderShortcut = (shortcut)=>({
            dom: {
                tag: 'div',
                classes: [
                    accessoryClass
                ]
            },
            components: [
                text$1(convertText(shortcut))
            ]
        })
    ;
    const renderCheckmark = (icons)=>renderIcon$1('checkmark', icons, [
            checkmarkClass
        ])
    ;
    const renderSubmenuCaret = (icons)=>renderIcon$1('chevron-right', icons, [
            caretClass
        ])
    ;
    const renderDownwardsCaret = (icons)=>renderIcon$1('chevron-down', icons, [
            caretClass
        ])
    ;
    const renderContainer1 = (container, components)=>{
        const directionClass = container.direction === 'vertical' ? containerColumnClass : containerRowClass;
        const alignClass = container.align === 'left' ? containerAlignLeftClass : containerAlignRightClass;
        const getValignClass = ()=>{
            switch(container.valign){
                case 'top':
                    return containerValignTopClass;
                case 'middle':
                    return containerValignMiddleClass;
                case 'bottom':
                    return containerValignBottomClass;
            }
        };
        return {
            dom: {
                tag: 'div',
                classes: [
                    containerClass,
                    directionClass,
                    alignClass,
                    getValignClass()
                ]
            },
            components
        };
    };
    const renderImage = (src, classes, alt)=>({
            dom: {
                tag: 'img',
                classes,
                attributes: {
                    src,
                    alt: alt.getOr('')
                }
            }
        })
    ;
    const renderColorStructure = (item, providerBackstage, fallbackIcon)=>{
        const colorPickerCommand = 'custom';
        const removeColorCommand = 'remove';
        const itemText = item.ariaLabel;
        const itemValue = item.value;
        const iconSvg = item.iconContent.map((name)=>getOr(name, providerBackstage.icons, fallbackIcon)
        );
        const getDom = ()=>{
            const common = colorClass;
            const icon = iconSvg.getOr('');
            const attributes = itemText.map((text)=>({
                    title: providerBackstage.translate(text)
                })
            ).getOr({});
            const baseDom = {
                tag: 'div',
                attributes,
                classes: [
                    common
                ]
            };
            if (itemValue === colorPickerCommand) return {
                ...baseDom,
                tag: 'button',
                classes: [
                    ...baseDom.classes,
                    'tox-swatches__picker-btn'
                ],
                innerHtml: icon
            };
            else if (itemValue === removeColorCommand) return {
                ...baseDom,
                classes: [
                    ...baseDom.classes,
                    'tox-swatch--remove'
                ],
                innerHtml: icon
            };
            else return {
                ...baseDom,
                attributes: {
                    ...baseDom.attributes,
                    'data-mce-color': itemValue
                },
                styles: {
                    'background-color': itemValue
                }
            };
        };
        return {
            dom: getDom(),
            optComponents: []
        };
    };
    const renderItemDomStructure = (ariaLabel)=>{
        const domTitle = ariaLabel.map((label)=>({
                attributes: {
                    title: global$8.translate(label)
                }
            })
        ).getOr({});
        return {
            tag: 'div',
            classes: [
                navClass,
                selectableClass
            ],
            ...domTitle
        };
    };
    const renderNormalItemStructure = (info, providersBackstage, renderIcons, fallbackIcon)=>{
        const iconSpec = {
            tag: 'div',
            classes: [
                iconClass
            ]
        };
        const renderIcon = (iconName)=>render$3(iconName, iconSpec, providersBackstage.icons, fallbackIcon)
        ;
        const renderEmptyIcon = ()=>Optional.some({
                dom: iconSpec
            })
        ;
        const leftIcon = renderIcons ? info.iconContent.map(renderIcon).orThunk(renderEmptyIcon) : Optional.none();
        const checkmark = info.checkMark;
        const textRender = Optional.from(info.meta).fold(()=>renderText1
        , (meta)=>has$2(meta, 'style') ? curry(renderStyledText, meta.style) : renderText1
        );
        const content = info.htmlContent.fold(()=>info.textContent.map(textRender)
        , (html)=>Optional.some(renderHtml(html, [
                textClass
            ]))
        );
        const menuItem = {
            dom: renderItemDomStructure(info.ariaLabel),
            optComponents: [
                leftIcon,
                content,
                info.shortcutContent.map(renderShortcut),
                checkmark,
                info.caret
            ]
        };
        return menuItem;
    };
    const renderItemStructure = (info, providersBackstage, renderIcons, fallbackIcon = Optional.none())=>{
        if (info.presets === 'color') return renderColorStructure(info, providersBackstage, fallbackIcon);
        else return renderNormalItemStructure(info, providersBackstage, renderIcons, fallbackIcon);
    };
    const tooltipBehaviour = (meta, sharedBackstage)=>get$g(meta, 'tooltipWorker').map((tooltipWorker)=>[
                Tooltipping.config({
                    lazySink: sharedBackstage.getSink,
                    tooltipDom: {
                        tag: 'div',
                        classes: [
                            'tox-tooltip-worker-container'
                        ]
                    },
                    tooltipComponents: [],
                    anchor: (comp)=>({
                            type: 'submenu',
                            item: comp,
                            overrides: {
                                maxHeightFunction: expandable$1
                            }
                        })
                    ,
                    mode: 'follow-highlight',
                    onShow: (component, _tooltip)=>{
                        tooltipWorker((elm)=>{
                            Tooltipping.setComponents(component, [
                                external$1({
                                    element: SugarElement.fromDom(elm)
                                })
                            ]);
                        });
                    }
                })
            ]
        ).getOr([])
    ;
    const encodeText = (text)=>global$7.DOM.encode(text)
    ;
    const replaceText = (text, matchText)=>{
        const translated = global$8.translate(text);
        const encoded = encodeText(translated);
        if (matchText.length > 0) {
            const escapedMatchRegex = new RegExp(escape(matchText), 'gi');
            return encoded.replace(escapedMatchRegex, (match)=>`<span class="tox-autocompleter-highlight">${match}</span>`
            );
        } else return encoded;
    };
    const renderAutocompleteItem = (spec, matchText, useText, presets, onItemValueHandler, itemResponse, sharedBackstage, renderIcons = true)=>{
        const structure = renderItemStructure({
            presets,
            textContent: Optional.none(),
            htmlContent: useText ? spec.text.map((text)=>replaceText(text, matchText)
            ) : Optional.none(),
            ariaLabel: spec.text,
            iconContent: spec.icon,
            shortcutContent: Optional.none(),
            checkMark: Optional.none(),
            caret: Optional.none(),
            value: spec.value
        }, sharedBackstage.providers, renderIcons, spec.icon);
        return renderCommonItem({
            data: buildData(spec),
            enabled: spec.enabled,
            getApi: constant$1({}),
            onAction: (_api)=>onItemValueHandler(spec.value, spec.meta)
            ,
            onSetup: constant$1(noop),
            triggersSubmenu: false,
            itemBehaviours: tooltipBehaviour(spec.meta, sharedBackstage)
        }, structure, itemResponse, sharedBackstage.providers);
    };
    const render$2 = (items, extras)=>map$2(items, (item)=>{
            switch(item.type){
                case 'cardcontainer':
                    return renderContainer1(item, render$2(item.items, extras));
                case 'cardimage':
                    return renderImage(item.src, item.classes, item.alt);
                case 'cardtext':
                    const shouldHighlight = item.name.exists((name)=>contains$2(extras.cardText.highlightOn, name)
                    );
                    const matchText = shouldHighlight ? Optional.from(extras.cardText.matchText).getOr('') : '';
                    return renderHtml(replaceText(item.text, matchText), item.classes);
            }
        })
    ;
    const renderCardMenuItem = (spec, itemResponse, sharedBackstage, extras)=>{
        const getApi = (component)=>({
                isEnabled: ()=>!Disabling.isDisabled(component)
                ,
                setEnabled: (state)=>{
                    Disabling.set(component, !state);
                    each$1(descendants(component.element, '*'), (elm)=>{
                        component.getSystem().getByDom(elm).each((comp)=>{
                            if (comp.hasConfigured(Disabling)) Disabling.set(comp, !state);
                        });
                    });
                }
            })
        ;
        const structure = {
            dom: renderItemDomStructure(spec.label),
            optComponents: [
                Optional.some({
                    dom: {
                        tag: 'div',
                        classes: [
                            containerClass,
                            containerRowClass
                        ]
                    },
                    components: render$2(spec.items, extras)
                })
            ]
        };
        return renderCommonItem({
            data: buildData({
                text: Optional.none(),
                ...spec
            }),
            enabled: spec.enabled,
            getApi,
            onAction: spec.onAction,
            onSetup: spec.onSetup,
            triggersSubmenu: false,
            itemBehaviours: Optional.from(extras.itemBehaviours).getOr([])
        }, structure, itemResponse, sharedBackstage.providers);
    };
    const renderChoiceItem = (spec, useText, presets, onItemValueHandler, isSelected, itemResponse, providersBackstage, renderIcons = true)=>{
        const getApi = (component)=>({
                setActive: (state)=>{
                    Toggling.set(component, state);
                },
                isActive: ()=>Toggling.isOn(component)
                ,
                isEnabled: ()=>!Disabling.isDisabled(component)
                ,
                setEnabled: (state)=>Disabling.set(component, !state)
            })
        ;
        const structure = renderItemStructure({
            presets,
            textContent: useText ? spec.text : Optional.none(),
            htmlContent: Optional.none(),
            ariaLabel: spec.text,
            iconContent: spec.icon,
            shortcutContent: useText ? spec.shortcut : Optional.none(),
            checkMark: useText ? Optional.some(renderCheckmark(providersBackstage.icons)) : Optional.none(),
            caret: Optional.none(),
            value: spec.value
        }, providersBackstage, renderIcons);
        return deepMerge(renderCommonItem({
            data: buildData(spec),
            enabled: spec.enabled,
            getApi,
            onAction: (_api)=>onItemValueHandler(spec.value)
            ,
            onSetup: (api)=>{
                api.setActive(isSelected);
                return noop;
            },
            triggersSubmenu: false,
            itemBehaviours: []
        }, structure, itemResponse, providersBackstage), {
            toggling: {
                toggleClass: tickedClass,
                toggleOnExecute: false,
                selected: spec.active
            }
        });
    };
    const parts$f = generate$3(owner$2(), parts$h());
    const hexColour1 = (value)=>({
            value
        })
    ;
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    const longformRegex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
    const isHexString = (hex)=>shorthandRegex.test(hex) || longformRegex.test(hex)
    ;
    const normalizeHex = (hex)=>removeLeading(hex, '#').toUpperCase()
    ;
    const fromString$1 = (hex)=>isHexString(hex) ? Optional.some({
            value: normalizeHex(hex)
        }) : Optional.none()
    ;
    const getLongForm = (hex)=>{
        const hexString = hex.value.replace(shorthandRegex, (m, r, g, b)=>r + r + g + g + b + b
        );
        return {
            value: hexString
        };
    };
    const extractValues = (hex)=>{
        const longForm = getLongForm(hex);
        const splitForm = longformRegex.exec(longForm.value);
        return splitForm === null ? [
            'FFFFFF',
            'FF',
            'FF',
            'FF'
        ] : splitForm;
    };
    const toHex = (component)=>{
        const hex = component.toString(16);
        return (hex.length === 1 ? '0' + hex : hex).toUpperCase();
    };
    const fromRgba = (rgbaColour)=>{
        const value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);
        return hexColour1(value);
    };
    const min1 = Math.min;
    const max1 = Math.max;
    const round$1 = Math.round;
    const rgbRegex = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i;
    const rgbaRegex = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i;
    const rgbaColour1 = (red, green, blue, alpha)=>({
            red,
            green,
            blue,
            alpha
        })
    ;
    const isRgbaComponent = (value)=>{
        const num = parseInt(value, 10);
        return num.toString() === value && num >= 0 && num <= 255;
    };
    const fromHsv = (hsv)=>{
        let r;
        let g;
        let b;
        const hue = (hsv.hue || 0) % 360;
        let saturation = hsv.saturation / 100;
        let brightness = hsv.value / 100;
        saturation = max1(0, min1(saturation, 1));
        brightness = max1(0, min1(brightness, 1));
        if (saturation === 0) {
            r = g = b = round$1(255 * brightness);
            return rgbaColour1(r, g, b, 1);
        }
        const side = hue / 60;
        const chroma = brightness * saturation;
        const x = chroma * (1 - Math.abs(side % 2 - 1));
        const match = brightness - chroma;
        switch(Math.floor(side)){
            case 0:
                r = chroma;
                g = x;
                b = 0;
                break;
            case 1:
                r = x;
                g = chroma;
                b = 0;
                break;
            case 2:
                r = 0;
                g = chroma;
                b = x;
                break;
            case 3:
                r = 0;
                g = x;
                b = chroma;
                break;
            case 4:
                r = x;
                g = 0;
                b = chroma;
                break;
            case 5:
                r = chroma;
                g = 0;
                b = x;
                break;
            default:
                r = g = b = 0;
        }
        r = round$1(255 * (r + match));
        g = round$1(255 * (g + match));
        b = round$1(255 * (b + match));
        return rgbaColour1(r, g, b, 1);
    };
    const fromHex = (hexColour)=>{
        const result = extractValues(hexColour);
        const red = parseInt(result[1], 16);
        const green = parseInt(result[2], 16);
        const blue = parseInt(result[3], 16);
        return rgbaColour1(red, green, blue, 1);
    };
    const fromStringValues = (red, green, blue, alpha)=>{
        const r = parseInt(red, 10);
        const g = parseInt(green, 10);
        const b = parseInt(blue, 10);
        const a = parseFloat(alpha);
        return rgbaColour1(r, g, b, a);
    };
    const fromString = (rgbaString)=>{
        if (rgbaString === 'transparent') return Optional.some(rgbaColour1(0, 0, 0, 0));
        const rgbMatch = rgbRegex.exec(rgbaString);
        if (rgbMatch !== null) return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));
        const rgbaMatch = rgbaRegex.exec(rgbaString);
        if (rgbaMatch !== null) return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));
        return Optional.none();
    };
    const toString1 = (rgba)=>`rgba(${rgba.red},${rgba.green},${rgba.blue},${rgba.alpha})`
    ;
    const red1 = rgbaColour1(255, 0, 0, 1);
    const fireSkinLoaded$1 = (editor)=>editor.dispatch('SkinLoaded')
    ;
    const fireSkinLoadError$1 = (editor, error)=>editor.dispatch('SkinLoadError', error)
    ;
    const fireResizeEditor = (editor)=>editor.dispatch('ResizeEditor')
    ;
    const fireResizeContent = (editor, e)=>editor.dispatch('ResizeContent', e)
    ;
    const fireScrollContent = (editor, e)=>editor.dispatch('ScrollContent', e)
    ;
    const fireTextColorChange = (editor, data)=>editor.dispatch('TextColorChange', data)
    ;
    const hsvColour = (hue, saturation, value)=>({
            hue,
            saturation,
            value
        })
    ;
    const fromRgb = (rgbaColour)=>{
        let h = 0;
        let s = 0;
        let v = 0;
        const r = rgbaColour.red / 255;
        const g = rgbaColour.green / 255;
        const b = rgbaColour.blue / 255;
        const minRGB = Math.min(r, Math.min(g, b));
        const maxRGB = Math.max(r, Math.max(g, b));
        if (minRGB === maxRGB) {
            v = minRGB;
            return hsvColour(0, 0, v * 100);
        }
        const d = r === minRGB ? g - b : b === minRGB ? r - g : b - r;
        h = r === minRGB ? 3 : b === minRGB ? 1 : 5;
        h = 60 * (h - d / (maxRGB - minRGB));
        s = (maxRGB - minRGB) / maxRGB;
        v = maxRGB;
        return hsvColour(Math.round(h), Math.round(s * 100), Math.round(v * 100));
    };
    const hexToHsv = (hex)=>fromRgb(fromHex(hex))
    ;
    const hsvToHex = (hsv)=>fromRgba(fromHsv(hsv))
    ;
    const anyToHex = (color)=>fromString$1(color).orThunk(()=>fromString(color).map(fromRgba)
        ).getOrThunk(()=>{
            const canvas = document.createElement('canvas');
            canvas.height = 1;
            canvas.width = 1;
            const canvasContext = canvas.getContext('2d');
            canvasContext.clearRect(0, 0, canvas.width, canvas.height);
            canvasContext.fillStyle = '#FFFFFF';
            canvasContext.fillStyle = color;
            canvasContext.fillRect(0, 0, 1, 1);
            const rgba = canvasContext.getImageData(0, 0, 1, 1).data;
            const r = rgba[0];
            const g = rgba[1];
            const b = rgba[2];
            const a = rgba[3];
            return fromRgba(rgbaColour1(r, g, b, a));
        })
    ;
    var global$4 = tinymce.util.Tools.resolve('tinymce.util.LocalStorage');
    const storageName = 'tinymce-custom-colors';
    var ColorCache = (max = 10)=>{
        const storageString = global$4.getItem(storageName);
        const localstorage = isString(storageString) ? JSON.parse(storageString) : [];
        const prune = (list)=>{
            const diff = max - list.length;
            return diff < 0 ? list.slice(0, max) : list;
        };
        const cache = prune(localstorage);
        const add = (key)=>{
            indexOf(cache, key).each(remove);
            cache.unshift(key);
            if (cache.length > max) cache.pop();
            global$4.setItem(storageName, JSON.stringify(cache));
        };
        const remove = (idx)=>{
            cache.splice(idx, 1);
        };
        const state = ()=>cache.slice(0)
        ;
        return {
            add,
            state
        };
    };
    const colorCache = ColorCache(10);
    const calcCols = (colors)=>Math.max(5, Math.ceil(Math.sqrt(colors)))
    ;
    const mapColors = (colorMap)=>{
        const colors = [];
        for(let i = 0; i < colorMap.length; i += 2)colors.push({
            text: colorMap[i + 1],
            value: '#' + anyToHex(colorMap[i]).value,
            type: 'choiceitem'
        });
        return colors;
    };
    const option$1 = (name)=>(editor)=>editor.options.get(name)
    ;
    const register$d = (editor)=>{
        const registerOption = editor.options.register;
        registerOption('color_map', {
            processor: (value)=>{
                if (isArrayOf(value, isString)) return {
                    value: mapColors(value),
                    valid: true
                };
                else return {
                    valid: false,
                    message: 'Must be an array of strings.'
                };
            },
            default: [
                '#BFEDD2',
                'Light Green',
                '#FBEEB8',
                'Light Yellow',
                '#F8CAC6',
                'Light Red',
                '#ECCAFA',
                'Light Purple',
                '#C2E0F4',
                'Light Blue',
                '#2DC26B',
                'Green',
                '#F1C40F',
                'Yellow',
                '#E03E2D',
                'Red',
                '#B96AD9',
                'Purple',
                '#3598DB',
                'Blue',
                '#169179',
                'Dark Turquoise',
                '#E67E23',
                'Orange',
                '#BA372A',
                'Dark Red',
                '#843FA1',
                'Dark Purple',
                '#236FA1',
                'Dark Blue',
                '#ECF0F1',
                'Light Gray',
                '#CED4D9',
                'Medium Gray',
                '#95A5A6',
                'Gray',
                '#7E8C8D',
                'Dark Gray',
                '#34495E',
                'Navy Blue',
                '#000000',
                'Black',
                '#ffffff',
                'White'
            ]
        });
        registerOption('color_cols', {
            processor: 'number',
            default: calcCols(getColors$2(editor).length)
        });
        registerOption('custom_colors', {
            processor: 'boolean',
            default: true
        });
    };
    const getColorCols$1 = option$1('color_cols');
    const hasCustomColors$1 = option$1('custom_colors');
    const getColors$2 = option$1('color_map');
    const getCurrentColors = ()=>map$2(colorCache.state(), (color)=>({
                type: 'choiceitem',
                text: color,
                value: color
            })
        )
    ;
    const addColor = (color)=>{
        colorCache.add(color);
    };
    const fallbackColor = '#000000';
    const getCurrentColor = (editor, format)=>{
        let color;
        editor.dom.getParents(editor.selection.getStart(), (elm)=>{
            let value;
            if (value = elm.style[format === 'forecolor' ? 'color' : 'background-color']) color = color ? color : value;
        });
        return Optional.from(color);
    };
    const applyFormat = (editor, format, value)=>{
        editor.undoManager.transact(()=>{
            editor.focus();
            editor.formatter.apply(format, {
                value
            });
            editor.nodeChanged();
        });
    };
    const removeFormat = (editor, format)=>{
        editor.undoManager.transact(()=>{
            editor.focus();
            editor.formatter.remove(format, {
                value: null
            }, null, true);
            editor.nodeChanged();
        });
    };
    const registerCommands = (editor)=>{
        editor.addCommand('mceApplyTextcolor', (format, value)=>{
            applyFormat(editor, format, value);
        });
        editor.addCommand('mceRemoveTextcolor', (format)=>{
            removeFormat(editor, format);
        });
    };
    const getAdditionalColors = (hasCustom)=>{
        const type = 'choiceitem';
        const remove = {
            type,
            text: 'Remove color',
            icon: 'color-swatch-remove-color',
            value: 'remove'
        };
        const custom = {
            type,
            text: 'Custom color',
            icon: 'color-picker',
            value: 'custom'
        };
        return hasCustom ? [
            remove,
            custom
        ] : [
            remove
        ];
    };
    const applyColor = (editor, format, value, onChoice)=>{
        if (value === 'custom') {
            const dialog = colorPickerDialog(editor);
            dialog((colorOpt)=>{
                colorOpt.each((color)=>{
                    addColor(color);
                    editor.execCommand('mceApplyTextcolor', format, color);
                    onChoice(color);
                });
            }, fallbackColor);
        } else if (value === 'remove') {
            onChoice('');
            editor.execCommand('mceRemoveTextcolor', format);
        } else {
            onChoice(value);
            editor.execCommand('mceApplyTextcolor', format, value);
        }
    };
    const getColors$1 = (colors, hasCustom)=>colors.concat(getCurrentColors().concat(getAdditionalColors(hasCustom)))
    ;
    const getFetch$1 = (colors, hasCustom)=>(callback)=>{
            callback(getColors$1(colors, hasCustom));
        }
    ;
    const setIconColor = (splitButtonApi, name, newColor)=>{
        const id = name === 'forecolor' ? 'tox-icon-text-color__color' : 'tox-icon-highlight-bg-color__color';
        splitButtonApi.setIconFill(id, newColor);
    };
    const registerTextColorButton = (editor, name, format, tooltip, lastColor)=>{
        editor.ui.registry.addSplitButton(name, {
            tooltip,
            presets: 'color',
            icon: name === 'forecolor' ? 'text-color' : 'highlight-bg-color',
            select: (value)=>{
                const optCurrentRgb = getCurrentColor(editor, format);
                return optCurrentRgb.bind((currentRgb)=>fromString(currentRgb).map((rgba)=>{
                        const currentHex = fromRgba(rgba).value;
                        return contains$1(value.toLowerCase(), currentHex);
                    })
                ).getOr(false);
            },
            columns: getColorCols$1(editor),
            fetch: getFetch$1(getColors$2(editor), hasCustomColors$1(editor)),
            onAction: (_splitButtonApi)=>{
                applyColor(editor, format, lastColor.get(), noop);
            },
            onItemAction: (_splitButtonApi, value)=>{
                applyColor(editor, format, value, (newColor)=>{
                    lastColor.set(newColor);
                    fireTextColorChange(editor, {
                        name,
                        color: newColor
                    });
                });
            },
            onSetup: (splitButtonApi)=>{
                setIconColor(splitButtonApi, name, lastColor.get());
                const handler = (e)=>{
                    if (e.name === name) setIconColor(splitButtonApi, e.name, e.color);
                };
                editor.on('TextColorChange', handler);
                return ()=>{
                    editor.off('TextColorChange', handler);
                };
            }
        });
    };
    const registerTextColorMenuItem = (editor, name, format, text)=>{
        editor.ui.registry.addNestedMenuItem(name, {
            text,
            icon: name === 'forecolor' ? 'text-color' : 'highlight-bg-color',
            getSubmenuItems: ()=>[
                    {
                        type: 'fancymenuitem',
                        fancytype: 'colorswatch',
                        onAction: (data)=>{
                            applyColor(editor, format, data.value, noop);
                        }
                    }
                ]
        });
    };
    const colorPickerDialog = (editor)=>(callback, value)=>{
            let isValid = false;
            const onSubmit = (api)=>{
                const data = api.getData();
                const hex = data.colorpicker;
                if (isValid) {
                    callback(Optional.from(hex));
                    api.close();
                } else editor.windowManager.alert(editor.translate([
                    'Invalid hex color code: {0}',
                    hex
                ]));
            };
            const onAction = (_api, details)=>{
                if (details.name === 'hex-valid') isValid = details.value;
            };
            const initialData = {
                colorpicker: value
            };
            editor.windowManager.open({
                title: 'Color Picker',
                size: 'normal',
                body: {
                    type: 'panel',
                    items: [
                        {
                            type: 'colorpicker',
                            name: 'colorpicker',
                            label: 'Color'
                        }
                    ]
                },
                buttons: [
                    {
                        type: 'cancel',
                        name: 'cancel',
                        text: 'Cancel'
                    },
                    {
                        type: 'submit',
                        name: 'save',
                        text: 'Save',
                        primary: true
                    }
                ],
                initialData,
                onAction,
                onSubmit,
                onClose: noop,
                onCancel: ()=>{
                    callback(Optional.none());
                }
            });
        }
    ;
    const register$c = (editor)=>{
        registerCommands(editor);
        const lastForeColor = Cell(fallbackColor);
        const lastBackColor = Cell(fallbackColor);
        registerTextColorButton(editor, 'forecolor', 'forecolor', 'Text color', lastForeColor);
        registerTextColorButton(editor, 'backcolor', 'hilitecolor', 'Background color', lastBackColor);
        registerTextColorMenuItem(editor, 'forecolor', 'forecolor', 'Text color');
        registerTextColorMenuItem(editor, 'backcolor', 'hilitecolor', 'Background color');
    };
    const createPartialChoiceMenu = (value, items, onItemValueHandler, columns, presets, itemResponse, select, providersBackstage)=>{
        const hasIcons = menuHasIcons1(items);
        const presetItemTypes = presets !== 'color' ? 'normal' : 'color';
        const alloyItems = createChoiceItems(items, onItemValueHandler, columns, presetItemTypes, itemResponse, select, providersBackstage);
        return createPartialMenuWithAlloyItems(value, hasIcons, alloyItems, columns, presets);
    };
    const createChoiceItems = (items, onItemValueHandler, columns, itemPresets, itemResponse, select, providersBackstage)=>cat(map$2(items, (item)=>{
            if (item.type === 'choiceitem') return createChoiceMenuItem(item).fold(handleError, (d)=>Optional.some(renderChoiceItem(d, columns === 1, itemPresets, onItemValueHandler, select(item.value), itemResponse, providersBackstage, menuHasIcons1(items)))
            );
            else return Optional.none();
        }))
    ;
    const deriveMenuMovement = (columns, presets)=>{
        const menuMarkers = markers(presets);
        if (columns === 1) return {
            mode: 'menu',
            moveOnTab: true
        };
        else if (columns === 'auto') return {
            mode: 'grid',
            selector: '.' + menuMarkers.item,
            initSize: {
                numColumns: 1,
                numRows: 1
            }
        };
        else {
            const rowClass = presets === 'color' ? 'tox-swatches__row' : 'tox-collection__group';
            return {
                mode: 'matrix',
                rowSelector: '.' + rowClass
            };
        }
    };
    const deriveCollectionMovement = (columns, presets)=>{
        if (columns === 1) return {
            mode: 'menu',
            moveOnTab: false,
            selector: '.tox-collection__item'
        };
        else if (columns === 'auto') return {
            mode: 'flatgrid',
            selector: ".tox-collection__item",
            initSize: {
                numColumns: 1,
                numRows: 1
            }
        };
        else return {
            mode: 'matrix',
            selectors: {
                row: presets === 'color' ? '.tox-swatches__row' : '.tox-collection__group',
                cell: presets === 'color' ? `.${colorClass}` : `.${selectableClass}`
            }
        };
    };
    const renderColorSwatchItem = (spec, backstage)=>{
        const items = getColorItems(spec, backstage);
        const columns = backstage.colorinput.getColorCols();
        const presets = 'color';
        const menuSpec = createPartialChoiceMenu(generate$6('menu-value'), items, (value)=>{
            spec.onAction({
                value
            });
        }, columns, presets, ItemResponse$1.CLOSE_ON_EXECUTE, never, backstage.shared.providers);
        const widgetSpec = {
            ...menuSpec,
            markers: markers(presets),
            movement: deriveMenuMovement(columns, presets)
        };
        return {
            type: 'widget',
            data: {
                value: generate$6('widget-id')
            },
            dom: {
                tag: 'div',
                classes: [
                    'tox-fancymenuitem'
                ]
            },
            autofocus: true,
            components: [
                parts$f.widget(Menu.sketch(widgetSpec))
            ]
        };
    };
    const getColorItems = (spec, backstage)=>{
        const useCustomColors = spec.initData.allowCustomColors && backstage.colorinput.hasCustomColors();
        return spec.initData.colors.fold(()=>getColors$1(backstage.colorinput.getColors(), useCustomColors)
        , (colors)=>colors.concat(getAdditionalColors(useCustomColors))
        );
    };
    const cellOverEvent = generate$6('cell-over');
    const cellExecuteEvent = generate$6('cell-execute');
    const makeCell = (row, col, labelId)=>{
        const emitCellOver = (c)=>emitWith(c, cellOverEvent, {
                row,
                col
            })
        ;
        const emitExecute = (c)=>emitWith(c, cellExecuteEvent, {
                row,
                col
            })
        ;
        const onClick = (c, se)=>{
            se.stop();
            emitExecute(c);
        };
        return build$1({
            dom: {
                tag: 'div',
                attributes: {
                    role: 'button',
                    ['aria-labelledby']: labelId
                }
            },
            behaviours: derive$1([
                config1('insert-table-picker-cell', [
                    run$1(mouseover(), Focusing.focus),
                    run$1(execute$5(), emitExecute),
                    run$1(click(), onClick),
                    run$1(tap(), onClick)
                ]),
                Toggling.config({
                    toggleClass: 'tox-insert-table-picker__selected',
                    toggleOnExecute: false
                }),
                Focusing.config({
                    onFocus: emitCellOver
                })
            ])
        });
    };
    const makeCells = (labelId, numRows, numCols)=>{
        const cells = [];
        for(let i = 0; i < numRows; i++){
            const row = [];
            for(let j = 0; j < numCols; j++)row.push(makeCell(i, j, labelId));
            cells.push(row);
        }
        return cells;
    };
    const selectCells = (cells, selectedRow, selectedColumn, numRows, numColumns)=>{
        for(let i = 0; i < numRows; i++)for(let j = 0; j < numColumns; j++)Toggling.set(cells[i][j], i <= selectedRow && j <= selectedColumn);
    };
    const makeComponents = (cells)=>bind$3(cells, (cellRow)=>map$2(cellRow, premade)
        )
    ;
    const makeLabelText = (row, col)=>text$1(`${col}x${row}`)
    ;
    const renderInsertTableMenuItem = (spec)=>{
        const numRows = 10;
        const numColumns = 10;
        const sizeLabelId = generate$6('size-label');
        const cells = makeCells(sizeLabelId, numRows, numColumns);
        const emptyLabelText = makeLabelText(0, 0);
        const memLabel = record1({
            dom: {
                tag: 'span',
                classes: [
                    'tox-insert-table-picker__label'
                ],
                attributes: {
                    id: sizeLabelId
                }
            },
            components: [
                emptyLabelText
            ],
            behaviours: derive$1([
                Replacing.config({})
            ])
        });
        return {
            type: 'widget',
            data: {
                value: generate$6('widget-id')
            },
            dom: {
                tag: 'div',
                classes: [
                    'tox-fancymenuitem'
                ]
            },
            autofocus: true,
            components: [
                parts$f.widget({
                    dom: {
                        tag: 'div',
                        classes: [
                            'tox-insert-table-picker'
                        ]
                    },
                    components: makeComponents(cells).concat(memLabel.asSpec()),
                    behaviours: derive$1([
                        config1('insert-table-picker', [
                            runOnAttached((c)=>{
                                Replacing.set(memLabel.get(c), [
                                    emptyLabelText
                                ]);
                            }),
                            runWithTarget(cellOverEvent, (c, t, e)=>{
                                const { row , col  } = e.event;
                                selectCells(cells, row, col, numRows, numColumns);
                                Replacing.set(memLabel.get(c), [
                                    makeLabelText(row + 1, col + 1)
                                ]);
                            }),
                            runWithTarget(cellExecuteEvent, (c, _, e)=>{
                                const { row , col  } = e.event;
                                spec.onAction({
                                    numRows: row + 1,
                                    numColumns: col + 1
                                });
                                emit(c, sandboxClose());
                            })
                        ]),
                        Keying.config({
                            initSize: {
                                numRows,
                                numColumns
                            },
                            mode: 'flatgrid',
                            selector: '[role="button"]'
                        })
                    ])
                })
            ]
        };
    };
    const fancyMenuItems = {
        inserttable: renderInsertTableMenuItem,
        colorswatch: renderColorSwatchItem
    };
    const renderFancyMenuItem = (spec, backstage)=>get$g(fancyMenuItems, spec.fancytype).map((render)=>render(spec, backstage)
        )
    ;
    const renderNestedItem = (spec, itemResponse, providersBackstage, renderIcons = true, downwardsCaret = false)=>{
        const caret = downwardsCaret ? renderDownwardsCaret(providersBackstage.icons) : renderSubmenuCaret(providersBackstage.icons);
        const getApi = (component)=>({
                isEnabled: ()=>!Disabling.isDisabled(component)
                ,
                setEnabled: (state)=>Disabling.set(component, !state)
            })
        ;
        const structure = renderItemStructure({
            presets: 'normal',
            iconContent: spec.icon,
            textContent: spec.text,
            htmlContent: Optional.none(),
            ariaLabel: spec.text,
            caret: Optional.some(caret),
            checkMark: Optional.none(),
            shortcutContent: spec.shortcut
        }, providersBackstage, renderIcons);
        return renderCommonItem({
            data: buildData(spec),
            getApi,
            enabled: spec.enabled,
            onAction: noop,
            onSetup: spec.onSetup,
            triggersSubmenu: true,
            itemBehaviours: []
        }, structure, itemResponse, providersBackstage);
    };
    const renderNormalItem = (spec, itemResponse, providersBackstage, renderIcons = true)=>{
        const getApi = (component)=>({
                isEnabled: ()=>!Disabling.isDisabled(component)
                ,
                setEnabled: (state)=>Disabling.set(component, !state)
            })
        ;
        const structure = renderItemStructure({
            presets: 'normal',
            iconContent: spec.icon,
            textContent: spec.text,
            htmlContent: Optional.none(),
            ariaLabel: spec.text,
            caret: Optional.none(),
            checkMark: Optional.none(),
            shortcutContent: spec.shortcut
        }, providersBackstage, renderIcons);
        return renderCommonItem({
            data: buildData(spec),
            getApi,
            enabled: spec.enabled,
            onAction: spec.onAction,
            onSetup: spec.onSetup,
            triggersSubmenu: false,
            itemBehaviours: []
        }, structure, itemResponse, providersBackstage);
    };
    const renderSeparatorItem = (spec)=>({
            type: 'separator',
            dom: {
                tag: 'div',
                classes: [
                    selectableClass,
                    groupHeadingClass
                ]
            },
            components: spec.text.map(text$1).toArray()
        })
    ;
    const renderToggleMenuItem = (spec, itemResponse, providersBackstage, renderIcons = true)=>{
        const getApi = (component)=>({
                setActive: (state)=>{
                    Toggling.set(component, state);
                },
                isActive: ()=>Toggling.isOn(component)
                ,
                isEnabled: ()=>!Disabling.isDisabled(component)
                ,
                setEnabled: (state)=>Disabling.set(component, !state)
            })
        ;
        const structure = renderItemStructure({
            iconContent: spec.icon,
            textContent: spec.text,
            htmlContent: Optional.none(),
            ariaLabel: spec.text,
            checkMark: Optional.some(renderCheckmark(providersBackstage.icons)),
            caret: Optional.none(),
            shortcutContent: spec.shortcut,
            presets: 'normal',
            meta: spec.meta
        }, providersBackstage, renderIcons);
        return deepMerge(renderCommonItem({
            data: buildData(spec),
            enabled: spec.enabled,
            getApi,
            onAction: spec.onAction,
            onSetup: spec.onSetup,
            triggersSubmenu: false,
            itemBehaviours: []
        }, structure, itemResponse, providersBackstage), {
            toggling: {
                toggleClass: tickedClass,
                toggleOnExecute: false,
                selected: spec.active
            }
        });
    };
    const autocomplete = renderAutocompleteItem;
    const separator$3 = renderSeparatorItem;
    const normal = renderNormalItem;
    const nested = renderNestedItem;
    const toggle$1 = renderToggleMenuItem;
    const fancy = renderFancyMenuItem;
    const card = renderCardMenuItem;
    var FocusMode1;
    (function(FocusMode) {
        FocusMode[FocusMode['ContentFocus'] = 0] = 'ContentFocus';
        FocusMode[FocusMode['UiFocus'] = 1] = 'UiFocus';
    })(FocusMode1 || (FocusMode1 = {}));
    const createMenuItemFromBridge = (item, itemResponse, backstage, menuHasIcons, isHorizontalMenu)=>{
        const providersBackstage = backstage.shared.providers;
        const parseForHorizontalMenu = (menuitem)=>!isHorizontalMenu ? menuitem : {
                ...menuitem,
                shortcut: Optional.none(),
                icon: menuitem.text.isSome() ? Optional.none() : menuitem.icon
            }
        ;
        switch(item.type){
            case 'menuitem':
                return createMenuItem(item).fold(handleError, (d)=>Optional.some(normal(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons))
                );
            case 'nestedmenuitem':
                return createNestedMenuItem(item).fold(handleError, (d)=>Optional.some(nested(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons, isHorizontalMenu))
                );
            case 'togglemenuitem':
                return createToggleMenuItem(item).fold(handleError, (d)=>Optional.some(toggle$1(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons))
                );
            case 'separator':
                return createSeparatorMenuItem(item).fold(handleError, (d)=>Optional.some(separator$3(d))
                );
            case 'fancymenuitem':
                return createFancyMenuItem(item).fold(handleError, (d)=>fancy(parseForHorizontalMenu(d), backstage)
                );
            default:
                console.error('Unknown item in general menu', item);
                return Optional.none();
        }
    };
    const createAutocompleteItems = (items, matchText, onItemValueHandler, columns, itemResponse, sharedBackstage, highlightOn)=>{
        const renderText = columns === 1;
        const renderIcons = !renderText || menuHasIcons1(items);
        return cat(map$2(items, (item)=>{
            switch(item.type){
                case 'separator':
                    return createSeparatorItem(item).fold(handleError, (d)=>Optional.some(separator$3(d))
                    );
                case 'cardmenuitem':
                    return createCardMenuItem(item).fold(handleError, (d)=>Optional.some(card({
                            ...d,
                            onAction: (api)=>{
                                d.onAction(api);
                                onItemValueHandler(d.value, d.meta);
                            }
                        }, itemResponse, sharedBackstage, {
                            itemBehaviours: tooltipBehaviour(d.meta, sharedBackstage),
                            cardText: {
                                matchText,
                                highlightOn
                            }
                        }))
                    );
                case 'autocompleteitem':
                default:
                    return createAutocompleterItem(item).fold(handleError, (d)=>Optional.some(autocomplete(d, matchText, renderText, 'normal', onItemValueHandler, itemResponse, sharedBackstage, renderIcons))
                    );
            }
        }));
    };
    const createPartialMenu = (value, items, itemResponse, backstage, isHorizontalMenu)=>{
        const hasIcons = menuHasIcons1(items);
        const alloyItems = cat(map$2(items, (item)=>{
            const itemHasIcon = (i)=>isHorizontalMenu ? !has$2(i, 'text') : hasIcons
            ;
            const createItem = (i)=>createMenuItemFromBridge(i, itemResponse, backstage, itemHasIcon(i), isHorizontalMenu)
            ;
            if (item.type === 'nestedmenuitem' && item.getSubmenuItems().length <= 0) return createItem({
                ...item,
                enabled: false
            });
            else return createItem(item);
        }));
        const createPartial = isHorizontalMenu ? createHorizontalPartialMenuWithAlloyItems : createPartialMenuWithAlloyItems;
        return createPartial(value, hasIcons, alloyItems, 1, 'normal');
    };
    const createTieredDataFrom = (partialMenu)=>tieredMenu.singleData(partialMenu.value, partialMenu)
    ;
    const createMenuFrom = (partialMenu, columns, focusMode, presets)=>{
        const focusManager = focusMode === FocusMode1.ContentFocus ? highlights() : dom$2();
        const movement = deriveMenuMovement(columns, presets);
        const menuMarkers = markers(presets);
        return {
            dom: partialMenu.dom,
            components: partialMenu.components,
            items: partialMenu.items,
            value: partialMenu.value,
            markers: {
                selectedItem: menuMarkers.selectedItem,
                item: menuMarkers.item
            },
            movement,
            fakeFocus: focusMode === FocusMode1.ContentFocus,
            focusManager,
            menuBehaviours: SimpleBehaviours.unnamedEvents(columns !== 'auto' ? [] : [
                runOnAttached((comp, _se)=>{
                    detectSize(comp, 4, menuMarkers.item).each(({ numColumns , numRows  })=>{
                        Keying.setGridSize(comp, numRows, numColumns);
                    });
                })
            ])
        };
    };
    const getAutocompleterRange = (dom, initRange)=>{
        return detect(SugarElement.fromDom(initRange.startContainer)).map((elm)=>{
            const range = dom.createRng();
            range.selectNode(elm.dom);
            return range;
        });
    };
    const register$b = (editor, sharedBackstage)=>{
        const processingAction = Cell(false);
        const activeState = Cell(false);
        const autocompleter = build$1(InlineView.sketch({
            dom: {
                tag: 'div',
                classes: [
                    'tox-autocompleter'
                ]
            },
            components: [],
            fireDismissalEventInstead: {},
            inlineBehaviours: derive$1([
                config1('dismissAutocompleter', [
                    run$1(dismissRequested(), ()=>cancelIfNecessary()
                    )
                ])
            ]),
            lazySink: sharedBackstage.getSink
        }));
        const isMenuOpen = ()=>InlineView.isOpen(autocompleter)
        ;
        const isActive = activeState.get;
        const hideIfNecessary = ()=>{
            if (isMenuOpen()) InlineView.hide(autocompleter);
        };
        const cancelIfNecessary = ()=>editor.execCommand('mceAutocompleterClose')
        ;
        const getCombinedItems = (matches)=>{
            const columns = findMap(matches, (m)=>Optional.from(m.columns)
            ).getOr(1);
            return bind$3(matches, (match)=>{
                const choices = match.items;
                return createAutocompleteItems(choices, match.matchText, (itemValue, itemMeta)=>{
                    const nr = editor.selection.getRng();
                    getAutocompleterRange(editor.dom, nr).each((range)=>{
                        const autocompleterApi = {
                            hide: ()=>cancelIfNecessary()
                            ,
                            reload: (fetchOptions)=>{
                                hideIfNecessary();
                                editor.execCommand('mceAutocompleterReload', false, {
                                    fetchOptions
                                });
                            }
                        };
                        processingAction.set(true);
                        match.onAction(autocompleterApi, range, itemValue, itemMeta);
                        processingAction.set(false);
                    });
                }, columns, ItemResponse$1.BUBBLE_TO_SANDBOX, sharedBackstage, match.highlightOn);
            });
        };
        const display = (lookupData, items)=>{
            findIn(SugarElement.fromDom(editor.getBody())).each((element)=>{
                const columns = findMap(lookupData, (ld)=>Optional.from(ld.columns)
                ).getOr(1);
                InlineView.showAt(autocompleter, Menu.sketch(createMenuFrom(createPartialMenuWithAlloyItems('autocompleter-value', true, items, columns, 'normal'), columns, FocusMode1.ContentFocus, 'normal')), {
                    anchor: {
                        type: 'node',
                        root: SugarElement.fromDom(editor.getBody()),
                        node: Optional.from(element)
                    }
                });
                InlineView.getContent(autocompleter).each(Highlighting.highlightFirst);
            });
        };
        const updateDisplay = (lookupData)=>{
            const combinedItems = getCombinedItems(lookupData);
            if (combinedItems.length > 0) display(lookupData, combinedItems);
            else hideIfNecessary();
        };
        editor.on('AutocompleterStart', ({ lookupData  })=>{
            activeState.set(true);
            processingAction.set(false);
            updateDisplay(lookupData);
        });
        editor.on('AutocompleterUpdate', ({ lookupData  })=>updateDisplay(lookupData)
        );
        editor.on('AutocompleterEnd', ()=>{
            hideIfNecessary();
            activeState.set(false);
            processingAction.set(false);
        });
        const autocompleterUiApi = {
            cancelIfNecessary,
            isMenuOpen,
            isActive,
            isProcessingAction: processingAction.get,
            getView: ()=>InlineView.getContent(autocompleter)
        };
        AutocompleterEditorEvents.setup(autocompleterUiApi, editor);
    };
    const Autocompleter = {
        register: register$b
    };
    const closest1 = (scope, selector, isRoot)=>closest$1(scope, selector, isRoot).isSome()
    ;
    const DelayedFunction = (fun, delay)=>{
        let ref = null;
        const schedule = (...args)=>{
            ref = setTimeout(()=>{
                fun.apply(null, args);
                ref = null;
            }, delay);
        };
        const cancel = ()=>{
            if (ref !== null) {
                clearTimeout(ref);
                ref = null;
            }
        };
        return {
            cancel,
            schedule
        };
    };
    const SIGNIFICANT_MOVE = 5;
    const LONGPRESS_DELAY = 400;
    const getTouch = (event)=>{
        const raw = event.raw;
        if (raw.touches === undefined || raw.touches.length !== 1) return Optional.none();
        return Optional.some(raw.touches[0]);
    };
    const isFarEnough = (touch, data)=>{
        const distX = Math.abs(touch.clientX - data.x);
        const distY = Math.abs(touch.clientY - data.y);
        return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;
    };
    const monitor = (settings)=>{
        const startData = value$2();
        const longpressFired = Cell(false);
        const longpress$1 = DelayedFunction((event)=>{
            settings.triggerEvent(longpress(), event);
            longpressFired.set(true);
        }, LONGPRESS_DELAY);
        const handleTouchstart = (event)=>{
            getTouch(event).each((touch)=>{
                longpress$1.cancel();
                const data = {
                    x: touch.clientX,
                    y: touch.clientY,
                    target: event.target
                };
                longpress$1.schedule(event);
                longpressFired.set(false);
                startData.set(data);
            });
            return Optional.none();
        };
        const handleTouchmove = (event)=>{
            longpress$1.cancel();
            getTouch(event).each((touch)=>{
                startData.on((data)=>{
                    if (isFarEnough(touch, data)) startData.clear();
                });
            });
            return Optional.none();
        };
        const handleTouchend = (event)=>{
            longpress$1.cancel();
            const isSame = (data)=>eq(data.target, event.target)
            ;
            return startData.get().filter(isSame).map((_data)=>{
                if (longpressFired.get()) {
                    event.prevent();
                    return false;
                } else return settings.triggerEvent(tap(), event);
            });
        };
        const handlers = wrapAll([
            {
                key: touchstart(),
                value: handleTouchstart
            },
            {
                key: touchmove(),
                value: handleTouchmove
            },
            {
                key: touchend(),
                value: handleTouchend
            }
        ]);
        const fireIfReady = (event, type)=>get$g(handlers, type).bind((handler)=>handler(event)
            )
        ;
        return {
            fireIfReady
        };
    };
    const isDangerous = (event)=>{
        const keyEv = event.raw;
        return keyEv.which === BACKSPACE[0] && !contains$2([
            'input',
            'textarea'
        ], name$3(event.target)) && !closest1(event.target, '[contenteditable="true"]');
    };
    const setup$d = (container, rawSettings)=>{
        const settings = {
            stopBackspace: true,
            ...rawSettings
        };
        const pointerEvents = [
            'touchstart',
            'touchmove',
            'touchend',
            'touchcancel',
            'gesturestart',
            'mousedown',
            'mouseup',
            'mouseover',
            'mousemove',
            'mouseout',
            'click'
        ];
        const tapEvent = monitor(settings);
        const simpleEvents = map$2(pointerEvents.concat([
            'selectstart',
            'input',
            'contextmenu',
            'change',
            'transitionend',
            'transitioncancel',
            'drag',
            'dragstart',
            'dragend',
            'dragenter',
            'dragleave',
            'dragover',
            'drop',
            'keyup'
        ]), (type)=>bind1(container, type, (event)=>{
                tapEvent.fireIfReady(event, type).each((tapStopped)=>{
                    if (tapStopped) event.kill();
                });
                const stopped = settings.triggerEvent(type, event);
                if (stopped) event.kill();
            })
        );
        const pasteTimeout = value$2();
        const onPaste = bind1(container, 'paste', (event)=>{
            tapEvent.fireIfReady(event, 'paste').each((tapStopped)=>{
                if (tapStopped) event.kill();
            });
            const stopped = settings.triggerEvent('paste', event);
            if (stopped) event.kill();
            pasteTimeout.set(setTimeout(()=>{
                settings.triggerEvent(postPaste(), event);
            }, 0));
        });
        const onKeydown = bind1(container, 'keydown', (event)=>{
            const stopped = settings.triggerEvent('keydown', event);
            if (stopped) event.kill();
            else if (settings.stopBackspace && isDangerous(event)) event.prevent();
        });
        const onFocusIn = bind1(container, 'focusin', (event)=>{
            const stopped = settings.triggerEvent('focusin', event);
            if (stopped) event.kill();
        });
        const focusoutTimeout = value$2();
        const onFocusOut = bind1(container, 'focusout', (event)=>{
            const stopped = settings.triggerEvent('focusout', event);
            if (stopped) event.kill();
            focusoutTimeout.set(setTimeout(()=>{
                settings.triggerEvent(postBlur(), event);
            }, 0));
        });
        const unbind = ()=>{
            each$1(simpleEvents, (e)=>{
                e.unbind();
            });
            onKeydown.unbind();
            onFocusIn.unbind();
            onFocusOut.unbind();
            onPaste.unbind();
            pasteTimeout.on(clearTimeout);
            focusoutTimeout.on(clearTimeout);
        };
        return {
            unbind
        };
    };
    const derive = (rawEvent, rawTarget)=>{
        const source = get$g(rawEvent, 'target').getOr(rawTarget);
        return Cell(source);
    };
    const fromSource = (event, source)=>{
        const stopper = Cell(false);
        const cutter = Cell(false);
        const stop = ()=>{
            stopper.set(true);
        };
        const cut = ()=>{
            cutter.set(true);
        };
        return {
            stop,
            cut,
            isStopped: stopper.get,
            isCut: cutter.get,
            event,
            setSource: source.set,
            getSource: source.get
        };
    };
    const fromExternal = (event)=>{
        const stopper = Cell(false);
        const stop = ()=>{
            stopper.set(true);
        };
        return {
            stop,
            cut: noop,
            isStopped: stopper.get,
            isCut: never,
            event,
            setSource: die('Cannot set source of a broadcasted event'),
            getSource: die('Cannot get source of a broadcasted event')
        };
    };
    const adt$1 = Adt.generate([
        {
            stopped: []
        },
        {
            resume: [
                'element'
            ]
        },
        {
            complete: []
        }
    ]);
    const doTriggerHandler = (lookup, eventType, rawEvent, target, source, logger)=>{
        const handler = lookup(eventType, target);
        const simulatedEvent = fromSource(rawEvent, source);
        return handler.fold(()=>{
            logger.logEventNoHandlers(eventType, target);
            return adt$1.complete();
        }, (handlerInfo)=>{
            const descHandler = handlerInfo.descHandler;
            const eventHandler = getCurried(descHandler);
            eventHandler(simulatedEvent);
            if (simulatedEvent.isStopped()) {
                logger.logEventStopped(eventType, handlerInfo.element, descHandler.purpose);
                return adt$1.stopped();
            } else if (simulatedEvent.isCut()) {
                logger.logEventCut(eventType, handlerInfo.element, descHandler.purpose);
                return adt$1.complete();
            } else return parent1(handlerInfo.element).fold(()=>{
                logger.logNoParent(eventType, handlerInfo.element, descHandler.purpose);
                return adt$1.complete();
            }, (parent)=>{
                logger.logEventResponse(eventType, handlerInfo.element, descHandler.purpose);
                return adt$1.resume(parent);
            });
        });
    };
    const doTriggerOnUntilStopped = (lookup, eventType, rawEvent, rawTarget, source, logger)=>doTriggerHandler(lookup, eventType, rawEvent, rawTarget, source, logger).fold(always, (parent)=>doTriggerOnUntilStopped(lookup, eventType, rawEvent, parent, source, logger)
        , never)
    ;
    const triggerHandler = (lookup, eventType, rawEvent, target, logger)=>{
        const source = derive(rawEvent, target);
        return doTriggerHandler(lookup, eventType, rawEvent, target, source, logger);
    };
    const broadcast = (listeners, rawEvent, _logger)=>{
        const simulatedEvent = fromExternal(rawEvent);
        each$1(listeners, (listener)=>{
            const descHandler = listener.descHandler;
            const handler = getCurried(descHandler);
            handler(simulatedEvent);
        });
        return simulatedEvent.isStopped();
    };
    const triggerUntilStopped = (lookup, eventType, rawEvent, logger)=>triggerOnUntilStopped(lookup, eventType, rawEvent, rawEvent.target, logger)
    ;
    const triggerOnUntilStopped = (lookup, eventType, rawEvent, rawTarget, logger)=>{
        const source = derive(rawEvent, rawTarget);
        return doTriggerOnUntilStopped(lookup, eventType, rawEvent, rawTarget, source, logger);
    };
    const eventHandler1 = (element, descHandler)=>({
            element,
            descHandler
        })
    ;
    const broadcastHandler = (id, handler)=>({
            id,
            descHandler: handler
        })
    ;
    const EventRegistry = ()=>{
        const registry = {};
        const registerId = (extraArgs, id, events)=>{
            each(events, (v, k)=>{
                const handlers = registry[k] !== undefined ? registry[k] : {};
                handlers[id] = curryArgs(v, extraArgs);
                registry[k] = handlers;
            });
        };
        const findHandler = (handlers, elem)=>read$1(elem).bind((id)=>get$g(handlers, id)
            ).map((descHandler)=>eventHandler1(elem, descHandler)
            )
        ;
        const filterByType = (type)=>get$g(registry, type).map((handlers)=>mapToArray(handlers, (f, id)=>broadcastHandler(id, f)
                )
            ).getOr([])
        ;
        const find = (isAboveRoot, type, target)=>get$g(registry, type).bind((handlers)=>closest$4(target, (elem)=>findHandler(handlers, elem)
                , isAboveRoot)
            )
        ;
        const unregisterId = (id)=>{
            each(registry, (handlersById, _eventName)=>{
                if (has$2(handlersById, id)) delete handlersById[id];
            });
        };
        return {
            registerId,
            unregisterId,
            filterByType,
            find
        };
    };
    const Registry = ()=>{
        const events = EventRegistry();
        const components = {};
        const readOrTag = (component)=>{
            const elem = component.element;
            return read$1(elem).getOrThunk(()=>write('uid-', component.element)
            );
        };
        const failOnDuplicate = (component, tagId)=>{
            const conflict = components[tagId];
            if (conflict === component) unregister(component);
            else throw new Error('The tagId "' + tagId + '" is already used by: ' + element1(conflict.element) + '\nCannot use it for: ' + element1(component.element) + '\n' + 'The conflicting element is' + (inBody(conflict.element) ? ' ' : ' not ') + 'already in the DOM');
        };
        const register = (component)=>{
            const tagId = readOrTag(component);
            if (hasNonNullableKey(components, tagId)) failOnDuplicate(component, tagId);
            const extraArgs = [
                component
            ];
            events.registerId(extraArgs, tagId, component.events);
            components[tagId] = component;
        };
        const unregister = (component)=>{
            read$1(component.element).each((tagId)=>{
                delete components[tagId];
                events.unregisterId(tagId);
            });
        };
        const filter = (type)=>events.filterByType(type)
        ;
        const find = (isAboveRoot, type, target)=>events.find(isAboveRoot, type, target)
        ;
        const getById = (id)=>get$g(components, id)
        ;
        return {
            find,
            filter,
            register,
            unregister,
            getById
        };
    };
    const factory$j = (detail)=>{
        const { attributes , ...domWithoutAttributes } = detail.dom;
        return {
            uid: detail.uid,
            dom: {
                tag: 'div',
                attributes: {
                    role: 'presentation',
                    ...attributes
                },
                ...domWithoutAttributes
            },
            components: detail.components,
            behaviours: get$3(detail.containerBehaviours),
            events: detail.events,
            domModification: detail.domModification,
            eventOrder: detail.eventOrder
        };
    };
    const Container = single({
        name: 'Container',
        factory: factory$j,
        configFields: [
            defaulted('components', []),
            field1('containerBehaviours', []),
            defaulted('events', {}),
            defaulted('domModification', {}),
            defaulted('eventOrder', {})
        ]
    });
    const takeover = (root)=>{
        const isAboveRoot = (el)=>parent1(root.element).fold(always, (parent)=>eq(el, parent)
            )
        ;
        const registry = Registry();
        const lookup = (eventName, target)=>registry.find(isAboveRoot, eventName, target)
        ;
        const domEvents = setup$d(root.element, {
            triggerEvent: (eventName, event)=>{
                return monitorEvent(eventName, event.target, (logger)=>triggerUntilStopped(lookup, eventName, event, logger)
                );
            }
        });
        const systemApi = {
            debugInfo: constant$1('real'),
            triggerEvent: (eventName, target, data)=>{
                monitorEvent(eventName, target, (logger)=>triggerOnUntilStopped(lookup, eventName, data, target, logger)
                );
            },
            triggerFocus: (target, originator)=>{
                read$1(target).fold(()=>{
                    focus$3(target);
                }, (_alloyId)=>{
                    monitorEvent(focus$4(), target, (logger)=>{
                        triggerHandler(lookup, focus$4(), {
                            originator,
                            kill: noop,
                            prevent: noop,
                            target
                        }, target, logger);
                        return false;
                    });
                });
            },
            triggerEscape: (comp, simulatedEvent)=>{
                systemApi.triggerEvent('keydown', comp.element, simulatedEvent.event);
            },
            getByUid: (uid)=>{
                return getByUid(uid);
            },
            getByDom: (elem)=>{
                return getByDom(elem);
            },
            build: build$1,
            buildOrPatch: buildOrPatch,
            addToGui: (c)=>{
                add(c);
            },
            removeFromGui: (c)=>{
                remove(c);
            },
            addToWorld: (c)=>{
                addToWorld(c);
            },
            removeFromWorld: (c)=>{
                removeFromWorld(c);
            },
            broadcast: (message)=>{
                broadcast$1(message);
            },
            broadcastOn: (channels, message)=>{
                broadcastOn(channels, message);
            },
            broadcastEvent: (eventName, event)=>{
                broadcastEvent(eventName, event);
            },
            isConnected: always
        };
        const addToWorld = (component)=>{
            component.connect(systemApi);
            if (!isText(component.element)) {
                registry.register(component);
                each$1(component.components(), addToWorld);
                systemApi.triggerEvent(systemInit(), component.element, {
                    target: component.element
                });
            }
        };
        const removeFromWorld = (component)=>{
            if (!isText(component.element)) {
                each$1(component.components(), removeFromWorld);
                registry.unregister(component);
            }
            component.disconnect();
        };
        const add = (component)=>{
            attach1(root, component);
        };
        const remove = (component)=>{
            detach(component);
        };
        const destroy = ()=>{
            domEvents.unbind();
            remove$5(root.element);
        };
        const broadcastData = (data)=>{
            const receivers = registry.filter(receive());
            each$1(receivers, (receiver)=>{
                const descHandler = receiver.descHandler;
                const handler = getCurried(descHandler);
                handler(data);
            });
        };
        const broadcast$1 = (message)=>{
            broadcastData({
                universal: true,
                data: message
            });
        };
        const broadcastOn = (channels, message)=>{
            broadcastData({
                universal: false,
                channels,
                data: message
            });
        };
        const broadcastEvent = (eventName, event)=>{
            const listeners = registry.filter(eventName);
            return broadcast(listeners, event);
        };
        const getByUid = (uid)=>registry.getById(uid).fold(()=>Result.error(new Error('Could not find component with uid: "' + uid + '" in system.'))
            , Result.value)
        ;
        const getByDom = (elem)=>{
            const uid = read$1(elem).getOr('not found');
            return getByUid(uid);
        };
        addToWorld(root);
        return {
            root,
            element: root.element,
            destroy,
            add,
            remove,
            getByUid,
            getByDom,
            addToWorld,
            removeFromWorld,
            broadcast: broadcast$1,
            broadcastOn,
            broadcastEvent
        };
    };
    const renderBar = (spec, backstage)=>({
            dom: {
                tag: 'div',
                classes: [
                    'tox-bar',
                    'tox-form__controls-h-stack'
                ]
            },
            components: map$2(spec.items, backstage.interpreter)
        })
    ;
    const schema$l = constant$1([
        defaulted('prefix', 'form-field'),
        field1('fieldBehaviours', [
            Composing,
            Representing
        ])
    ]);
    const parts$e = constant$1([
        optional1({
            schema: [
                required$1('dom')
            ],
            name: 'label'
        }),
        optional1({
            factory: {
                sketch: (spec)=>{
                    return {
                        uid: spec.uid,
                        dom: {
                            tag: 'span',
                            styles: {
                                display: 'none'
                            },
                            attributes: {
                                'aria-hidden': 'true'
                            },
                            innerHtml: spec.text
                        }
                    };
                }
            },
            schema: [
                required$1('text')
            ],
            name: 'aria-descriptor'
        }),
        required1({
            factory: {
                sketch: (spec)=>{
                    const excludeFactory = exclude(spec, [
                        'factory'
                    ]);
                    return spec.factory.sketch(excludeFactory);
                }
            },
            schema: [
                required$1('factory')
            ],
            name: 'field'
        })
    ]);
    const factory$i = (detail, components, _spec, _externals)=>{
        const behaviours = augment(detail.fieldBehaviours, [
            Composing.config({
                find: (container)=>{
                    return getPart(container, detail, 'field');
                }
            }),
            Representing.config({
                store: {
                    mode: 'manual',
                    getValue: (field)=>{
                        return Composing.getCurrent(field).bind(Representing.getValue);
                    },
                    setValue: (field, value)=>{
                        Composing.getCurrent(field).each((current)=>{
                            Representing.setValue(current, value);
                        });
                    }
                }
            })
        ]);
        const events = derive$2([
            runOnAttached((component, _simulatedEvent)=>{
                const ps = getParts(component, detail, [
                    'label',
                    'field',
                    'aria-descriptor'
                ]);
                ps.field().each((field)=>{
                    const id = generate$6(detail.prefix);
                    ps.label().each((label)=>{
                        set$9(label.element, 'for', id);
                        set$9(field.element, 'id', id);
                    });
                    ps['aria-descriptor']().each((descriptor)=>{
                        const descriptorId = generate$6(detail.prefix);
                        set$9(descriptor.element, 'id', descriptorId);
                        set$9(field.element, 'aria-describedby', descriptorId);
                    });
                });
            })
        ]);
        const apis = {
            getField: (container)=>getPart(container, detail, 'field')
            ,
            getLabel: (container)=>getPart(container, detail, 'label')
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours,
            events,
            apis
        };
    };
    const FormField = composite({
        name: 'FormField',
        configFields: schema$l(),
        partFields: parts$e(),
        factory: factory$i,
        apis: {
            getField: (apis, comp)=>apis.getField(comp)
            ,
            getLabel: (apis, comp)=>apis.getLabel(comp)
        }
    });
    const exhibit$2 = (base, tabConfig)=>nu$7({
            attributes: wrapAll([
                {
                    key: tabConfig.tabAttr,
                    value: 'true'
                }
            ])
        })
    ;
    var ActiveTabstopping = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        exhibit: exhibit$2
    });
    var TabstopSchema = [
        defaulted('tabAttr', 'data-alloy-tabstop')
    ];
    const Tabstopping = create$3({
        fields: TabstopSchema,
        name: 'tabstopping',
        active: ActiveTabstopping
    });
    var global$3 = tinymce.util.Tools.resolve('tinymce.html.Entities');
    const renderFormFieldWith = (pLabel, pField, extraClasses, extraBehaviours)=>{
        const spec = renderFormFieldSpecWith(pLabel, pField, extraClasses, extraBehaviours);
        return FormField.sketch(spec);
    };
    const renderFormField = (pLabel, pField)=>renderFormFieldWith(pLabel, pField, [], [])
    ;
    const renderFormFieldSpecWith = (pLabel, pField, extraClasses, extraBehaviours)=>({
            dom: renderFormFieldDomWith(extraClasses),
            components: pLabel.toArray().concat([
                pField
            ]),
            fieldBehaviours: derive$1(extraBehaviours)
        })
    ;
    const renderFormFieldDom = ()=>renderFormFieldDomWith([])
    ;
    const renderFormFieldDomWith = (extraClasses)=>({
            tag: 'div',
            classes: [
                'tox-form__group'
            ].concat(extraClasses)
        })
    ;
    const renderLabel$2 = (label, providersBackstage)=>FormField.parts.label({
            dom: {
                tag: 'label',
                classes: [
                    'tox-label'
                ]
            },
            components: [
                text$1(providersBackstage.translate(label))
            ]
        })
    ;
    const formChangeEvent = generate$6('form-component-change');
    const formCloseEvent = generate$6('form-close');
    const formCancelEvent = generate$6('form-cancel');
    const formActionEvent = generate$6('form-action');
    const formSubmitEvent = generate$6('form-submit');
    const formBlockEvent = generate$6('form-block');
    const formUnblockEvent = generate$6('form-unblock');
    const formTabChangeEvent = generate$6('form-tabchange');
    const formResizeEvent = generate$6('form-resize');
    const renderCollection = (spec, providersBackstage, initialData)=>{
        const pLabel = spec.label.map((label)=>renderLabel$2(label, providersBackstage)
        );
        const runOnItem = (f)=>(comp, se)=>{
                closest$1(se.event.target, '[data-collection-item-value]').each((target)=>{
                    f(comp, se, target, get$f(target, 'data-collection-item-value'));
                });
            }
        ;
        const setContents = (comp, items)=>{
            const htmlLines = map$2(items, (item)=>{
                const itemText = global$8.translate(item.text);
                const textContent = spec.columns === 1 ? `<div class="tox-collection__item-label">${itemText}</div>` : '';
                const iconContent = `<div class="tox-collection__item-icon">${item.icon}</div>`;
                const mapItemName = {
                    '_': ' ',
                    ' - ': ' ',
                    '-': ' '
                };
                const ariaLabel = itemText.replace(/\_| \- |\-/g, (match)=>mapItemName[match]
                );
                const disabledClass = providersBackstage.isDisabled() ? ' tox-collection__item--state-disabled' : '';
                return `<div class="tox-collection__item${disabledClass}" tabindex="-1" data-collection-item-value="${global$3.encodeAllRaw(item.value)}" title="${ariaLabel}" aria-label="${ariaLabel}">${iconContent}${textContent}</div>`;
            });
            const chunks = spec.columns !== 'auto' && spec.columns > 1 ? chunk$1(htmlLines, spec.columns) : [
                htmlLines
            ];
            const html = map$2(chunks, (ch)=>`<div class="tox-collection__group">${ch.join('')}</div>`
            );
            set$6(comp.element, html.join(''));
        };
        const onClick = runOnItem((comp, se, tgt, itemValue)=>{
            se.stop();
            if (!providersBackstage.isDisabled()) emitWith(comp, formActionEvent, {
                name: spec.name,
                value: itemValue
            });
        });
        const collectionEvents = [
            run$1(mouseover(), runOnItem((comp, se, tgt)=>{
                focus$3(tgt);
            })),
            run$1(click(), onClick),
            run$1(tap(), onClick),
            run$1(focusin(), runOnItem((comp, se, tgt)=>{
                descendant(comp.element, '.' + activeClass).each((currentActive)=>{
                    remove$2(currentActive, activeClass);
                });
                add$2(tgt, activeClass);
            })),
            run$1(focusout(), runOnItem((comp)=>{
                descendant(comp.element, '.' + activeClass).each((currentActive)=>{
                    remove$2(currentActive, activeClass);
                });
            })),
            runOnExecute$1(runOnItem((comp, se, tgt, itemValue)=>{
                emitWith(comp, formActionEvent, {
                    name: spec.name,
                    value: itemValue
                });
            }))
        ];
        const iterCollectionItems = (comp, applyAttributes)=>map$2(descendants(comp.element, '.tox-collection__item'), applyAttributes)
        ;
        const pField = FormField.parts.field({
            dom: {
                tag: 'div',
                classes: [
                    'tox-collection'
                ].concat(spec.columns !== 1 ? [
                    'tox-collection--grid'
                ] : [
                    'tox-collection--list'
                ])
            },
            components: [],
            factory: {
                sketch: identity
            },
            behaviours: derive$1([
                Disabling.config({
                    disabled: providersBackstage.isDisabled,
                    onDisabled: (comp)=>{
                        iterCollectionItems(comp, (childElm)=>{
                            add$2(childElm, 'tox-collection__item--state-disabled');
                            set$9(childElm, 'aria-disabled', true);
                        });
                    },
                    onEnabled: (comp)=>{
                        iterCollectionItems(comp, (childElm)=>{
                            remove$2(childElm, 'tox-collection__item--state-disabled');
                            remove$7(childElm, 'aria-disabled');
                        });
                    }
                }),
                receivingConfig(),
                Replacing.config({}),
                Representing.config({
                    store: {
                        mode: 'memory',
                        initialValue: initialData.getOr([])
                    },
                    onSetValue: (comp, items)=>{
                        setContents(comp, items);
                        if (spec.columns === 'auto') detectSize(comp, 5, 'tox-collection__item').each(({ numRows , numColumns  })=>{
                            Keying.setGridSize(comp, numRows, numColumns);
                        });
                        emit(comp, formResizeEvent);
                    }
                }),
                Tabstopping.config({}),
                Keying.config(deriveCollectionMovement(spec.columns, 'normal')),
                config1('collection-events', collectionEvents)
            ]),
            eventOrder: {
                [execute$5()]: [
                    'disabling',
                    'alloy.base.behaviour',
                    'collection-events'
                ]
            }
        });
        const extraClasses = [
            'tox-form__group--collection'
        ];
        return renderFormFieldWith(pLabel, pField, extraClasses, []);
    };
    const schema$k = constant$1([
        option$3('data'),
        defaulted('inputAttributes', {}),
        defaulted('inputStyles', {}),
        defaulted('tag', 'input'),
        defaulted('inputClasses', []),
        onHandler('onSetValue'),
        defaulted('styles', {}),
        defaulted('eventOrder', {}),
        field1('inputBehaviours', [
            Representing,
            Focusing
        ]),
        defaulted('selectOnFocus', true)
    ]);
    const focusBehaviours = (detail)=>derive$1([
            Focusing.config({
                onFocus: !detail.selectOnFocus ? noop : (component)=>{
                    const input = component.element;
                    const value = get$6(input);
                    input.dom.setSelectionRange(0, value.length);
                }
            })
        ])
    ;
    const behaviours1 = (detail)=>({
            ...focusBehaviours(detail),
            ...augment(detail.inputBehaviours, [
                Representing.config({
                    store: {
                        mode: 'manual',
                        ...detail.data.map((data)=>({
                                initialValue: data
                            })
                        ).getOr({}),
                        getValue: (input)=>{
                            return get$6(input.element);
                        },
                        setValue: (input, data)=>{
                            const current = get$6(input.element);
                            if (current !== data) set$5(input.element, data);
                        }
                    },
                    onSetValue: detail.onSetValue
                })
            ])
        })
    ;
    const dom1 = (detail)=>({
            tag: detail.tag,
            attributes: {
                type: 'text',
                ...detail.inputAttributes
            },
            styles: detail.inputStyles,
            classes: detail.inputClasses
        })
    ;
    const factory$h = (detail, _spec)=>({
            uid: detail.uid,
            dom: dom1(detail),
            components: [],
            behaviours: behaviours1(detail),
            eventOrder: detail.eventOrder
        })
    ;
    const Input = single({
        name: 'Input',
        configFields: schema$k(),
        factory: factory$h
    });
    const nu$3 = (baseFn)=>{
        let data1 = Optional.none();
        let callbacks = [];
        const map = (f)=>nu$3((nCallback)=>{
                get((data)=>{
                    nCallback(f(data));
                });
            })
        ;
        const get = (nCallback)=>{
            if (isReady()) call(nCallback);
            else callbacks.push(nCallback);
        };
        const set = (x)=>{
            if (!isReady()) {
                data1 = Optional.some(x);
                run(callbacks);
                callbacks = [];
            }
        };
        const isReady = ()=>data1.isSome()
        ;
        const run = (cbs)=>{
            each$1(cbs, call);
        };
        const call = (cb)=>{
            data1.each((x)=>{
                setTimeout(()=>{
                    cb(x);
                }, 0);
            });
        };
        baseFn(set);
        return {
            get,
            map,
            isReady
        };
    };
    const pure$1 = (a)=>nu$3((callback)=>{
            callback(a);
        })
    ;
    const LazyValue = {
        nu: nu$3,
        pure: pure$1
    };
    const errorReporter = (err)=>{
        setTimeout(()=>{
            throw err;
        }, 0);
    };
    const make$5 = (run)=>{
        const get = (callback)=>{
            run().then(callback, errorReporter);
        };
        const map = (fab)=>{
            return make$5(()=>run().then(fab)
            );
        };
        const bind = (aFutureB)=>{
            return make$5(()=>run().then((v)=>aFutureB(v).toPromise()
                )
            );
        };
        const anonBind = (futureB)=>{
            return make$5(()=>run().then(()=>futureB.toPromise()
                )
            );
        };
        const toLazy = ()=>{
            return LazyValue.nu(get);
        };
        const toCached = ()=>{
            let cache = null;
            return make$5(()=>{
                if (cache === null) cache = run();
                return cache;
            });
        };
        const toPromise = run;
        return {
            map,
            bind,
            anonBind,
            toLazy,
            toCached,
            toPromise,
            get
        };
    };
    const nu$2 = (baseFn)=>{
        return make$5(()=>new Promise(baseFn)
        );
    };
    const pure = (a)=>{
        return make$5(()=>Promise.resolve(a)
        );
    };
    const Future = {
        nu: nu$2,
        pure
    };
    const ariaElements = [
        'input',
        'textarea'
    ];
    const isAriaElement = (elem)=>{
        const name = name$3(elem);
        return contains$2(ariaElements, name);
    };
    const markValid = (component, invalidConfig)=>{
        const elem = invalidConfig.getRoot(component).getOr(component.element);
        remove$2(elem, invalidConfig.invalidClass);
        invalidConfig.notify.each((notifyInfo)=>{
            if (isAriaElement(component.element)) set$9(component.element, 'aria-invalid', false);
            notifyInfo.getContainer(component).each((container)=>{
                set$6(container, notifyInfo.validHtml);
            });
            notifyInfo.onValid(component);
        });
    };
    const markInvalid = (component, invalidConfig, invalidState, text)=>{
        const elem = invalidConfig.getRoot(component).getOr(component.element);
        add$2(elem, invalidConfig.invalidClass);
        invalidConfig.notify.each((notifyInfo)=>{
            if (isAriaElement(component.element)) set$9(component.element, 'aria-invalid', true);
            notifyInfo.getContainer(component).each((container)=>{
                set$6(container, text);
            });
            notifyInfo.onInvalid(component, text);
        });
    };
    const query1 = (component, invalidConfig, _invalidState)=>invalidConfig.validator.fold(()=>Future.pure(Result.value(true))
        , (validatorInfo)=>validatorInfo.validate(component)
        )
    ;
    const run1 = (component, invalidConfig, invalidState)=>{
        invalidConfig.notify.each((notifyInfo)=>{
            notifyInfo.onValidate(component);
        });
        return query1(component, invalidConfig).map((valid)=>{
            if (component.getSystem().isConnected()) return valid.fold((err)=>{
                markInvalid(component, invalidConfig, invalidState, err);
                return Result.error(err);
            }, (v)=>{
                markValid(component, invalidConfig);
                return Result.value(v);
            });
            else return Result.error('No longer in system');
        });
    };
    const isInvalid = (component, invalidConfig)=>{
        const elem = invalidConfig.getRoot(component).getOr(component.element);
        return has(elem, invalidConfig.invalidClass);
    };
    var InvalidateApis = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        markValid: markValid,
        markInvalid: markInvalid,
        query: query1,
        run: run1,
        isInvalid: isInvalid
    });
    const events$8 = (invalidConfig, invalidState)=>invalidConfig.validator.map((validatorInfo)=>derive$2([
                run$1(validatorInfo.onEvent, (component)=>{
                    run1(component, invalidConfig, invalidState).get(identity);
                })
            ].concat(validatorInfo.validateOnLoad ? [
                runOnAttached((component)=>{
                    run1(component, invalidConfig, invalidState).get(noop);
                })
            ] : []))
        ).getOr({})
    ;
    var ActiveInvalidate = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        events: events$8
    });
    var InvalidateSchema = [
        required$1('invalidClass'),
        defaulted('getRoot', Optional.none),
        optionObjOf('notify', [
            defaulted('aria', 'alert'),
            defaulted('getContainer', Optional.none),
            defaulted('validHtml', ''),
            onHandler('onValid'),
            onHandler('onInvalid'),
            onHandler('onValidate')
        ]),
        optionObjOf('validator', [
            required$1('validate'),
            defaulted('onEvent', 'input'),
            defaulted('validateOnLoad', true)
        ])
    ];
    const Invalidating = create$3({
        fields: InvalidateSchema,
        name: 'invalidating',
        active: ActiveInvalidate,
        apis: InvalidateApis,
        extra: {
            validation: (validator)=>{
                return (component)=>{
                    const v = Representing.getValue(component);
                    return Future.pure(validator(v));
                };
            }
        }
    });
    const getCoupled = (component, coupleConfig, coupleState, name)=>coupleState.getOrCreate(component, coupleConfig, name)
    ;
    var CouplingApis = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        getCoupled: getCoupled
    });
    var CouplingSchema = [
        requiredOf('others', setOf(Result.value, anyValue()))
    ];
    const init$a = ()=>{
        const coupled = {};
        const getOrCreate = (component, coupleConfig, name)=>{
            const available = keys1(coupleConfig.others);
            if (!available) throw new Error('Cannot find coupled component: ' + name + '. Known coupled components: ' + JSON.stringify(available, null, 2));
            else return get$g(coupled, name).getOrThunk(()=>{
                const builder = get$g(coupleConfig.others, name).getOrDie('No information found for coupled component: ' + name);
                const spec = builder(component);
                const built = component.getSystem().build(spec);
                coupled[name] = built;
                return built;
            });
        };
        const readState = constant$1({});
        return nu$8({
            readState,
            getOrCreate
        });
    };
    var CouplingState = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        init: init$a
    });
    const Coupling = create$3({
        fields: CouplingSchema,
        name: 'coupling',
        apis: CouplingApis,
        state: CouplingState
    });
    const suffix1 = constant$1('sink');
    const partType$1 = constant$1(optional1({
        name: suffix1(),
        overrides: constant$1({
            dom: {
                tag: 'div'
            },
            behaviours: derive$1([
                Positioning.config({
                    useFixed: always
                })
            ]),
            events: derive$2([
                cutter1(keydown()),
                cutter1(mousedown()),
                cutter1(click())
            ])
        })
    }));
    var HighlightOnOpen1;
    (function(HighlightOnOpen) {
        HighlightOnOpen[HighlightOnOpen['HighlightFirst'] = 0] = 'HighlightFirst';
        HighlightOnOpen[HighlightOnOpen['HighlightNone'] = 1] = 'HighlightNone';
    })(HighlightOnOpen1 || (HighlightOnOpen1 = {}));
    const getAnchor1 = (detail, component)=>{
        const hotspot = detail.getHotspot(component).getOr(component);
        const type = 'hotspot';
        const overrides = detail.getAnchorOverrides();
        return detail.layouts.fold(()=>({
                type,
                hotspot,
                overrides
            })
        , (layouts)=>({
                type,
                hotspot,
                overrides,
                layouts
            })
        );
    };
    const fetch = (detail, mapFetch, component)=>{
        const fetcher = detail.fetch;
        return fetcher(component).map(mapFetch);
    };
    const openF = (detail, mapFetch, anchor, component, sandbox, externals, highlightOnOpen)=>{
        const futureData = fetch(detail, mapFetch, component);
        const getLazySink = getSink1(component, detail);
        return futureData.map((tdata)=>tdata.bind((data)=>Optional.from(tieredMenu.sketch({
                    ...externals.menu(),
                    uid: generate$5(''),
                    data,
                    highlightImmediately: highlightOnOpen === HighlightOnOpen1.HighlightFirst,
                    onOpenMenu: (tmenu, menu)=>{
                        const sink = getLazySink().getOrDie();
                        Positioning.position(sink, menu, {
                            anchor
                        });
                        Sandboxing.decloak(sandbox);
                    },
                    onOpenSubmenu: (tmenu, item, submenu)=>{
                        const sink = getLazySink().getOrDie();
                        Positioning.position(sink, submenu, {
                            anchor: {
                                type: 'submenu',
                                item
                            }
                        });
                        Sandboxing.decloak(sandbox);
                    },
                    onRepositionMenu: (tmenu, primaryMenu, submenuTriggers)=>{
                        const sink = getLazySink().getOrDie();
                        Positioning.position(sink, primaryMenu, {
                            anchor
                        });
                        each$1(submenuTriggers, (st)=>{
                            Positioning.position(sink, st.triggeredMenu, {
                                anchor: {
                                    type: 'submenu',
                                    item: st.triggeringItem
                                }
                            });
                        });
                    },
                    onEscape: ()=>{
                        Focusing.focus(component);
                        Sandboxing.close(sandbox);
                        return Optional.some(true);
                    }
                }))
            )
        );
    };
    const open1 = (detail, mapFetch, hotspot, sandbox, externals, onOpenSync, highlightOnOpen)=>{
        const anchor = getAnchor1(detail, hotspot);
        const processed = openF(detail, mapFetch, anchor, hotspot, sandbox, externals, highlightOnOpen);
        return processed.map((tdata)=>{
            tdata.fold(()=>{
                if (Sandboxing.isOpen(sandbox)) Sandboxing.close(sandbox);
            }, (data)=>{
                Sandboxing.cloak(sandbox);
                Sandboxing.open(sandbox, data);
                onOpenSync(sandbox);
            });
            return sandbox;
        });
    };
    const close1 = (detail, mapFetch, component, sandbox, _externals, _onOpenSync, _highlightOnOpen)=>{
        Sandboxing.close(sandbox);
        return Future.pure(sandbox);
    };
    const togglePopup = (detail, mapFetch, hotspot, externals, onOpenSync, highlightOnOpen)=>{
        const sandbox = Coupling.getCoupled(hotspot, 'sandbox');
        const showing = Sandboxing.isOpen(sandbox);
        const action = showing ? close1 : open1;
        return action(detail, mapFetch, hotspot, sandbox, externals, onOpenSync, highlightOnOpen);
    };
    const matchWidth = (hotspot, container, useMinWidth)=>{
        const menu = Composing.getCurrent(container).getOr(container);
        const buttonWidth = get$c(hotspot.element);
        if (useMinWidth) set$8(menu.element, 'min-width', buttonWidth + 'px');
        else set$7(menu.element, buttonWidth);
    };
    const getSink1 = (anyInSystem, sinkDetail)=>anyInSystem.getSystem().getByUid(sinkDetail.uid + '-' + suffix1()).map((internalSink)=>()=>Result.value(internalSink)
        ).getOrThunk(()=>sinkDetail.lazySink.fold(()=>()=>Result.error(new Error('No internal sink is specified, nor could an external sink be found'))
            , (lazySinkFn)=>()=>lazySinkFn(anyInSystem)
            )
        )
    ;
    const doRepositionMenus = (sandbox)=>{
        Sandboxing.getState(sandbox).each((tmenu)=>{
            tieredMenu.repositionMenus(tmenu);
        });
    };
    const makeSandbox$1 = (detail, hotspot, extras)=>{
        const ariaControls = manager();
        const onOpen = (component, menu)=>{
            const anchor = getAnchor1(detail, hotspot);
            ariaControls.link(hotspot.element);
            if (detail.matchWidth) matchWidth(anchor.hotspot, menu, detail.useMinWidth);
            detail.onOpen(anchor, component, menu);
            if (extras !== undefined && extras.onOpen !== undefined) extras.onOpen(component, menu);
        };
        const onClose = (component, menu)=>{
            ariaControls.unlink(hotspot.element);
            if (extras !== undefined && extras.onClose !== undefined) extras.onClose(component, menu);
        };
        const lazySink = getSink1(hotspot, detail);
        return {
            dom: {
                tag: 'div',
                classes: detail.sandboxClasses,
                attributes: {
                    id: ariaControls.id,
                    role: 'listbox'
                }
            },
            behaviours: SketchBehaviours.augment(detail.sandboxBehaviours, [
                Representing.config({
                    store: {
                        mode: 'memory',
                        initialValue: hotspot
                    }
                }),
                Sandboxing.config({
                    onOpen,
                    onClose,
                    isPartOf: (container, data, queryElem)=>{
                        return isPartOf$1(data, queryElem) || isPartOf$1(hotspot, queryElem);
                    },
                    getAttachPoint: ()=>{
                        return lazySink().getOrDie();
                    }
                }),
                Composing.config({
                    find: (sandbox)=>{
                        return Sandboxing.getState(sandbox).bind((menu)=>Composing.getCurrent(menu)
                        );
                    }
                }),
                Receiving.config({
                    channels: {
                        ...receivingChannel$1({
                            isExtraPart: never
                        }),
                        ...receivingChannel({
                            doReposition: doRepositionMenus
                        })
                    }
                })
            ])
        };
    };
    const repositionMenus1 = (comp)=>{
        const sandbox = Coupling.getCoupled(comp, 'sandbox');
        doRepositionMenus(sandbox);
    };
    const sandboxFields = ()=>[
            defaulted('sandboxClasses', []),
            SketchBehaviours.field('sandboxBehaviours', [
                Composing,
                Receiving,
                Sandboxing,
                Representing
            ])
        ]
    ;
    const schema$j = constant$1([
        required$1('dom'),
        required$1('fetch'),
        onHandler('onOpen'),
        onKeyboardHandler('onExecute'),
        defaulted('getHotspot', Optional.some),
        defaulted('getAnchorOverrides', constant$1({})),
        schema$y(),
        field1('dropdownBehaviours', [
            Toggling,
            Coupling,
            Keying,
            Focusing
        ]),
        required$1('toggleClass'),
        defaulted('eventOrder', {}),
        option$3('lazySink'),
        defaulted('matchWidth', false),
        defaulted('useMinWidth', false),
        option$3('role')
    ].concat(sandboxFields()));
    const parts$d = constant$1([
        external({
            schema: [
                tieredMenuMarkers()
            ],
            name: 'menu',
            defaults: (detail)=>{
                return {
                    onExecute: detail.onExecute
                };
            }
        }),
        partType$1()
    ]);
    const factory$g = (detail, components, _spec, externals)=>{
        const lookupAttr = (attr)=>get$g(detail.dom, 'attributes').bind((attrs)=>get$g(attrs, attr)
            )
        ;
        const switchToMenu = (sandbox)=>{
            Sandboxing.getState(sandbox).each((tmenu)=>{
                tieredMenu.highlightPrimary(tmenu);
            });
        };
        const action = (component)=>{
            const onOpenSync = switchToMenu;
            togglePopup(detail, identity, component, externals, onOpenSync, HighlightOnOpen1.HighlightFirst).get(noop);
        };
        const apis = {
            expand: (comp)=>{
                if (!Toggling.isOn(comp)) togglePopup(detail, identity, comp, externals, noop, HighlightOnOpen1.HighlightNone).get(noop);
            },
            open: (comp)=>{
                if (!Toggling.isOn(comp)) togglePopup(detail, identity, comp, externals, noop, HighlightOnOpen1.HighlightFirst).get(noop);
            },
            isOpen: Toggling.isOn,
            close: (comp)=>{
                if (Toggling.isOn(comp)) togglePopup(detail, identity, comp, externals, noop, HighlightOnOpen1.HighlightFirst).get(noop);
            },
            repositionMenus: (comp)=>{
                if (Toggling.isOn(comp)) repositionMenus1(comp);
            }
        };
        const triggerExecute = (comp, _se)=>{
            emitExecute1(comp);
            return Optional.some(true);
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: augment(detail.dropdownBehaviours, [
                Toggling.config({
                    toggleClass: detail.toggleClass,
                    aria: {
                        mode: 'expanded'
                    }
                }),
                Coupling.config({
                    others: {
                        sandbox: (hotspot)=>{
                            return makeSandbox$1(detail, hotspot, {
                                onOpen: ()=>Toggling.on(hotspot)
                                ,
                                onClose: ()=>Toggling.off(hotspot)
                            });
                        }
                    }
                }),
                Keying.config({
                    mode: 'special',
                    onSpace: triggerExecute,
                    onEnter: triggerExecute,
                    onDown: (comp, _se)=>{
                        if (Dropdown.isOpen(comp)) {
                            const sandbox = Coupling.getCoupled(comp, 'sandbox');
                            switchToMenu(sandbox);
                        } else Dropdown.open(comp);
                        return Optional.some(true);
                    },
                    onEscape: (comp, _se)=>{
                        if (Dropdown.isOpen(comp)) {
                            Dropdown.close(comp);
                            return Optional.some(true);
                        } else return Optional.none();
                    }
                }),
                Focusing.config({})
            ]),
            events: events$a(Optional.some(action)),
            eventOrder: {
                ...detail.eventOrder,
                [execute$5()]: [
                    'disabling',
                    'toggling',
                    'alloy.base.behaviour'
                ]
            },
            apis,
            domModification: {
                attributes: {
                    'aria-haspopup': 'true',
                    ...detail.role.fold(()=>({})
                    , (role)=>({
                            role
                        })
                    ),
                    ...detail.dom.tag === 'button' ? {
                        type: lookupAttr('type').getOr('button')
                    } : {}
                }
            }
        };
    };
    const Dropdown = composite({
        name: 'Dropdown',
        configFields: schema$j(),
        partFields: parts$d(),
        factory: factory$g,
        apis: {
            open: (apis, comp)=>apis.open(comp)
            ,
            expand: (apis, comp)=>apis.expand(comp)
            ,
            close: (apis, comp)=>apis.close(comp)
            ,
            isOpen: (apis, comp)=>apis.isOpen(comp)
            ,
            repositionMenus: (apis, comp)=>apis.repositionMenus(comp)
        }
    });
    const exhibit$1 = ()=>nu$7({
            styles: {
                '-webkit-user-select': 'none',
                'user-select': 'none',
                '-ms-user-select': 'none',
                '-moz-user-select': '-moz-none'
            },
            attributes: {
                unselectable: 'on'
            }
        })
    ;
    const events$7 = ()=>derive$2([
            abort1(selectstart(), always)
        ])
    ;
    var ActiveUnselecting = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        events: events$7,
        exhibit: exhibit$1
    });
    const Unselecting = create$3({
        fields: [],
        name: 'unselecting',
        active: ActiveUnselecting
    });
    const renderPanelButton = (spec, sharedBackstage)=>Dropdown.sketch({
            dom: spec.dom,
            components: spec.components,
            toggleClass: 'mce-active',
            dropdownBehaviours: derive$1([
                DisablingConfigs.button(sharedBackstage.providers.isDisabled),
                receivingConfig(),
                Unselecting.config({}),
                Tabstopping.config({})
            ]),
            layouts: spec.layouts,
            sandboxClasses: [
                'tox-dialog__popups'
            ],
            lazySink: sharedBackstage.getSink,
            fetch: (comp)=>Future.nu((callback)=>spec.fetch(callback)
                ).map((items)=>Optional.from(createTieredDataFrom(deepMerge(createPartialChoiceMenu(generate$6('menu-value'), items, (value)=>{
                        spec.onItemAction(comp, value);
                    }, spec.columns, spec.presets, ItemResponse$1.CLOSE_ON_EXECUTE, never, sharedBackstage.providers), {
                        movement: deriveMenuMovement(spec.columns, spec.presets)
                    })))
                )
            ,
            parts: {
                menu: part1(false, 1, spec.presets)
            }
        })
    ;
    const colorInputChangeEvent = generate$6('color-input-change');
    const colorSwatchChangeEvent = generate$6('color-swatch-change');
    const colorPickerCancelEvent = generate$6('color-picker-cancel');
    const renderColorInput = (spec, sharedBackstage, colorInputBackstage, initialData)=>{
        const pField = FormField.parts.field({
            factory: Input,
            inputClasses: [
                'tox-textfield'
            ],
            data: initialData,
            onSetValue: (c)=>Invalidating.run(c).get(noop)
            ,
            inputBehaviours: derive$1([
                Disabling.config({
                    disabled: sharedBackstage.providers.isDisabled
                }),
                receivingConfig(),
                Tabstopping.config({}),
                Invalidating.config({
                    invalidClass: 'tox-textbox-field-invalid',
                    getRoot: (comp)=>parentElement(comp.element)
                    ,
                    notify: {
                        onValid: (comp)=>{
                            const val = Representing.getValue(comp);
                            emitWith(comp, colorInputChangeEvent, {
                                color: val
                            });
                        }
                    },
                    validator: {
                        validateOnLoad: false,
                        validate: (input)=>{
                            const inputValue = Representing.getValue(input);
                            if (inputValue.length === 0) return Future.pure(Result.value(true));
                            else {
                                const span = SugarElement.fromTag('span');
                                set$8(span, 'background-color', inputValue);
                                const res = getRaw(span, 'background-color').fold(()=>Result.error('blah')
                                , (_)=>Result.value(inputValue)
                                );
                                return Future.pure(res);
                            }
                        }
                    }
                })
            ]),
            selectOnFocus: false
        });
        const pLabel = spec.label.map((label)=>renderLabel$2(label, sharedBackstage.providers)
        );
        const emitSwatchChange = (colorBit, value)=>{
            emitWith(colorBit, colorSwatchChangeEvent, {
                value
            });
        };
        const onItemAction = (comp, value2)=>{
            memColorButton.getOpt(comp).each((colorBit)=>{
                if (value2 === 'custom') colorInputBackstage.colorPicker((valueOpt)=>{
                    valueOpt.fold(()=>emit(colorBit, colorPickerCancelEvent)
                    , (value)=>{
                        emitSwatchChange(colorBit, value);
                        addColor(value);
                    });
                }, '#ffffff');
                else if (value2 === 'remove') emitSwatchChange(colorBit, '');
                else emitSwatchChange(colorBit, value2);
            });
        };
        const memColorButton = record1(renderPanelButton({
            dom: {
                tag: 'span',
                attributes: {
                    'aria-label': sharedBackstage.providers.translate('Color swatch')
                }
            },
            layouts: {
                onRtl: ()=>[
                        southwest$2,
                        southeast$2,
                        south$2
                    ]
                ,
                onLtr: ()=>[
                        southeast$2,
                        southwest$2,
                        south$2
                    ]
            },
            components: [],
            fetch: getFetch$1(colorInputBackstage.getColors(), colorInputBackstage.hasCustomColors()),
            columns: colorInputBackstage.getColorCols(),
            presets: 'color',
            onItemAction
        }, sharedBackstage));
        return FormField.sketch({
            dom: {
                tag: 'div',
                classes: [
                    'tox-form__group'
                ]
            },
            components: pLabel.toArray().concat([
                {
                    dom: {
                        tag: 'div',
                        classes: [
                            'tox-color-input'
                        ]
                    },
                    components: [
                        pField,
                        memColorButton.asSpec()
                    ]
                }
            ]),
            fieldBehaviours: derive$1([
                config1('form-field-events', [
                    run$1(colorInputChangeEvent, (comp, se)=>{
                        memColorButton.getOpt(comp).each((colorButton)=>{
                            set$8(colorButton.element, 'background-color', se.event.color);
                        });
                        emitWith(comp, formChangeEvent, {
                            name: spec.name
                        });
                    }),
                    run$1(colorSwatchChangeEvent, (comp, se)=>{
                        FormField.getField(comp).each((field)=>{
                            Representing.setValue(field, se.event.value);
                            Composing.getCurrent(comp).each(Focusing.focus);
                        });
                    }),
                    run$1(colorPickerCancelEvent, (comp, _se)=>{
                        FormField.getField(comp).each((_field)=>{
                            Composing.getCurrent(comp).each(Focusing.focus);
                        });
                    })
                ])
            ])
        });
    };
    const labelPart1 = optional1({
        schema: [
            required$1('dom')
        ],
        name: 'label'
    });
    const edgePart = (name)=>optional1({
            name: '' + name + '-edge',
            overrides: (detail)=>{
                const action = detail.model.manager.edgeActions[name];
                return action.fold(()=>({})
                , (a)=>({
                        events: derive$2([
                            runActionExtra(touchstart(), (comp, se, d)=>a(comp, d)
                            , [
                                detail
                            ]),
                            runActionExtra(mousedown(), (comp, se, d)=>a(comp, d)
                            , [
                                detail
                            ]),
                            runActionExtra(mousemove(), (comp, se, det)=>{
                                if (det.mouseIsDown.get()) a(comp, det);
                            }, [
                                detail
                            ])
                        ])
                    })
                );
            }
        })
    ;
    const tlEdgePart = edgePart('top-left');
    const tedgePart = edgePart('top');
    const trEdgePart = edgePart('top-right');
    const redgePart = edgePart('right');
    const brEdgePart = edgePart('bottom-right');
    const bedgePart = edgePart('bottom');
    const blEdgePart = edgePart('bottom-left');
    const ledgePart = edgePart('left');
    const thumbPart1 = required1({
        name: 'thumb',
        defaults: constant$1({
            dom: {
                styles: {
                    position: 'absolute'
                }
            }
        }),
        overrides: (detail)=>{
            return {
                events: derive$2([
                    redirectToPart(touchstart(), detail, 'spectrum'),
                    redirectToPart(touchmove(), detail, 'spectrum'),
                    redirectToPart(touchend(), detail, 'spectrum'),
                    redirectToPart(mousedown(), detail, 'spectrum'),
                    redirectToPart(mousemove(), detail, 'spectrum'),
                    redirectToPart(mouseup(), detail, 'spectrum')
                ])
            };
        }
    });
    const spectrumPart1 = required1({
        schema: [
            customField('mouseIsDown', ()=>Cell(false)
            )
        ],
        name: 'spectrum',
        overrides: (detail)=>{
            const modelDetail = detail.model;
            const model = modelDetail.manager;
            const setValueFrom = (component, simulatedEvent)=>model.getValueFromEvent(simulatedEvent).map((value)=>model.setValueFrom(component, detail, value)
                )
            ;
            return {
                behaviours: derive$1([
                    Keying.config({
                        mode: 'special',
                        onLeft: (spectrum)=>model.onLeft(spectrum, detail)
                        ,
                        onRight: (spectrum)=>model.onRight(spectrum, detail)
                        ,
                        onUp: (spectrum)=>model.onUp(spectrum, detail)
                        ,
                        onDown: (spectrum)=>model.onDown(spectrum, detail)
                    }),
                    Focusing.config({})
                ]),
                events: derive$2([
                    run$1(touchstart(), setValueFrom),
                    run$1(touchmove(), setValueFrom),
                    run$1(mousedown(), setValueFrom),
                    run$1(mousemove(), (spectrum, se)=>{
                        if (detail.mouseIsDown.get()) setValueFrom(spectrum, se);
                    })
                ])
            };
        }
    });
    var SliderParts = [
        labelPart1,
        ledgePart,
        redgePart,
        tedgePart,
        bedgePart,
        tlEdgePart,
        trEdgePart,
        blEdgePart,
        brEdgePart,
        thumbPart1,
        spectrumPart1
    ];
    const _sliderChangeEvent = 'slider.change.value';
    const sliderChangeEvent = constant$1(_sliderChangeEvent);
    const isTouchEvent$1 = (evt)=>evt.type.indexOf('touch') !== -1
    ;
    const getEventSource = (simulatedEvent)=>{
        const evt = simulatedEvent.event.raw;
        if (isTouchEvent$1(evt)) {
            const touchEvent = evt;
            return touchEvent.touches !== undefined && touchEvent.touches.length === 1 ? Optional.some(touchEvent.touches[0]).map((t)=>SugarPosition(t.clientX, t.clientY)
            ) : Optional.none();
        } else {
            const mouseEvent = evt;
            return mouseEvent.clientX !== undefined ? Optional.some(mouseEvent).map((me)=>SugarPosition(me.clientX, me.clientY)
            ) : Optional.none();
        }
    };
    const t1 = 'top', r1 = 'right', b1 = 'bottom', l1 = 'left';
    const minX = (detail)=>detail.model.minX
    ;
    const minY = (detail)=>detail.model.minY
    ;
    const min1X = (detail)=>detail.model.minX - 1
    ;
    const min1Y = (detail)=>detail.model.minY - 1
    ;
    const maxX1 = (detail)=>detail.model.maxX
    ;
    const maxY1 = (detail)=>detail.model.maxY
    ;
    const max1X = (detail)=>detail.model.maxX + 1
    ;
    const max1Y = (detail)=>detail.model.maxY + 1
    ;
    const range1 = (detail, max, min)=>max(detail) - min(detail)
    ;
    const xRange1 = (detail)=>range1(detail, maxX1, minX)
    ;
    const yRange1 = (detail)=>range1(detail, maxY1, minY)
    ;
    const halfX = (detail)=>xRange1(detail) / 2
    ;
    const halfY = (detail)=>yRange1(detail) / 2
    ;
    const step1 = (detail)=>detail.stepSize
    ;
    const snap1 = (detail)=>detail.snapToGrid
    ;
    const snapStart1 = (detail)=>detail.snapStart
    ;
    const rounded1 = (detail)=>detail.rounded
    ;
    const hasEdge = (detail, edgeName)=>detail[edgeName + '-edge'] !== undefined
    ;
    const hasLEdge = (detail)=>hasEdge(detail, l1)
    ;
    const hasREdge = (detail)=>hasEdge(detail, r1)
    ;
    const hasTEdge = (detail)=>hasEdge(detail, t1)
    ;
    const hasBEdge = (detail)=>hasEdge(detail, b1)
    ;
    const currentValue1 = (detail)=>detail.model.value.get()
    ;
    const xyValue = (x, y)=>({
            x,
            y
        })
    ;
    const fireSliderChange$3 = (component, value)=>{
        emitWith(component, sliderChangeEvent(), {
            value
        });
    };
    const setToTLEdgeXY = (edge, detail)=>{
        fireSliderChange$3(edge, xyValue(min1X(detail), min1Y(detail)));
    };
    const setToTEdge = (edge, detail)=>{
        fireSliderChange$3(edge, min1Y(detail));
    };
    const setToTEdgeXY = (edge, detail)=>{
        fireSliderChange$3(edge, xyValue(halfX(detail), min1Y(detail)));
    };
    const setToTREdgeXY = (edge, detail)=>{
        fireSliderChange$3(edge, xyValue(max1X(detail), min1Y(detail)));
    };
    const setToREdge = (edge, detail)=>{
        fireSliderChange$3(edge, max1X(detail));
    };
    const setToREdgeXY = (edge, detail)=>{
        fireSliderChange$3(edge, xyValue(max1X(detail), halfY(detail)));
    };
    const setToBREdgeXY = (edge, detail)=>{
        fireSliderChange$3(edge, xyValue(max1X(detail), max1Y(detail)));
    };
    const setToBEdge = (edge, detail)=>{
        fireSliderChange$3(edge, max1Y(detail));
    };
    const setToBEdgeXY = (edge, detail)=>{
        fireSliderChange$3(edge, xyValue(halfX(detail), max1Y(detail)));
    };
    const setToBLEdgeXY = (edge, detail)=>{
        fireSliderChange$3(edge, xyValue(min1X(detail), max1Y(detail)));
    };
    const setToLEdge = (edge, detail)=>{
        fireSliderChange$3(edge, min1X(detail));
    };
    const setToLEdgeXY = (edge, detail)=>{
        fireSliderChange$3(edge, xyValue(min1X(detail), halfY(detail)));
    };
    const reduceBy = (value, min, max, step)=>{
        if (value < min) return value;
        else if (value > max) return max;
        else if (value === min) return min - 1;
        else return Math.max(min, value - step);
    };
    const increaseBy = (value, min, max, step)=>{
        if (value > max) return value;
        else if (value < min) return min;
        else if (value === max) return max + 1;
        else return Math.min(max, value + step);
    };
    const capValue = (value, min, max)=>Math.max(min, Math.min(max, value))
    ;
    const snapValueOf = (value, min, max, step, snapStart)=>snapStart.fold(()=>{
            const initValue = value - min;
            const extraValue = Math.round(initValue / step) * step;
            return capValue(min + extraValue, min - 1, max + 1);
        }, (start)=>{
            const remainder = (value - start) % step;
            const adjustment = Math.round(remainder / step);
            const rawSteps = Math.floor((value - start) / step);
            const maxSteps = Math.floor((max - start) / step);
            const numSteps = Math.min(maxSteps, rawSteps + adjustment);
            const r = start + numSteps * step;
            return Math.max(start, r);
        })
    ;
    const findOffsetOf = (value, min, max)=>Math.min(max, Math.max(value, min)) - min
    ;
    const findValueOf = (args)=>{
        const { min , max , range , value , step , snap , snapStart , rounded , hasMinEdge , hasMaxEdge , minBound , maxBound , screenRange  } = args;
        const capMin = hasMinEdge ? min - 1 : min;
        const capMax = hasMaxEdge ? max + 1 : max;
        if (value < minBound) return capMin;
        else if (value > maxBound) return capMax;
        else {
            const offset = findOffsetOf(value, minBound, maxBound);
            const newValue = capValue(offset / screenRange * range + min, capMin, capMax);
            if (snap && newValue >= min && newValue <= max) return snapValueOf(newValue, min, max, step, snapStart);
            else if (rounded) return Math.round(newValue);
            else return newValue;
        }
    };
    const findOffsetOfValue$2 = (args)=>{
        const { min , max , range , value , hasMinEdge , hasMaxEdge , maxBound , maxOffset , centerMinEdge , centerMaxEdge  } = args;
        if (value < min) return hasMinEdge ? 0 : centerMinEdge;
        else if (value > max) return hasMaxEdge ? maxBound : centerMaxEdge;
        else return (value - min) / range * maxOffset;
    };
    const top1 = 'top', right1 = 'right', bottom1 = 'bottom', left1 = 'left', width1 = 'width', height1 = 'height';
    const getBounds1 = (component)=>component.element.dom.getBoundingClientRect()
    ;
    const getBoundsProperty = (bounds, property)=>bounds[property]
    ;
    const getMinXBounds = (component)=>{
        const bounds = getBounds1(component);
        return getBoundsProperty(bounds, left1);
    };
    const getMaxXBounds = (component)=>{
        const bounds = getBounds1(component);
        return getBoundsProperty(bounds, right1);
    };
    const getMinYBounds = (component)=>{
        const bounds = getBounds1(component);
        return getBoundsProperty(bounds, top1);
    };
    const getMaxYBounds = (component)=>{
        const bounds = getBounds1(component);
        return getBoundsProperty(bounds, bottom1);
    };
    const getXScreenRange = (component)=>{
        const bounds = getBounds1(component);
        return getBoundsProperty(bounds, width1);
    };
    const getYScreenRange = (component)=>{
        const bounds = getBounds1(component);
        return getBoundsProperty(bounds, height1);
    };
    const getCenterOffsetOf = (componentMinEdge, componentMaxEdge, spectrumMinEdge)=>(componentMinEdge + componentMaxEdge) / 2 - spectrumMinEdge
    ;
    const getXCenterOffSetOf = (component, spectrum)=>{
        const componentBounds = getBounds1(component);
        const spectrumBounds = getBounds1(spectrum);
        const componentMinEdge = getBoundsProperty(componentBounds, left1);
        const componentMaxEdge = getBoundsProperty(componentBounds, right1);
        const spectrumMinEdge = getBoundsProperty(spectrumBounds, left1);
        return getCenterOffsetOf(componentMinEdge, componentMaxEdge, spectrumMinEdge);
    };
    const getYCenterOffSetOf = (component, spectrum)=>{
        const componentBounds = getBounds1(component);
        const spectrumBounds = getBounds1(spectrum);
        const componentMinEdge = getBoundsProperty(componentBounds, top1);
        const componentMaxEdge = getBoundsProperty(componentBounds, bottom1);
        const spectrumMinEdge = getBoundsProperty(spectrumBounds, top1);
        return getCenterOffsetOf(componentMinEdge, componentMaxEdge, spectrumMinEdge);
    };
    const fireSliderChange$2 = (spectrum, value)=>{
        emitWith(spectrum, sliderChangeEvent(), {
            value
        });
    };
    const findValueOfOffset$1 = (spectrum, detail, left)=>{
        const args = {
            min: minX(detail),
            max: maxX1(detail),
            range: xRange1(detail),
            value: left,
            step: step1(detail),
            snap: snap1(detail),
            snapStart: snapStart1(detail),
            rounded: rounded1(detail),
            hasMinEdge: hasLEdge(detail),
            hasMaxEdge: hasREdge(detail),
            minBound: getMinXBounds(spectrum),
            maxBound: getMaxXBounds(spectrum),
            screenRange: getXScreenRange(spectrum)
        };
        return findValueOf(args);
    };
    const setValueFrom$2 = (spectrum, detail, value)=>{
        const xValue = findValueOfOffset$1(spectrum, detail, value);
        const sliderVal = xValue;
        fireSliderChange$2(spectrum, sliderVal);
        return xValue;
    };
    const setToMin$2 = (spectrum, detail)=>{
        const min = minX(detail);
        fireSliderChange$2(spectrum, min);
    };
    const setToMax$2 = (spectrum, detail)=>{
        const max = maxX1(detail);
        fireSliderChange$2(spectrum, max);
    };
    const moveBy$2 = (direction, spectrum, detail)=>{
        const f = direction > 0 ? increaseBy : reduceBy;
        const xValue = f(currentValue1(detail), minX(detail), maxX1(detail), step1(detail));
        fireSliderChange$2(spectrum, xValue);
        return Optional.some(xValue);
    };
    const handleMovement$2 = (direction)=>(spectrum, detail)=>moveBy$2(direction, spectrum, detail).map(always)
    ;
    const getValueFromEvent$2 = (simulatedEvent)=>{
        const pos = getEventSource(simulatedEvent);
        return pos.map((p)=>p.left
        );
    };
    const findOffsetOfValue$1 = (spectrum, detail, value, minEdge, maxEdge)=>{
        const minOffset = 0;
        const maxOffset = getXScreenRange(spectrum);
        const centerMinEdge = minEdge.bind((edge)=>Optional.some(getXCenterOffSetOf(edge, spectrum))
        ).getOr(minOffset);
        const centerMaxEdge = maxEdge.bind((edge)=>Optional.some(getXCenterOffSetOf(edge, spectrum))
        ).getOr(maxOffset);
        const args = {
            min: minX(detail),
            max: maxX1(detail),
            range: xRange1(detail),
            value,
            hasMinEdge: hasLEdge(detail),
            hasMaxEdge: hasREdge(detail),
            minBound: getMinXBounds(spectrum),
            minOffset,
            maxBound: getMaxXBounds(spectrum),
            maxOffset,
            centerMinEdge,
            centerMaxEdge
        };
        return findOffsetOfValue$2(args);
    };
    const findPositionOfValue$1 = (slider, spectrum, value, minEdge, maxEdge, detail)=>{
        const offset = findOffsetOfValue$1(spectrum, detail, value, minEdge, maxEdge);
        return getMinXBounds(spectrum) - getMinXBounds(slider) + offset;
    };
    const setPositionFromValue$2 = (slider, thumb, detail, edges)=>{
        const value = currentValue1(detail);
        const pos = findPositionOfValue$1(slider, edges.getSpectrum(slider), value, edges.getLeftEdge(slider), edges.getRightEdge(slider), detail);
        const thumbRadius = get$c(thumb.element) / 2;
        set$8(thumb.element, 'left', pos - thumbRadius + 'px');
    };
    const onLeft$2 = handleMovement$2(-1);
    const onRight$2 = handleMovement$2(1);
    const onUp$2 = Optional.none;
    const onDown$2 = Optional.none;
    const edgeActions$2 = {
        'top-left': Optional.none(),
        'top': Optional.none(),
        'top-right': Optional.none(),
        'right': Optional.some(setToREdge),
        'bottom-right': Optional.none(),
        'bottom': Optional.none(),
        'bottom-left': Optional.none(),
        'left': Optional.some(setToLEdge)
    };
    var HorizontalModel = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        setValueFrom: setValueFrom$2,
        setToMin: setToMin$2,
        setToMax: setToMax$2,
        findValueOfOffset: findValueOfOffset$1,
        getValueFromEvent: getValueFromEvent$2,
        findPositionOfValue: findPositionOfValue$1,
        setPositionFromValue: setPositionFromValue$2,
        onLeft: onLeft$2,
        onRight: onRight$2,
        onUp: onUp$2,
        onDown: onDown$2,
        edgeActions: edgeActions$2
    });
    const fireSliderChange$1 = (spectrum, value)=>{
        emitWith(spectrum, sliderChangeEvent(), {
            value
        });
    };
    const findValueOfOffset = (spectrum, detail, top)=>{
        const args = {
            min: minY(detail),
            max: maxY1(detail),
            range: yRange1(detail),
            value: top,
            step: step1(detail),
            snap: snap1(detail),
            snapStart: snapStart1(detail),
            rounded: rounded1(detail),
            hasMinEdge: hasTEdge(detail),
            hasMaxEdge: hasBEdge(detail),
            minBound: getMinYBounds(spectrum),
            maxBound: getMaxYBounds(spectrum),
            screenRange: getYScreenRange(spectrum)
        };
        return findValueOf(args);
    };
    const setValueFrom$1 = (spectrum, detail, value)=>{
        const yValue = findValueOfOffset(spectrum, detail, value);
        const sliderVal = yValue;
        fireSliderChange$1(spectrum, sliderVal);
        return yValue;
    };
    const setToMin$1 = (spectrum, detail)=>{
        const min = minY(detail);
        fireSliderChange$1(spectrum, min);
    };
    const setToMax$1 = (spectrum, detail)=>{
        const max = maxY1(detail);
        fireSliderChange$1(spectrum, max);
    };
    const moveBy$1 = (direction, spectrum, detail)=>{
        const f = direction > 0 ? increaseBy : reduceBy;
        const yValue = f(currentValue1(detail), minY(detail), maxY1(detail), step1(detail));
        fireSliderChange$1(spectrum, yValue);
        return Optional.some(yValue);
    };
    const handleMovement$1 = (direction)=>(spectrum, detail)=>moveBy$1(direction, spectrum, detail).map(always)
    ;
    const getValueFromEvent$1 = (simulatedEvent)=>{
        const pos = getEventSource(simulatedEvent);
        return pos.map((p)=>{
            return p.top;
        });
    };
    const findOffsetOfValue = (spectrum, detail, value, minEdge, maxEdge)=>{
        const minOffset = 0;
        const maxOffset = getYScreenRange(spectrum);
        const centerMinEdge = minEdge.bind((edge)=>Optional.some(getYCenterOffSetOf(edge, spectrum))
        ).getOr(minOffset);
        const centerMaxEdge = maxEdge.bind((edge)=>Optional.some(getYCenterOffSetOf(edge, spectrum))
        ).getOr(maxOffset);
        const args = {
            min: minY(detail),
            max: maxY1(detail),
            range: yRange1(detail),
            value,
            hasMinEdge: hasTEdge(detail),
            hasMaxEdge: hasBEdge(detail),
            minBound: getMinYBounds(spectrum),
            minOffset,
            maxBound: getMaxYBounds(spectrum),
            maxOffset,
            centerMinEdge,
            centerMaxEdge
        };
        return findOffsetOfValue$2(args);
    };
    const findPositionOfValue = (slider, spectrum, value, minEdge, maxEdge, detail)=>{
        const offset = findOffsetOfValue(spectrum, detail, value, minEdge, maxEdge);
        return getMinYBounds(spectrum) - getMinYBounds(slider) + offset;
    };
    const setPositionFromValue$1 = (slider, thumb, detail, edges)=>{
        const value = currentValue1(detail);
        const pos = findPositionOfValue(slider, edges.getSpectrum(slider), value, edges.getTopEdge(slider), edges.getBottomEdge(slider), detail);
        const thumbRadius = get$d(thumb.element) / 2;
        set$8(thumb.element, 'top', pos - thumbRadius + 'px');
    };
    const onLeft$1 = Optional.none;
    const onRight$1 = Optional.none;
    const onUp$1 = handleMovement$1(-1);
    const onDown$1 = handleMovement$1(1);
    const edgeActions$1 = {
        'top-left': Optional.none(),
        'top': Optional.some(setToTEdge),
        'top-right': Optional.none(),
        'right': Optional.none(),
        'bottom-right': Optional.none(),
        'bottom': Optional.some(setToBEdge),
        'bottom-left': Optional.none(),
        'left': Optional.none()
    };
    var VerticalModel = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        setValueFrom: setValueFrom$1,
        setToMin: setToMin$1,
        setToMax: setToMax$1,
        findValueOfOffset: findValueOfOffset,
        getValueFromEvent: getValueFromEvent$1,
        findPositionOfValue: findPositionOfValue,
        setPositionFromValue: setPositionFromValue$1,
        onLeft: onLeft$1,
        onRight: onRight$1,
        onUp: onUp$1,
        onDown: onDown$1,
        edgeActions: edgeActions$1
    });
    const fireSliderChange = (spectrum, value)=>{
        emitWith(spectrum, sliderChangeEvent(), {
            value
        });
    };
    const sliderValue = (x, y)=>({
            x,
            y
        })
    ;
    const setValueFrom1 = (spectrum, detail, value)=>{
        const xValue = findValueOfOffset$1(spectrum, detail, value.left);
        const yValue = findValueOfOffset(spectrum, detail, value.top);
        const val = sliderValue(xValue, yValue);
        fireSliderChange(spectrum, val);
        return val;
    };
    const moveBy = (direction, isVerticalMovement, spectrum, detail)=>{
        const f = direction > 0 ? increaseBy : reduceBy;
        const xValue = isVerticalMovement ? currentValue1(detail).x : f(currentValue1(detail).x, minX(detail), maxX1(detail), step1(detail));
        const yValue = !isVerticalMovement ? currentValue1(detail).y : f(currentValue1(detail).y, minY(detail), maxY1(detail), step1(detail));
        fireSliderChange(spectrum, sliderValue(xValue, yValue));
        return Optional.some(xValue);
    };
    const handleMovement = (direction, isVerticalMovement)=>(spectrum, detail)=>moveBy(direction, isVerticalMovement, spectrum, detail).map(always)
    ;
    const setToMin = (spectrum, detail)=>{
        const mX = minX(detail);
        const mY = minY(detail);
        fireSliderChange(spectrum, sliderValue(mX, mY));
    };
    const setToMax = (spectrum, detail)=>{
        const mX = maxX1(detail);
        const mY = maxY1(detail);
        fireSliderChange(spectrum, sliderValue(mX, mY));
    };
    const getValueFromEvent = (simulatedEvent)=>getEventSource(simulatedEvent)
    ;
    const setPositionFromValue = (slider, thumb, detail, edges)=>{
        const value = currentValue1(detail);
        const xPos = findPositionOfValue$1(slider, edges.getSpectrum(slider), value.x, edges.getLeftEdge(slider), edges.getRightEdge(slider), detail);
        const yPos = findPositionOfValue(slider, edges.getSpectrum(slider), value.y, edges.getTopEdge(slider), edges.getBottomEdge(slider), detail);
        const thumbXRadius = get$c(thumb.element) / 2;
        const thumbYRadius = get$d(thumb.element) / 2;
        set$8(thumb.element, 'left', xPos - thumbXRadius + 'px');
        set$8(thumb.element, 'top', yPos - thumbYRadius + 'px');
    };
    const onLeft1 = handleMovement(-1, false);
    const onRight1 = handleMovement(1, false);
    const onUp = handleMovement(-1, true);
    const onDown = handleMovement(1, true);
    const edgeActions = {
        'top-left': Optional.some(setToTLEdgeXY),
        'top': Optional.some(setToTEdgeXY),
        'top-right': Optional.some(setToTREdgeXY),
        'right': Optional.some(setToREdgeXY),
        'bottom-right': Optional.some(setToBREdgeXY),
        'bottom': Optional.some(setToBEdgeXY),
        'bottom-left': Optional.some(setToBLEdgeXY),
        'left': Optional.some(setToLEdgeXY)
    };
    var TwoDModel = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        setValueFrom: setValueFrom1,
        setToMin: setToMin,
        setToMax: setToMax,
        getValueFromEvent: getValueFromEvent,
        setPositionFromValue: setPositionFromValue,
        onLeft: onLeft1,
        onRight: onRight1,
        onUp: onUp,
        onDown: onDown,
        edgeActions: edgeActions
    });
    const SliderSchema = [
        defaulted('stepSize', 1),
        defaulted('onChange', noop),
        defaulted('onChoose', noop),
        defaulted('onInit', noop),
        defaulted('onDragStart', noop),
        defaulted('onDragEnd', noop),
        defaulted('snapToGrid', false),
        defaulted('rounded', true),
        option$3('snapStart'),
        requiredOf('model', choose$1('mode', {
            x: [
                defaulted('minX', 0),
                defaulted('maxX', 100),
                customField('value', (spec)=>Cell(spec.mode.minX)
                ),
                required$1('getInitialValue'),
                output$1('manager', HorizontalModel)
            ],
            y: [
                defaulted('minY', 0),
                defaulted('maxY', 100),
                customField('value', (spec)=>Cell(spec.mode.minY)
                ),
                required$1('getInitialValue'),
                output$1('manager', VerticalModel)
            ],
            xy: [
                defaulted('minX', 0),
                defaulted('maxX', 100),
                defaulted('minY', 0),
                defaulted('maxY', 100),
                customField('value', (spec)=>Cell({
                        x: spec.mode.minX,
                        y: spec.mode.minY
                    })
                ),
                required$1('getInitialValue'),
                output$1('manager', TwoDModel)
            ]
        })),
        field1('sliderBehaviours', [
            Keying,
            Representing
        ]),
        customField('mouseIsDown', ()=>Cell(false)
        )
    ];
    const sketch$2 = (detail, components, _spec, _externals)=>{
        const getThumb = (component)=>getPartOrDie(component, detail, 'thumb')
        ;
        const getSpectrum = (component)=>getPartOrDie(component, detail, 'spectrum')
        ;
        const getLeftEdge = (component)=>getPart(component, detail, 'left-edge')
        ;
        const getRightEdge = (component)=>getPart(component, detail, 'right-edge')
        ;
        const getTopEdge = (component)=>getPart(component, detail, 'top-edge')
        ;
        const getBottomEdge = (component)=>getPart(component, detail, 'bottom-edge')
        ;
        const modelDetail = detail.model;
        const model = modelDetail.manager;
        const refresh = (slider, thumb)=>{
            model.setPositionFromValue(slider, thumb, detail, {
                getLeftEdge,
                getRightEdge,
                getTopEdge,
                getBottomEdge,
                getSpectrum
            });
        };
        const setValue = (slider, newValue)=>{
            modelDetail.value.set(newValue);
            const thumb = getThumb(slider);
            refresh(slider, thumb);
        };
        const changeValue = (slider, newValue)=>{
            setValue(slider, newValue);
            const thumb = getThumb(slider);
            detail.onChange(slider, thumb, newValue);
            return Optional.some(true);
        };
        const resetToMin = (slider)=>{
            model.setToMin(slider, detail);
        };
        const resetToMax = (slider)=>{
            model.setToMax(slider, detail);
        };
        const choose = (slider)=>{
            const fireOnChoose = ()=>{
                getPart(slider, detail, 'thumb').each((thumb)=>{
                    const value = modelDetail.value.get();
                    detail.onChoose(slider, thumb, value);
                });
            };
            const wasDown = detail.mouseIsDown.get();
            detail.mouseIsDown.set(false);
            if (wasDown) fireOnChoose();
        };
        const onDragStart = (slider, simulatedEvent)=>{
            simulatedEvent.stop();
            detail.mouseIsDown.set(true);
            detail.onDragStart(slider, getThumb(slider));
        };
        const onDragEnd = (slider, simulatedEvent)=>{
            simulatedEvent.stop();
            detail.onDragEnd(slider, getThumb(slider));
            choose(slider);
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: augment(detail.sliderBehaviours, [
                Keying.config({
                    mode: 'special',
                    focusIn: (slider)=>{
                        return getPart(slider, detail, 'spectrum').map(Keying.focusIn).map(always);
                    }
                }),
                Representing.config({
                    store: {
                        mode: 'manual',
                        getValue: (_)=>{
                            return modelDetail.value.get();
                        },
                        setValue
                    }
                }),
                Receiving.config({
                    channels: {
                        [mouseReleased()]: {
                            onReceive: choose
                        }
                    }
                })
            ]),
            events: derive$2([
                run$1(sliderChangeEvent(), (slider, simulatedEvent)=>{
                    changeValue(slider, simulatedEvent.event.value);
                }),
                runOnAttached((slider, _simulatedEvent)=>{
                    const getInitial = modelDetail.getInitialValue();
                    modelDetail.value.set(getInitial);
                    const thumb = getThumb(slider);
                    refresh(slider, thumb);
                    const spectrum = getSpectrum(slider);
                    detail.onInit(slider, thumb, spectrum, modelDetail.value.get());
                }),
                run$1(touchstart(), onDragStart),
                run$1(touchend(), onDragEnd),
                run$1(mousedown(), onDragStart),
                run$1(mouseup(), onDragEnd)
            ]),
            apis: {
                resetToMin,
                resetToMax,
                setValue,
                refresh
            },
            domModification: {
                styles: {
                    position: 'relative'
                }
            }
        };
    };
    const Slider = composite({
        name: 'Slider',
        configFields: SliderSchema,
        partFields: SliderParts,
        factory: sketch$2,
        apis: {
            setValue: (apis, slider, value)=>{
                apis.setValue(slider, value);
            },
            resetToMin: (apis, slider)=>{
                apis.resetToMin(slider);
            },
            resetToMax: (apis, slider)=>{
                apis.resetToMax(slider);
            },
            refresh: (apis, slider)=>{
                apis.refresh(slider);
            }
        }
    });
    const fieldsUpdate = generate$6('rgb-hex-update');
    const sliderUpdate = generate$6('slider-update');
    const paletteUpdate = generate$6('palette-update');
    const sliderFactory = (translate, getClass)=>{
        const spectrum = Slider.parts.spectrum({
            dom: {
                tag: 'div',
                classes: [
                    getClass('hue-slider-spectrum')
                ],
                attributes: {
                    role: 'presentation'
                }
            }
        });
        const thumb = Slider.parts.thumb({
            dom: {
                tag: 'div',
                classes: [
                    getClass('hue-slider-thumb')
                ],
                attributes: {
                    role: 'presentation'
                }
            }
        });
        return Slider.sketch({
            dom: {
                tag: 'div',
                classes: [
                    getClass('hue-slider')
                ],
                attributes: {
                    role: 'presentation'
                }
            },
            rounded: false,
            model: {
                mode: 'y',
                getInitialValue: constant$1(0)
            },
            components: [
                spectrum,
                thumb
            ],
            sliderBehaviours: derive$1([
                Focusing.config({})
            ]),
            onChange: (slider, _thumb, value)=>{
                emitWith(slider, sliderUpdate, {
                    value
                });
            }
        });
    };
    const owner$1 = 'form';
    const schema$i = [
        field1('formBehaviours', [
            Representing
        ])
    ];
    const getPartName$1 = (name)=>'<alloy.field.' + name + '>'
    ;
    const sketch$1 = (fSpec)=>{
        const parts = (()=>{
            const record = [];
            const field = (name, config)=>{
                record.push(name);
                return generateOne$1(owner$1, getPartName$1(name), config);
            };
            return {
                field,
                record: constant$1(record)
            };
        })();
        const spec = fSpec(parts);
        const partNames = parts.record();
        const fieldParts = map$2(partNames, (n)=>required1({
                name: n,
                pname: getPartName$1(n)
            })
        );
        return composite$1(owner$1, schema$i, fieldParts, make$4, spec);
    };
    const toResult = (o, e)=>o.fold(()=>Result.error(e)
        , Result.value)
    ;
    const make$4 = (detail, components)=>({
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: augment(detail.formBehaviours, [
                Representing.config({
                    store: {
                        mode: 'manual',
                        getValue: (form)=>{
                            const resPs = getAllParts(form, detail);
                            return map$1(resPs, (resPThunk, pName)=>resPThunk().bind((v)=>{
                                    const opt = Composing.getCurrent(v);
                                    return toResult(opt, new Error(`Cannot find a current component to extract the value from for form part '${pName}': ` + element1(v.element)));
                                }).map(Representing.getValue)
                            );
                        },
                        setValue: (form, values)=>{
                            each(values, (newValue, key)=>{
                                getPart(form, detail, key).each((wrapper)=>{
                                    Composing.getCurrent(wrapper).each((field)=>{
                                        Representing.setValue(field, newValue);
                                    });
                                });
                            });
                        }
                    }
                })
            ]),
            apis: {
                getField: (form, key)=>{
                    return getPart(form, detail, key).bind(Composing.getCurrent);
                }
            }
        })
    ;
    const Form = {
        getField: makeApi((apis, component, key)=>apis.getField(component, key)
        ),
        sketch: sketch$1
    };
    const validInput = generate$6('valid-input');
    const invalidInput = generate$6('invalid-input');
    const validatingInput = generate$6('validating-input');
    const translatePrefix = 'colorcustom.rgb.';
    const rgbFormFactory = (translate, getClass, onValidHexx, onInvalidHexx)=>{
        const invalidation = (label, isValid)=>Invalidating.config({
                invalidClass: getClass('invalid'),
                notify: {
                    onValidate: (comp)=>{
                        emitWith(comp, validatingInput, {
                            type: label
                        });
                    },
                    onValid: (comp)=>{
                        emitWith(comp, validInput, {
                            type: label,
                            value: Representing.getValue(comp)
                        });
                    },
                    onInvalid: (comp)=>{
                        emitWith(comp, invalidInput, {
                            type: label,
                            value: Representing.getValue(comp)
                        });
                    }
                },
                validator: {
                    validate: (comp)=>{
                        const value = Representing.getValue(comp);
                        const res = isValid(value) ? Result.value(true) : Result.error(translate('aria.input.invalid'));
                        return Future.pure(res);
                    },
                    validateOnLoad: false
                }
            })
        ;
        const renderTextField = (isValid, name, label, description, data)=>{
            const helptext = translate(translatePrefix + 'range');
            const pLabel = FormField.parts.label({
                dom: {
                    tag: 'label',
                    attributes: {
                        'aria-label': description
                    }
                },
                components: [
                    text$1(label)
                ]
            });
            const pField = FormField.parts.field({
                data,
                factory: Input,
                inputAttributes: {
                    type: 'text',
                    ...name === 'hex' ? {
                        'aria-live': 'polite'
                    } : {}
                },
                inputClasses: [
                    getClass('textfield')
                ],
                inputBehaviours: derive$1([
                    invalidation(name, isValid),
                    Tabstopping.config({})
                ]),
                onSetValue: (input)=>{
                    if (Invalidating.isInvalid(input)) {
                        const run = Invalidating.run(input);
                        run.get(noop);
                    }
                }
            });
            const comps = [
                pLabel,
                pField
            ];
            const concats = name !== 'hex' ? [
                FormField.parts['aria-descriptor']({
                    text: helptext
                })
            ] : [];
            const components = comps.concat(concats);
            return {
                dom: {
                    tag: 'div',
                    attributes: {
                        role: 'presentation'
                    }
                },
                components
            };
        };
        const copyRgbToHex = (form, rgba)=>{
            const hex = fromRgba(rgba);
            Form.getField(form, 'hex').each((hexField)=>{
                if (!Focusing.isFocused(hexField)) Representing.setValue(form, {
                    hex: hex.value
                });
            });
            return hex;
        };
        const copyRgbToForm = (form, rgb)=>{
            const red = rgb.red;
            const green = rgb.green;
            const blue = rgb.blue;
            Representing.setValue(form, {
                red,
                green,
                blue
            });
        };
        const memPreview = record1({
            dom: {
                tag: 'div',
                classes: [
                    getClass('rgba-preview')
                ],
                styles: {
                    'background-color': 'white'
                },
                attributes: {
                    role: 'presentation'
                }
            }
        });
        const updatePreview = (anyInSystem, hex)=>{
            memPreview.getOpt(anyInSystem).each((preview)=>{
                set$8(preview.element, 'background-color', '#' + hex.value);
            });
        };
        const factory = ()=>{
            const state = {
                red: Cell(Optional.some(255)),
                green: Cell(Optional.some(255)),
                blue: Cell(Optional.some(255)),
                hex: Cell(Optional.some('ffffff'))
            };
            const copyHexToRgb = (form, hex)=>{
                const rgb = fromHex(hex);
                copyRgbToForm(form, rgb);
                setValueRgb(rgb);
            };
            const get = (prop)=>state[prop].get()
            ;
            const set = (prop, value)=>{
                state[prop].set(value);
            };
            const getValueRgb = ()=>get('red').bind((red)=>get('green').bind((green)=>get('blue').map((blue)=>rgbaColour1(red, green, blue, 1)
                        )
                    )
                )
            ;
            const setValueRgb = (rgb)=>{
                const red = rgb.red;
                const green = rgb.green;
                const blue = rgb.blue;
                set('red', Optional.some(red));
                set('green', Optional.some(green));
                set('blue', Optional.some(blue));
            };
            const onInvalidInput = (form, simulatedEvent)=>{
                const data = simulatedEvent.event;
                if (data.type !== 'hex') set(data.type, Optional.none());
                else onInvalidHexx(form);
            };
            const onValidHex = (form, value)=>{
                onValidHexx(form);
                const hex = hexColour1(value);
                set('hex', Optional.some(value));
                const rgb = fromHex(hex);
                copyRgbToForm(form, rgb);
                setValueRgb(rgb);
                emitWith(form, fieldsUpdate, {
                    hex
                });
                updatePreview(form, hex);
            };
            const onValidRgb = (form, prop, value)=>{
                const val = parseInt(value, 10);
                set(prop, Optional.some(val));
                getValueRgb().each((rgb)=>{
                    const hex = copyRgbToHex(form, rgb);
                    emitWith(form, fieldsUpdate, {
                        hex
                    });
                    updatePreview(form, hex);
                });
            };
            const isHexInputEvent = (data)=>data.type === 'hex'
            ;
            const onValidInput = (form, simulatedEvent)=>{
                const data = simulatedEvent.event;
                if (isHexInputEvent(data)) onValidHex(form, data.value);
                else onValidRgb(form, data.type, data.value);
            };
            const formPartStrings = (key)=>({
                    label: translate(translatePrefix + key + '.label'),
                    description: translate(translatePrefix + key + '.description')
                })
            ;
            const redStrings = formPartStrings('red');
            const greenStrings = formPartStrings('green');
            const blueStrings = formPartStrings('blue');
            const hexStrings = formPartStrings('hex');
            return deepMerge(Form.sketch((parts)=>({
                    dom: {
                        tag: 'form',
                        classes: [
                            getClass('rgb-form')
                        ],
                        attributes: {
                            'aria-label': translate('aria.color.picker')
                        }
                    },
                    components: [
                        parts.field('red', FormField.sketch(renderTextField(isRgbaComponent, 'red', redStrings.label, redStrings.description, 255))),
                        parts.field('green', FormField.sketch(renderTextField(isRgbaComponent, 'green', greenStrings.label, greenStrings.description, 255))),
                        parts.field('blue', FormField.sketch(renderTextField(isRgbaComponent, 'blue', blueStrings.label, blueStrings.description, 255))),
                        parts.field('hex', FormField.sketch(renderTextField(isHexString, 'hex', hexStrings.label, hexStrings.description, 'ffffff'))),
                        memPreview.asSpec()
                    ],
                    formBehaviours: derive$1([
                        Invalidating.config({
                            invalidClass: getClass('form-invalid')
                        }),
                        config1('rgb-form-events', [
                            run$1(validInput, onValidInput),
                            run$1(invalidInput, onInvalidInput),
                            run$1(validatingInput, onInvalidInput)
                        ])
                    ])
                })
            ), {
                apis: {
                    updateHex: (form, hex)=>{
                        Representing.setValue(form, {
                            hex: hex.value
                        });
                        copyHexToRgb(form, hex);
                        updatePreview(form, hex);
                    }
                }
            });
        };
        const rgbFormSketcher = single({
            factory,
            name: 'RgbForm',
            configFields: [],
            apis: {
                updateHex: (apis, form, hex)=>{
                    apis.updateHex(form, hex);
                }
            },
            extraApis: {}
        });
        return rgbFormSketcher;
    };
    const paletteFactory = (_translate, getClass)=>{
        const spectrumPart = Slider.parts.spectrum({
            dom: {
                tag: 'canvas',
                attributes: {
                    role: 'presentation'
                },
                classes: [
                    getClass('sv-palette-spectrum')
                ]
            }
        });
        const thumbPart = Slider.parts.thumb({
            dom: {
                tag: 'div',
                attributes: {
                    role: 'presentation'
                },
                classes: [
                    getClass('sv-palette-thumb')
                ],
                innerHtml: `<div class=${getClass('sv-palette-inner-thumb')} role="presentation"></div>`
            }
        });
        const setColour = (canvas, rgba)=>{
            const { width , height  } = canvas;
            const ctx = canvas.getContext('2d');
            if (ctx === null) return;
            ctx.fillStyle = rgba;
            ctx.fillRect(0, 0, width, height);
            const grdWhite = ctx.createLinearGradient(0, 0, width, 0);
            grdWhite.addColorStop(0, 'rgba(255,255,255,1)');
            grdWhite.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grdWhite;
            ctx.fillRect(0, 0, width, height);
            const grdBlack = ctx.createLinearGradient(0, 0, 0, height);
            grdBlack.addColorStop(0, 'rgba(0,0,0,0)');
            grdBlack.addColorStop(1, 'rgba(0,0,0,1)');
            ctx.fillStyle = grdBlack;
            ctx.fillRect(0, 0, width, height);
        };
        const setPaletteHue = (slider, hue)=>{
            const canvas = slider.components()[0].element.dom;
            const hsv = hsvColour(hue, 100, 100);
            const rgba = fromHsv(hsv);
            setColour(canvas, toString1(rgba));
        };
        const setPaletteThumb = (slider, hex)=>{
            const hsv = fromRgb(fromHex(hex));
            Slider.setValue(slider, {
                x: hsv.saturation,
                y: 100 - hsv.value
            });
        };
        const factory = (_detail)=>{
            const getInitialValue = constant$1({
                x: 0,
                y: 0
            });
            const onChange = (slider, _thumb, value)=>{
                emitWith(slider, paletteUpdate, {
                    value
                });
            };
            const onInit = (_slider, _thumb, spectrum, _value)=>{
                setColour(spectrum.element.dom, toString1(red1));
            };
            const sliderBehaviours = derive$1([
                Composing.config({
                    find: Optional.some
                }),
                Focusing.config({})
            ]);
            return Slider.sketch({
                dom: {
                    tag: 'div',
                    attributes: {
                        role: 'presentation'
                    },
                    classes: [
                        getClass('sv-palette')
                    ]
                },
                model: {
                    mode: 'xy',
                    getInitialValue
                },
                rounded: false,
                components: [
                    spectrumPart,
                    thumbPart
                ],
                onChange,
                onInit,
                sliderBehaviours
            });
        };
        const saturationBrightnessPaletteSketcher = single({
            factory,
            name: 'SaturationBrightnessPalette',
            configFields: [],
            apis: {
                setHue: (_apis, slider, hue)=>{
                    setPaletteHue(slider, hue);
                },
                setThumb: (_apis, slider, hex)=>{
                    setPaletteThumb(slider, hex);
                }
            },
            extraApis: {}
        });
        return saturationBrightnessPaletteSketcher;
    };
    const makeFactory = (translate, getClass)=>{
        const factory = (detail)=>{
            const rgbForm = rgbFormFactory(translate, getClass, detail.onValidHex, detail.onInvalidHex);
            const sbPalette = paletteFactory(translate, getClass);
            const hueSliderToDegrees = (hue)=>(100 - hue) / 100 * 360
            ;
            const hueDegreesToSlider = (hue)=>100 - hue / 360 * 100
            ;
            const state = {
                paletteRgba: Cell(red1),
                paletteHue: Cell(0)
            };
            const memSlider = record1(sliderFactory(translate, getClass));
            const memPalette = record1(sbPalette.sketch({}));
            const memRgb = record1(rgbForm.sketch({}));
            const updatePalette = (anyInSystem, _hex, hue)=>{
                memPalette.getOpt(anyInSystem).each((palette)=>{
                    sbPalette.setHue(palette, hue);
                });
            };
            const updateFields = (anyInSystem, hex)=>{
                memRgb.getOpt(anyInSystem).each((form)=>{
                    rgbForm.updateHex(form, hex);
                });
            };
            const updateSlider = (anyInSystem, _hex, hue)=>{
                memSlider.getOpt(anyInSystem).each((slider)=>{
                    Slider.setValue(slider, hueDegreesToSlider(hue));
                });
            };
            const updatePaletteThumb = (anyInSystem, hex)=>{
                memPalette.getOpt(anyInSystem).each((palette)=>{
                    sbPalette.setThumb(palette, hex);
                });
            };
            const updateState = (hex, hue)=>{
                const rgba = fromHex(hex);
                state.paletteRgba.set(rgba);
                state.paletteHue.set(hue);
            };
            const runUpdates = (anyInSystem, hex, hue, updates)=>{
                updateState(hex, hue);
                each$1(updates, (update)=>{
                    update(anyInSystem, hex, hue);
                });
            };
            const onPaletteUpdate = ()=>{
                const updates = [
                    updateFields
                ];
                return (form, simulatedEvent)=>{
                    const value = simulatedEvent.event.value;
                    const oldHue = state.paletteHue.get();
                    const newHsv = hsvColour(oldHue, value.x, 100 - value.y);
                    const newHex = hsvToHex(newHsv);
                    runUpdates(form, newHex, oldHue, updates);
                };
            };
            const onSliderUpdate = ()=>{
                const updates = [
                    updatePalette,
                    updateFields
                ];
                return (form, simulatedEvent)=>{
                    const hue = hueSliderToDegrees(simulatedEvent.event.value);
                    const oldRgb = state.paletteRgba.get();
                    const oldHsv = fromRgb(oldRgb);
                    const newHsv = hsvColour(hue, oldHsv.saturation, oldHsv.value);
                    const newHex = hsvToHex(newHsv);
                    runUpdates(form, newHex, hue, updates);
                };
            };
            const onFieldsUpdate = ()=>{
                const updates = [
                    updatePalette,
                    updateSlider,
                    updatePaletteThumb
                ];
                return (form, simulatedEvent)=>{
                    const hex = simulatedEvent.event.hex;
                    const hsv = hexToHsv(hex);
                    runUpdates(form, hex, hsv.hue, updates);
                };
            };
            return {
                uid: detail.uid,
                dom: detail.dom,
                components: [
                    memPalette.asSpec(),
                    memSlider.asSpec(),
                    memRgb.asSpec()
                ],
                behaviours: derive$1([
                    config1('colour-picker-events', [
                        run$1(fieldsUpdate, onFieldsUpdate()),
                        run$1(paletteUpdate, onPaletteUpdate()),
                        run$1(sliderUpdate, onSliderUpdate())
                    ]),
                    Composing.config({
                        find: (comp)=>memRgb.getOpt(comp)
                    }),
                    Keying.config({
                        mode: 'acyclic'
                    })
                ])
            };
        };
        const colourPickerSketcher = single({
            name: 'ColourPicker',
            configFields: [
                required$1('dom'),
                defaulted('onValidHex', noop),
                defaulted('onInvalidHex', noop)
            ],
            factory
        });
        return colourPickerSketcher;
    };
    const self1 = ()=>Composing.config({
            find: Optional.some
        })
    ;
    const memento$1 = (mem)=>Composing.config({
            find: mem.getOpt
        })
    ;
    const childAt = (index)=>Composing.config({
            find: (comp)=>child$2(comp.element, index).bind((element)=>comp.getSystem().getByDom(element).toOptional()
                )
        })
    ;
    const ComposingConfigs = {
        self: self1,
        memento: memento$1,
        childAt
    };
    const processors = objOf([
        defaulted('preprocess', identity),
        defaulted('postprocess', identity)
    ]);
    const memento = (mem, rawProcessors)=>{
        const ps = asRawOrDie$1('RepresentingConfigs.memento processors', processors, rawProcessors);
        return Representing.config({
            store: {
                mode: 'manual',
                getValue: (comp)=>{
                    const other = mem.get(comp);
                    const rawValue = Representing.getValue(other);
                    return ps.postprocess(rawValue);
                },
                setValue: (comp, rawValue)=>{
                    const newValue = ps.preprocess(rawValue);
                    const other = mem.get(comp);
                    Representing.setValue(other, newValue);
                }
            }
        });
    };
    const withComp = (optInitialValue, getter, setter)=>Representing.config({
            store: {
                mode: 'manual',
                ...optInitialValue.map((initialValue)=>({
                        initialValue
                    })
                ).getOr({}),
                getValue: getter,
                setValue: setter
            }
        })
    ;
    const withElement = (initialValue, getter, setter)=>withComp(initialValue, (c)=>getter(c.element)
        , (c, v)=>setter(c.element, v)
        )
    ;
    const domValue = (optInitialValue)=>withElement(optInitialValue, get$6, set$5)
    ;
    const domHtml = (optInitialValue)=>withElement(optInitialValue, get$9, set$6)
    ;
    const memory = (initialValue)=>Representing.config({
            store: {
                mode: 'memory',
                initialValue
            }
        })
    ;
    const RepresentingConfigs = {
        memento,
        withElement,
        withComp,
        domValue,
        domHtml,
        memory
    };
    const english = {
        'colorcustom.rgb.red.label': 'R',
        'colorcustom.rgb.red.description': 'Red component',
        'colorcustom.rgb.green.label': 'G',
        'colorcustom.rgb.green.description': 'Green component',
        'colorcustom.rgb.blue.label': 'B',
        'colorcustom.rgb.blue.description': 'Blue component',
        'colorcustom.rgb.hex.label': '#',
        'colorcustom.rgb.hex.description': 'Hex color code',
        'colorcustom.rgb.range': 'Range 0 to 255',
        'aria.color.picker': 'Color Picker',
        'aria.input.invalid': 'Invalid input'
    };
    const translate$1 = (providerBackstage)=>(key)=>{
            return providerBackstage.translate(english[key]);
        }
    ;
    const renderColorPicker = (_spec, providerBackstage, initialData)=>{
        const getClass = (key)=>'tox-' + key
        ;
        const colourPickerFactory = makeFactory(translate$1(providerBackstage), getClass);
        const onValidHex = (form)=>{
            emitWith(form, formActionEvent, {
                name: 'hex-valid',
                value: true
            });
        };
        const onInvalidHex = (form)=>{
            emitWith(form, formActionEvent, {
                name: 'hex-valid',
                value: false
            });
        };
        const memPicker = record1(colourPickerFactory.sketch({
            dom: {
                tag: 'div',
                classes: [
                    getClass('color-picker-container')
                ],
                attributes: {
                    role: 'presentation'
                }
            },
            onValidHex,
            onInvalidHex
        }));
        return {
            dom: {
                tag: 'div'
            },
            components: [
                memPicker.asSpec()
            ],
            behaviours: derive$1([
                RepresentingConfigs.withComp(initialData, (comp)=>{
                    const picker = memPicker.get(comp);
                    const optRgbForm = Composing.getCurrent(picker);
                    const optHex = optRgbForm.bind((rgbForm)=>{
                        const formValues = Representing.getValue(rgbForm);
                        return formValues.hex;
                    });
                    return optHex.map((hex)=>'#' + hex
                    ).getOr('');
                }, (comp, newValue)=>{
                    const pattern = /^#([a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?)/;
                    const m = pattern.exec(newValue);
                    const picker = memPicker.get(comp);
                    const optRgbForm = Composing.getCurrent(picker);
                    optRgbForm.fold(()=>{
                        console.log('Can not find form');
                    }, (rgbForm)=>{
                        Representing.setValue(rgbForm, {
                            hex: Optional.from(m[1]).getOr('')
                        });
                        Form.getField(rgbForm, 'hex').each((hexField)=>{
                            emit(hexField, input1());
                        });
                    });
                }),
                ComposingConfigs.self()
            ])
        };
    };
    var global$2 = tinymce.util.Tools.resolve('tinymce.Resource');
    const isOldCustomEditor = (spec)=>has$2(spec, 'init')
    ;
    const renderCustomEditor = (spec)=>{
        const editorApi = value$2();
        const memReplaced = record1({
            dom: {
                tag: spec.tag
            }
        });
        const initialValue = value$2();
        return {
            dom: {
                tag: 'div',
                classes: [
                    'tox-custom-editor'
                ]
            },
            behaviours: derive$1([
                config1('custom-editor-events', [
                    runOnAttached((component)=>{
                        memReplaced.getOpt(component).each((ta)=>{
                            (isOldCustomEditor(spec) ? spec.init(ta.element.dom) : global$2.load(spec.scriptId, spec.scriptUrl).then((init)=>init(ta.element.dom, spec.settings)
                            )).then((ea)=>{
                                initialValue.on((cvalue)=>{
                                    ea.setValue(cvalue);
                                });
                                initialValue.clear();
                                editorApi.set(ea);
                            });
                        });
                    })
                ]),
                RepresentingConfigs.withComp(Optional.none(), ()=>editorApi.get().fold(()=>initialValue.get().getOr('')
                    , (ed)=>ed.getValue()
                    )
                , (component, value)=>{
                    editorApi.get().fold(()=>initialValue.set(value)
                    , (ed)=>ed.setValue(value)
                    );
                }),
                ComposingConfigs.self()
            ]),
            components: [
                memReplaced.asSpec()
            ]
        };
    };
    var global$1 = tinymce.util.Tools.resolve('tinymce.util.Tools');
    const filterByExtension = (files, providersBackstage)=>{
        const allowedImageFileTypes = global$1.explode(providersBackstage.getOption('images_file_types'));
        const isFileInAllowedTypes = (file)=>exists(allowedImageFileTypes, (type)=>endsWith(file.name.toLowerCase(), `.${type.toLowerCase()}`)
            )
        ;
        return filter$2(from(files), isFileInAllowedTypes);
    };
    const renderDropZone = (spec, providersBackstage, initialData)=>{
        const stopper = (_, se)=>{
            se.stop();
        };
        const sequence = (actions)=>(comp, se)=>{
                each$1(actions, (a)=>{
                    a(comp, se);
                });
            }
        ;
        const onDrop = (comp, se)=>{
            if (!Disabling.isDisabled(comp)) {
                const transferEvent = se.event.raw;
                handleFiles(comp, transferEvent.dataTransfer.files);
            }
        };
        const onSelect = (component, simulatedEvent)=>{
            const input = simulatedEvent.event.raw.target;
            handleFiles(component, input.files);
        };
        const handleFiles = (component, files)=>{
            Representing.setValue(component, filterByExtension(files, providersBackstage));
            emitWith(component, formChangeEvent, {
                name: spec.name
            });
        };
        const memInput = record1({
            dom: {
                tag: 'input',
                attributes: {
                    type: 'file',
                    accept: 'image/*'
                },
                styles: {
                    display: 'none'
                }
            },
            behaviours: derive$1([
                config1('input-file-events', [
                    cutter1(click()),
                    cutter1(tap())
                ])
            ])
        });
        const renderField = (s)=>({
                uid: s.uid,
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-dropzone-container'
                    ]
                },
                behaviours: derive$1([
                    RepresentingConfigs.memory(initialData.getOr([])),
                    ComposingConfigs.self(),
                    Disabling.config({}),
                    Toggling.config({
                        toggleClass: 'dragenter',
                        toggleOnExecute: false
                    }),
                    config1('dropzone-events', [
                        run$1('dragenter', sequence([
                            stopper,
                            Toggling.toggle
                        ])),
                        run$1('dragleave', sequence([
                            stopper,
                            Toggling.toggle
                        ])),
                        run$1('dragover', stopper),
                        run$1('drop', sequence([
                            stopper,
                            onDrop
                        ])),
                        run$1(change1(), onSelect)
                    ])
                ]),
                components: [
                    {
                        dom: {
                            tag: 'div',
                            classes: [
                                'tox-dropzone'
                            ],
                            styles: {}
                        },
                        components: [
                            {
                                dom: {
                                    tag: 'p'
                                },
                                components: [
                                    text$1(providersBackstage.translate('Drop an image here'))
                                ]
                            },
                            Button.sketch({
                                dom: {
                                    tag: 'button',
                                    styles: {
                                        position: 'relative'
                                    },
                                    classes: [
                                        'tox-button',
                                        'tox-button--secondary'
                                    ]
                                },
                                components: [
                                    text$1(providersBackstage.translate('Browse for an image')),
                                    memInput.asSpec()
                                ],
                                action: (comp)=>{
                                    const inputComp = memInput.get(comp);
                                    inputComp.element.dom.click();
                                },
                                buttonBehaviours: derive$1([
                                    Tabstopping.config({}),
                                    DisablingConfigs.button(providersBackstage.isDisabled),
                                    receivingConfig()
                                ])
                            })
                        ]
                    }
                ]
            })
        ;
        const pLabel = spec.label.map((label)=>renderLabel$2(label, providersBackstage)
        );
        const pField = FormField.parts.field({
            factory: {
                sketch: renderField
            }
        });
        return renderFormFieldWith(pLabel, pField, [
            'tox-form__group--stretched'
        ], []);
    };
    const renderGrid = (spec, backstage)=>({
            dom: {
                tag: 'div',
                classes: [
                    'tox-form__grid',
                    `tox-form__grid--${spec.columns}col`
                ]
            },
            components: map$2(spec.items, backstage.interpreter)
        })
    ;
    const beforeObject = generate$6('alloy-fake-before-tabstop');
    const afterObject = generate$6('alloy-fake-after-tabstop');
    const craftWithClasses = (classes)=>{
        return {
            dom: {
                tag: 'div',
                styles: {
                    width: '1px',
                    height: '1px',
                    outline: 'none'
                },
                attributes: {
                    tabindex: '0'
                },
                classes
            },
            behaviours: derive$1([
                Focusing.config({
                    ignore: true
                }),
                Tabstopping.config({})
            ])
        };
    };
    const craft = (spec)=>{
        return {
            dom: {
                tag: 'div',
                classes: [
                    'tox-navobj'
                ]
            },
            components: [
                craftWithClasses([
                    beforeObject
                ]),
                spec,
                craftWithClasses([
                    afterObject
                ])
            ],
            behaviours: derive$1([
                ComposingConfigs.childAt(1)
            ])
        };
    };
    const triggerTab = (placeholder, shiftKey)=>{
        emitWith(placeholder, keydown(), {
            raw: {
                which: 9,
                shiftKey
            }
        });
    };
    const onFocus = (container, targetComp)=>{
        const target = targetComp.element;
        if (has(target, beforeObject)) triggerTab(container, true);
        else if (has(target, afterObject)) triggerTab(container, false);
    };
    const isPseudoStop = (element)=>{
        return closest1(element, [
            '.' + beforeObject,
            '.' + afterObject
        ].join(','), never);
    };
    const getDynamicSource = (initialData)=>{
        const cachedValue = Cell(initialData.getOr(''));
        return {
            getValue: (_frameComponent)=>cachedValue.get()
            ,
            setValue: (frameComponent, html)=>{
                if (cachedValue.get() !== html) set$9(frameComponent.element, 'srcdoc', html);
                cachedValue.set(html);
            }
        };
    };
    const renderIFrame = (spec, providersBackstage, initialData)=>{
        const isSandbox = spec.sandboxed;
        const attributes = {
            ...spec.label.map((title)=>({
                    title
                })
            ).getOr({}),
            ...initialData.map((html)=>({
                    srcdoc: html
                })
            ).getOr({}),
            ...isSandbox ? {
                sandbox: 'allow-scripts allow-same-origin'
            } : {}
        };
        const sourcing = getDynamicSource(initialData);
        const pLabel = spec.label.map((label)=>renderLabel$2(label, providersBackstage)
        );
        const factory = (newSpec)=>craft({
                uid: newSpec.uid,
                dom: {
                    tag: 'iframe',
                    attributes
                },
                behaviours: derive$1([
                    Tabstopping.config({}),
                    Focusing.config({}),
                    RepresentingConfigs.withComp(initialData, sourcing.getValue, sourcing.setValue)
                ])
            })
        ;
        const pField = FormField.parts.field({
            factory: {
                sketch: factory
            }
        });
        return renderFormFieldWith(pLabel, pField, [
            'tox-form__group--stretched'
        ], []);
    };
    const image1 = (image)=>new Promise((resolve, reject)=>{
            const loaded = ()=>{
                destroy();
                resolve(image);
            };
            const listeners = [
                bind1(image, 'load', loaded),
                bind1(image, 'error', ()=>{
                    destroy();
                    reject('Unable to load data from image: ' + image.dom.src);
                })
            ];
            const destroy = ()=>each$1(listeners, (l)=>l.unbind()
                )
            ;
            if (image.dom.complete) loaded();
        })
    ;
    const calculateImagePosition = (panelWidth, panelHeight, imageWidth, imageHeight, zoom)=>{
        const width = imageWidth * zoom;
        const height = imageHeight * zoom;
        const left = Math.max(0, panelWidth / 2 - width / 2);
        const top = Math.max(0, panelHeight / 2 - height / 2);
        return {
            left: left.toString() + 'px',
            top: top.toString() + 'px',
            width: width.toString() + 'px',
            height: height.toString() + 'px'
        };
    };
    const zoomToFit = (panel, width, height)=>{
        const panelW = get$c(panel);
        const panelH = get$d(panel);
        return Math.min(panelW / width, panelH / height, 1);
    };
    const renderImagePreview = (spec, initialData)=>{
        const cachedData = Cell(initialData.getOr({
            url: ''
        }));
        const memImage = record1({
            dom: {
                tag: 'img',
                classes: [
                    'tox-imagepreview__image'
                ],
                attributes: initialData.map((data)=>({
                        src: data.url
                    })
                ).getOr({})
            }
        });
        const memContainer = record1({
            dom: {
                tag: 'div',
                classes: [
                    'tox-imagepreview__container'
                ],
                attributes: {
                    role: 'presentation'
                }
            },
            components: [
                memImage.asSpec()
            ]
        });
        const setValue = (frameComponent, data)=>{
            const translatedData = {
                url: data.url
            };
            data.zoom.each((z)=>translatedData.zoom = z
            );
            data.cachedWidth.each((z)=>translatedData.cachedWidth = z
            );
            data.cachedHeight.each((z)=>translatedData.cachedHeight = z
            );
            cachedData.set(translatedData);
            const applyFramePositioning = ()=>{
                const imageWidth = translatedData.cachedWidth;
                const imageHeight = translatedData.cachedHeight;
                if (isUndefined(translatedData.zoom)) {
                    const z = zoomToFit(frameComponent.element, imageWidth, imageHeight);
                    translatedData.zoom = z;
                }
                const position = calculateImagePosition(get$c(frameComponent.element), get$d(frameComponent.element), imageWidth, imageHeight, translatedData.zoom);
                memContainer.getOpt(frameComponent).each((container)=>{
                    setAll(container.element, position);
                });
            };
            memImage.getOpt(frameComponent).each((imageComponent)=>{
                const img1 = imageComponent.element;
                if (data.url !== get$f(img1, 'src')) {
                    set$9(img1, 'src', data.url);
                    remove$2(frameComponent.element, 'tox-imagepreview__loaded');
                }
                if (!isUndefined(translatedData.cachedWidth) && !isUndefined(translatedData.cachedHeight)) applyFramePositioning();
                image1(img1).then((img)=>{
                    if (frameComponent.getSystem().isConnected()) {
                        add$2(frameComponent.element, 'tox-imagepreview__loaded');
                        translatedData.cachedWidth = img.dom.naturalWidth;
                        translatedData.cachedHeight = img.dom.naturalHeight;
                        applyFramePositioning();
                    }
                });
            });
        };
        const styles = {};
        spec.height.each((h)=>styles.height = h
        );
        const fakeValidatedData = initialData.map((d)=>({
                url: d.url,
                zoom: Optional.from(d.zoom),
                cachedWidth: Optional.from(d.cachedWidth),
                cachedHeight: Optional.from(d.cachedHeight)
            })
        );
        return {
            dom: {
                tag: 'div',
                classes: [
                    'tox-imagepreview'
                ],
                styles,
                attributes: {
                    role: 'presentation'
                }
            },
            components: [
                memContainer.asSpec()
            ],
            behaviours: derive$1([
                ComposingConfigs.self(),
                RepresentingConfigs.withComp(fakeValidatedData, ()=>cachedData.get()
                , setValue)
            ])
        };
    };
    const renderLabel$1 = (spec, backstageShared)=>{
        const label = {
            dom: {
                tag: 'label',
                classes: [
                    'tox-label'
                ]
            },
            components: [
                text$1(backstageShared.providers.translate(spec.label))
            ]
        };
        const comps = map$2(spec.items, backstageShared.interpreter);
        return {
            dom: {
                tag: 'div',
                classes: [
                    'tox-form__group'
                ]
            },
            components: [
                label,
                ...comps
            ],
            behaviours: derive$1([
                ComposingConfigs.self(),
                Replacing.config({}),
                RepresentingConfigs.domHtml(Optional.none()),
                Keying.config({
                    mode: 'acyclic'
                })
            ])
        };
    };
    const internalToolbarButtonExecute = generate$6('toolbar.button.execute');
    const onToolbarButtonExecute = (info)=>runOnExecute$1((comp, _simulatedEvent)=>{
            runWithApi(info, comp)((itemApi)=>{
                emitWith(comp, internalToolbarButtonExecute, {
                    buttonApi: itemApi
                });
                info.onAction(itemApi);
            });
        })
    ;
    const toolbarButtonEventOrder = {
        [execute$5()]: [
            'disabling',
            'alloy.base.behaviour',
            'toggling',
            'toolbar-button-events'
        ]
    };
    const renderIcon1 = (iconName, iconsProvider, behaviours)=>render$3(iconName, {
            tag: 'span',
            classes: [
                'tox-icon',
                'tox-tbtn__icon-wrap'
            ],
            behaviours
        }, iconsProvider)
    ;
    const renderIconFromPack = (iconName, iconsProvider)=>renderIcon1(iconName, iconsProvider, [])
    ;
    const renderReplacableIconFromPack = (iconName, iconsProvider)=>renderIcon1(iconName, iconsProvider, [
            Replacing.config({})
        ])
    ;
    const renderLabel = (text, prefix, providersBackstage)=>({
            dom: {
                tag: 'span',
                classes: [
                    `${prefix}__select-label`
                ]
            },
            components: [
                text$1(providersBackstage.translate(text))
            ],
            behaviours: derive$1([
                Replacing.config({})
            ])
        })
    ;
    const updateMenuText = generate$6('update-menu-text');
    const updateMenuIcon = generate$6('update-menu-icon');
    const renderCommonDropdown = (spec, prefix, sharedBackstage)=>{
        const editorOffCell = Cell(noop);
        const optMemDisplayText = spec.text.map((text)=>record1(renderLabel(text, prefix, sharedBackstage.providers))
        );
        const optMemDisplayIcon = spec.icon.map((iconName)=>record1(renderReplacableIconFromPack(iconName, sharedBackstage.providers.icons))
        );
        const onLeftOrRightInMenu = (comp, se)=>{
            const dropdown = Representing.getValue(comp);
            Focusing.focus(dropdown);
            emitWith(dropdown, 'keydown', {
                raw: se.event.raw
            });
            Dropdown.close(dropdown);
            return Optional.some(true);
        };
        const role1 = spec.role.fold(()=>({})
        , (role)=>({
                role
            })
        );
        const tooltipAttributes = spec.tooltip.fold(()=>({})
        , (tooltip)=>{
            const translatedTooltip = sharedBackstage.providers.translate(tooltip);
            return {
                'title': translatedTooltip,
                'aria-label': translatedTooltip
            };
        });
        const iconSpec = render$3('chevron-down', {
            tag: 'div',
            classes: [
                `${prefix}__select-chevron`
            ]
        }, sharedBackstage.providers.icons);
        const memDropdown = record1(Dropdown.sketch({
            ...spec.uid ? {
                uid: spec.uid
            } : {},
            ...role1,
            dom: {
                tag: 'button',
                classes: [
                    prefix,
                    `${prefix}--select`
                ].concat(map$2(spec.classes, (c)=>`${prefix}--${c}`
                )),
                attributes: {
                    ...tooltipAttributes
                }
            },
            components: componentRenderPipeline([
                optMemDisplayIcon.map((mem)=>mem.asSpec()
                ),
                optMemDisplayText.map((mem)=>mem.asSpec()
                ),
                Optional.some(iconSpec)
            ]),
            matchWidth: true,
            useMinWidth: true,
            dropdownBehaviours: derive$1([
                ...spec.dropdownBehaviours,
                DisablingConfigs.button(()=>spec.disabled || sharedBackstage.providers.isDisabled()
                ),
                receivingConfig(),
                Unselecting.config({}),
                Replacing.config({}),
                config1('dropdown-events', [
                    onControlAttached(spec, editorOffCell),
                    onControlDetached(spec, editorOffCell)
                ]),
                config1('menubutton-update-display-text', [
                    run$1(updateMenuText, (comp, se)=>{
                        optMemDisplayText.bind((mem)=>mem.getOpt(comp)
                        ).each((displayText)=>{
                            Replacing.set(displayText, [
                                text$1(sharedBackstage.providers.translate(se.event.text))
                            ]);
                        });
                    }),
                    run$1(updateMenuIcon, (comp, se)=>{
                        optMemDisplayIcon.bind((mem)=>mem.getOpt(comp)
                        ).each((displayIcon)=>{
                            Replacing.set(displayIcon, [
                                renderReplacableIconFromPack(se.event.icon, sharedBackstage.providers.icons)
                            ]);
                        });
                    })
                ])
            ]),
            eventOrder: deepMerge(toolbarButtonEventOrder, {
                mousedown: [
                    'focusing',
                    'alloy.base.behaviour',
                    'item-type-events',
                    'normal-dropdown-events'
                ]
            }),
            sandboxBehaviours: derive$1([
                Keying.config({
                    mode: 'special',
                    onLeft: onLeftOrRightInMenu,
                    onRight: onLeftOrRightInMenu
                })
            ]),
            lazySink: sharedBackstage.getSink,
            toggleClass: `${prefix}--active`,
            parts: {
                menu: part1(false, spec.columns, spec.presets)
            },
            fetch: (comp)=>Future.nu(curry(spec.fetch, comp))
        }));
        return memDropdown.asSpec();
    };
    const isMenuItemReference = (item)=>isString(item)
    ;
    const isSeparator$1 = (item)=>item.type === 'separator'
    ;
    const isExpandingMenuItem = (item)=>has$2(item, 'getSubmenuItems')
    ;
    const separator$2 = {
        type: 'separator'
    };
    const unwrapReferences = (items, menuItems)=>{
        const realItems = foldl(items, (acc, item)=>{
            if (isMenuItemReference(item)) {
                if (item === '') return acc;
                else if (item === '|') return acc.length > 0 && !isSeparator$1(acc[acc.length - 1]) ? acc.concat([
                    separator$2
                ]) : acc;
                else if (has$2(menuItems, item.toLowerCase())) return acc.concat([
                    menuItems[item.toLowerCase()]
                ]);
                else return acc;
            } else return acc.concat([
                item
            ]);
        }, []);
        if (realItems.length > 0 && isSeparator$1(realItems[realItems.length - 1])) realItems.pop();
        return realItems;
    };
    const getFromExpandingItem = (item, menuItems)=>{
        const submenuItems = item.getSubmenuItems();
        const rest = expand1(submenuItems, menuItems);
        const newMenus = deepMerge(rest.menus, wrap$1(item.value, rest.items));
        const newExpansions = deepMerge(rest.expansions, wrap$1(item.value, item.value));
        return {
            item,
            menus: newMenus,
            expansions: newExpansions
        };
    };
    const getFromItem = (item, menuItems)=>isExpandingMenuItem(item) ? getFromExpandingItem(item, menuItems) : {
            item,
            menus: {},
            expansions: {}
        }
    ;
    const generateValueIfRequired = (item)=>{
        if (isSeparator$1(item)) return item;
        else {
            const itemValue = get$g(item, 'value').getOrThunk(()=>generate$6('generated-menu-item')
            );
            return deepMerge({
                value: itemValue
            }, item);
        }
    };
    const expand1 = (items, menuItems)=>{
        const realItems = unwrapReferences(isString(items) ? items.split(' ') : items, menuItems);
        return foldr(realItems, (acc, item)=>{
            const itemWithValue = generateValueIfRequired(item);
            const newData = getFromItem(itemWithValue, menuItems);
            return {
                menus: deepMerge(acc.menus, newData.menus),
                items: [
                    newData.item
                ].concat(acc.items),
                expansions: deepMerge(acc.expansions, newData.expansions)
            };
        }, {
            menus: {},
            expansions: {},
            items: []
        });
    };
    const build1 = (items, itemResponse, backstage, isHorizontalMenu)=>{
        const primary = generate$6('primary-menu');
        const data = expand1(items, backstage.shared.providers.menuItems());
        if (data.items.length === 0) return Optional.none();
        const mainMenu = createPartialMenu(primary, data.items, itemResponse, backstage, isHorizontalMenu);
        const submenus = map$1(data.menus, (menuItems, menuName)=>createPartialMenu(menuName, menuItems, itemResponse, backstage, false)
        );
        const menus = deepMerge(submenus, wrap$1(primary, mainMenu));
        return Optional.from(tieredMenu.tieredData(primary, menus, data.expansions));
    };
    const isSingleListItem = (item)=>!has$2(item, 'items')
    ;
    const dataAttribute = 'data-value';
    const fetchItems = (dropdownComp, name, items, selectedValue)=>map$2(items, (item)=>{
            if (!isSingleListItem(item)) return {
                type: 'nestedmenuitem',
                text: item.text,
                getSubmenuItems: ()=>fetchItems(dropdownComp, name, item.items, selectedValue)
            };
            else return {
                type: 'togglemenuitem',
                text: item.text,
                value: item.value,
                active: item.value === selectedValue,
                onAction: ()=>{
                    Representing.setValue(dropdownComp, item.value);
                    emitWith(dropdownComp, formChangeEvent, {
                        name
                    });
                    Focusing.focus(dropdownComp);
                }
            };
        })
    ;
    const findItemByValue = (items, value)=>findMap(items, (item)=>{
            if (!isSingleListItem(item)) return findItemByValue(item.items, value);
            else return someIf(item.value === value, item);
        })
    ;
    const renderListBox = (spec, backstage, initialData)=>{
        const providersBackstage = backstage.shared.providers;
        const initialItem = initialData.bind((value)=>findItemByValue(spec.items, value)
        ).orThunk(()=>head(spec.items).filter(isSingleListItem)
        );
        const pLabel = spec.label.map((label)=>renderLabel$2(label, providersBackstage)
        );
        const pField = FormField.parts.field({
            dom: {},
            factory: {
                sketch: (sketchSpec)=>renderCommonDropdown({
                        uid: sketchSpec.uid,
                        text: initialItem.map((item)=>item.text
                        ),
                        icon: Optional.none(),
                        tooltip: spec.label,
                        role: Optional.none(),
                        fetch: (comp, callback)=>{
                            const items = fetchItems(comp, spec.name, spec.items, Representing.getValue(comp));
                            callback(build1(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, false));
                        },
                        onSetup: constant$1(noop),
                        getApi: constant$1({}),
                        columns: 1,
                        presets: 'normal',
                        classes: [],
                        dropdownBehaviours: [
                            Tabstopping.config({}),
                            RepresentingConfigs.withComp(initialItem.map((item)=>item.value
                            ), (comp)=>get$f(comp.element, dataAttribute)
                            , (comp, data)=>{
                                findItemByValue(spec.items, data).each((item)=>{
                                    set$9(comp.element, dataAttribute, item.value);
                                    emitWith(comp, updateMenuText, {
                                        text: item.text
                                    });
                                });
                            })
                        ]
                    }, 'tox-listbox', backstage.shared)
            }
        });
        const listBoxWrap = {
            dom: {
                tag: 'div',
                classes: [
                    'tox-listboxfield'
                ]
            },
            components: [
                pField
            ]
        };
        return FormField.sketch({
            dom: {
                tag: 'div',
                classes: [
                    'tox-form__group'
                ]
            },
            components: flatten1([
                pLabel.toArray(),
                [
                    listBoxWrap
                ]
            ]),
            fieldBehaviours: derive$1([
                Disabling.config({
                    disabled: constant$1(!spec.enabled),
                    onDisabled: (comp)=>{
                        FormField.getField(comp).each(Disabling.disable);
                    },
                    onEnabled: (comp)=>{
                        FormField.getField(comp).each(Disabling.enable);
                    }
                })
            ])
        });
    };
    const renderPanel = (spec, backstage)=>({
            dom: {
                tag: 'div',
                classes: spec.classes
            },
            components: map$2(spec.items, backstage.shared.interpreter)
        })
    ;
    const factory$f = (detail, _spec)=>{
        const options = map$2(detail.options, (option)=>({
                dom: {
                    tag: 'option',
                    value: option.value,
                    innerHtml: option.text
                }
            })
        );
        const initialValues = detail.data.map((v)=>wrap$1('initialValue', v)
        ).getOr({});
        return {
            uid: detail.uid,
            dom: {
                tag: 'select',
                classes: detail.selectClasses,
                attributes: detail.selectAttributes
            },
            components: options,
            behaviours: augment(detail.selectBehaviours, [
                Focusing.config({}),
                Representing.config({
                    store: {
                        mode: 'manual',
                        getValue: (select)=>{
                            return get$6(select.element);
                        },
                        setValue: (select, newValue)=>{
                            const found = find$5(detail.options, (opt)=>opt.value === newValue
                            );
                            if (found.isSome()) set$5(select.element, newValue);
                        },
                        ...initialValues
                    }
                })
            ])
        };
    };
    const HtmlSelect = single({
        name: 'HtmlSelect',
        configFields: [
            required$1('options'),
            field1('selectBehaviours', [
                Focusing,
                Representing
            ]),
            defaulted('selectClasses', []),
            defaulted('selectAttributes', {}),
            option$3('data')
        ],
        factory: factory$f
    });
    const renderSelectBox = (spec, providersBackstage, initialData)=>{
        const translatedOptions = map$2(spec.items, (item)=>({
                text: providersBackstage.translate(item.text),
                value: item.value
            })
        );
        const pLabel = spec.label.map((label)=>renderLabel$2(label, providersBackstage)
        );
        const pField = FormField.parts.field({
            dom: {},
            ...initialData.map((data)=>({
                    data
                })
            ).getOr({}),
            selectAttributes: {
                size: spec.size
            },
            options: translatedOptions,
            factory: HtmlSelect,
            selectBehaviours: derive$1([
                Disabling.config({
                    disabled: ()=>!spec.enabled || providersBackstage.isDisabled()
                }),
                Tabstopping.config({}),
                config1('selectbox-change', [
                    run$1(change1(), (component, _)=>{
                        emitWith(component, formChangeEvent, {
                            name: spec.name
                        });
                    })
                ])
            ])
        });
        const chevron = spec.size > 1 ? Optional.none() : Optional.some(render$3('chevron-down', {
            tag: 'div',
            classes: [
                'tox-selectfield__icon-js'
            ]
        }, providersBackstage.icons));
        const selectWrap = {
            dom: {
                tag: 'div',
                classes: [
                    'tox-selectfield'
                ]
            },
            components: flatten1([
                [
                    pField
                ],
                chevron.toArray()
            ])
        };
        return FormField.sketch({
            dom: {
                tag: 'div',
                classes: [
                    'tox-form__group'
                ]
            },
            components: flatten1([
                pLabel.toArray(),
                [
                    selectWrap
                ]
            ]),
            fieldBehaviours: derive$1([
                Disabling.config({
                    disabled: ()=>!spec.enabled || providersBackstage.isDisabled()
                    ,
                    onDisabled: (comp)=>{
                        FormField.getField(comp).each(Disabling.disable);
                    },
                    onEnabled: (comp)=>{
                        FormField.getField(comp).each(Disabling.enable);
                    }
                }),
                receivingConfig()
            ])
        });
    };
    const schema$h = constant$1([
        defaulted('field1Name', 'field1'),
        defaulted('field2Name', 'field2'),
        onStrictHandler('onLockedChange'),
        markers$1([
            'lockClass'
        ]),
        defaulted('locked', false),
        SketchBehaviours.field('coupledFieldBehaviours', [
            Composing,
            Representing
        ])
    ]);
    const getField = (comp, detail, partName)=>getPart(comp, detail, partName).bind(Composing.getCurrent)
    ;
    const coupledPart = (selfName, otherName)=>required1({
            factory: FormField,
            name: selfName,
            overrides: (detail)=>{
                return {
                    fieldBehaviours: derive$1([
                        config1('coupled-input-behaviour', [
                            run$1(input1(), (me)=>{
                                getField(me, detail, otherName).each((other)=>{
                                    getPart(me, detail, 'lock').each((lock)=>{
                                        if (Toggling.isOn(lock)) detail.onLockedChange(me, other, lock);
                                    });
                                });
                            })
                        ])
                    ])
                };
            }
        })
    ;
    const parts$c = constant$1([
        coupledPart('field1', 'field2'),
        coupledPart('field2', 'field1'),
        required1({
            factory: Button,
            schema: [
                required$1('dom')
            ],
            name: 'lock',
            overrides: (detail)=>{
                return {
                    buttonBehaviours: derive$1([
                        Toggling.config({
                            selected: detail.locked,
                            toggleClass: detail.markers.lockClass,
                            aria: {
                                mode: 'pressed'
                            }
                        })
                    ])
                };
            }
        })
    ]);
    const factory$e = (detail, components, _spec, _externals)=>({
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: SketchBehaviours.augment(detail.coupledFieldBehaviours, [
                Composing.config({
                    find: Optional.some
                }),
                Representing.config({
                    store: {
                        mode: 'manual',
                        getValue: (comp)=>{
                            const parts = getPartsOrDie(comp, detail, [
                                'field1',
                                'field2'
                            ]);
                            return {
                                [detail.field1Name]: Representing.getValue(parts.field1()),
                                [detail.field2Name]: Representing.getValue(parts.field2())
                            };
                        },
                        setValue: (comp, value)=>{
                            const parts = getPartsOrDie(comp, detail, [
                                'field1',
                                'field2'
                            ]);
                            if (hasNonNullableKey(value, detail.field1Name)) Representing.setValue(parts.field1(), value[detail.field1Name]);
                            if (hasNonNullableKey(value, detail.field2Name)) Representing.setValue(parts.field2(), value[detail.field2Name]);
                        }
                    }
                })
            ]),
            apis: {
                getField1: (component)=>getPart(component, detail, 'field1')
                ,
                getField2: (component)=>getPart(component, detail, 'field2')
                ,
                getLock: (component)=>getPart(component, detail, 'lock')
            }
        })
    ;
    const FormCoupledInputs = composite({
        name: 'FormCoupledInputs',
        configFields: schema$h(),
        partFields: parts$c(),
        factory: factory$e,
        apis: {
            getField1: (apis, component)=>apis.getField1(component)
            ,
            getField2: (apis, component)=>apis.getField2(component)
            ,
            getLock: (apis, component)=>apis.getLock(component)
        }
    });
    const formatSize = (size)=>{
        const unitDec = {
            '': 0,
            'px': 0,
            'pt': 1,
            'mm': 1,
            'pc': 2,
            'ex': 2,
            'em': 2,
            'ch': 2,
            'rem': 2,
            'cm': 3,
            'in': 4,
            '%': 4
        };
        const maxDecimal = (unit)=>unit in unitDec ? unitDec[unit] : 1
        ;
        let numText = size.value.toFixed(maxDecimal(size.unit));
        if (numText.indexOf('.') !== -1) numText = numText.replace(/\.?0*$/, '');
        return numText + size.unit;
    };
    const parseSize = (sizeText)=>{
        const numPattern = /^\s*(\d+(?:\.\d+)?)\s*(|cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|vmin|vmax|%)\s*$/;
        const match = numPattern.exec(sizeText);
        if (match !== null) {
            const value = parseFloat(match[1]);
            const unit = match[2];
            return Result.value({
                value,
                unit
            });
        } else return Result.error(sizeText);
    };
    const convertUnit = (size, unit)=>{
        const inInch = {
            '': 96,
            'px': 96,
            'pt': 72,
            'cm': 2.54,
            'pc': 12,
            'mm': 25.4,
            'in': 1
        };
        const supported = (u)=>has$2(inInch, u)
        ;
        if (size.unit === unit) return Optional.some(size.value);
        else if (supported(size.unit) && supported(unit)) {
            if (inInch[size.unit] === inInch[unit]) return Optional.some(size.value);
            else return Optional.some(size.value / inInch[size.unit] * inInch[unit]);
        } else return Optional.none();
    };
    const noSizeConversion = (_input)=>Optional.none()
    ;
    const ratioSizeConversion = (scale, unit)=>(size)=>convertUnit(size, unit).map((value)=>({
                    value: value * scale,
                    unit
                })
            )
    ;
    const makeRatioConverter = (currentFieldText, otherFieldText)=>{
        const cValue = parseSize(currentFieldText).toOptional();
        const oValue = parseSize(otherFieldText).toOptional();
        return lift2(cValue, oValue, (cSize, oSize)=>convertUnit(cSize, oSize.unit).map((val)=>oSize.value / val
            ).map((r)=>ratioSizeConversion(r, oSize.unit)
            ).getOr(noSizeConversion)
        ).getOr(noSizeConversion);
    };
    const renderSizeInput = (spec, providersBackstage)=>{
        let converter = noSizeConversion;
        const ratioEvent = generate$6('ratio-event');
        const makeIcon = (iconName)=>render$3(iconName, {
                tag: 'span',
                classes: [
                    'tox-icon',
                    'tox-lock-icon__' + iconName
                ]
            }, providersBackstage.icons)
        ;
        const pLock = FormCoupledInputs.parts.lock({
            dom: {
                tag: 'button',
                classes: [
                    'tox-lock',
                    'tox-button',
                    'tox-button--naked',
                    'tox-button--icon'
                ],
                attributes: {
                    title: providersBackstage.translate(spec.label.getOr('Constrain proportions'))
                }
            },
            components: [
                makeIcon('lock'),
                makeIcon('unlock')
            ],
            buttonBehaviours: derive$1([
                Disabling.config({
                    disabled: ()=>!spec.enabled || providersBackstage.isDisabled()
                }),
                receivingConfig(),
                Tabstopping.config({})
            ])
        });
        const formGroup = (components)=>({
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-form__group'
                    ]
                },
                components
            })
        ;
        const getFieldPart = (isField1)=>FormField.parts.field({
                factory: Input,
                inputClasses: [
                    'tox-textfield'
                ],
                inputBehaviours: derive$1([
                    Disabling.config({
                        disabled: ()=>!spec.enabled || providersBackstage.isDisabled()
                    }),
                    receivingConfig(),
                    Tabstopping.config({}),
                    config1('size-input-events', [
                        run$1(focusin(), (component, _simulatedEvent)=>{
                            emitWith(component, ratioEvent, {
                                isField1
                            });
                        }),
                        run$1(change1(), (component, _simulatedEvent)=>{
                            emitWith(component, formChangeEvent, {
                                name: spec.name
                            });
                        })
                    ])
                ]),
                selectOnFocus: false
            })
        ;
        const getLabel = (label)=>({
                dom: {
                    tag: 'label',
                    classes: [
                        'tox-label'
                    ]
                },
                components: [
                    text$1(providersBackstage.translate(label))
                ]
            })
        ;
        const widthField = FormCoupledInputs.parts.field1(formGroup([
            FormField.parts.label(getLabel('Width')),
            getFieldPart(true)
        ]));
        const heightField = FormCoupledInputs.parts.field2(formGroup([
            FormField.parts.label(getLabel('Height')),
            getFieldPart(false)
        ]));
        return FormCoupledInputs.sketch({
            dom: {
                tag: 'div',
                classes: [
                    'tox-form__group'
                ]
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: [
                            'tox-form__controls-h-stack'
                        ]
                    },
                    components: [
                        widthField,
                        heightField,
                        formGroup([
                            getLabel(nbsp),
                            pLock
                        ])
                    ]
                }
            ],
            field1Name: 'width',
            field2Name: 'height',
            locked: true,
            markers: {
                lockClass: 'tox-locked'
            },
            onLockedChange: (current, other, _lock)=>{
                parseSize(Representing.getValue(current)).each((size)=>{
                    converter(size).each((newSize)=>{
                        Representing.setValue(other, formatSize(newSize));
                    });
                });
            },
            coupledFieldBehaviours: derive$1([
                Disabling.config({
                    disabled: ()=>!spec.enabled || providersBackstage.isDisabled()
                    ,
                    onDisabled: (comp)=>{
                        FormCoupledInputs.getField1(comp).bind(FormField.getField).each(Disabling.disable);
                        FormCoupledInputs.getField2(comp).bind(FormField.getField).each(Disabling.disable);
                        FormCoupledInputs.getLock(comp).each(Disabling.disable);
                    },
                    onEnabled: (comp)=>{
                        FormCoupledInputs.getField1(comp).bind(FormField.getField).each(Disabling.enable);
                        FormCoupledInputs.getField2(comp).bind(FormField.getField).each(Disabling.enable);
                        FormCoupledInputs.getLock(comp).each(Disabling.enable);
                    }
                }),
                receivingConfig(),
                config1('size-input-events2', [
                    run$1(ratioEvent, (component, simulatedEvent)=>{
                        const isField1 = simulatedEvent.event.isField1;
                        const optCurrent = isField1 ? FormCoupledInputs.getField1(component) : FormCoupledInputs.getField2(component);
                        const optOther = isField1 ? FormCoupledInputs.getField2(component) : FormCoupledInputs.getField1(component);
                        const value1 = optCurrent.map(Representing.getValue).getOr('');
                        const value2 = optOther.map(Representing.getValue).getOr('');
                        converter = makeRatioConverter(value1, value2);
                    })
                ])
            ])
        });
    };
    const renderSlider = (spec, providerBackstage, initialData)=>{
        const labelPart = Slider.parts.label({
            dom: {
                tag: 'label',
                classes: [
                    'tox-label'
                ]
            },
            components: [
                text$1(providerBackstage.translate(spec.label))
            ]
        });
        const spectrum = Slider.parts.spectrum({
            dom: {
                tag: 'div',
                classes: [
                    'tox-slider__rail'
                ],
                attributes: {
                    role: 'presentation'
                }
            }
        });
        const thumb = Slider.parts.thumb({
            dom: {
                tag: 'div',
                classes: [
                    'tox-slider__handle'
                ],
                attributes: {
                    role: 'presentation'
                }
            }
        });
        return Slider.sketch({
            dom: {
                tag: 'div',
                classes: [
                    'tox-slider'
                ],
                attributes: {
                    role: 'presentation'
                }
            },
            model: {
                mode: 'x',
                minX: spec.min,
                maxX: spec.max,
                getInitialValue: constant$1(initialData.getOrThunk(()=>(Math.abs(spec.max) - Math.abs(spec.min)) / 2
                ))
            },
            components: [
                labelPart,
                spectrum,
                thumb
            ],
            sliderBehaviours: derive$1([
                ComposingConfigs.self(),
                Focusing.config({})
            ]),
            onChoose: (component, thumb, value)=>{
                emitWith(component, formChangeEvent, {
                    name: spec.name,
                    value
                });
            }
        });
    };
    const renderTable = (spec, providersBackstage)=>{
        const renderTh = (text)=>({
                dom: {
                    tag: 'th',
                    innerHtml: providersBackstage.translate(text)
                }
            })
        ;
        const renderHeader = (header)=>({
                dom: {
                    tag: 'thead'
                },
                components: [
                    {
                        dom: {
                            tag: 'tr'
                        },
                        components: map$2(header, renderTh)
                    }
                ]
            })
        ;
        const renderTd = (text)=>({
                dom: {
                    tag: 'td',
                    innerHtml: providersBackstage.translate(text)
                }
            })
        ;
        const renderTr = (row)=>({
                dom: {
                    tag: 'tr'
                },
                components: map$2(row, renderTd)
            })
        ;
        const renderRows = (rows)=>({
                dom: {
                    tag: 'tbody'
                },
                components: map$2(rows, renderTr)
            })
        ;
        return {
            dom: {
                tag: 'table',
                classes: [
                    'tox-dialog__table'
                ]
            },
            components: [
                renderHeader(spec.header),
                renderRows(spec.cells)
            ],
            behaviours: derive$1([
                Tabstopping.config({}),
                Focusing.config({})
            ])
        };
    };
    const renderTextField1 = (spec, providersBackstage)=>{
        const pLabel = spec.label.map((label)=>renderLabel$2(label, providersBackstage)
        );
        const baseInputBehaviours = [
            Disabling.config({
                disabled: ()=>spec.disabled || providersBackstage.isDisabled()
            }),
            receivingConfig(),
            Keying.config({
                mode: 'execution',
                useEnter: spec.multiline !== true,
                useControlEnter: spec.multiline === true,
                execute: (comp)=>{
                    emit(comp, formSubmitEvent);
                    return Optional.some(true);
                }
            }),
            config1('textfield-change', [
                run$1(input1(), (component, _)=>{
                    emitWith(component, formChangeEvent, {
                        name: spec.name
                    });
                }),
                run$1(postPaste(), (component, _)=>{
                    emitWith(component, formChangeEvent, {
                        name: spec.name
                    });
                })
            ]),
            Tabstopping.config({})
        ];
        const validatingBehaviours = spec.validation.map((vl)=>Invalidating.config({
                getRoot: (input)=>{
                    return parentElement(input.element);
                },
                invalidClass: 'tox-invalid',
                validator: {
                    validate: (input)=>{
                        const v = Representing.getValue(input);
                        const result = vl.validator(v);
                        return Future.pure(result === true ? Result.value(v) : Result.error(result));
                    },
                    validateOnLoad: vl.validateOnLoad
                }
            })
        ).toArray();
        const placeholder = spec.placeholder.fold(constant$1({}), (p)=>({
                placeholder: providersBackstage.translate(p)
            })
        );
        const inputMode = spec.inputMode.fold(constant$1({}), (mode)=>({
                inputmode: mode
            })
        );
        const inputAttributes = {
            ...placeholder,
            ...inputMode
        };
        const pField = FormField.parts.field({
            tag: spec.multiline === true ? 'textarea' : 'input',
            ...spec.data.map((data)=>({
                    data
                })
            ).getOr({}),
            inputAttributes,
            inputClasses: [
                spec.classname
            ],
            inputBehaviours: derive$1(flatten1([
                baseInputBehaviours,
                validatingBehaviours
            ])),
            selectOnFocus: false,
            factory: Input
        });
        const extraClasses = spec.flex ? [
            'tox-form__group--stretched'
        ] : [];
        const extraClasses2 = extraClasses.concat(spec.maximized ? [
            'tox-form-group--maximize'
        ] : []);
        const extraBehaviours = [
            Disabling.config({
                disabled: ()=>spec.disabled || providersBackstage.isDisabled()
                ,
                onDisabled: (comp)=>{
                    FormField.getField(comp).each(Disabling.disable);
                },
                onEnabled: (comp)=>{
                    FormField.getField(comp).each(Disabling.enable);
                }
            }),
            receivingConfig()
        ];
        return renderFormFieldWith(pLabel, pField, extraClasses2, extraBehaviours);
    };
    const renderInput = (spec, providersBackstage, initialData)=>renderTextField1({
            name: spec.name,
            multiline: false,
            label: spec.label,
            inputMode: spec.inputMode,
            placeholder: spec.placeholder,
            flex: false,
            disabled: !spec.enabled,
            classname: 'tox-textfield',
            validation: Optional.none(),
            maximized: spec.maximized,
            data: initialData
        }, providersBackstage)
    ;
    const renderTextarea = (spec, providersBackstage, initialData)=>renderTextField1({
            name: spec.name,
            multiline: true,
            label: spec.label,
            inputMode: Optional.none(),
            placeholder: spec.placeholder,
            flex: true,
            disabled: !spec.enabled,
            classname: 'tox-textarea',
            validation: Optional.none(),
            maximized: spec.maximized,
            data: initialData
        }, providersBackstage)
    ;
    const events$6 = (streamConfig, streamState)=>{
        const streams = streamConfig.stream.streams;
        const processor = streams.setup(streamConfig, streamState);
        return derive$2([
            run$1(streamConfig.event, processor),
            runOnDetached(()=>streamState.cancel()
            )
        ].concat(streamConfig.cancelEvent.map((e)=>[
                run$1(e, ()=>streamState.cancel()
                )
            ]
        ).getOr([])));
    };
    var ActiveStreaming = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        events: events$6
    });
    const first1 = (fn, rate)=>{
        let timer = null;
        const cancel = ()=>{
            if (!isNull(timer)) {
                clearTimeout(timer);
                timer = null;
            }
        };
        const throttle = (...args)=>{
            if (isNull(timer)) timer = setTimeout(()=>{
                timer = null;
                fn.apply(null, args);
            }, rate);
        };
        return {
            cancel,
            throttle
        };
    };
    const last1 = (fn, rate)=>{
        let timer = null;
        const cancel = ()=>{
            if (!isNull(timer)) {
                clearTimeout(timer);
                timer = null;
            }
        };
        const throttle = (...args)=>{
            cancel();
            timer = setTimeout(()=>{
                timer = null;
                fn.apply(null, args);
            }, rate);
        };
        return {
            cancel,
            throttle
        };
    };
    const throttle1 = (_config)=>{
        const state = Cell(null);
        const readState = ()=>({
                timer: state.get() !== null ? 'set' : 'unset'
            })
        ;
        const setTimer = (t)=>{
            state.set(t);
        };
        const cancel = ()=>{
            const t = state.get();
            if (t !== null) t.cancel();
        };
        return nu$8({
            readState,
            setTimer,
            cancel
        });
    };
    const init$9 = (spec)=>spec.stream.streams.state(spec)
    ;
    var StreamingState = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        throttle: throttle1,
        init: init$9
    });
    const setup$c = (streamInfo, streamState)=>{
        const sInfo = streamInfo.stream;
        const throttler = last1(streamInfo.onStream, sInfo.delay);
        streamState.setTimer(throttler);
        return (component, simulatedEvent)=>{
            throttler.throttle(component, simulatedEvent);
            if (sInfo.stopEvent) simulatedEvent.stop();
        };
    };
    var StreamingSchema = [
        requiredOf('stream', choose$1('mode', {
            throttle: [
                required$1('delay'),
                defaulted('stopEvent', true),
                output$1('streams', {
                    setup: setup$c,
                    state: throttle1
                })
            ]
        })),
        defaulted('event', 'input'),
        option$3('cancelEvent'),
        onStrictHandler('onStream')
    ];
    const Streaming = create$3({
        fields: StreamingSchema,
        name: 'streaming',
        active: ActiveStreaming,
        state: StreamingState
    });
    const setValueFromItem = (model, input, item)=>{
        const itemData = Representing.getValue(item);
        Representing.setValue(input, itemData);
        setCursorAtEnd(input);
    };
    const setSelectionOn = (input, f)=>{
        const el = input.element;
        const value = get$6(el);
        const node = el.dom;
        if (get$f(el, 'type') !== 'number') f(node, value);
    };
    const setCursorAtEnd = (input)=>{
        setSelectionOn(input, (node, value)=>node.setSelectionRange(value.length, value.length)
        );
    };
    const setSelectionToEnd = (input, startOffset)=>{
        setSelectionOn(input, (node, value)=>node.setSelectionRange(startOffset, value.length)
        );
    };
    const attemptSelectOver = (model, input, item)=>{
        if (!model.selectsOver) return Optional.none();
        else {
            const currentValue = Representing.getValue(input);
            const inputDisplay = model.getDisplayText(currentValue);
            const itemValue = Representing.getValue(item);
            const itemDisplay = model.getDisplayText(itemValue);
            return itemDisplay.indexOf(inputDisplay) === 0 ? Optional.some(()=>{
                setValueFromItem(model, input, item);
                setSelectionToEnd(input, inputDisplay.length);
            }) : Optional.none();
        }
    };
    const itemExecute = constant$1('alloy.typeahead.itemexecute');
    const make$3 = (detail, components, spec, externals)=>{
        const navigateList = (comp, simulatedEvent, highlighter)=>{
            detail.previewing.set(false);
            const sandbox1 = Coupling.getCoupled(comp, 'sandbox');
            if (Sandboxing.isOpen(sandbox1)) Composing.getCurrent(sandbox1).each((menu)=>{
                Highlighting.getHighlighted(menu).fold(()=>{
                    highlighter(menu);
                }, ()=>{
                    dispatchEvent(sandbox1, menu.element, 'keydown', simulatedEvent);
                });
            });
            else {
                const onOpenSync = (sandbox)=>{
                    Composing.getCurrent(sandbox).each(highlighter);
                };
                open1(detail, mapFetch(comp), comp, sandbox1, externals, onOpenSync, HighlightOnOpen1.HighlightFirst).get(noop);
            }
        };
        const focusBehaviours$1 = focusBehaviours(detail);
        const mapFetch = (comp)=>(tdata)=>tdata.map((data)=>{
                    const menus = values1(data.menus);
                    const items = bind$3(menus, (menu)=>filter$2(menu.items, (item)=>item.type === 'item'
                        )
                    );
                    const repState = Representing.getState(comp);
                    repState.update(map$2(items, (item)=>item.data
                    ));
                    return data;
                })
        ;
        const behaviours = [
            Focusing.config({}),
            Representing.config({
                onSetValue: detail.onSetValue,
                store: {
                    mode: 'dataset',
                    getDataKey: (comp)=>get$6(comp.element)
                    ,
                    getFallbackEntry: (itemString)=>({
                            value: itemString,
                            meta: {}
                        })
                    ,
                    setValue: (comp, data)=>{
                        set$5(comp.element, detail.model.getDisplayText(data));
                    },
                    ...detail.initialData.map((d)=>wrap$1('initialValue', d)
                    ).getOr({})
                }
            }),
            Streaming.config({
                stream: {
                    mode: 'throttle',
                    delay: detail.responseTime,
                    stopEvent: false
                },
                onStream: (component, _simulatedEvent)=>{
                    const sandbox = Coupling.getCoupled(component, 'sandbox');
                    const focusInInput = Focusing.isFocused(component);
                    if (focusInInput) {
                        if (get$6(component.element).length >= detail.minChars) {
                            const previousValue = Composing.getCurrent(sandbox).bind((menu)=>Highlighting.getHighlighted(menu).map(Representing.getValue)
                            );
                            detail.previewing.set(true);
                            const onOpenSync = (_sandbox)=>{
                                Composing.getCurrent(sandbox).each((menu)=>{
                                    previousValue.fold(()=>{
                                        if (detail.model.selectsOver) Highlighting.highlightFirst(menu);
                                    }, (pv)=>{
                                        Highlighting.highlightBy(menu, (item)=>{
                                            const itemData = Representing.getValue(item);
                                            return itemData.value === pv.value;
                                        });
                                        Highlighting.getHighlighted(menu).orThunk(()=>{
                                            Highlighting.highlightFirst(menu);
                                            return Optional.none();
                                        });
                                    });
                                });
                            };
                            open1(detail, mapFetch(component), component, sandbox, externals, onOpenSync, HighlightOnOpen1.HighlightFirst).get(noop);
                        }
                    }
                },
                cancelEvent: typeaheadCancel()
            }),
            Keying.config({
                mode: 'special',
                onDown: (comp, simulatedEvent)=>{
                    navigateList(comp, simulatedEvent, Highlighting.highlightFirst);
                    return Optional.some(true);
                },
                onEscape: (comp)=>{
                    const sandbox = Coupling.getCoupled(comp, 'sandbox');
                    if (Sandboxing.isOpen(sandbox)) {
                        Sandboxing.close(sandbox);
                        return Optional.some(true);
                    }
                    return Optional.none();
                },
                onUp: (comp, simulatedEvent)=>{
                    navigateList(comp, simulatedEvent, Highlighting.highlightLast);
                    return Optional.some(true);
                },
                onEnter: (comp)=>{
                    const sandbox = Coupling.getCoupled(comp, 'sandbox');
                    const sandboxIsOpen = Sandboxing.isOpen(sandbox);
                    if (sandboxIsOpen && !detail.previewing.get()) return Composing.getCurrent(sandbox).bind((menu)=>Highlighting.getHighlighted(menu)
                    ).map((item)=>{
                        emitWith(comp, itemExecute(), {
                            item
                        });
                        return true;
                    });
                    else {
                        const currentValue = Representing.getValue(comp);
                        emit(comp, typeaheadCancel());
                        detail.onExecute(sandbox, comp, currentValue);
                        if (sandboxIsOpen) Sandboxing.close(sandbox);
                        return Optional.some(true);
                    }
                }
            }),
            Toggling.config({
                toggleClass: detail.markers.openClass,
                aria: {
                    mode: 'expanded'
                }
            }),
            Coupling.config({
                others: {
                    sandbox: (hotspot)=>{
                        return makeSandbox$1(detail, hotspot, {
                            onOpen: ()=>Toggling.on(hotspot)
                            ,
                            onClose: ()=>Toggling.off(hotspot)
                        });
                    }
                }
            }),
            config1('typeaheadevents', [
                runOnExecute$1((comp)=>{
                    const onOpenSync = noop;
                    togglePopup(detail, mapFetch(comp), comp, externals, onOpenSync, HighlightOnOpen1.HighlightFirst).get(noop);
                }),
                run$1(itemExecute(), (comp, se)=>{
                    const sandbox = Coupling.getCoupled(comp, 'sandbox');
                    setValueFromItem(detail.model, comp, se.event.item);
                    emit(comp, typeaheadCancel());
                    detail.onItemExecute(comp, sandbox, se.event.item, Representing.getValue(comp));
                    Sandboxing.close(sandbox);
                    setCursorAtEnd(comp);
                })
            ].concat(detail.dismissOnBlur ? [
                run$1(postBlur(), (typeahead)=>{
                    const sandbox = Coupling.getCoupled(typeahead, 'sandbox');
                    if (search1(sandbox.element).isNone()) Sandboxing.close(sandbox);
                })
            ] : []))
        ];
        return {
            uid: detail.uid,
            dom: dom1(deepMerge(detail, {
                inputAttributes: {
                    'role': 'combobox',
                    'aria-autocomplete': 'list',
                    'aria-haspopup': 'true'
                }
            })),
            behaviours: {
                ...focusBehaviours$1,
                ...augment(detail.typeaheadBehaviours, behaviours)
            },
            eventOrder: detail.eventOrder
        };
    };
    const schema$g = constant$1([
        option$3('lazySink'),
        required$1('fetch'),
        defaulted('minChars', 5),
        defaulted('responseTime', 1000),
        onHandler('onOpen'),
        defaulted('getHotspot', Optional.some),
        defaulted('getAnchorOverrides', constant$1({})),
        defaulted('layouts', Optional.none()),
        defaulted('eventOrder', {}),
        defaultedObjOf('model', {}, [
            defaulted('getDisplayText', (itemData)=>itemData.meta !== undefined && itemData.meta.text !== undefined ? itemData.meta.text : itemData.value
            ),
            defaulted('selectsOver', true),
            defaulted('populateFromBrowse', true)
        ]),
        onHandler('onSetValue'),
        onKeyboardHandler('onExecute'),
        onHandler('onItemExecute'),
        defaulted('inputClasses', []),
        defaulted('inputAttributes', {}),
        defaulted('inputStyles', {}),
        defaulted('matchWidth', true),
        defaulted('useMinWidth', false),
        defaulted('dismissOnBlur', true),
        markers$1([
            'openClass'
        ]),
        option$3('initialData'),
        field1('typeaheadBehaviours', [
            Focusing,
            Representing,
            Streaming,
            Keying,
            Toggling,
            Coupling
        ]),
        customField('previewing', ()=>Cell(true)
        )
    ].concat(schema$k()).concat(sandboxFields()));
    const parts$b = constant$1([
        external({
            schema: [
                tieredMenuMarkers()
            ],
            name: 'menu',
            overrides: (detail)=>{
                return {
                    fakeFocus: true,
                    onHighlight: (menu, item)=>{
                        if (!detail.previewing.get()) menu.getSystem().getByUid(detail.uid).each((input)=>{
                            if (detail.model.populateFromBrowse) setValueFromItem(detail.model, input, item);
                        });
                        else menu.getSystem().getByUid(detail.uid).each((input)=>{
                            attemptSelectOver(detail.model, input, item).fold(()=>Highlighting.dehighlight(menu, item)
                            , (fn)=>fn()
                            );
                        });
                        detail.previewing.set(false);
                    },
                    onExecute: (menu, item)=>{
                        return menu.getSystem().getByUid(detail.uid).toOptional().map((typeahead)=>{
                            emitWith(typeahead, itemExecute(), {
                                item
                            });
                            return true;
                        });
                    },
                    onHover: (menu, item)=>{
                        detail.previewing.set(false);
                        menu.getSystem().getByUid(detail.uid).each((input)=>{
                            if (detail.model.populateFromBrowse) setValueFromItem(detail.model, input, item);
                        });
                    }
                };
            }
        })
    ]);
    const Typeahead = composite({
        name: 'Typeahead',
        configFields: schema$g(),
        partFields: parts$b(),
        factory: make$3
    });
    const wrap = (delegate)=>{
        const toCached = ()=>{
            return wrap(delegate.toCached());
        };
        const bindFuture = (f)=>{
            return wrap(delegate.bind((resA)=>resA.fold((err)=>Future.pure(Result.error(err))
                , (a)=>f(a)
                )
            ));
        };
        const bindResult = (f)=>{
            return wrap(delegate.map((resA)=>resA.bind(f)
            ));
        };
        const mapResult = (f)=>{
            return wrap(delegate.map((resA)=>resA.map(f)
            ));
        };
        const mapError = (f)=>{
            return wrap(delegate.map((resA)=>resA.mapError(f)
            ));
        };
        const foldResult = (whenError, whenValue)=>{
            return delegate.map((res)=>res.fold(whenError, whenValue)
            );
        };
        const withTimeout = (timeout, errorThunk)=>{
            return wrap(Future.nu((callback)=>{
                let timedOut = false;
                const timer = setTimeout(()=>{
                    timedOut = true;
                    callback(Result.error(errorThunk()));
                }, timeout);
                delegate.get((result)=>{
                    if (!timedOut) {
                        clearTimeout(timer);
                        callback(result);
                    }
                });
            }));
        };
        return {
            ...delegate,
            toCached,
            bindFuture,
            bindResult,
            mapResult,
            mapError,
            foldResult,
            withTimeout
        };
    };
    const nu$1 = (worker)=>{
        return wrap(Future.nu(worker));
    };
    const value1 = (value)=>{
        return wrap(Future.pure(Result.value(value)));
    };
    const error1 = (error)=>{
        return wrap(Future.pure(Result.error(error)));
    };
    const fromResult = (result)=>{
        return wrap(Future.pure(result));
    };
    const fromFuture = (future)=>{
        return wrap(future.map(Result.value));
    };
    const fromPromise = (promise)=>{
        return nu$1((completer)=>{
            promise.then((value)=>{
                completer(Result.value(value));
            }, (error)=>{
                completer(Result.error(error));
            });
        });
    };
    const FutureResult = {
        nu: nu$1,
        wrap,
        pure: value1,
        value: value1,
        error: error1,
        fromResult,
        fromFuture,
        fromPromise
    };
    const getMenuButtonApi = (component)=>({
            isEnabled: ()=>!Disabling.isDisabled(component)
            ,
            setEnabled: (state)=>Disabling.set(component, !state)
            ,
            setActive: (state)=>{
                const elm = component.element;
                if (state) {
                    add$2(elm, 'tox-tbtn--enabled');
                    set$9(elm, 'aria-pressed', true);
                } else {
                    remove$2(elm, 'tox-tbtn--enabled');
                    remove$7(elm, 'aria-pressed');
                }
            },
            isActive: ()=>has(component.element, 'tox-tbtn--enabled')
        })
    ;
    const renderMenuButton = (spec, prefix, backstage, role)=>renderCommonDropdown({
            text: spec.text,
            icon: spec.icon,
            tooltip: spec.tooltip,
            role,
            fetch: (_comp, callback)=>{
                spec.fetch((items)=>{
                    callback(build1(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, false));
                });
            },
            onSetup: spec.onSetup,
            getApi: getMenuButtonApi,
            columns: 1,
            presets: 'normal',
            classes: [],
            dropdownBehaviours: [
                Tabstopping.config({})
            ]
        }, prefix, backstage.shared)
    ;
    const getFetch1 = (items, getButton, backstage)=>{
        const getMenuItemAction = (item)=>(api)=>{
                const newValue = !api.isActive();
                api.setActive(newValue);
                item.storage.set(newValue);
                backstage.shared.getSink().each((sink)=>{
                    getButton().getOpt(sink).each((orig)=>{
                        focus$3(orig.element);
                        emitWith(orig, formActionEvent, {
                            name: item.name,
                            value: item.storage.get()
                        });
                    });
                });
            }
        ;
        const getMenuItemSetup = (item)=>(api)=>{
                api.setActive(item.storage.get());
            }
        ;
        return (success)=>{
            success(map$2(items, (item)=>{
                const text2 = item.text.fold(()=>({})
                , (text)=>({
                        text
                    })
                );
                return {
                    type: item.type,
                    active: false,
                    ...text2,
                    onAction: getMenuItemAction(item),
                    onSetup: getMenuItemSetup(item)
                };
            }));
        };
    };
    const renderCommonSpec = (spec, actionOpt, extraBehaviours = [], dom, components, providersBackstage)=>{
        const action1 = actionOpt.fold(()=>({})
        , (action)=>({
                action
            })
        );
        const common = {
            buttonBehaviours: derive$1([
                DisablingConfigs.button(()=>!spec.enabled || providersBackstage.isDisabled()
                ),
                receivingConfig(),
                Tabstopping.config({}),
                config1('button press', [
                    preventDefault('click'),
                    preventDefault('mousedown')
                ])
            ].concat(extraBehaviours)),
            eventOrder: {
                click: [
                    'button press',
                    'alloy.base.behaviour'
                ],
                mousedown: [
                    'button press',
                    'alloy.base.behaviour'
                ]
            },
            ...action1
        };
        const domFinal = deepMerge(common, {
            dom
        });
        return deepMerge(domFinal, {
            components
        });
    };
    const renderIconButtonSpec = (spec, action, providersBackstage, extraBehaviours = [])=>{
        const tooltipAttributes = spec.tooltip.map((tooltip)=>({
                'aria-label': providersBackstage.translate(tooltip),
                'title': providersBackstage.translate(tooltip)
            })
        ).getOr({});
        const dom = {
            tag: 'button',
            classes: [
                'tox-tbtn'
            ],
            attributes: tooltipAttributes
        };
        const icon = spec.icon.map((iconName)=>renderIconFromPack(iconName, providersBackstage.icons)
        );
        const components = componentRenderPipeline([
            icon
        ]);
        return renderCommonSpec(spec, action, extraBehaviours, dom, components, providersBackstage);
    };
    const calculateClassesFromButtonType = (buttonType)=>{
        switch(buttonType){
            case 'primary':
                return [
                    'tox-button'
                ];
            case 'toolbar':
                return [
                    'tox-tbtn'
                ];
            case 'secondary':
            default:
                return [
                    'tox-button',
                    'tox-button--secondary'
                ];
        }
    };
    const renderButtonSpec = (spec, action, providersBackstage, extraBehaviours = [], extraClasses = [])=>{
        const translatedText = providersBackstage.translate(spec.text);
        const icon = spec.icon.map((iconName)=>renderIconFromPack(iconName, providersBackstage.icons)
        );
        const components = [
            icon.getOrThunk(()=>text$1(translatedText)
            )
        ];
        const buttonType = spec.buttonType.getOr(!spec.primary && !spec.borderless ? 'secondary' : 'primary');
        const baseClasses = calculateClassesFromButtonType(buttonType);
        const classes = [
            ...baseClasses,
            ...icon.isSome() ? [
                'tox-button--icon'
            ] : [],
            ...spec.borderless ? [
                'tox-button--naked'
            ] : [],
            ...extraClasses
        ];
        const dom = {
            tag: 'button',
            classes,
            attributes: {
                title: translatedText
            }
        };
        return renderCommonSpec(spec, action, extraBehaviours, dom, components, providersBackstage);
    };
    const renderButton = (spec, action, providersBackstage, extraBehaviours = [], extraClasses = [])=>{
        const buttonSpec = renderButtonSpec(spec, Optional.some(action), providersBackstage, extraBehaviours, extraClasses);
        return Button.sketch(buttonSpec);
    };
    const getAction = (name, buttonType)=>(comp)=>{
            if (buttonType === 'custom') emitWith(comp, formActionEvent, {
                name,
                value: {}
            });
            else if (buttonType === 'submit') emit(comp, formSubmitEvent);
            else if (buttonType === 'cancel') emit(comp, formCancelEvent);
            else console.error('Unknown button type: ', buttonType);
        }
    ;
    const isMenuFooterButtonSpec = (spec, buttonType)=>buttonType === 'menu'
    ;
    const isNormalFooterButtonSpec = (spec, buttonType)=>buttonType === 'custom' || buttonType === 'cancel' || buttonType === 'submit'
    ;
    const renderFooterButton = (spec, buttonType, backstage)=>{
        if (isMenuFooterButtonSpec(spec, buttonType)) {
            const getButton = ()=>memButton
            ;
            const menuButtonSpec = spec;
            const fixedSpec = {
                ...spec,
                onSetup: (api)=>{
                    api.setEnabled(spec.enabled);
                    return noop;
                },
                fetch: getFetch1(menuButtonSpec.items, getButton, backstage)
            };
            const memButton = record1(renderMenuButton(fixedSpec, 'tox-tbtn', backstage, Optional.none()));
            return memButton.asSpec();
        } else if (isNormalFooterButtonSpec(spec, buttonType)) {
            const action = getAction(spec.name, buttonType);
            const buttonSpec = {
                ...spec,
                borderless: false
            };
            return renderButton(buttonSpec, action, backstage.shared.providers, []);
        } else console.error('Unknown footer button type: ', buttonType);
    };
    const renderDialogButton = (spec, providersBackstage)=>{
        const action = getAction(spec.name, 'custom');
        return renderFormField(Optional.none(), FormField.parts.field({
            factory: Button,
            ...renderButtonSpec(spec, Optional.some(action), providersBackstage, [
                RepresentingConfigs.memory(''),
                ComposingConfigs.self()
            ])
        }));
    };
    const separator$1 = {
        type: 'separator'
    };
    const toMenuItem = (target)=>({
            type: 'menuitem',
            value: target.url,
            text: target.title,
            meta: {
                attach: target.attach
            },
            onAction: noop
        })
    ;
    const staticMenuItem = (title, url)=>({
            type: 'menuitem',
            value: url,
            text: title,
            meta: {
                attach: undefined
            },
            onAction: noop
        })
    ;
    const toMenuItems = (targets)=>map$2(targets, toMenuItem)
    ;
    const filterLinkTargets = (type, targets)=>filter$2(targets, (target)=>target.type === type
        )
    ;
    const filteredTargets = (type, targets)=>toMenuItems(filterLinkTargets(type, targets))
    ;
    const headerTargets = (linkInfo)=>filteredTargets('header', linkInfo.targets)
    ;
    const anchorTargets = (linkInfo)=>filteredTargets('anchor', linkInfo.targets)
    ;
    const anchorTargetTop = (linkInfo)=>Optional.from(linkInfo.anchorTop).map((url)=>staticMenuItem('<top>', url)
        ).toArray()
    ;
    const anchorTargetBottom = (linkInfo)=>Optional.from(linkInfo.anchorBottom).map((url)=>staticMenuItem('<bottom>', url)
        ).toArray()
    ;
    const historyTargets = (history)=>map$2(history, (url)=>staticMenuItem(url, url)
        )
    ;
    const joinMenuLists = (items)=>{
        return foldl(items, (a, b)=>{
            const bothEmpty = a.length === 0 || b.length === 0;
            return bothEmpty ? a.concat(b) : a.concat(separator$1, b);
        }, []);
    };
    const filterByQuery = (term, menuItems)=>{
        const lowerCaseTerm = term.toLowerCase();
        return filter$2(menuItems, (item)=>{
            const text = item.meta !== undefined && item.meta.text !== undefined ? item.meta.text : item.text;
            return contains$1(text.toLowerCase(), lowerCaseTerm) || contains$1(item.value.toLowerCase(), lowerCaseTerm);
        });
    };
    const getItems = (fileType, input, urlBackstage)=>{
        const urlInputValue = Representing.getValue(input);
        const term = urlInputValue.meta.text !== undefined ? urlInputValue.meta.text : urlInputValue.value;
        const info = urlBackstage.getLinkInformation();
        return info.fold(()=>[]
        , (linkInfo)=>{
            const history = filterByQuery(term, historyTargets(urlBackstage.getHistory(fileType)));
            return fileType === 'file' ? joinMenuLists([
                history,
                filterByQuery(term, headerTargets(linkInfo)),
                filterByQuery(term, flatten1([
                    anchorTargetTop(linkInfo),
                    anchorTargets(linkInfo),
                    anchorTargetBottom(linkInfo)
                ]))
            ]) : history;
        });
    };
    const errorId = generate$6('aria-invalid');
    const renderUrlInput = (spec, backstage, urlBackstage, initialData1)=>{
        const providersBackstage = backstage.shared.providers;
        const updateHistory = (component)=>{
            const urlEntry = Representing.getValue(component);
            urlBackstage.addToHistory(urlEntry.value, spec.filetype);
        };
        const pField = FormField.parts.field({
            factory: Typeahead,
            ...initialData1.map((initialData)=>({
                    initialData
                })
            ).getOr({}),
            dismissOnBlur: true,
            inputClasses: [
                'tox-textfield'
            ],
            sandboxClasses: [
                'tox-dialog__popups'
            ],
            inputAttributes: {
                'aria-errormessage': errorId,
                'type': 'url'
            },
            minChars: 0,
            responseTime: 0,
            fetch: (input)=>{
                const items = getItems(spec.filetype, input, urlBackstage);
                const tdata = build1(items, ItemResponse$1.BUBBLE_TO_SANDBOX, backstage, false);
                return Future.pure(tdata);
            },
            getHotspot: (comp)=>memUrlBox.getOpt(comp)
            ,
            onSetValue: (comp, _newValue)=>{
                if (comp.hasConfigured(Invalidating)) Invalidating.run(comp).get(noop);
            },
            typeaheadBehaviours: derive$1(flatten1([
                urlBackstage.getValidationHandler().map((handler)=>Invalidating.config({
                        getRoot: (comp)=>parentElement(comp.element)
                        ,
                        invalidClass: 'tox-control-wrap--status-invalid',
                        notify: {
                            onInvalid: (comp, err)=>{
                                memInvalidIcon.getOpt(comp).each((invalidComp)=>{
                                    set$9(invalidComp.element, 'title', providersBackstage.translate(err));
                                });
                            }
                        },
                        validator: {
                            validate: (input)=>{
                                const urlEntry = Representing.getValue(input);
                                return FutureResult.nu((completer)=>{
                                    handler({
                                        type: spec.filetype,
                                        url: urlEntry.value
                                    }, (validation)=>{
                                        if (validation.status === 'invalid') {
                                            const err = Result.error(validation.message);
                                            completer(err);
                                        } else {
                                            const val = Result.value(validation.message);
                                            completer(val);
                                        }
                                    });
                                });
                            },
                            validateOnLoad: false
                        }
                    })
                ).toArray(),
                [
                    Disabling.config({
                        disabled: ()=>!spec.enabled || providersBackstage.isDisabled()
                    }),
                    Tabstopping.config({}),
                    config1('urlinput-events', flatten1([
                        spec.filetype === 'file' ? [
                            run$1(input1(), (comp)=>{
                                emitWith(comp, formChangeEvent, {
                                    name: spec.name
                                });
                            })
                        ] : [],
                        [
                            run$1(change1(), (comp)=>{
                                emitWith(comp, formChangeEvent, {
                                    name: spec.name
                                });
                                updateHistory(comp);
                            }),
                            run$1(postPaste(), (comp)=>{
                                emitWith(comp, formChangeEvent, {
                                    name: spec.name
                                });
                                updateHistory(comp);
                            })
                        ]
                    ]))
                ]
            ])),
            eventOrder: {
                [input1()]: [
                    'streaming',
                    'urlinput-events',
                    'invalidating'
                ]
            },
            model: {
                getDisplayText: (itemData)=>itemData.value
                ,
                selectsOver: false,
                populateFromBrowse: false
            },
            markers: {
                openClass: 'tox-textfield--popup-open'
            },
            lazySink: backstage.shared.getSink,
            parts: {
                menu: part1(false, 1, 'normal')
            },
            onExecute: (_menu, component, _entry)=>{
                emitWith(component, formSubmitEvent, {});
            },
            onItemExecute: (typeahead, _sandbox, _item, _value)=>{
                updateHistory(typeahead);
                emitWith(typeahead, formChangeEvent, {
                    name: spec.name
                });
            }
        });
        const pLabel = spec.label.map((label)=>renderLabel$2(label, providersBackstage)
        );
        const makeIcon = (name, errId, icon = name, label = name)=>render$3(icon, {
                tag: 'div',
                classes: [
                    'tox-icon',
                    'tox-control-wrap__status-icon-' + name
                ],
                attributes: {
                    'title': providersBackstage.translate(label),
                    'aria-live': 'polite',
                    ...errId.fold(()=>({})
                    , (id)=>({
                            id
                        })
                    )
                }
            }, providersBackstage.icons)
        ;
        const memInvalidIcon = record1(makeIcon('invalid', Optional.some(errorId), 'warning'));
        const memStatus = record1({
            dom: {
                tag: 'div',
                classes: [
                    'tox-control-wrap__status-icon-wrap'
                ]
            },
            components: [
                memInvalidIcon.asSpec()
            ]
        });
        const optUrlPicker = urlBackstage.getUrlPicker(spec.filetype);
        const browseUrlEvent = generate$6('browser.url.event');
        const memUrlBox = record1({
            dom: {
                tag: 'div',
                classes: [
                    'tox-control-wrap'
                ]
            },
            components: [
                pField,
                memStatus.asSpec()
            ],
            behaviours: derive$1([
                Disabling.config({
                    disabled: ()=>!spec.enabled || providersBackstage.isDisabled()
                })
            ])
        });
        const memUrlPickerButton = record1(renderButton({
            name: spec.name,
            icon: Optional.some('browse'),
            text: spec.label.getOr(''),
            enabled: spec.enabled,
            primary: false,
            buttonType: Optional.none(),
            borderless: true
        }, (component)=>emit(component, browseUrlEvent)
        , providersBackstage, [], [
            'tox-browse-url'
        ]));
        const controlHWrapper = ()=>({
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-form__controls-h-stack'
                    ]
                },
                components: flatten1([
                    [
                        memUrlBox.asSpec()
                    ],
                    optUrlPicker.map(()=>memUrlPickerButton.asSpec()
                    ).toArray()
                ])
            })
        ;
        const openUrlPicker = (comp)=>{
            Composing.getCurrent(comp).each((field)=>{
                const componentData = Representing.getValue(field);
                const urlData = {
                    fieldname: spec.name,
                    ...componentData
                };
                optUrlPicker.each((picker)=>{
                    picker(urlData).get((chosenData)=>{
                        Representing.setValue(field, chosenData);
                        emitWith(comp, formChangeEvent, {
                            name: spec.name
                        });
                    });
                });
            });
        };
        return FormField.sketch({
            dom: renderFormFieldDom(),
            components: pLabel.toArray().concat([
                controlHWrapper()
            ]),
            fieldBehaviours: derive$1([
                Disabling.config({
                    disabled: ()=>!spec.enabled || providersBackstage.isDisabled()
                    ,
                    onDisabled: (comp)=>{
                        FormField.getField(comp).each(Disabling.disable);
                        memUrlPickerButton.getOpt(comp).each(Disabling.disable);
                    },
                    onEnabled: (comp)=>{
                        FormField.getField(comp).each(Disabling.enable);
                        memUrlPickerButton.getOpt(comp).each(Disabling.enable);
                    }
                }),
                receivingConfig(),
                config1('url-input-events', [
                    run$1(browseUrlEvent, openUrlPicker)
                ])
            ])
        });
    };
    const renderAlertBanner = (spec, providersBackstage)=>Container.sketch({
            dom: {
                tag: 'div',
                attributes: {
                    role: 'alert'
                },
                classes: [
                    'tox-notification',
                    'tox-notification--in',
                    `tox-notification--${spec.level}`
                ]
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: [
                            'tox-notification__icon'
                        ]
                    },
                    components: [
                        Button.sketch({
                            dom: {
                                tag: 'button',
                                classes: [
                                    'tox-button',
                                    'tox-button--naked',
                                    'tox-button--icon'
                                ],
                                innerHtml: get$2(spec.icon, providersBackstage.icons),
                                attributes: {
                                    title: providersBackstage.translate(spec.iconTooltip)
                                }
                            },
                            action: (comp)=>{
                                emitWith(comp, formActionEvent, {
                                    name: 'alert-banner',
                                    value: spec.url
                                });
                            },
                            buttonBehaviours: derive$1([
                                addFocusableBehaviour()
                            ])
                        })
                    ]
                },
                {
                    dom: {
                        tag: 'div',
                        classes: [
                            'tox-notification__body'
                        ],
                        innerHtml: providersBackstage.translate(spec.text)
                    }
                }
            ]
        })
    ;
    const set$1 = (element, status)=>{
        element.dom.checked = status;
    };
    const get$1 = (element)=>element.dom.checked
    ;
    const renderCheckbox = (spec, providerBackstage, initialData)=>{
        const toggleCheckboxHandler = (comp)=>{
            comp.element.dom.click();
            return Optional.some(true);
        };
        const pField = FormField.parts.field({
            factory: {
                sketch: identity
            },
            dom: {
                tag: 'input',
                classes: [
                    'tox-checkbox__input'
                ],
                attributes: {
                    type: 'checkbox'
                }
            },
            behaviours: derive$1([
                ComposingConfigs.self(),
                Disabling.config({
                    disabled: ()=>!spec.enabled || providerBackstage.isDisabled()
                }),
                Tabstopping.config({}),
                Focusing.config({}),
                RepresentingConfigs.withElement(initialData, get$1, set$1),
                Keying.config({
                    mode: 'special',
                    onEnter: toggleCheckboxHandler,
                    onSpace: toggleCheckboxHandler,
                    stopSpaceKeyup: true
                }),
                config1('checkbox-events', [
                    run$1(change1(), (component, _)=>{
                        emitWith(component, formChangeEvent, {
                            name: spec.name
                        });
                    })
                ])
            ])
        });
        const pLabel = FormField.parts.label({
            dom: {
                tag: 'span',
                classes: [
                    'tox-checkbox__label'
                ]
            },
            components: [
                text$1(providerBackstage.translate(spec.label))
            ],
            behaviours: derive$1([
                Unselecting.config({})
            ])
        });
        const makeIcon = (className)=>{
            const iconName = className === 'checked' ? 'selected' : 'unselected';
            return render$3(iconName, {
                tag: 'span',
                classes: [
                    'tox-icon',
                    'tox-checkbox-icon__' + className
                ]
            }, providerBackstage.icons);
        };
        const memIcons = record1({
            dom: {
                tag: 'div',
                classes: [
                    'tox-checkbox__icons'
                ]
            },
            components: [
                makeIcon('checked'),
                makeIcon('unchecked')
            ]
        });
        return FormField.sketch({
            dom: {
                tag: 'label',
                classes: [
                    'tox-checkbox'
                ]
            },
            components: [
                pField,
                memIcons.asSpec(),
                pLabel
            ],
            fieldBehaviours: derive$1([
                Disabling.config({
                    disabled: ()=>!spec.enabled || providerBackstage.isDisabled()
                    ,
                    disableClass: 'tox-checkbox--disabled',
                    onDisabled: (comp)=>{
                        FormField.getField(comp).each(Disabling.disable);
                    },
                    onEnabled: (comp)=>{
                        FormField.getField(comp).each(Disabling.enable);
                    }
                }),
                receivingConfig()
            ])
        });
    };
    const renderHtmlPanel = (spec)=>{
        if (spec.presets === 'presentation') return Container.sketch({
            dom: {
                tag: 'div',
                classes: [
                    'tox-form__group'
                ],
                innerHtml: spec.html
            }
        });
        else return Container.sketch({
            dom: {
                tag: 'div',
                classes: [
                    'tox-form__group'
                ],
                innerHtml: spec.html,
                attributes: {
                    role: 'document'
                }
            },
            containerBehaviours: derive$1([
                Tabstopping.config({}),
                Focusing.config({})
            ])
        });
    };
    const make$2 = (render)=>{
        return (parts, spec, dialogData, backstage)=>get$g(spec, 'name').fold(()=>render(spec, backstage, Optional.none())
            , (fieldName)=>parts.field(fieldName, render(spec, backstage, get$g(dialogData, fieldName)))
            )
        ;
    };
    const makeIframe = (render)=>(parts, spec, dialogData, backstage)=>{
            const iframeSpec = deepMerge(spec, {
                source: 'dynamic'
            });
            return make$2(render)(parts, iframeSpec, dialogData, backstage);
        }
    ;
    const factories = {
        bar: make$2((spec, backstage)=>renderBar(spec, backstage.shared)
        ),
        collection: make$2((spec, backstage, data)=>renderCollection(spec, backstage.shared.providers, data)
        ),
        alertbanner: make$2((spec, backstage)=>renderAlertBanner(spec, backstage.shared.providers)
        ),
        input: make$2((spec, backstage, data)=>renderInput(spec, backstage.shared.providers, data)
        ),
        textarea: make$2((spec, backstage, data)=>renderTextarea(spec, backstage.shared.providers, data)
        ),
        label: make$2((spec, backstage)=>renderLabel$1(spec, backstage.shared)
        ),
        iframe: makeIframe((spec, backstage, data)=>renderIFrame(spec, backstage.shared.providers, data)
        ),
        button: make$2((spec, backstage)=>renderDialogButton(spec, backstage.shared.providers)
        ),
        checkbox: make$2((spec, backstage, data)=>renderCheckbox(spec, backstage.shared.providers, data)
        ),
        colorinput: make$2((spec, backstage, data)=>renderColorInput(spec, backstage.shared, backstage.colorinput, data)
        ),
        colorpicker: make$2((spec, backstage, data)=>renderColorPicker(spec, backstage.shared.providers, data)
        ),
        dropzone: make$2((spec, backstage, data)=>renderDropZone(spec, backstage.shared.providers, data)
        ),
        grid: make$2((spec, backstage)=>renderGrid(spec, backstage.shared)
        ),
        listbox: make$2((spec, backstage, data)=>renderListBox(spec, backstage, data)
        ),
        selectbox: make$2((spec, backstage, data)=>renderSelectBox(spec, backstage.shared.providers, data)
        ),
        sizeinput: make$2((spec, backstage)=>renderSizeInput(spec, backstage.shared.providers)
        ),
        slider: make$2((spec, backstage, data)=>renderSlider(spec, backstage.shared.providers, data)
        ),
        urlinput: make$2((spec, backstage, data)=>renderUrlInput(spec, backstage, backstage.urlinput, data)
        ),
        customeditor: make$2(renderCustomEditor),
        htmlpanel: make$2(renderHtmlPanel),
        imagepreview: make$2((spec, _, data)=>renderImagePreview(spec, data)
        ),
        table: make$2((spec, backstage)=>renderTable(spec, backstage.shared.providers)
        ),
        panel: make$2((spec, backstage)=>renderPanel(spec, backstage)
        )
    };
    const noFormParts = {
        field: (_name, spec)=>spec
        ,
        record: constant$1([])
    };
    const interpretInForm = (parts, spec, dialogData, oldBackstage)=>{
        const newBackstage = deepMerge(oldBackstage, {
            shared: {
                interpreter: (childSpec)=>interpretParts(parts, childSpec, dialogData, newBackstage)
            }
        });
        return interpretParts(parts, spec, dialogData, newBackstage);
    };
    const interpretParts = (parts, spec, dialogData, backstage)=>get$g(factories, spec.type).fold(()=>{
            console.error(`Unknown factory type "${spec.type}", defaulting to container: `, spec);
            return spec;
        }, (factory)=>factory(parts, spec, dialogData, backstage)
        )
    ;
    const interpretWithoutForm = (spec, dialogData, backstage)=>interpretParts(noFormParts, spec, dialogData, backstage)
    ;
    const labelPrefix1 = 'layout-inset';
    const westEdgeX = (anchor)=>anchor.x
    ;
    const middleX = (anchor, element)=>anchor.x + anchor.width / 2 - element.width / 2
    ;
    const eastEdgeX = (anchor, element)=>anchor.x + anchor.width - element.width
    ;
    const northY = (anchor)=>anchor.y
    ;
    const southY = (anchor, element)=>anchor.y + anchor.height - element.height
    ;
    const centreY = (anchor, element)=>anchor.y + anchor.height / 2 - element.height / 2
    ;
    const southwest1 = (anchor, element, bubbles)=>nu$6(eastEdgeX(anchor, element), southY(anchor, element), bubbles.insetSouthwest(), northwest$3(), 'southwest', boundsRestriction1(anchor, {
            right: 0,
            bottom: 3
        }), labelPrefix1)
    ;
    const southeast1 = (anchor, element, bubbles)=>nu$6(westEdgeX(anchor), southY(anchor, element), bubbles.insetSoutheast(), northeast$3(), 'southeast', boundsRestriction1(anchor, {
            left: 1,
            bottom: 3
        }), labelPrefix1)
    ;
    const northwest1 = (anchor, element, bubbles)=>nu$6(eastEdgeX(anchor, element), northY(anchor), bubbles.insetNorthwest(), southwest$3(), 'northwest', boundsRestriction1(anchor, {
            right: 0,
            top: 2
        }), labelPrefix1)
    ;
    const northeast1 = (anchor, element, bubbles)=>nu$6(westEdgeX(anchor), northY(anchor), bubbles.insetNortheast(), southeast$3(), 'northeast', boundsRestriction1(anchor, {
            left: 1,
            top: 2
        }), labelPrefix1)
    ;
    const north1 = (anchor, element, bubbles)=>nu$6(middleX(anchor, element), northY(anchor), bubbles.insetNorth(), south$3(), 'north', boundsRestriction1(anchor, {
            top: 2
        }), labelPrefix1)
    ;
    const south1 = (anchor, element, bubbles)=>nu$6(middleX(anchor, element), southY(anchor, element), bubbles.insetSouth(), north$3(), 'south', boundsRestriction1(anchor, {
            bottom: 3
        }), labelPrefix1)
    ;
    const east1 = (anchor, element, bubbles)=>nu$6(eastEdgeX(anchor, element), centreY(anchor, element), bubbles.insetEast(), west$3(), 'east', boundsRestriction1(anchor, {
            right: 0
        }), labelPrefix1)
    ;
    const west1 = (anchor, element, bubbles)=>nu$6(westEdgeX(anchor), centreY(anchor, element), bubbles.insetWest(), east$3(), 'west', boundsRestriction1(anchor, {
            left: 1
        }), labelPrefix1)
    ;
    const lookupPreserveLayout = (lastPlacement)=>{
        switch(lastPlacement){
            case 'north':
                return north1;
            case 'northeast':
                return northeast1;
            case 'northwest':
                return northwest1;
            case 'south':
                return south1;
            case 'southeast':
                return southeast1;
            case 'southwest':
                return southwest1;
            case 'east':
                return east1;
            case 'west':
                return west1;
        }
    };
    const preserve = (anchor, element, bubbles, placee, bounds)=>{
        const layout = getPlacement(placee).map(lookupPreserveLayout).getOr(north1);
        return layout(anchor, element, bubbles, placee, bounds);
    };
    const lookupFlippedLayout = (lastPlacement)=>{
        switch(lastPlacement){
            case 'north':
                return south1;
            case 'northeast':
                return southeast1;
            case 'northwest':
                return southwest1;
            case 'south':
                return north1;
            case 'southeast':
                return northeast1;
            case 'southwest':
                return northwest1;
            case 'east':
                return west1;
            case 'west':
                return east1;
        }
    };
    const flip = (anchor, element, bubbles, placee, bounds)=>{
        const layout = getPlacement(placee).map(lookupFlippedLayout).getOr(north1);
        return layout(anchor, element, bubbles, placee, bounds);
    };
    const bubbleAlignments$2 = {
        valignCentre: [],
        alignCentre: [],
        alignLeft: [],
        alignRight: [],
        right: [],
        left: [],
        bottom: [],
        top: []
    };
    const getInlineDialogAnchor = (contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor)=>{
        const bubbleSize = 12;
        const overrides = {
            maxHeightFunction: expandable$1()
        };
        const editableAreaAnchor = ()=>({
                type: 'node',
                root: getContentContainer(contentAreaElement()),
                node: Optional.from(contentAreaElement()),
                bubble: nu$5(bubbleSize, bubbleSize, bubbleAlignments$2),
                layouts: {
                    onRtl: ()=>[
                            northeast1
                        ]
                    ,
                    onLtr: ()=>[
                            northwest1
                        ]
                },
                overrides
            })
        ;
        const standardAnchor = ()=>({
                type: 'hotspot',
                hotspot: lazyAnchorbar(),
                bubble: nu$5(-bubbleSize, bubbleSize, bubbleAlignments$2),
                layouts: {
                    onRtl: ()=>[
                            southeast$2
                        ]
                    ,
                    onLtr: ()=>[
                            southwest$2
                        ]
                },
                overrides
            })
        ;
        return ()=>lazyUseEditableAreaAnchor() ? editableAreaAnchor() : standardAnchor()
        ;
    };
    const getBannerAnchor = (contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor)=>{
        const editableAreaAnchor = ()=>({
                type: 'node',
                root: getContentContainer(contentAreaElement()),
                node: Optional.from(contentAreaElement()),
                layouts: {
                    onRtl: ()=>[
                            north1
                        ]
                    ,
                    onLtr: ()=>[
                            north1
                        ]
                }
            })
        ;
        const standardAnchor = ()=>({
                type: 'hotspot',
                hotspot: lazyAnchorbar(),
                layouts: {
                    onRtl: ()=>[
                            south$2
                        ]
                    ,
                    onLtr: ()=>[
                            south$2
                        ]
                }
            })
        ;
        return ()=>lazyUseEditableAreaAnchor() ? editableAreaAnchor() : standardAnchor()
        ;
    };
    const getCursorAnchor = (editor, bodyElement)=>()=>({
                type: 'selection',
                root: bodyElement(),
                getSelection: ()=>{
                    const rng = editor.selection.getRng();
                    return Optional.some(SimSelection.range(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));
                }
            })
    ;
    const getNodeAnchor$1 = (bodyElement)=>(element)=>({
                type: 'node',
                root: bodyElement(),
                node: element
            })
    ;
    const getAnchors = (editor, lazyAnchorbar, isToolbarTop)=>{
        const useFixedToolbarContainer = useFixedContainer(editor);
        const bodyElement = ()=>SugarElement.fromDom(editor.getBody())
        ;
        const contentAreaElement = ()=>SugarElement.fromDom(editor.getContentAreaContainer())
        ;
        const lazyUseEditableAreaAnchor = ()=>useFixedToolbarContainer || !isToolbarTop()
        ;
        return {
            inlineDialog: getInlineDialogAnchor(contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor),
            banner: getBannerAnchor(contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor),
            cursor: getCursorAnchor(editor, bodyElement),
            node: getNodeAnchor$1(bodyElement)
        };
    };
    const colorPicker = (editor)=>(callback, value)=>{
            const dialog = colorPickerDialog(editor);
            dialog(callback, value);
        }
    ;
    const hasCustomColors = (editor)=>()=>hasCustomColors$1(editor)
    ;
    const getColors = (editor)=>()=>getColors$2(editor)
    ;
    const getColorCols = (editor)=>()=>getColorCols$1(editor)
    ;
    const ColorInputBackstage = (editor)=>({
            colorPicker: colorPicker(editor),
            hasCustomColors: hasCustomColors(editor),
            getColors: getColors(editor),
            getColorCols: getColorCols(editor)
        })
    ;
    const isDraggableModal = (editor)=>()=>isDraggableModal$1(editor)
    ;
    const DialogBackstage = (editor)=>({
            isDraggableModal: isDraggableModal(editor)
        })
    ;
    const HeaderBackstage = (editor)=>{
        const mode = Cell(isToolbarLocationBottom(editor) ? 'bottom' : 'top');
        return {
            isPositionedAtTop: ()=>mode.get() === 'top'
            ,
            getDockingMode: mode.get,
            setDockingMode: mode.set
        };
    };
    const defaultStyleFormats = [
        {
            title: 'Headings',
            items: [
                {
                    title: 'Heading 1',
                    format: 'h1'
                },
                {
                    title: 'Heading 2',
                    format: 'h2'
                },
                {
                    title: 'Heading 3',
                    format: 'h3'
                },
                {
                    title: 'Heading 4',
                    format: 'h4'
                },
                {
                    title: 'Heading 5',
                    format: 'h5'
                },
                {
                    title: 'Heading 6',
                    format: 'h6'
                }
            ]
        },
        {
            title: 'Inline',
            items: [
                {
                    title: 'Bold',
                    format: 'bold'
                },
                {
                    title: 'Italic',
                    format: 'italic'
                },
                {
                    title: 'Underline',
                    format: 'underline'
                },
                {
                    title: 'Strikethrough',
                    format: 'strikethrough'
                },
                {
                    title: 'Superscript',
                    format: 'superscript'
                },
                {
                    title: 'Subscript',
                    format: 'subscript'
                },
                {
                    title: 'Code',
                    format: 'code'
                }
            ]
        },
        {
            title: 'Blocks',
            items: [
                {
                    title: 'Paragraph',
                    format: 'p'
                },
                {
                    title: 'Blockquote',
                    format: 'blockquote'
                },
                {
                    title: 'Div',
                    format: 'div'
                },
                {
                    title: 'Pre',
                    format: 'pre'
                }
            ]
        },
        {
            title: 'Align',
            items: [
                {
                    title: 'Left',
                    format: 'alignleft'
                },
                {
                    title: 'Center',
                    format: 'aligncenter'
                },
                {
                    title: 'Right',
                    format: 'alignright'
                },
                {
                    title: 'Justify',
                    format: 'alignjustify'
                }
            ]
        }
    ];
    const isNestedFormat = (format)=>has$2(format, 'items')
    ;
    const isBlockFormat = (format)=>has$2(format, 'block')
    ;
    const isInlineFormat = (format)=>has$2(format, 'inline')
    ;
    const isSelectorFormat = (format)=>has$2(format, 'selector')
    ;
    const mapFormats = (userFormats)=>foldl(userFormats, (acc, fmt)=>{
            if (isNestedFormat(fmt)) {
                const result = mapFormats(fmt.items);
                return {
                    customFormats: acc.customFormats.concat(result.customFormats),
                    formats: acc.formats.concat([
                        {
                            title: fmt.title,
                            items: result.formats
                        }
                    ])
                };
            } else if (isInlineFormat(fmt) || isBlockFormat(fmt) || isSelectorFormat(fmt)) {
                const formatName = isString(fmt.name) ? fmt.name : fmt.title.toLowerCase();
                const formatNameWithPrefix = `custom-${formatName}`;
                return {
                    customFormats: acc.customFormats.concat([
                        {
                            name: formatNameWithPrefix,
                            format: fmt
                        }
                    ]),
                    formats: acc.formats.concat([
                        {
                            title: fmt.title,
                            format: formatNameWithPrefix,
                            icon: fmt.icon
                        }
                    ])
                };
            } else return {
                ...acc,
                formats: acc.formats.concat(fmt)
            };
        }, {
            customFormats: [],
            formats: []
        })
    ;
    const registerCustomFormats = (editor, userFormats)=>{
        const result = mapFormats(userFormats);
        const registerFormats = (customFormats)=>{
            each$1(customFormats, (fmt)=>{
                if (!editor.formatter.has(fmt.name)) editor.formatter.register(fmt.name, fmt.format);
            });
        };
        if (editor.formatter) registerFormats(result.customFormats);
        else editor.on('init', ()=>{
            registerFormats(result.customFormats);
        });
        return result.formats;
    };
    const getStyleFormats = (editor)=>getUserStyleFormats(editor).map((userFormats)=>{
            const registeredUserFormats = registerCustomFormats(editor, userFormats);
            return shouldMergeStyleFormats(editor) ? defaultStyleFormats.concat(registeredUserFormats) : registeredUserFormats;
        }).getOr(defaultStyleFormats)
    ;
    const processBasic = (item, isSelectedFor, getPreviewFor)=>{
        const formatterSpec = {
            type: 'formatter',
            isSelected: isSelectedFor(item.format),
            getStylePreview: getPreviewFor(item.format)
        };
        return deepMerge(item, formatterSpec);
    };
    const register$a = (editor, formats, isSelectedFor, getPreviewFor)=>{
        const enrichSupported = (item)=>processBasic(item, isSelectedFor, getPreviewFor)
        ;
        const enrichMenu = (item)=>{
            const submenuSpec = {
                type: 'submenu'
            };
            return deepMerge(item, submenuSpec);
        };
        const enrichCustom = (item)=>{
            const formatName = isString(item.name) ? item.name : generate$6(item.title);
            const formatNameWithPrefix = `custom-${formatName}`;
            const customSpec = {
                type: 'formatter',
                format: formatNameWithPrefix,
                isSelected: isSelectedFor(formatNameWithPrefix),
                getStylePreview: getPreviewFor(formatNameWithPrefix)
            };
            const newItem = deepMerge(item, customSpec);
            editor.formatter.register(formatName, newItem);
            return newItem;
        };
        const doEnrich = (items)=>map$2(items, (item)=>{
                const keys$1 = keys1(item);
                if (hasNonNullableKey(item, 'items')) {
                    const newItems = doEnrich(item.items);
                    return deepMerge(enrichMenu(item), {
                        getStyleItems: constant$1(newItems)
                    });
                } else if (hasNonNullableKey(item, 'format')) return enrichSupported(item);
                else if (keys$1.length === 1 && contains$2(keys$1, 'title')) return deepMerge(item, {
                    type: 'separator'
                });
                else return enrichCustom(item);
            })
        ;
        return doEnrich(formats);
    };
    const init$8 = (editor)=>{
        const isSelectedFor = (format)=>()=>editor.formatter.match(format)
        ;
        const getPreviewFor = (format)=>()=>{
                const fmt = editor.formatter.get(format);
                return fmt !== undefined ? Optional.some({
                    tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || 'div' : 'div',
                    styles: editor.dom.parseStyle(editor.formatter.getCssText(format))
                }) : Optional.none();
            }
        ;
        const flatten = (fmt)=>{
            const subs = fmt.items;
            return subs !== undefined && subs.length > 0 ? bind$3(subs, flatten) : [
                fmt.format
            ];
        };
        const settingsFormats = Cell([]);
        const settingsFlattenedFormats = Cell([]);
        const eventsFormats = Cell([]);
        const eventsFlattenedFormats = Cell([]);
        const replaceSettings = Cell(false);
        editor.on('PreInit', (_e)=>{
            const formats = getStyleFormats(editor);
            const enriched = register$a(editor, formats, isSelectedFor, getPreviewFor);
            settingsFormats.set(enriched);
            settingsFlattenedFormats.set(bind$3(enriched, flatten));
        });
        editor.on('addStyleModifications', (e)=>{
            const modifications = register$a(editor, e.items, isSelectedFor, getPreviewFor);
            eventsFormats.set(modifications);
            replaceSettings.set(e.replace);
            eventsFlattenedFormats.set(bind$3(modifications, flatten));
        });
        const getData = ()=>{
            const fromSettings = replaceSettings.get() ? [] : settingsFormats.get();
            const fromEvents = eventsFormats.get();
            return fromSettings.concat(fromEvents);
        };
        const getFlattenedKeys = ()=>{
            const fromSettings = replaceSettings.get() ? [] : settingsFlattenedFormats.get();
            const fromEvents = eventsFlattenedFormats.get();
            return fromSettings.concat(fromEvents);
        };
        return {
            getData,
            getFlattenedKeys
        };
    };
    const isElement = (node)=>isNonNullable(node) && node.nodeType === 1
    ;
    const trim = global$1.trim;
    const hasContentEditableState = (value)=>{
        return (node)=>{
            if (isElement(node)) {
                if (node.contentEditable === value) return true;
                if (node.getAttribute('data-mce-contenteditable') === value) return true;
            }
            return false;
        };
    };
    const isContentEditableTrue = hasContentEditableState('true');
    const isContentEditableFalse = hasContentEditableState('false');
    const create = (type, title, url, level, attach)=>{
        return {
            type,
            title,
            url,
            level,
            attach
        };
    };
    const isChildOfContentEditableTrue = (node)=>{
        while(node = node.parentNode){
            const value = node.contentEditable;
            if (value && value !== 'inherit') return isContentEditableTrue(node);
        }
        return false;
    };
    const select1 = (selector, root)=>{
        return map$2(descendants(SugarElement.fromDom(root), selector), (element)=>{
            return element.dom;
        });
    };
    const getElementText = (elm)=>{
        return elm.innerText || elm.textContent;
    };
    const getOrGenerateId = (elm)=>{
        return elm.id ? elm.id : generate$6('h');
    };
    const isAnchor = (elm)=>{
        return elm && elm.nodeName === 'A' && (elm.id || elm.name) !== undefined;
    };
    const isValidAnchor = (elm)=>{
        return isAnchor(elm) && isEditable(elm);
    };
    const isHeader = (elm)=>{
        return elm && /^(H[1-6])$/.test(elm.nodeName);
    };
    const isEditable = (elm)=>{
        return isChildOfContentEditableTrue(elm) && !isContentEditableFalse(elm);
    };
    const isValidHeader = (elm)=>{
        return isHeader(elm) && isEditable(elm);
    };
    const getLevel = (elm)=>{
        return isHeader(elm) ? parseInt(elm.nodeName.substr(1), 10) : 0;
    };
    const headerTarget = (elm)=>{
        const headerId = getOrGenerateId(elm);
        const attach = ()=>{
            elm.id = headerId;
        };
        return create('header', getElementText(elm), '#' + headerId, getLevel(elm), attach);
    };
    const anchorTarget = (elm)=>{
        const anchorId = elm.id || elm.name;
        const anchorText = getElementText(elm);
        return create('anchor', anchorText ? anchorText : '#' + anchorId, '#' + anchorId, 0, noop);
    };
    const getHeaderTargets = (elms)=>{
        return map$2(filter$2(elms, isValidHeader), headerTarget);
    };
    const getAnchorTargets = (elms)=>{
        return map$2(filter$2(elms, isValidAnchor), anchorTarget);
    };
    const getTargetElements = (elm)=>{
        const elms = select1('h1,h2,h3,h4,h5,h6,a:not([href])', elm);
        return elms;
    };
    const hasTitle = (target)=>{
        return trim(target.title).length > 0;
    };
    const find1 = (elm)=>{
        const elms = getTargetElements(elm);
        return filter$2(getHeaderTargets(elms).concat(getAnchorTargets(elms)), hasTitle);
    };
    const LinkTargets = {
        find: find1
    };
    const STORAGE_KEY = 'tinymce-url-history';
    const HISTORY_LENGTH = 5;
    const isHttpUrl = (url)=>isString(url) && /^https?/.test(url)
    ;
    const isArrayOfUrl = (a)=>isArray(a) && a.length <= HISTORY_LENGTH && forall(a, isHttpUrl)
    ;
    const isRecordOfUrlArray = (r)=>isObject(r) && find$4(r, (value)=>!isArrayOfUrl(value)
        ).isNone()
    ;
    const getAllHistory = ()=>{
        const unparsedHistory = global$4.getItem(STORAGE_KEY);
        if (unparsedHistory === null) return {};
        let history;
        try {
            history = JSON.parse(unparsedHistory);
        } catch (e) {
            if (e instanceof SyntaxError) {
                console.log('Local storage ' + STORAGE_KEY + ' was not valid JSON', e);
                return {};
            }
            throw e;
        }
        if (!isRecordOfUrlArray(history)) {
            console.log('Local storage ' + STORAGE_KEY + ' was not valid format', history);
            return {};
        }
        return history;
    };
    const setAllHistory = (history)=>{
        if (!isRecordOfUrlArray(history)) throw new Error('Bad format for history:\n' + JSON.stringify(history));
        global$4.setItem(STORAGE_KEY, JSON.stringify(history));
    };
    const getHistory = (fileType)=>{
        const history = getAllHistory();
        return get$g(history, fileType).getOr([]);
    };
    const addToHistory = (url, fileType)=>{
        if (!isHttpUrl(url)) return;
        const history = getAllHistory();
        const items = get$g(history, fileType).getOr([]);
        const itemsWithoutUrl = filter$2(items, (item)=>item !== url
        );
        history[fileType] = [
            url
        ].concat(itemsWithoutUrl).slice(0, HISTORY_LENGTH);
        setAllHistory(history);
    };
    const isTruthy = (value)=>!!value
    ;
    const makeMap = (value)=>map$1(global$1.makeMap(value, /[, ]/), isTruthy)
    ;
    const getPicker = (editor)=>Optional.from(getFilePickerCallback(editor))
    ;
    const getPickerTypes = (editor)=>{
        const optFileTypes = Optional.from(getFilePickerTypes(editor)).filter(isTruthy).map(makeMap);
        return getPicker(editor).fold(never, (_picker)=>optFileTypes.fold(always, (types)=>keys1(types).length > 0 ? types : false
            )
        );
    };
    const getPickerSetting = (editor, filetype)=>{
        const pickerTypes = getPickerTypes(editor);
        if (isBoolean(pickerTypes)) return pickerTypes ? getPicker(editor) : Optional.none();
        else return pickerTypes[filetype] ? getPicker(editor) : Optional.none();
    };
    const getUrlPicker = (editor, filetype)=>getPickerSetting(editor, filetype).map((picker)=>(entry)=>Future.nu((completer)=>{
                    const handler = (value, meta)=>{
                        if (!isString(value)) throw new Error('Expected value to be string');
                        if (meta !== undefined && !isObject(meta)) throw new Error('Expected meta to be a object');
                        const r = {
                            value,
                            meta
                        };
                        completer(r);
                    };
                    const meta1 = {
                        filetype,
                        fieldname: entry.fieldname,
                        ...Optional.from(entry.meta).getOr({})
                    };
                    picker.call(editor, handler, entry.value, meta1);
                })
        )
    ;
    const getTextSetting = (value)=>Optional.from(value).filter(isString).getOrUndefined()
    ;
    const getLinkInformation = (editor)=>{
        if (!useTypeaheadUrls(editor)) return Optional.none();
        return Optional.some({
            targets: LinkTargets.find(editor.getBody()),
            anchorTop: getTextSetting(getAnchorTop(editor)),
            anchorBottom: getTextSetting(getAnchorBottom(editor))
        });
    };
    const getValidationHandler = (editor)=>Optional.from(getFilePickerValidatorHandler(editor))
    ;
    const UrlInputBackstage = (editor)=>({
            getHistory,
            addToHistory,
            getLinkInformation: ()=>getLinkInformation(editor)
            ,
            getValidationHandler: ()=>getValidationHandler(editor)
            ,
            getUrlPicker: (filetype)=>getUrlPicker(editor, filetype)
        })
    ;
    const init$7 = (lazySink, editor, lazyAnchorbar)=>{
        const contextMenuState = Cell(false);
        const toolbar = HeaderBackstage(editor);
        const backstage = {
            shared: {
                providers: {
                    icons: ()=>editor.ui.registry.getAll().icons
                    ,
                    menuItems: ()=>editor.ui.registry.getAll().menuItems
                    ,
                    translate: global$8.translate,
                    isDisabled: ()=>editor.mode.isReadOnly() || !editor.ui.isEnabled()
                    ,
                    getOption: editor.options.get
                },
                interpreter: (s)=>interpretWithoutForm(s, {}, backstage)
                ,
                anchors: getAnchors(editor, lazyAnchorbar, toolbar.isPositionedAtTop),
                header: toolbar,
                getSink: lazySink
            },
            urlinput: UrlInputBackstage(editor),
            styles: init$8(editor),
            colorinput: ColorInputBackstage(editor),
            dialog: DialogBackstage(editor),
            isContextMenuOpen: ()=>contextMenuState.get()
            ,
            setContextMenuState: (state)=>contextMenuState.set(state)
        };
        return backstage;
    };
    const setup$b = (editor, mothership, uiMothership)=>{
        const broadcastEvent = (name, evt)=>{
            each$1([
                mothership,
                uiMothership
            ], (ship)=>{
                ship.broadcastEvent(name, evt);
            });
        };
        const broadcastOn = (channel, message)=>{
            each$1([
                mothership,
                uiMothership
            ], (ship)=>{
                ship.broadcastOn([
                    channel
                ], message);
            });
        };
        const fireDismissPopups = (evt)=>broadcastOn(dismissPopups(), {
                target: evt.target
            })
        ;
        const doc = getDocument();
        const onTouchstart = bind1(doc, 'touchstart', fireDismissPopups);
        const onTouchmove = bind1(doc, 'touchmove', (evt)=>broadcastEvent(documentTouchmove(), evt)
        );
        const onTouchend = bind1(doc, 'touchend', (evt)=>broadcastEvent(documentTouchend(), evt)
        );
        const onMousedown = bind1(doc, 'mousedown', fireDismissPopups);
        const onMouseup = bind1(doc, 'mouseup', (evt)=>{
            if (evt.raw.button === 0) broadcastOn(mouseReleased(), {
                target: evt.target
            });
        });
        const onContentClick = (raw)=>broadcastOn(dismissPopups(), {
                target: SugarElement.fromDom(raw.target)
            })
        ;
        const onContentMouseup = (raw)=>{
            if (raw.button === 0) broadcastOn(mouseReleased(), {
                target: SugarElement.fromDom(raw.target)
            });
        };
        const onContentMousedown = ()=>{
            each$1(editor.editorManager.get(), (loopEditor)=>{
                if (editor !== loopEditor) loopEditor.dispatch('DismissPopups', {
                    relatedTarget: editor
                });
            });
        };
        const onWindowScroll = (evt)=>broadcastEvent(windowScroll(), fromRawEvent(evt))
        ;
        const onWindowResize = (evt)=>{
            broadcastOn(repositionPopups(), {});
            broadcastEvent(windowResize(), fromRawEvent(evt));
        };
        const onEditorResize = ()=>broadcastOn(repositionPopups(), {})
        ;
        const onEditorProgress = (evt)=>{
            if (evt.state) broadcastOn(dismissPopups(), {
                target: SugarElement.fromDom(editor.getContainer())
            });
        };
        const onDismissPopups = (event)=>{
            broadcastOn(dismissPopups(), {
                target: SugarElement.fromDom(event.relatedTarget.getContainer())
            });
        };
        editor.on('PostRender', ()=>{
            editor.on('click', onContentClick);
            editor.on('tap', onContentClick);
            editor.on('mouseup', onContentMouseup);
            editor.on('mousedown', onContentMousedown);
            editor.on('ScrollWindow', onWindowScroll);
            editor.on('ResizeWindow', onWindowResize);
            editor.on('ResizeEditor', onEditorResize);
            editor.on('AfterProgressState', onEditorProgress);
            editor.on('DismissPopups', onDismissPopups);
        });
        editor.on('remove', ()=>{
            editor.off('click', onContentClick);
            editor.off('tap', onContentClick);
            editor.off('mouseup', onContentMouseup);
            editor.off('mousedown', onContentMousedown);
            editor.off('ScrollWindow', onWindowScroll);
            editor.off('ResizeWindow', onWindowResize);
            editor.off('ResizeEditor', onEditorResize);
            editor.off('AfterProgressState', onEditorProgress);
            editor.off('DismissPopups', onDismissPopups);
            onMousedown.unbind();
            onTouchstart.unbind();
            onTouchmove.unbind();
            onTouchend.unbind();
            onMouseup.unbind();
        });
        editor.on('detach', ()=>{
            detachSystem(mothership);
            detachSystem(uiMothership);
            mothership.destroy();
            uiMothership.destroy();
        });
    };
    const parts$a = AlloyParts;
    const partType = PartType;
    const schema$f = constant$1([
        defaulted('shell', false),
        required$1('makeItem'),
        defaulted('setupItem', noop),
        SketchBehaviours.field('listBehaviours', [
            Replacing
        ])
    ]);
    const customListDetail = ()=>({
            behaviours: derive$1([
                Replacing.config({})
            ])
        })
    ;
    const itemsPart = optional1({
        name: 'items',
        overrides: customListDetail
    });
    const parts$9 = constant$1([
        itemsPart
    ]);
    const name1 = constant$1('CustomList');
    const factory$d = (detail, components, _spec, _external)=>{
        const setItems = (list, items)=>{
            getListContainer(list).fold(()=>{
                console.error('Custom List was defined to not be a shell, but no item container was specified in components');
                throw new Error('Custom List was defined to not be a shell, but no item container was specified in components');
            }, (container)=>{
                const itemComps = Replacing.contents(container);
                const numListsRequired = items.length;
                const numListsToAdd = numListsRequired - itemComps.length;
                const itemsToAdd = numListsToAdd > 0 ? range$2(numListsToAdd, ()=>detail.makeItem()
                ) : [];
                const itemsToRemove = itemComps.slice(numListsRequired);
                each$1(itemsToRemove, (item)=>Replacing.remove(container, item)
                );
                each$1(itemsToAdd, (item)=>Replacing.append(container, item)
                );
                const builtLists = Replacing.contents(container);
                each$1(builtLists, (item, i)=>{
                    detail.setupItem(list, item, items[i], i);
                });
            });
        };
        const extra = detail.shell ? {
            behaviours: [
                Replacing.config({})
            ],
            components: []
        } : {
            behaviours: [],
            components
        };
        const getListContainer = (component)=>detail.shell ? Optional.some(component) : getPart(component, detail, 'items')
        ;
        return {
            uid: detail.uid,
            dom: detail.dom,
            components: extra.components,
            behaviours: augment(detail.listBehaviours, extra.behaviours),
            apis: {
                setItems
            }
        };
    };
    const CustomList = composite({
        name: name1(),
        configFields: schema$f(),
        partFields: parts$9(),
        factory: factory$d,
        apis: {
            setItems: (apis, list, items)=>{
                apis.setItems(list, items);
            }
        }
    });
    const schema$e = constant$1([
        required$1('dom'),
        defaulted('shell', true),
        field1('toolbarBehaviours', [
            Replacing
        ])
    ]);
    const enhanceGroups = ()=>({
            behaviours: derive$1([
                Replacing.config({})
            ])
        })
    ;
    const parts$8 = constant$1([
        optional1({
            name: 'groups',
            overrides: enhanceGroups
        })
    ]);
    const factory$c = (detail, components, _spec, _externals)=>{
        const setGroups = (toolbar, groups)=>{
            getGroupContainer(toolbar).fold(()=>{
                console.error('Toolbar was defined to not be a shell, but no groups container was specified in components');
                throw new Error('Toolbar was defined to not be a shell, but no groups container was specified in components');
            }, (container)=>{
                Replacing.set(container, groups);
            });
        };
        const getGroupContainer = (component)=>detail.shell ? Optional.some(component) : getPart(component, detail, 'groups')
        ;
        const extra = detail.shell ? {
            behaviours: [
                Replacing.config({})
            ],
            components: []
        } : {
            behaviours: [],
            components
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components: extra.components,
            behaviours: augment(detail.toolbarBehaviours, extra.behaviours),
            apis: {
                setGroups
            },
            domModification: {
                attributes: {
                    role: 'group'
                }
            }
        };
    };
    const Toolbar = composite({
        name: 'Toolbar',
        configFields: schema$e(),
        partFields: parts$8(),
        factory: factory$c,
        apis: {
            setGroups: (apis, toolbar, groups)=>{
                apis.setGroups(toolbar, groups);
            }
        }
    });
    const setup$a = noop;
    const isDocked$2 = never;
    const getBehaviours$1 = constant$1([]);
    var StaticHeader = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        setup: setup$a,
        isDocked: isDocked$2,
        getBehaviours: getBehaviours$1
    });
    const getOffsetParent = (element)=>{
        const isFixed = is$11(getRaw(element, 'position'), 'fixed');
        const offsetParent$11 = isFixed ? Optional.none() : offsetParent(element);
        return offsetParent$11.orThunk(()=>{
            const marker = SugarElement.fromTag('span');
            return parent1(element).bind((parent)=>{
                append$2(parent, marker);
                const offsetParent$1 = offsetParent(marker);
                remove$5(marker);
                return offsetParent$1;
            });
        });
    };
    const getOrigin = (element)=>getOffsetParent(element).map(absolute$3).getOrThunk(()=>SugarPosition(0, 0)
        )
    ;
    const morphAdt = Adt.generate([
        {
            static: []
        },
        {
            absolute: [
                'positionCss'
            ]
        },
        {
            fixed: [
                'positionCss'
            ]
        }
    ]);
    const appear = (component, contextualInfo)=>{
        const elem = component.element;
        add$2(elem, contextualInfo.transitionClass);
        remove$2(elem, contextualInfo.fadeOutClass);
        add$2(elem, contextualInfo.fadeInClass);
        contextualInfo.onShow(component);
    };
    const disappear = (component, contextualInfo)=>{
        const elem = component.element;
        add$2(elem, contextualInfo.transitionClass);
        remove$2(elem, contextualInfo.fadeInClass);
        add$2(elem, contextualInfo.fadeOutClass);
        contextualInfo.onHide(component);
    };
    const isPartiallyVisible = (box, viewport)=>box.y < viewport.bottom && box.bottom > viewport.y
    ;
    const isTopCompletelyVisible = (box, viewport)=>box.y >= viewport.y
    ;
    const isBottomCompletelyVisible = (box, viewport)=>box.bottom <= viewport.bottom
    ;
    const isVisibleForModes = (modes, box, viewport)=>forall(modes, (mode)=>{
            switch(mode){
                case 'bottom':
                    return isBottomCompletelyVisible(box, viewport);
                case 'top':
                    return isTopCompletelyVisible(box, viewport);
            }
        })
    ;
    const getPrior = (elem, state)=>state.getInitialPos().map((pos)=>bounds1(pos.bounds.x, pos.bounds.y, get$c(elem), get$d(elem))
        )
    ;
    const storePrior = (elem, box, state)=>{
        state.setInitialPos({
            style: getAllRaw(elem),
            position: get$e(elem, 'position') || 'static',
            bounds: box
        });
    };
    const revertToOriginal = (elem, box, state)=>state.getInitialPos().bind((position)=>{
            state.clearInitialPos();
            switch(position.position){
                case 'static':
                    return Optional.some(morphAdt.static());
                case 'absolute':
                    const offsetBox = getOffsetParent(elem).map(box$1).getOrThunk(()=>box$1(body1())
                    );
                    return Optional.some(morphAdt.absolute(NuPositionCss('absolute', get$g(position.style, 'left').map((_left)=>box.x - offsetBox.x
                    ), get$g(position.style, 'top').map((_top)=>box.y - offsetBox.y
                    ), get$g(position.style, 'right').map((_right)=>offsetBox.right - box.right
                    ), get$g(position.style, 'bottom').map((_bottom)=>offsetBox.bottom - box.bottom
                    ))));
                default:
                    return Optional.none();
            }
        })
    ;
    const morphToOriginal = (elem, viewport, state)=>getPrior(elem, state).filter((box)=>isVisibleForModes(state.getModes(), box, viewport)
        ).bind((box)=>revertToOriginal(elem, box, state)
        )
    ;
    const morphToFixed = (elem, viewport, state)=>{
        const box = box$1(elem);
        if (!isVisibleForModes(state.getModes(), box, viewport)) {
            storePrior(elem, box, state);
            const winBox = win1();
            const left = box.x - winBox.x;
            const top = viewport.y - winBox.y;
            const bottom = winBox.bottom - viewport.bottom;
            const isTop = box.y <= viewport.y;
            return Optional.some(morphAdt.fixed(NuPositionCss('fixed', Optional.some(left), isTop ? Optional.some(top) : Optional.none(), Optional.none(), !isTop ? Optional.some(bottom) : Optional.none())));
        } else return Optional.none();
    };
    const getMorph = (component, viewport, state)=>{
        const elem = component.element;
        const isDocked = is$11(getRaw(elem, 'position'), 'fixed');
        return isDocked ? morphToOriginal(elem, viewport, state) : morphToFixed(elem, viewport, state);
    };
    const getMorphToOriginal = (component, state)=>{
        const elem = component.element;
        return getPrior(elem, state).bind((box)=>revertToOriginal(elem, box, state)
        );
    };
    const morphToStatic = (component, config, state)=>{
        state.setDocked(false);
        each$1([
            'left',
            'right',
            'top',
            'bottom',
            'position'
        ], (prop)=>remove$6(component.element, prop)
        );
        config.onUndocked(component);
    };
    const morphToCoord = (component, config, state, position)=>{
        const isDocked = position.position === 'fixed';
        state.setDocked(isDocked);
        applyPositionCss(component.element, position);
        const method = isDocked ? config.onDocked : config.onUndocked;
        method(component);
    };
    const updateVisibility = (component, config, state, viewport, morphToDocked = false)=>{
        config.contextual.each((contextInfo)=>{
            contextInfo.lazyContext(component).each((box)=>{
                const isVisible = isPartiallyVisible(box, viewport);
                if (isVisible !== state.isVisible()) {
                    state.setVisible(isVisible);
                    if (morphToDocked && !isVisible) {
                        add$1(component.element, [
                            contextInfo.fadeOutClass
                        ]);
                        contextInfo.onHide(component);
                    } else {
                        const method = isVisible ? appear : disappear;
                        method(component, contextInfo);
                    }
                }
            });
        });
    };
    const refreshInternal = (component, config, state)=>{
        const viewport = config.lazyViewport(component);
        const isDocked = state.isDocked();
        if (isDocked) updateVisibility(component, config, state, viewport);
        getMorph(component, viewport, state).each((morph)=>{
            morph.fold(()=>morphToStatic(component, config, state)
            , (position)=>morphToCoord(component, config, state, position)
            , (position)=>{
                updateVisibility(component, config, state, viewport, true);
                morphToCoord(component, config, state, position);
            });
        });
    };
    const resetInternal = (component, config, state)=>{
        const elem = component.element;
        state.setDocked(false);
        getMorphToOriginal(component, state).each((morph)=>{
            morph.fold(()=>morphToStatic(component, config, state)
            , (position)=>morphToCoord(component, config, state, position)
            , noop);
        });
        state.setVisible(true);
        config.contextual.each((contextInfo)=>{
            remove$1(elem, [
                contextInfo.fadeInClass,
                contextInfo.fadeOutClass,
                contextInfo.transitionClass
            ]);
            contextInfo.onShow(component);
        });
        refresh$4(component, config, state);
    };
    const refresh$4 = (component, config, state)=>{
        if (component.getSystem().isConnected()) refreshInternal(component, config, state);
    };
    const reset1 = (component, config, state)=>{
        if (state.isDocked()) resetInternal(component, config, state);
    };
    const isDocked$1 = (component, config, state)=>state.isDocked()
    ;
    const setModes = (component, config, state, modes)=>state.setModes(modes)
    ;
    const getModes = (component, config, state)=>state.getModes()
    ;
    var DockingApis = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        refresh: refresh$4,
        reset: reset1,
        isDocked: isDocked$1,
        getModes: getModes,
        setModes: setModes
    });
    const events$5 = (dockInfo, dockState)=>derive$2([
            runOnSource(transitionend(), (component, simulatedEvent)=>{
                dockInfo.contextual.each((contextInfo)=>{
                    if (has(component.element, contextInfo.transitionClass)) {
                        remove$1(component.element, [
                            contextInfo.transitionClass,
                            contextInfo.fadeInClass
                        ]);
                        const notify = dockState.isVisible() ? contextInfo.onShown : contextInfo.onHidden;
                        notify(component);
                    }
                    simulatedEvent.stop();
                });
            }),
            run$1(windowScroll(), (component, _)=>{
                refresh$4(component, dockInfo, dockState);
            }),
            run$1(windowResize(), (component, _)=>{
                reset1(component, dockInfo, dockState);
            })
        ])
    ;
    var ActiveDocking = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        events: events$5
    });
    var DockingSchema = [
        optionObjOf('contextual', [
            requiredString('fadeInClass'),
            requiredString('fadeOutClass'),
            requiredString('transitionClass'),
            requiredFunction('lazyContext'),
            onHandler('onShow'),
            onHandler('onShown'),
            onHandler('onHide'),
            onHandler('onHidden')
        ]),
        defaultedFunction('lazyViewport', win1),
        defaultedArrayOf('modes', [
            'top',
            'bottom'
        ], string),
        onHandler('onDocked'),
        onHandler('onUndocked')
    ];
    const init$6 = (spec)=>{
        const docked = Cell(false);
        const visible = Cell(true);
        const initialBounds = value$2();
        const modes = Cell(spec.modes);
        const readState = ()=>`docked:  ${docked.get()}, visible: ${visible.get()}, modes: ${modes.get().join(',')}`
        ;
        return nu$8({
            isDocked: docked.get,
            setDocked: docked.set,
            getInitialPos: initialBounds.get,
            setInitialPos: initialBounds.set,
            clearInitialPos: initialBounds.clear,
            isVisible: visible.get,
            setVisible: visible.set,
            getModes: modes.get,
            setModes: modes.set,
            readState
        });
    };
    var DockingState = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        init: init$6
    });
    const Docking = create$3({
        fields: DockingSchema,
        name: 'docking',
        active: ActiveDocking,
        apis: DockingApis,
        state: DockingState
    });
    const toolbarHeightChange = constant$1(generate$6('toolbar-height-change'));
    const visibility = {
        fadeInClass: 'tox-editor-dock-fadein',
        fadeOutClass: 'tox-editor-dock-fadeout',
        transitionClass: 'tox-editor-dock-transition'
    };
    const editorStickyOnClass = 'tox-tinymce--toolbar-sticky-on';
    const editorStickyOffClass = 'tox-tinymce--toolbar-sticky-off';
    const scrollFromBehindHeader = (e, containerHeader)=>{
        const doc = owner$4(containerHeader);
        const viewHeight = doc.dom.defaultView.innerHeight;
        const scrollPos = get$b(doc);
        const markerElement = SugarElement.fromDom(e.elm);
        const markerPos = absolute$2(markerElement);
        const markerHeight = get$d(markerElement);
        const markerTop = markerPos.y;
        const markerBottom = markerTop + markerHeight;
        const editorHeaderPos = absolute$3(containerHeader);
        const editorHeaderHeight = get$d(containerHeader);
        const editorHeaderTop = editorHeaderPos.top;
        const editorHeaderBottom = editorHeaderTop + editorHeaderHeight;
        const editorHeaderDockedAtTop = Math.abs(editorHeaderTop - scrollPos.top) < 2;
        const editorHeaderDockedAtBottom = Math.abs(editorHeaderBottom - (scrollPos.top + viewHeight)) < 2;
        if (editorHeaderDockedAtTop && markerTop < editorHeaderBottom) to(scrollPos.left, markerTop - editorHeaderHeight, doc);
        else if (editorHeaderDockedAtBottom && markerBottom > editorHeaderTop) {
            const y = markerTop - viewHeight + markerHeight + editorHeaderHeight;
            to(scrollPos.left, y, doc);
        }
    };
    const isDockedMode = (header, mode)=>contains$2(Docking.getModes(header), mode)
    ;
    const updateIframeContentFlow = (header)=>{
        const getOccupiedHeight = (elm)=>getOuter$2(elm) + (parseInt(get$e(elm, 'margin-top'), 10) || 0) + (parseInt(get$e(elm, 'margin-bottom'), 10) || 0)
        ;
        const elm1 = header.element;
        parent1(elm1).each((parentElem)=>{
            const padding = 'padding-' + Docking.getModes(header)[0];
            if (Docking.isDocked(header)) {
                const parentWidth = get$c(parentElem);
                set$8(elm1, 'width', parentWidth + 'px');
                set$8(parentElem, padding, getOccupiedHeight(elm1) + 'px');
            } else {
                remove$6(elm1, 'width');
                remove$6(parentElem, padding);
            }
        });
    };
    const updateSinkVisibility = (sinkElem, visible)=>{
        if (visible) {
            remove$2(sinkElem, visibility.fadeOutClass);
            add$1(sinkElem, [
                visibility.transitionClass,
                visibility.fadeInClass
            ]);
        } else {
            remove$2(sinkElem, visibility.fadeInClass);
            add$1(sinkElem, [
                visibility.fadeOutClass,
                visibility.transitionClass
            ]);
        }
    };
    const updateEditorClasses = (editor, docked)=>{
        const editorContainer = SugarElement.fromDom(editor.getContainer());
        if (docked) {
            add$2(editorContainer, editorStickyOnClass);
            remove$2(editorContainer, editorStickyOffClass);
        } else {
            add$2(editorContainer, editorStickyOffClass);
            remove$2(editorContainer, editorStickyOnClass);
        }
    };
    const restoreFocus = (headerElem, focusedElem)=>{
        const ownerDoc = owner$4(focusedElem);
        active$1(ownerDoc).filter((activeElm)=>!eq(focusedElem, activeElm)
        ).filter((activeElm)=>eq(activeElm, SugarElement.fromDom(ownerDoc.dom.body)) || contains(headerElem, activeElm)
        ).each(()=>focus$3(focusedElem)
        );
    };
    const findFocusedElem = (rootElm, lazySink)=>search1(rootElm).orThunk(()=>lazySink().toOptional().bind((sink)=>search1(sink.element)
            )
        )
    ;
    const setup$9 = (editor, sharedBackstage, lazyHeader)=>{
        if (!editor.inline) {
            if (!sharedBackstage.header.isPositionedAtTop()) editor.on('ResizeEditor', ()=>{
                lazyHeader().each(Docking.reset);
            });
            editor.on('ResizeWindow ResizeEditor', ()=>{
                lazyHeader().each(updateIframeContentFlow);
            });
            editor.on('SkinLoaded', ()=>{
                lazyHeader().each((comp)=>{
                    Docking.isDocked(comp) ? Docking.reset(comp) : Docking.refresh(comp);
                });
            });
            editor.on('FullscreenStateChanged', ()=>{
                lazyHeader().each(Docking.reset);
            });
        }
        editor.on('AfterScrollIntoView', (e)=>{
            lazyHeader().each((header)=>{
                Docking.refresh(header);
                const headerElem = header.element;
                if (isVisible1(headerElem)) scrollFromBehindHeader(e, headerElem);
            });
        });
        editor.on('PostRender', ()=>{
            updateEditorClasses(editor, false);
        });
    };
    const isDocked1 = (lazyHeader)=>lazyHeader().map(Docking.isDocked).getOr(false)
    ;
    const getIframeBehaviours = ()=>[
            Receiving.config({
                channels: {
                    [toolbarHeightChange()]: {
                        onReceive: updateIframeContentFlow
                    }
                }
            })
        ]
    ;
    const getBehaviours = (editor, sharedBackstage)=>{
        const focusedElm = value$2();
        const lazySink = sharedBackstage.getSink;
        const runOnSinkElement = (f)=>{
            lazySink().each((sink)=>f(sink.element)
            );
        };
        const onDockingSwitch = (comp)=>{
            if (!editor.inline) updateIframeContentFlow(comp);
            updateEditorClasses(editor, Docking.isDocked(comp));
            comp.getSystem().broadcastOn([
                repositionPopups()
            ], {});
            lazySink().each((sink)=>sink.getSystem().broadcastOn([
                    repositionPopups()
                ], {})
            );
        };
        const additionalBehaviours = editor.inline ? [] : getIframeBehaviours();
        return [
            Focusing.config({}),
            Docking.config({
                contextual: {
                    lazyContext: (comp)=>{
                        const headerHeight = getOuter$2(comp.element);
                        const container = editor.inline ? editor.getContentAreaContainer() : editor.getContainer();
                        const box = box$1(SugarElement.fromDom(container));
                        const boxHeight = box.height - headerHeight;
                        const topBound = box.y + (isDockedMode(comp, 'top') ? 0 : headerHeight);
                        return Optional.some(bounds1(box.x, topBound, box.width, boxHeight));
                    },
                    onShow: ()=>{
                        runOnSinkElement((elem)=>updateSinkVisibility(elem, true)
                        );
                    },
                    onShown: (comp)=>{
                        runOnSinkElement((elem)=>remove$1(elem, [
                                visibility.transitionClass,
                                visibility.fadeInClass
                            ])
                        );
                        focusedElm.get().each((elem)=>{
                            restoreFocus(comp.element, elem);
                            focusedElm.clear();
                        });
                    },
                    onHide: (comp)=>{
                        findFocusedElem(comp.element, lazySink).fold(focusedElm.clear, focusedElm.set);
                        runOnSinkElement((elem)=>updateSinkVisibility(elem, false)
                        );
                    },
                    onHidden: ()=>{
                        runOnSinkElement((elem)=>remove$1(elem, [
                                visibility.transitionClass
                            ])
                        );
                    },
                    ...visibility
                },
                lazyViewport: (comp)=>{
                    const win$1 = win1();
                    const offset = getStickyToolbarOffset(editor);
                    const top = win$1.y + (isDockedMode(comp, 'top') ? offset : 0);
                    const height = win$1.height - (isDockedMode(comp, 'bottom') ? offset : 0);
                    return bounds1(win$1.x, top, win$1.width, height);
                },
                modes: [
                    sharedBackstage.header.getDockingMode()
                ],
                onDocked: onDockingSwitch,
                onUndocked: onDockingSwitch
            }),
            ...additionalBehaviours
        ];
    };
    var StickyHeader = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        setup: setup$9,
        isDocked: isDocked1,
        getBehaviours: getBehaviours
    });
    const renderHeader1 = (spec)=>{
        const editor = spec.editor;
        const getBehaviours$2 = spec.sticky ? getBehaviours : getBehaviours$1;
        return {
            uid: spec.uid,
            dom: spec.dom,
            components: spec.components,
            behaviours: derive$1(getBehaviours$2(editor, spec.sharedBackstage))
        };
    };
    const groupToolbarButtonSchema = objOf([
        type1,
        requiredOf('items', oneOf([
            arrOfObj([
                name$1,
                requiredArrayOf('items', string)
            ]),
            string
        ]))
    ].concat(baseToolbarButtonFields));
    const createGroupToolbarButton = (spec)=>asRaw('GroupToolbarButton', groupToolbarButtonSchema, spec)
    ;
    const baseMenuButtonFields = [
        optionString('text'),
        optionString('tooltip'),
        optionString('icon'),
        requiredFunction('fetch'),
        defaultedFunction('onSetup', ()=>noop
        )
    ];
    const MenuButtonSchema = objOf([
        type1,
        ...baseMenuButtonFields
    ]);
    const createMenuButton = (spec)=>asRaw('menubutton', MenuButtonSchema, spec)
    ;
    const splitButtonSchema = objOf([
        type1,
        optionalTooltip,
        optionalIcon,
        optionalText,
        optionalSelect,
        fetch$1,
        onSetup1,
        defaultedStringEnum('presets', 'normal', [
            'normal',
            'color',
            'listpreview'
        ]),
        defaultedColumns(1),
        onAction1,
        onItemAction1
    ]);
    const createSplitButton = (spec)=>asRaw('SplitButton', splitButtonSchema, spec)
    ;
    const factory$b = (detail, spec)=>{
        const setMenus = (comp, menus)=>{
            const newMenus = map$2(menus, (m)=>{
                const buttonSpec = {
                    type: 'menubutton',
                    text: m.text,
                    fetch: (callback)=>{
                        callback(m.getItems());
                    }
                };
                const internal = createMenuButton(buttonSpec).mapError((errInfo)=>formatError(errInfo)
                ).getOrDie();
                return renderMenuButton(internal, 'tox-mbtn', spec.backstage, Optional.some('menuitem'));
            });
            Replacing.set(comp, newMenus);
        };
        const apis = {
            focus: Keying.focusIn,
            setMenus
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components: [],
            behaviours: derive$1([
                Replacing.config({}),
                config1('menubar-events', [
                    runOnAttached((component)=>{
                        detail.onSetup(component);
                    }),
                    run$1(mouseover(), (comp, se)=>{
                        descendant(comp.element, ".tox-mbtn--active").each((activeButton)=>{
                            closest$1(se.event.target, ".tox-mbtn").each((hoveredButton)=>{
                                if (!eq(activeButton, hoveredButton)) comp.getSystem().getByDom(activeButton).each((activeComp)=>{
                                    comp.getSystem().getByDom(hoveredButton).each((hoveredComp)=>{
                                        Dropdown.expand(hoveredComp);
                                        Dropdown.close(activeComp);
                                        Focusing.focus(hoveredComp);
                                    });
                                });
                            });
                        });
                    }),
                    run$1(focusShifted(), (comp, se)=>{
                        se.event.prevFocus.bind((prev)=>comp.getSystem().getByDom(prev).toOptional()
                        ).each((prev)=>{
                            se.event.newFocus.bind((nu)=>comp.getSystem().getByDom(nu).toOptional()
                            ).each((nu)=>{
                                if (Dropdown.isOpen(prev)) {
                                    Dropdown.expand(nu);
                                    Dropdown.close(prev);
                                }
                            });
                        });
                    })
                ]),
                Keying.config({
                    mode: 'flow',
                    selector: ".tox-mbtn",
                    onEscape: (comp)=>{
                        detail.onEscape(comp);
                        return Optional.some(true);
                    }
                }),
                Tabstopping.config({})
            ]),
            apis,
            domModification: {
                attributes: {
                    role: 'menubar'
                }
            }
        };
    };
    var SilverMenubar = single({
        factory: factory$b,
        name: 'silver.Menubar',
        configFields: [
            required$1('dom'),
            required$1('uid'),
            required$1('onEscape'),
            required$1('backstage'),
            defaulted('onSetup', noop)
        ],
        apis: {
            focus: (apis, comp)=>{
                apis.focus(comp);
            },
            setMenus: (apis, comp, menus)=>{
                apis.setMenus(comp, menus);
            }
        }
    });
    const getAnimationRoot = (component, slideConfig)=>slideConfig.getAnimationRoot.fold(()=>component.element
        , (get)=>get(component)
        )
    ;
    const getDimensionProperty = (slideConfig)=>slideConfig.dimension.property
    ;
    const getDimension = (slideConfig, elem)=>slideConfig.dimension.getDimension(elem)
    ;
    const disableTransitions = (component, slideConfig)=>{
        const root = getAnimationRoot(component, slideConfig);
        remove$1(root, [
            slideConfig.shrinkingClass,
            slideConfig.growingClass
        ]);
    };
    const setShrunk = (component, slideConfig)=>{
        remove$2(component.element, slideConfig.openClass);
        add$2(component.element, slideConfig.closedClass);
        set$8(component.element, getDimensionProperty(slideConfig), '0px');
        reflow(component.element);
    };
    const setGrown = (component, slideConfig)=>{
        remove$2(component.element, slideConfig.closedClass);
        add$2(component.element, slideConfig.openClass);
        remove$6(component.element, getDimensionProperty(slideConfig));
    };
    const doImmediateShrink = (component, slideConfig, slideState, _calculatedSize)=>{
        slideState.setCollapsed();
        set$8(component.element, getDimensionProperty(slideConfig), getDimension(slideConfig, component.element));
        reflow(component.element);
        disableTransitions(component, slideConfig);
        setShrunk(component, slideConfig);
        slideConfig.onStartShrink(component);
        slideConfig.onShrunk(component);
    };
    const doStartShrink = (component, slideConfig, slideState, calculatedSize)=>{
        const size = calculatedSize.getOrThunk(()=>getDimension(slideConfig, component.element)
        );
        slideState.setCollapsed();
        set$8(component.element, getDimensionProperty(slideConfig), size);
        reflow(component.element);
        const root = getAnimationRoot(component, slideConfig);
        remove$2(root, slideConfig.growingClass);
        add$2(root, slideConfig.shrinkingClass);
        setShrunk(component, slideConfig);
        slideConfig.onStartShrink(component);
    };
    const doStartSmartShrink = (component, slideConfig, slideState)=>{
        const size = getDimension(slideConfig, component.element);
        const shrinker = size === '0px' ? doImmediateShrink : doStartShrink;
        shrinker(component, slideConfig, slideState, Optional.some(size));
    };
    const doStartGrow = (component, slideConfig, slideState)=>{
        const root = getAnimationRoot(component, slideConfig);
        const wasShrinking = has(root, slideConfig.shrinkingClass);
        const beforeSize = getDimension(slideConfig, component.element);
        setGrown(component, slideConfig);
        const fullSize = getDimension(slideConfig, component.element);
        const startPartialGrow = ()=>{
            set$8(component.element, getDimensionProperty(slideConfig), beforeSize);
            reflow(component.element);
        };
        const startCompleteGrow = ()=>{
            setShrunk(component, slideConfig);
        };
        const setStartSize = wasShrinking ? startPartialGrow : startCompleteGrow;
        setStartSize();
        remove$2(root, slideConfig.shrinkingClass);
        add$2(root, slideConfig.growingClass);
        setGrown(component, slideConfig);
        set$8(component.element, getDimensionProperty(slideConfig), fullSize);
        slideState.setExpanded();
        slideConfig.onStartGrow(component);
    };
    const refresh$3 = (component, slideConfig, slideState)=>{
        if (slideState.isExpanded()) {
            remove$6(component.element, getDimensionProperty(slideConfig));
            const fullSize = getDimension(slideConfig, component.element);
            set$8(component.element, getDimensionProperty(slideConfig), fullSize);
        }
    };
    const grow = (component, slideConfig, slideState)=>{
        if (!slideState.isExpanded()) doStartGrow(component, slideConfig, slideState);
    };
    const shrink = (component, slideConfig, slideState)=>{
        if (slideState.isExpanded()) doStartSmartShrink(component, slideConfig, slideState);
    };
    const immediateShrink = (component, slideConfig, slideState)=>{
        if (slideState.isExpanded()) doImmediateShrink(component, slideConfig, slideState);
    };
    const hasGrown1 = (component, slideConfig, slideState)=>slideState.isExpanded()
    ;
    const hasShrunk = (component, slideConfig, slideState)=>slideState.isCollapsed()
    ;
    const isGrowing = (component, slideConfig, _slideState)=>{
        const root = getAnimationRoot(component, slideConfig);
        return has(root, slideConfig.growingClass) === true;
    };
    const isShrinking = (component, slideConfig, _slideState)=>{
        const root = getAnimationRoot(component, slideConfig);
        return has(root, slideConfig.shrinkingClass) === true;
    };
    const isTransitioning = (component, slideConfig, slideState)=>isGrowing(component, slideConfig) || isShrinking(component, slideConfig)
    ;
    const toggleGrow = (component, slideConfig, slideState)=>{
        const f = slideState.isExpanded() ? doStartSmartShrink : doStartGrow;
        f(component, slideConfig, slideState);
    };
    var SlidingApis = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        refresh: refresh$3,
        grow: grow,
        shrink: shrink,
        immediateShrink: immediateShrink,
        hasGrown: hasGrown1,
        hasShrunk: hasShrunk,
        isGrowing: isGrowing,
        isShrinking: isShrinking,
        isTransitioning: isTransitioning,
        toggleGrow: toggleGrow,
        disableTransitions: disableTransitions
    });
    const exhibit = (base, slideConfig, _slideState)=>{
        const expanded = slideConfig.expanded;
        return expanded ? nu$7({
            classes: [
                slideConfig.openClass
            ],
            styles: {}
        }) : nu$7({
            classes: [
                slideConfig.closedClass
            ],
            styles: wrap$1(slideConfig.dimension.property, '0px')
        });
    };
    const events$4 = (slideConfig, slideState)=>derive$2([
            runOnSource(transitionend(), (component, simulatedEvent)=>{
                const raw = simulatedEvent.event.raw;
                if (raw.propertyName === slideConfig.dimension.property) {
                    disableTransitions(component, slideConfig);
                    if (slideState.isExpanded()) remove$6(component.element, slideConfig.dimension.property);
                    const notify = slideState.isExpanded() ? slideConfig.onGrown : slideConfig.onShrunk;
                    notify(component);
                }
            })
        ])
    ;
    var ActiveSliding = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        exhibit: exhibit,
        events: events$4
    });
    var SlidingSchema = [
        required$1('closedClass'),
        required$1('openClass'),
        required$1('shrinkingClass'),
        required$1('growingClass'),
        option$3('getAnimationRoot'),
        onHandler('onShrunk'),
        onHandler('onStartShrink'),
        onHandler('onGrown'),
        onHandler('onStartGrow'),
        defaulted('expanded', false),
        requiredOf('dimension', choose$1('property', {
            width: [
                output$1('property', 'width'),
                output$1('getDimension', (elem)=>get$c(elem) + 'px'
                )
            ],
            height: [
                output$1('property', 'height'),
                output$1('getDimension', (elem)=>get$d(elem) + 'px'
                )
            ]
        }))
    ];
    const init$5 = (spec)=>{
        const state = Cell(spec.expanded);
        const readState = ()=>'expanded: ' + state.get()
        ;
        return nu$8({
            isExpanded: ()=>state.get() === true
            ,
            isCollapsed: ()=>state.get() === false
            ,
            setCollapsed: curry(state.set, false),
            setExpanded: curry(state.set, true),
            readState
        });
    };
    var SlidingState = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        init: init$5
    });
    const Sliding = create$3({
        fields: SlidingSchema,
        name: 'sliding',
        active: ActiveSliding,
        apis: SlidingApis,
        state: SlidingState
    });
    const owner1 = 'container';
    const schema$d = [
        field1('slotBehaviours', [])
    ];
    const getPartName = (name)=>'<alloy.field.' + name + '>'
    ;
    const sketch1 = (sSpec)=>{
        const parts = (()=>{
            const record = [];
            const slot = (name, config)=>{
                record.push(name);
                return generateOne$1(owner1, getPartName(name), config);
            };
            return {
                slot,
                record: constant$1(record)
            };
        })();
        const spec = sSpec(parts);
        const partNames = parts.record();
        const fieldParts = map$2(partNames, (n)=>required1({
                name: n,
                pname: getPartName(n)
            })
        );
        return composite$1(owner1, schema$d, fieldParts, make$1, spec);
    };
    const make$1 = (detail, components)=>{
        const getSlotNames = (_)=>getAllPartNames(detail)
        ;
        const getSlot = (container, key)=>getPart(container, detail, key)
        ;
        const onSlot = (f, def)=>(container, key)=>getPart(container, detail, key).map((slot)=>f(slot, key)
                ).getOr(def)
        ;
        const onSlots = (f)=>(container, keys)=>{
                each$1(keys, (key)=>f(container, key)
                );
            }
        ;
        const doShowing = (comp, _key)=>get$f(comp.element, 'aria-hidden') !== 'true'
        ;
        const doShow = (comp, key)=>{
            if (!doShowing(comp)) {
                const element = comp.element;
                remove$6(element, 'display');
                remove$7(element, 'aria-hidden');
                emitWith(comp, slotVisibility(), {
                    name: key,
                    visible: true
                });
            }
        };
        const doHide = (comp, key)=>{
            if (doShowing(comp)) {
                const element = comp.element;
                set$8(element, 'display', 'none');
                set$9(element, 'aria-hidden', 'true');
                emitWith(comp, slotVisibility(), {
                    name: key,
                    visible: false
                });
            }
        };
        const isShowing = onSlot(doShowing, false);
        const hideSlot = onSlot(doHide);
        const hideSlots = onSlots(hideSlot);
        const hideAllSlots = (container)=>hideSlots(container, getSlotNames())
        ;
        const showSlot = onSlot(doShow);
        const apis = {
            getSlotNames,
            getSlot,
            isShowing,
            hideSlot,
            hideAllSlots,
            showSlot
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: get$3(detail.slotBehaviours),
            apis
        };
    };
    const slotApis = map$1({
        getSlotNames: (apis, c)=>apis.getSlotNames(c)
        ,
        getSlot: (apis, c, key)=>apis.getSlot(c, key)
        ,
        isShowing: (apis, c, key)=>apis.isShowing(c, key)
        ,
        hideSlot: (apis, c, key)=>apis.hideSlot(c, key)
        ,
        hideAllSlots: (apis, c)=>apis.hideAllSlots(c)
        ,
        showSlot: (apis, c, key)=>apis.showSlot(c, key)
    }, (value)=>makeApi(value)
    );
    const SlotContainer = {
        ...slotApis,
        sketch: sketch1
    };
    const sidebarSchema = objOf([
        optionalIcon,
        optionalTooltip,
        defaultedFunction('onShow', noop),
        defaultedFunction('onHide', noop),
        onSetup1
    ]);
    const createSidebar = (spec)=>asRaw('sidebar', sidebarSchema, spec)
    ;
    const setup$8 = (editor)=>{
        const { sidebars  } = editor.ui.registry.getAll();
        each$1(keys1(sidebars), (name)=>{
            const spec = sidebars[name];
            const isActive = ()=>is$11(Optional.from(editor.queryCommandValue('ToggleSidebar')), name)
            ;
            editor.ui.registry.addToggleButton(name, {
                icon: spec.icon,
                tooltip: spec.tooltip,
                onAction: (buttonApi)=>{
                    editor.execCommand('ToggleSidebar', false, name);
                    buttonApi.setActive(isActive());
                },
                onSetup: (buttonApi)=>{
                    const handleToggle = ()=>buttonApi.setActive(isActive())
                    ;
                    editor.on('ToggleSidebar', handleToggle);
                    return ()=>{
                        editor.off('ToggleSidebar', handleToggle);
                    };
                }
            });
        });
    };
    const getApi1 = (comp)=>({
            element: ()=>comp.element.dom
        })
    ;
    const makePanels = (parts, panelConfigs)=>{
        const specs = map$2(keys1(panelConfigs), (name)=>{
            const spec = panelConfigs[name];
            const bridged = getOrDie(createSidebar(spec));
            return {
                name,
                getApi: getApi1,
                onSetup: bridged.onSetup,
                onShow: bridged.onShow,
                onHide: bridged.onHide
            };
        });
        return map$2(specs, (spec)=>{
            const editorOffCell = Cell(noop);
            return parts.slot(spec.name, {
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-sidebar__pane'
                    ]
                },
                behaviours: SimpleBehaviours.unnamedEvents([
                    onControlAttached(spec, editorOffCell),
                    onControlDetached(spec, editorOffCell),
                    run$1(slotVisibility(), (sidepanel, se)=>{
                        const data = se.event;
                        const optSidePanelSpec = find$5(specs, (config)=>config.name === data.name
                        );
                        optSidePanelSpec.each((sidePanelSpec)=>{
                            const handler = data.visible ? sidePanelSpec.onShow : sidePanelSpec.onHide;
                            handler(sidePanelSpec.getApi(sidepanel));
                        });
                    })
                ])
            });
        });
    };
    const makeSidebar = (panelConfigs)=>SlotContainer.sketch((parts)=>({
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-sidebar__pane-container'
                    ]
                },
                components: makePanels(parts, panelConfigs),
                slotBehaviours: SimpleBehaviours.unnamedEvents([
                    runOnAttached((slotContainer)=>SlotContainer.hideAllSlots(slotContainer)
                    )
                ])
            })
        )
    ;
    const setSidebar = (sidebar, panelConfigs)=>{
        const optSlider = Composing.getCurrent(sidebar);
        optSlider.each((slider)=>Replacing.set(slider, [
                makeSidebar(panelConfigs)
            ])
        );
    };
    const toggleSidebar = (sidebar, name)=>{
        const optSlider = Composing.getCurrent(sidebar);
        optSlider.each((slider)=>{
            const optSlotContainer = Composing.getCurrent(slider);
            optSlotContainer.each((slotContainer)=>{
                if (Sliding.hasGrown(slider)) {
                    if (SlotContainer.isShowing(slotContainer, name)) Sliding.shrink(slider);
                    else {
                        SlotContainer.hideAllSlots(slotContainer);
                        SlotContainer.showSlot(slotContainer, name);
                    }
                } else {
                    SlotContainer.hideAllSlots(slotContainer);
                    SlotContainer.showSlot(slotContainer, name);
                    Sliding.grow(slider);
                }
            });
        });
    };
    const whichSidebar = (sidebar)=>{
        const optSlider = Composing.getCurrent(sidebar);
        return optSlider.bind((slider)=>{
            const sidebarOpen = Sliding.isGrowing(slider) || Sliding.hasGrown(slider);
            if (sidebarOpen) {
                const optSlotContainer = Composing.getCurrent(slider);
                return optSlotContainer.bind((slotContainer)=>find$5(SlotContainer.getSlotNames(slotContainer), (name)=>SlotContainer.isShowing(slotContainer, name)
                    )
                );
            } else return Optional.none();
        });
    };
    const fixSize = generate$6('FixSizeEvent');
    const autoSize = generate$6('AutoSizeEvent');
    const renderSidebar = (spec)=>({
            uid: spec.uid,
            dom: {
                tag: 'div',
                classes: [
                    'tox-sidebar'
                ],
                attributes: {
                    role: 'complementary'
                }
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: [
                            'tox-sidebar__slider'
                        ]
                    },
                    components: [],
                    behaviours: derive$1([
                        Tabstopping.config({}),
                        Focusing.config({}),
                        Sliding.config({
                            dimension: {
                                property: 'width'
                            },
                            closedClass: 'tox-sidebar--sliding-closed',
                            openClass: 'tox-sidebar--sliding-open',
                            shrinkingClass: 'tox-sidebar--sliding-shrinking',
                            growingClass: 'tox-sidebar--sliding-growing',
                            onShrunk: (slider)=>{
                                const optSlotContainer = Composing.getCurrent(slider);
                                optSlotContainer.each(SlotContainer.hideAllSlots);
                                emit(slider, autoSize);
                            },
                            onGrown: (slider)=>{
                                emit(slider, autoSize);
                            },
                            onStartGrow: (slider)=>{
                                emitWith(slider, fixSize, {
                                    width: getRaw(slider.element, 'width').getOr('')
                                });
                            },
                            onStartShrink: (slider)=>{
                                emitWith(slider, fixSize, {
                                    width: get$c(slider.element) + 'px'
                                });
                            }
                        }),
                        Replacing.config({}),
                        Composing.config({
                            find: (comp)=>{
                                const children = Replacing.contents(comp);
                                return head(children);
                            }
                        })
                    ])
                }
            ],
            behaviours: derive$1([
                ComposingConfigs.childAt(0),
                config1('sidebar-sliding-events', [
                    run$1(fixSize, (comp, se)=>{
                        set$8(comp.element, 'width', se.event.width);
                    }),
                    run$1(autoSize, (comp, _se)=>{
                        remove$6(comp.element, 'width');
                    })
                ])
            ])
        })
    ;
    const block1 = (component, config, state, getBusySpec)=>{
        set$9(component.element, 'aria-busy', true);
        const root = config.getRoot(component).getOr(component);
        const blockerBehaviours = derive$1([
            Keying.config({
                mode: 'special',
                onTab: ()=>Optional.some(true)
                ,
                onShiftTab: ()=>Optional.some(true)
            }),
            Focusing.config({})
        ]);
        const blockSpec = getBusySpec(root, blockerBehaviours);
        const blocker = root.getSystem().build(blockSpec);
        Replacing.append(root, premade(blocker));
        if (blocker.hasConfigured(Keying) && config.focus) Keying.focusIn(blocker);
        if (!state.isBlocked()) config.onBlock(component);
        state.blockWith(()=>Replacing.remove(root, blocker)
        );
    };
    const unblock1 = (component, config, state)=>{
        remove$7(component.element, 'aria-busy');
        if (state.isBlocked()) config.onUnblock(component);
        state.clear();
    };
    var BlockingApis = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        block: block1,
        unblock: unblock1
    });
    var BlockingSchema = [
        defaultedFunction('getRoot', Optional.none),
        defaultedBoolean('focus', true),
        onHandler('onBlock'),
        onHandler('onUnblock')
    ];
    const init$4 = ()=>{
        const blocker = destroyable();
        const blockWith = (destroy)=>{
            blocker.set({
                destroy
            });
        };
        return nu$8({
            readState: blocker.isSet,
            blockWith,
            clear: blocker.clear,
            isBlocked: blocker.isSet
        });
    };
    var BlockingState = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        init: init$4
    });
    const Blocking = create$3({
        fields: BlockingSchema,
        name: 'blocking',
        apis: BlockingApis,
        state: BlockingState
    });
    const getAttrs = (elem)=>{
        const attributes = elem.dom.attributes !== undefined ? elem.dom.attributes : [];
        return foldl(attributes, (b, attr)=>{
            if (attr.name === 'class') return b;
            else return {
                ...b,
                [attr.name]: attr.value
            };
        }, {});
    };
    const getClasses1 = (elem)=>Array.prototype.slice.call(elem.dom.classList, 0)
    ;
    const fromHtml = (html)=>{
        const elem = SugarElement.fromHtml(html);
        const children$1 = children1(elem);
        const attrs = getAttrs(elem);
        const classes = getClasses1(elem);
        const contents = children$1.length === 0 ? {} : {
            innerHtml: get$9(elem)
        };
        return {
            tag: name$3(elem),
            classes,
            attributes: attrs,
            ...contents
        };
    };
    const getBusySpec$1 = (providerBackstage)=>(_root, _behaviours)=>({
                dom: {
                    tag: 'div',
                    attributes: {
                        'aria-label': providerBackstage.translate('Loading...'),
                        'tabindex': '0'
                    },
                    classes: [
                        'tox-throbber__busy-spinner'
                    ]
                },
                components: [
                    {
                        dom: fromHtml('<div class="tox-spinner"><div></div><div></div><div></div></div>')
                    }
                ]
            })
    ;
    const focusBusyComponent = (throbber)=>Composing.getCurrent(throbber).each((comp)=>focus$3(comp.element)
        )
    ;
    const toggleEditorTabIndex = (editor, state)=>{
        const tabIndexAttr = 'tabindex';
        const dataTabIndexAttr = `data-mce-${tabIndexAttr}`;
        Optional.from(editor.iframeElement).map(SugarElement.fromDom).each((iframe)=>{
            if (state) {
                getOpt1(iframe, tabIndexAttr).each((tabIndex)=>set$9(iframe, dataTabIndexAttr, tabIndex)
                );
                set$9(iframe, tabIndexAttr, -1);
            } else {
                remove$7(iframe, tabIndexAttr);
                getOpt1(iframe, dataTabIndexAttr).each((tabIndex)=>{
                    set$9(iframe, tabIndexAttr, tabIndex);
                    remove$7(iframe, dataTabIndexAttr);
                });
            }
        });
    };
    const toggleThrobber = (editor, comp, state, providerBackstage)=>{
        const element = comp.element;
        toggleEditorTabIndex(editor, state);
        if (state) {
            Blocking.block(comp, getBusySpec$1(providerBackstage));
            remove$6(element, 'display');
            remove$7(element, 'aria-hidden');
            if (editor.hasFocus()) focusBusyComponent(comp);
        } else {
            const throbberFocus = Composing.getCurrent(comp).exists((busyComp)=>hasFocus1(busyComp.element)
            );
            Blocking.unblock(comp);
            set$8(element, 'display', 'none');
            set$9(element, 'aria-hidden', 'true');
            if (throbberFocus) editor.focus();
        }
    };
    const renderThrobber = (spec)=>({
            uid: spec.uid,
            dom: {
                tag: 'div',
                attributes: {
                    'aria-hidden': 'true'
                },
                classes: [
                    'tox-throbber'
                ],
                styles: {
                    display: 'none'
                }
            },
            behaviours: derive$1([
                Replacing.config({}),
                Blocking.config({
                    focus: false
                }),
                Composing.config({
                    find: (comp)=>head(comp.components())
                })
            ]),
            components: []
        })
    ;
    const isFocusEvent = (event)=>event.type === 'focusin'
    ;
    const isPasteBinTarget = (event)=>{
        if (isFocusEvent(event)) {
            const node = event.composed ? head(event.composedPath()) : Optional.from(event.target);
            return node.map(SugarElement.fromDom).filter(isElement$1).exists((targetElm)=>has(targetElm, 'mce-pastebin')
            );
        } else return false;
    };
    const setup$7 = (editor, lazyThrobber, sharedBackstage)=>{
        const throbberState = Cell(false);
        const timer = value$2();
        const stealFocus = (e)=>{
            if (throbberState.get() && !isPasteBinTarget(e)) {
                e.preventDefault();
                focusBusyComponent(lazyThrobber());
                editor.editorManager.setActive(editor);
            }
        };
        if (!editor.inline) editor.on('PreInit', ()=>{
            editor.dom.bind(editor.getWin(), 'focusin', stealFocus);
            editor.on('BeforeExecCommand', (e)=>{
                if (e.command.toLowerCase() === 'mcefocus' && e.value !== true) stealFocus(e);
            });
        });
        const toggle = (state)=>{
            if (state !== throbberState.get()) {
                throbberState.set(state);
                toggleThrobber(editor, lazyThrobber(), state, sharedBackstage.providers);
                editor.dispatch('AfterProgressState', {
                    state
                });
            }
        };
        editor.on('ProgressState', (e)=>{
            timer.on(clearTimeout);
            if (isNumber(e.time)) {
                const timerId = global$9.setEditorTimeout(editor, ()=>toggle(e.state)
                , e.time);
                timer.set(timerId);
            } else {
                toggle(e.state);
                timer.clear();
            }
        });
    };
    const generate$1 = (xs, f)=>{
        const init = {
            len: 0,
            list: []
        };
        const r = foldl(xs, (b, a)=>{
            const value = f(a, b.len);
            return value.fold(constant$1(b), (v)=>({
                    len: v.finish,
                    list: b.list.concat([
                        v
                    ])
                })
            );
        }, init);
        return r.list;
    };
    const output1 = (within, extra, withinWidth)=>({
            within,
            extra,
            withinWidth
        })
    ;
    const apportion = (units, total, len)=>{
        const parray = generate$1(units, (unit, current)=>{
            const width = len(unit);
            return Optional.some({
                element: unit,
                start: current,
                finish: current + width,
                width
            });
        });
        const within = filter$2(parray, (unit)=>unit.finish <= total
        );
        const withinWidth = foldr(within, (acc, el)=>acc + el.width
        , 0);
        const extra = parray.slice(within.length);
        return {
            within,
            extra,
            withinWidth
        };
    };
    const toUnit = (parray)=>map$2(parray, (unit)=>unit.element
        )
    ;
    const fitLast = (within, extra, withinWidth)=>{
        const fits = toUnit(within.concat(extra));
        return output1(fits, [], withinWidth);
    };
    const overflow1 = (within, extra, overflower, withinWidth)=>{
        const fits = toUnit(within).concat([
            overflower
        ]);
        return output1(fits, toUnit(extra), withinWidth);
    };
    const fitAll = (within, extra, withinWidth)=>output1(toUnit(within), [], withinWidth)
    ;
    const tryFit = (total, units, len)=>{
        const divide = apportion(units, total, len);
        return divide.extra.length === 0 ? Optional.some(divide) : Optional.none();
    };
    const partition1 = (total, units, len, overflower)=>{
        const divide = tryFit(total, units, len).getOrThunk(()=>apportion(units, total - len(overflower), len)
        );
        const within = divide.within;
        const extra = divide.extra;
        const withinWidth = divide.withinWidth;
        if (extra.length === 1 && extra[0].width <= len(overflower)) return fitLast(within, extra, withinWidth);
        else if (extra.length >= 1) return overflow1(within, extra, overflower, withinWidth);
        else return fitAll(within, extra, withinWidth);
    };
    const setGroups$1 = (toolbar, storedGroups)=>{
        const bGroups = map$2(storedGroups, (g)=>premade(g)
        );
        Toolbar.setGroups(toolbar, bGroups);
    };
    const findFocusedComp = (comps)=>findMap(comps, (comp)=>search1(comp.element).bind((focusedElm)=>comp.getSystem().getByDom(focusedElm).toOptional()
            )
        )
    ;
    const refresh$2 = (toolbar, detail, setOverflow)=>{
        const builtGroups = detail.builtGroups.get();
        if (builtGroups.length === 0) return;
        const primary = getPartOrDie(toolbar, detail, 'primary');
        const overflowGroup = Coupling.getCoupled(toolbar, 'overflowGroup');
        set$8(primary.element, 'visibility', 'hidden');
        const groups = builtGroups.concat([
            overflowGroup
        ]);
        const focusedComp = findFocusedComp(groups);
        setOverflow([]);
        setGroups$1(primary, groups);
        const availableWidth = get$c(primary.element);
        const overflows = partition1(availableWidth, detail.builtGroups.get(), (comp)=>get$c(comp.element)
        , overflowGroup);
        if (overflows.extra.length === 0) {
            Replacing.remove(primary, overflowGroup);
            setOverflow([]);
        } else {
            setGroups$1(primary, overflows.within);
            setOverflow(overflows.extra);
        }
        remove$6(primary.element, 'visibility');
        reflow(primary.element);
        focusedComp.each(Focusing.focus);
    };
    const schema$c = constant$1([
        field1('splitToolbarBehaviours', [
            Coupling
        ]),
        customField('builtGroups', ()=>Cell([])
        )
    ]);
    const schema$b = constant$1([
        markers$1([
            'overflowToggledClass'
        ]),
        optionFunction('getOverflowBounds'),
        required$1('lazySink'),
        customField('overflowGroups', ()=>Cell([])
        )
    ].concat(schema$c()));
    const parts$7 = constant$1([
        required1({
            factory: Toolbar,
            schema: schema$e(),
            name: 'primary'
        }),
        external({
            schema: schema$e(),
            name: 'overflow'
        }),
        external({
            name: 'overflow-button'
        }),
        external({
            name: 'overflow-group'
        })
    ]);
    const expandable = constant$1((element, available)=>{
        setMax(element, Math.floor(available));
    });
    const schema$a = constant$1([
        markers$1([
            'toggledClass'
        ]),
        required$1('lazySink'),
        requiredFunction('fetch'),
        optionFunction('getBounds'),
        optionObjOf('fireDismissalEventInstead', [
            defaulted('event', dismissRequested())
        ]),
        schema$y()
    ]);
    const parts$6 = constant$1([
        external({
            name: 'button',
            overrides: (detail)=>({
                    dom: {
                        attributes: {
                            'aria-haspopup': 'true'
                        }
                    },
                    buttonBehaviours: derive$1([
                        Toggling.config({
                            toggleClass: detail.markers.toggledClass,
                            aria: {
                                mode: 'expanded'
                            },
                            toggleOnExecute: false
                        })
                    ])
                })
        }),
        external({
            factory: Toolbar,
            schema: schema$e(),
            name: 'toolbar',
            overrides: (detail)=>{
                return {
                    toolbarBehaviours: derive$1([
                        Keying.config({
                            mode: 'cyclic',
                            onEscape: (comp)=>{
                                getPart(comp, detail, 'button').each(Focusing.focus);
                                return Optional.none();
                            }
                        })
                    ])
                };
            }
        })
    ]);
    const toggle1 = (button, externals)=>{
        const toolbarSandbox = Coupling.getCoupled(button, 'toolbarSandbox');
        if (Sandboxing.isOpen(toolbarSandbox)) Sandboxing.close(toolbarSandbox);
        else Sandboxing.open(toolbarSandbox, externals.toolbar());
    };
    const position1 = (button, toolbar, detail, layouts)=>{
        const bounds = detail.getBounds.map((bounder)=>bounder()
        );
        const sink = detail.lazySink(button).getOrDie();
        Positioning.positionWithinBounds(sink, toolbar, {
            anchor: {
                type: 'hotspot',
                hotspot: button,
                layouts,
                overrides: {
                    maxWidthFunction: expandable()
                }
            }
        }, bounds);
    };
    const setGroups1 = (button, toolbar, detail, layouts, groups)=>{
        Toolbar.setGroups(toolbar, groups);
        position1(button, toolbar, detail, layouts);
        Toggling.on(button);
    };
    const makeSandbox = (button, spec, detail)=>{
        const ariaControls = manager();
        const onOpen = (sandbox, toolbar)=>{
            detail.fetch().get((groups)=>{
                setGroups1(button, toolbar, detail, spec.layouts, groups);
                ariaControls.link(button.element);
                Keying.focusIn(toolbar);
            });
        };
        const onClose = ()=>{
            Toggling.off(button);
            Focusing.focus(button);
            ariaControls.unlink(button.element);
        };
        return {
            dom: {
                tag: 'div',
                attributes: {
                    id: ariaControls.id
                }
            },
            behaviours: derive$1([
                Keying.config({
                    mode: 'special',
                    onEscape: (comp)=>{
                        Sandboxing.close(comp);
                        return Optional.some(true);
                    }
                }),
                Sandboxing.config({
                    onOpen,
                    onClose,
                    isPartOf: (container, data, queryElem)=>{
                        return isPartOf$1(data, queryElem) || isPartOf$1(button, queryElem);
                    },
                    getAttachPoint: ()=>{
                        return detail.lazySink(button).getOrDie();
                    }
                }),
                Receiving.config({
                    channels: {
                        ...receivingChannel$1({
                            isExtraPart: never,
                            ...detail.fireDismissalEventInstead.map((fe)=>({
                                    fireEventInstead: {
                                        event: fe.event
                                    }
                                })
                            ).getOr({})
                        }),
                        ...receivingChannel({
                            doReposition: ()=>{
                                Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each((toolbar)=>{
                                    position1(button, toolbar, detail, spec.layouts);
                                });
                            }
                        })
                    }
                })
            ])
        };
    };
    const factory$a = (detail, components, spec, externals)=>({
            ...Button.sketch({
                ...externals.button(),
                action: (button)=>{
                    toggle1(button, externals);
                },
                buttonBehaviours: SketchBehaviours.augment({
                    dump: externals.button().buttonBehaviours
                }, [
                    Coupling.config({
                        others: {
                            toolbarSandbox: (button)=>{
                                return makeSandbox(button, spec, detail);
                            }
                        }
                    })
                ])
            }),
            apis: {
                setGroups: (button, groups)=>{
                    Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each((toolbar)=>{
                        setGroups1(button, toolbar, detail, spec.layouts, groups);
                    });
                },
                reposition: (button)=>{
                    Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each((toolbar)=>{
                        position1(button, toolbar, detail, spec.layouts);
                    });
                },
                toggle: (button)=>{
                    toggle1(button, externals);
                },
                getToolbar: (button)=>{
                    return Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox'));
                },
                isOpen: (button)=>{
                    return Sandboxing.isOpen(Coupling.getCoupled(button, 'toolbarSandbox'));
                }
            }
        })
    ;
    const FloatingToolbarButton = composite({
        name: 'FloatingToolbarButton',
        factory: factory$a,
        configFields: schema$a(),
        partFields: parts$6(),
        apis: {
            setGroups: (apis, button, groups)=>{
                apis.setGroups(button, groups);
            },
            reposition: (apis, button)=>{
                apis.reposition(button);
            },
            toggle: (apis, button)=>{
                apis.toggle(button);
            },
            getToolbar: (apis, button)=>apis.getToolbar(button)
            ,
            isOpen: (apis, button)=>apis.isOpen(button)
        }
    });
    const schema$9 = constant$1([
        required$1('items'),
        markers$1([
            'itemSelector'
        ]),
        field1('tgroupBehaviours', [
            Keying
        ])
    ]);
    const parts$5 = constant$1([
        group1({
            name: 'items',
            unit: 'item'
        })
    ]);
    const factory$9 = (detail, components, _spec, _externals)=>({
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: augment(detail.tgroupBehaviours, [
                Keying.config({
                    mode: 'flow',
                    selector: detail.markers.itemSelector
                })
            ]),
            domModification: {
                attributes: {
                    role: 'toolbar'
                }
            }
        })
    ;
    const ToolbarGroup = composite({
        name: 'ToolbarGroup',
        configFields: schema$9(),
        partFields: parts$5(),
        factory: factory$9
    });
    const buildGroups = (comps)=>map$2(comps, (g)=>premade(g)
        )
    ;
    const refresh$1 = (toolbar, memFloatingToolbarButton, detail)=>{
        refresh$2(toolbar, detail, (overflowGroups)=>{
            detail.overflowGroups.set(overflowGroups);
            memFloatingToolbarButton.getOpt(toolbar).each((floatingToolbarButton)=>{
                FloatingToolbarButton.setGroups(floatingToolbarButton, buildGroups(overflowGroups));
            });
        });
    };
    const factory$8 = (detail, components, spec, externals)=>{
        const memFloatingToolbarButton = record1(FloatingToolbarButton.sketch({
            fetch: ()=>Future.nu((resolve)=>{
                    resolve(buildGroups(detail.overflowGroups.get()));
                })
            ,
            layouts: {
                onLtr: ()=>[
                        southwest$2,
                        southeast$2
                    ]
                ,
                onRtl: ()=>[
                        southeast$2,
                        southwest$2
                    ]
                ,
                onBottomLtr: ()=>[
                        northwest$2,
                        northeast$2
                    ]
                ,
                onBottomRtl: ()=>[
                        northeast$2,
                        northwest$2
                    ]
            },
            getBounds: spec.getOverflowBounds,
            lazySink: detail.lazySink,
            fireDismissalEventInstead: {},
            markers: {
                toggledClass: detail.markers.overflowToggledClass
            },
            parts: {
                button: externals['overflow-button'](),
                toolbar: externals.overflow()
            }
        }));
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: augment(detail.splitToolbarBehaviours, [
                Coupling.config({
                    others: {
                        overflowGroup: ()=>{
                            return ToolbarGroup.sketch({
                                ...externals['overflow-group'](),
                                items: [
                                    memFloatingToolbarButton.asSpec()
                                ]
                            });
                        }
                    }
                })
            ]),
            apis: {
                setGroups: (toolbar, groups)=>{
                    detail.builtGroups.set(map$2(groups, toolbar.getSystem().build));
                    refresh$1(toolbar, memFloatingToolbarButton, detail);
                },
                refresh: (toolbar)=>refresh$1(toolbar, memFloatingToolbarButton, detail)
                ,
                toggle: (toolbar)=>{
                    memFloatingToolbarButton.getOpt(toolbar).each((floatingToolbarButton)=>{
                        FloatingToolbarButton.toggle(floatingToolbarButton);
                    });
                },
                isOpen: (toolbar)=>memFloatingToolbarButton.getOpt(toolbar).map(FloatingToolbarButton.isOpen).getOr(false)
                ,
                reposition: (toolbar)=>{
                    memFloatingToolbarButton.getOpt(toolbar).each((floatingToolbarButton)=>{
                        FloatingToolbarButton.reposition(floatingToolbarButton);
                    });
                },
                getOverflow: (toolbar)=>memFloatingToolbarButton.getOpt(toolbar).bind(FloatingToolbarButton.getToolbar)
            },
            domModification: {
                attributes: {
                    role: 'group'
                }
            }
        };
    };
    const SplitFloatingToolbar = composite({
        name: 'SplitFloatingToolbar',
        configFields: schema$b(),
        partFields: parts$7(),
        factory: factory$8,
        apis: {
            setGroups: (apis, toolbar, groups)=>{
                apis.setGroups(toolbar, groups);
            },
            refresh: (apis, toolbar)=>{
                apis.refresh(toolbar);
            },
            reposition: (apis, toolbar)=>{
                apis.reposition(toolbar);
            },
            toggle: (apis, toolbar)=>{
                apis.toggle(toolbar);
            },
            isOpen: (apis, toolbar)=>apis.isOpen(toolbar)
            ,
            getOverflow: (apis, toolbar)=>apis.getOverflow(toolbar)
        }
    });
    const schema$8 = constant$1([
        markers$1([
            'closedClass',
            'openClass',
            'shrinkingClass',
            'growingClass',
            'overflowToggledClass'
        ]),
        onHandler('onOpened'),
        onHandler('onClosed')
    ].concat(schema$c()));
    const parts$4 = constant$1([
        required1({
            factory: Toolbar,
            schema: schema$e(),
            name: 'primary'
        }),
        required1({
            factory: Toolbar,
            schema: schema$e(),
            name: 'overflow',
            overrides: (detail)=>{
                return {
                    toolbarBehaviours: derive$1([
                        Sliding.config({
                            dimension: {
                                property: 'height'
                            },
                            closedClass: detail.markers.closedClass,
                            openClass: detail.markers.openClass,
                            shrinkingClass: detail.markers.shrinkingClass,
                            growingClass: detail.markers.growingClass,
                            onShrunk: (comp)=>{
                                getPart(comp, detail, 'overflow-button').each((button)=>{
                                    Toggling.off(button);
                                    Focusing.focus(button);
                                });
                                detail.onClosed(comp);
                            },
                            onGrown: (comp)=>{
                                Keying.focusIn(comp);
                                detail.onOpened(comp);
                            },
                            onStartGrow: (comp)=>{
                                getPart(comp, detail, 'overflow-button').each(Toggling.on);
                            }
                        }),
                        Keying.config({
                            mode: 'acyclic',
                            onEscape: (comp)=>{
                                getPart(comp, detail, 'overflow-button').each(Focusing.focus);
                                return Optional.some(true);
                            }
                        })
                    ])
                };
            }
        }),
        external({
            name: 'overflow-button',
            overrides: (detail)=>({
                    buttonBehaviours: derive$1([
                        Toggling.config({
                            toggleClass: detail.markers.overflowToggledClass,
                            aria: {
                                mode: 'pressed'
                            },
                            toggleOnExecute: false
                        })
                    ])
                })
        }),
        external({
            name: 'overflow-group'
        })
    ]);
    const isOpen1 = (toolbar, detail)=>getPart(toolbar, detail, 'overflow').map(Sliding.hasGrown).getOr(false)
    ;
    const toggleToolbar = (toolbar, detail)=>{
        getPart(toolbar, detail, 'overflow-button').bind(()=>getPart(toolbar, detail, 'overflow')
        ).each((overf)=>{
            refresh1(toolbar, detail);
            Sliding.toggleGrow(overf);
        });
    };
    const refresh1 = (toolbar, detail)=>{
        getPart(toolbar, detail, 'overflow').each((overflow)=>{
            refresh$2(toolbar, detail, (groups)=>{
                const builtGroups = map$2(groups, (g)=>premade(g)
                );
                Toolbar.setGroups(overflow, builtGroups);
            });
            getPart(toolbar, detail, 'overflow-button').each((button)=>{
                if (Sliding.hasGrown(overflow)) Toggling.on(button);
            });
            Sliding.refresh(overflow);
        });
    };
    const factory$7 = (detail, components, spec, externals)=>{
        const toolbarToggleEvent = 'alloy.toolbar.toggle';
        const doSetGroups = (toolbar, groups)=>{
            const built = map$2(groups, toolbar.getSystem().build);
            detail.builtGroups.set(built);
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: augment(detail.splitToolbarBehaviours, [
                Coupling.config({
                    others: {
                        overflowGroup: (toolbar)=>{
                            return ToolbarGroup.sketch({
                                ...externals['overflow-group'](),
                                items: [
                                    Button.sketch({
                                        ...externals['overflow-button'](),
                                        action: (_button)=>{
                                            emit(toolbar, toolbarToggleEvent);
                                        }
                                    })
                                ]
                            });
                        }
                    }
                }),
                config1('toolbar-toggle-events', [
                    run$1(toolbarToggleEvent, (toolbar)=>{
                        toggleToolbar(toolbar, detail);
                    })
                ])
            ]),
            apis: {
                setGroups: (toolbar, groups)=>{
                    doSetGroups(toolbar, groups);
                    refresh1(toolbar, detail);
                },
                refresh: (toolbar)=>refresh1(toolbar, detail)
                ,
                toggle: (toolbar)=>toggleToolbar(toolbar, detail)
                ,
                isOpen: (toolbar)=>isOpen1(toolbar, detail)
            },
            domModification: {
                attributes: {
                    role: 'group'
                }
            }
        };
    };
    const SplitSlidingToolbar = composite({
        name: 'SplitSlidingToolbar',
        configFields: schema$8(),
        partFields: parts$4(),
        factory: factory$7,
        apis: {
            setGroups: (apis, toolbar, groups)=>{
                apis.setGroups(toolbar, groups);
            },
            refresh: (apis, toolbar)=>{
                apis.refresh(toolbar);
            },
            toggle: (apis, toolbar)=>{
                apis.toggle(toolbar);
            },
            isOpen: (apis, toolbar)=>apis.isOpen(toolbar)
        }
    });
    const renderToolbarGroupCommon = (toolbarGroup)=>{
        const attributes = toolbarGroup.title.fold(()=>({})
        , (title)=>({
                attributes: {
                    title
                }
            })
        );
        return {
            dom: {
                tag: 'div',
                classes: [
                    'tox-toolbar__group'
                ],
                ...attributes
            },
            components: [
                ToolbarGroup.parts.items({})
            ],
            items: toolbarGroup.items,
            markers: {
                itemSelector: "*:not(.tox-split-button) > .tox-tbtn:not([disabled]), .tox-split-button:not([disabled]), .tox-toolbar-nav-js:not([disabled])"
            },
            tgroupBehaviours: derive$1([
                Tabstopping.config({}),
                Focusing.config({})
            ])
        };
    };
    const renderToolbarGroup = (toolbarGroup)=>ToolbarGroup.sketch(renderToolbarGroupCommon(toolbarGroup))
    ;
    const getToolbarbehaviours = (toolbarSpec, modeName)=>{
        const onAttached = runOnAttached((component)=>{
            const groups = map$2(toolbarSpec.initGroups, renderToolbarGroup);
            Toolbar.setGroups(component, groups);
        });
        return derive$1([
            DisablingConfigs.toolbarButton(toolbarSpec.providers.isDisabled),
            receivingConfig(),
            Keying.config({
                mode: modeName,
                onEscape: toolbarSpec.onEscape,
                selector: '.tox-toolbar__group'
            }),
            config1('toolbar-events', [
                onAttached
            ])
        ]);
    };
    const renderMoreToolbarCommon = (toolbarSpec)=>{
        const modeName = toolbarSpec.cyclicKeying ? 'cyclic' : 'acyclic';
        return {
            uid: toolbarSpec.uid,
            dom: {
                tag: 'div',
                classes: [
                    'tox-toolbar-overlord'
                ]
            },
            parts: {
                'overflow-group': renderToolbarGroupCommon({
                    title: Optional.none(),
                    items: []
                }),
                'overflow-button': renderIconButtonSpec({
                    name: 'more',
                    icon: Optional.some('more-drawer'),
                    enabled: true,
                    tooltip: Optional.some('More...'),
                    primary: false,
                    buttonType: Optional.none(),
                    borderless: false
                }, Optional.none(), toolbarSpec.providers)
            },
            splitToolbarBehaviours: getToolbarbehaviours(toolbarSpec, modeName)
        };
    };
    const renderFloatingMoreToolbar = (toolbarSpec)=>{
        const baseSpec = renderMoreToolbarCommon(toolbarSpec);
        const overflowXOffset = 4;
        const primary = SplitFloatingToolbar.parts.primary({
            dom: {
                tag: 'div',
                classes: [
                    'tox-toolbar__primary'
                ]
            }
        });
        return SplitFloatingToolbar.sketch({
            ...baseSpec,
            lazySink: toolbarSpec.getSink,
            getOverflowBounds: ()=>{
                const headerElem = toolbarSpec.moreDrawerData.lazyHeader().element;
                const headerBounds = absolute$2(headerElem);
                const docElem = documentElement(headerElem);
                const docBounds = absolute$2(docElem);
                const height = Math.max(docElem.dom.scrollHeight, docBounds.height);
                return bounds1(headerBounds.x + overflowXOffset, docBounds.y, headerBounds.width - overflowXOffset * 2, height);
            },
            parts: {
                ...baseSpec.parts,
                overflow: {
                    dom: {
                        tag: 'div',
                        classes: [
                            'tox-toolbar__overflow'
                        ],
                        attributes: toolbarSpec.attributes
                    }
                }
            },
            components: [
                primary
            ],
            markers: {
                overflowToggledClass: 'tox-tbtn--enabled'
            }
        });
    };
    const renderSlidingMoreToolbar = (toolbarSpec)=>{
        const primary = SplitSlidingToolbar.parts.primary({
            dom: {
                tag: 'div',
                classes: [
                    'tox-toolbar__primary'
                ]
            }
        });
        const overflow = SplitSlidingToolbar.parts.overflow({
            dom: {
                tag: 'div',
                classes: [
                    'tox-toolbar__overflow'
                ]
            }
        });
        const baseSpec = renderMoreToolbarCommon(toolbarSpec);
        return SplitSlidingToolbar.sketch({
            ...baseSpec,
            components: [
                primary,
                overflow
            ],
            markers: {
                openClass: 'tox-toolbar__overflow--open',
                closedClass: 'tox-toolbar__overflow--closed',
                growingClass: 'tox-toolbar__overflow--growing',
                shrinkingClass: 'tox-toolbar__overflow--shrinking',
                overflowToggledClass: 'tox-tbtn--enabled'
            },
            onOpened: (comp)=>{
                comp.getSystem().broadcastOn([
                    toolbarHeightChange()
                ], {
                    type: 'opened'
                });
            },
            onClosed: (comp)=>{
                comp.getSystem().broadcastOn([
                    toolbarHeightChange()
                ], {
                    type: 'closed'
                });
            }
        });
    };
    const renderToolbar = (toolbarSpec)=>{
        const modeName = toolbarSpec.cyclicKeying ? 'cyclic' : 'acyclic';
        return Toolbar.sketch({
            uid: toolbarSpec.uid,
            dom: {
                tag: 'div',
                classes: [
                    'tox-toolbar'
                ].concat(toolbarSpec.type === ToolbarMode$1.scrolling ? [
                    'tox-toolbar--scrolling'
                ] : [])
            },
            components: [
                Toolbar.parts.groups({})
            ],
            toolbarBehaviours: getToolbarbehaviours(toolbarSpec, modeName)
        });
    };
    const factory$6 = (detail, components, _spec)=>{
        const apis = {
            getSocket: (comp)=>{
                return parts$a.getPart(comp, detail, 'socket');
            },
            setSidebar: (comp, panelConfigs)=>{
                parts$a.getPart(comp, detail, 'sidebar').each((sidebar)=>setSidebar(sidebar, panelConfigs)
                );
            },
            toggleSidebar: (comp, name)=>{
                parts$a.getPart(comp, detail, 'sidebar').each((sidebar)=>toggleSidebar(sidebar, name)
                );
            },
            whichSidebar: (comp)=>{
                return parts$a.getPart(comp, detail, 'sidebar').bind(whichSidebar).getOrNull();
            },
            getHeader: (comp)=>{
                return parts$a.getPart(comp, detail, 'header');
            },
            getToolbar: (comp)=>{
                return parts$a.getPart(comp, detail, 'toolbar');
            },
            setToolbar: (comp, groups)=>{
                parts$a.getPart(comp, detail, 'toolbar').each((toolbar)=>{
                    toolbar.getApis().setGroups(toolbar, groups);
                });
            },
            setToolbars: (comp, toolbars)=>{
                parts$a.getPart(comp, detail, 'multiple-toolbar').each((mToolbar)=>{
                    CustomList.setItems(mToolbar, toolbars);
                });
            },
            refreshToolbar: (comp)=>{
                const toolbar1 = parts$a.getPart(comp, detail, 'toolbar');
                toolbar1.each((toolbar)=>toolbar.getApis().refresh(toolbar)
                );
            },
            toggleToolbarDrawer: (comp)=>{
                parts$a.getPart(comp, detail, 'toolbar').each((toolbar)=>{
                    mapFrom(toolbar.getApis().toggle, (toggle)=>toggle(toolbar)
                    );
                });
            },
            isToolbarDrawerToggled: (comp)=>{
                return parts$a.getPart(comp, detail, 'toolbar').bind((toolbar)=>Optional.from(toolbar.getApis().isOpen).map((isOpen)=>isOpen(toolbar)
                    )
                ).getOr(false);
            },
            getThrobber: (comp)=>{
                return parts$a.getPart(comp, detail, 'throbber');
            },
            focusToolbar: (comp)=>{
                const optToolbar = parts$a.getPart(comp, detail, 'toolbar').orThunk(()=>parts$a.getPart(comp, detail, 'multiple-toolbar')
                );
                optToolbar.each((toolbar)=>{
                    Keying.focusIn(toolbar);
                });
            },
            setMenubar: (comp, menus)=>{
                parts$a.getPart(comp, detail, 'menubar').each((menubar)=>{
                    SilverMenubar.setMenus(menubar, menus);
                });
            },
            focusMenubar: (comp)=>{
                parts$a.getPart(comp, detail, 'menubar').each((menubar)=>{
                    SilverMenubar.focus(menubar);
                });
            }
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            apis,
            behaviours: detail.behaviours
        };
    };
    const partMenubar1 = partType.optional({
        factory: SilverMenubar,
        name: 'menubar',
        schema: [
            required$1('backstage')
        ]
    });
    const toolbarFactory = (spec)=>{
        if (spec.type === ToolbarMode$1.sliding) return renderSlidingMoreToolbar;
        else if (spec.type === ToolbarMode$1.floating) return renderFloatingMoreToolbar;
        else return renderToolbar;
    };
    const partMultipleToolbar1 = partType.optional({
        factory: {
            sketch: (spec)=>CustomList.sketch({
                    uid: spec.uid,
                    dom: spec.dom,
                    listBehaviours: derive$1([
                        Keying.config({
                            mode: 'acyclic',
                            selector: '.tox-toolbar'
                        })
                    ]),
                    makeItem: ()=>renderToolbar({
                            type: spec.type,
                            uid: generate$6('multiple-toolbar-item'),
                            cyclicKeying: false,
                            initGroups: [],
                            providers: spec.providers,
                            onEscape: ()=>{
                                spec.onEscape();
                                return Optional.some(true);
                            }
                        })
                    ,
                    setupItem: (_mToolbar, tc, data, _index)=>{
                        Toolbar.setGroups(tc, data);
                    },
                    shell: true
                })
        },
        name: 'multiple-toolbar',
        schema: [
            required$1('dom'),
            required$1('onEscape')
        ]
    });
    const partToolbar1 = partType.optional({
        factory: {
            sketch: (spec)=>{
                const renderer = toolbarFactory(spec);
                const toolbarSpec = {
                    type: spec.type,
                    uid: spec.uid,
                    onEscape: ()=>{
                        spec.onEscape();
                        return Optional.some(true);
                    },
                    cyclicKeying: false,
                    initGroups: [],
                    getSink: spec.getSink,
                    providers: spec.providers,
                    moreDrawerData: {
                        lazyToolbar: spec.lazyToolbar,
                        lazyMoreButton: spec.lazyMoreButton,
                        lazyHeader: spec.lazyHeader
                    },
                    attributes: spec.attributes
                };
                return renderer(toolbarSpec);
            }
        },
        name: 'toolbar',
        schema: [
            required$1('dom'),
            required$1('onEscape'),
            required$1('getSink')
        ]
    });
    const partHeader1 = partType.optional({
        factory: {
            sketch: renderHeader1
        },
        name: 'header',
        schema: [
            required$1('dom')
        ]
    });
    const partSocket1 = partType.optional({
        name: 'socket',
        schema: [
            required$1('dom')
        ]
    });
    const partSidebar1 = partType.optional({
        factory: {
            sketch: renderSidebar
        },
        name: 'sidebar',
        schema: [
            required$1('dom')
        ]
    });
    const partThrobber1 = partType.optional({
        factory: {
            sketch: renderThrobber
        },
        name: 'throbber',
        schema: [
            required$1('dom')
        ]
    });
    var OuterContainer = composite({
        name: 'OuterContainer',
        factory: factory$6,
        configFields: [
            required$1('dom'),
            required$1('behaviours')
        ],
        partFields: [
            partHeader1,
            partMenubar1,
            partToolbar1,
            partMultipleToolbar1,
            partSocket1,
            partSidebar1,
            partThrobber1
        ],
        apis: {
            getSocket: (apis, comp)=>{
                return apis.getSocket(comp);
            },
            setSidebar: (apis, comp, panelConfigs)=>{
                apis.setSidebar(comp, panelConfigs);
            },
            toggleSidebar: (apis, comp, name)=>{
                apis.toggleSidebar(comp, name);
            },
            whichSidebar: (apis, comp)=>{
                return apis.whichSidebar(comp);
            },
            getHeader: (apis, comp)=>{
                return apis.getHeader(comp);
            },
            getToolbar: (apis, comp)=>{
                return apis.getToolbar(comp);
            },
            setToolbar: (apis, comp, grps)=>{
                const groups = map$2(grps, (grp)=>{
                    return renderToolbarGroup(grp);
                });
                apis.setToolbar(comp, groups);
            },
            setToolbars: (apis, comp, ts)=>{
                const renderedToolbars = map$2(ts, (g)=>map$2(g, renderToolbarGroup)
                );
                apis.setToolbars(comp, renderedToolbars);
            },
            refreshToolbar: (apis, comp)=>{
                return apis.refreshToolbar(comp);
            },
            toggleToolbarDrawer: (apis, comp)=>{
                apis.toggleToolbarDrawer(comp);
            },
            isToolbarDrawerToggled: (apis, comp)=>{
                return apis.isToolbarDrawerToggled(comp);
            },
            getThrobber: (apis, comp)=>{
                return apis.getThrobber(comp);
            },
            setMenubar: (apis, comp, menus)=>{
                apis.setMenubar(comp, menus);
            },
            focusMenubar: (apis, comp)=>{
                apis.focusMenubar(comp);
            },
            focusToolbar: (apis, comp)=>{
                apis.focusToolbar(comp);
            }
        }
    });
    const defaultMenubar = 'file edit view insert format tools table help';
    const defaultMenus = {
        file: {
            title: 'File',
            items: 'newdocument restoredraft | preview | export print | deleteallconversations'
        },
        edit: {
            title: 'Edit',
            items: 'undo redo | cut copy paste pastetext | selectall | searchreplace'
        },
        view: {
            title: 'View',
            items: 'code | visualaid visualchars visualblocks | spellchecker | preview fullscreen | showcomments'
        },
        insert: {
            title: 'Insert',
            items: 'image link media addcomment pageembed template codesample inserttable | charmap emoticons hr | pagebreak nonbreaking anchor tableofcontents | insertdatetime'
        },
        format: {
            title: 'Format',
            items: 'bold italic underline strikethrough superscript subscript codeformat | styles blocks fontfamily fontsize align lineheight | forecolor backcolor | language | removeformat'
        },
        tools: {
            title: 'Tools',
            items: 'spellchecker spellcheckerlanguage | a11ycheck code wordcount'
        },
        table: {
            title: 'Table',
            items: 'inserttable | cell row column | advtablesort | tableprops deletetable'
        },
        help: {
            title: 'Help',
            items: 'help'
        }
    };
    const make1 = (menu, registry, editor)=>{
        const removedMenuItems = getRemovedMenuItems(editor).split(/[ ,]/);
        return {
            text: menu.title,
            getItems: ()=>bind$3(menu.items, (i)=>{
                    const itemName = i.toLowerCase();
                    if (itemName.trim().length === 0) return [];
                    else if (exists(removedMenuItems, (removedMenuItem)=>removedMenuItem === itemName
                    )) return [];
                    else if (itemName === 'separator' || itemName === '|') return [
                        {
                            type: 'separator'
                        }
                    ];
                    else if (registry.menuItems[itemName]) return [
                        registry.menuItems[itemName]
                    ];
                    else return [];
                })
        };
    };
    const parseItemsString = (items)=>{
        if (typeof items === 'string') return items.split(' ');
        return items;
    };
    const identifyMenus = (editor, registry)=>{
        const rawMenuData = {
            ...defaultMenus,
            ...registry.menus
        };
        const userDefinedMenus = keys1(registry.menus).length > 0;
        const menubar = registry.menubar === undefined || registry.menubar === true ? parseItemsString(defaultMenubar) : parseItemsString(registry.menubar === false ? '' : registry.menubar);
        const validMenus = filter$2(menubar, (menuName)=>{
            const isDefaultMenu = has$2(defaultMenus, menuName);
            if (userDefinedMenus) return isDefaultMenu || get$g(registry.menus, menuName).exists((menu)=>has$2(menu, 'items')
            );
            else return isDefaultMenu;
        });
        const menus = map$2(validMenus, (menuName)=>{
            const menuData = rawMenuData[menuName];
            return make1({
                title: menuData.title,
                items: parseItemsString(menuData.items)
            }, registry, editor);
        });
        return filter$2(menus, (menu)=>{
            const isNotSeparator = (item)=>item.type !== 'separator'
            ;
            return menu.getItems().length > 0 && exists(menu.getItems(), isNotSeparator);
        });
    };
    const fireSkinLoaded = (editor)=>{
        const done = ()=>{
            editor._skinLoaded = true;
            fireSkinLoaded$1(editor);
        };
        return ()=>{
            if (editor.initialized) done();
            else editor.on('init', done);
        };
    };
    const fireSkinLoadError = (editor, err)=>()=>fireSkinLoadError$1(editor, {
                message: err
            })
    ;
    const loadStylesheet = (editor, stylesheetUrl, styleSheetLoader)=>{
        editor.on('remove', ()=>styleSheetLoader.unload(stylesheetUrl)
        );
        return styleSheetLoader.load(stylesheetUrl);
    };
    const loadUiSkins = (editor, skinUrl)=>{
        const skinUiCss = skinUrl + '/skin.min.css';
        return loadStylesheet(editor, skinUiCss, editor.ui.styleSheetLoader);
    };
    const loadShadowDomUiSkins = (editor, skinUrl)=>{
        const isInShadowRoot$1 = isInShadowRoot(SugarElement.fromDom(editor.getElement()));
        if (isInShadowRoot$1) {
            const shadowDomSkinCss = skinUrl + '/skin.shadowdom.min.css';
            return loadStylesheet(editor, shadowDomSkinCss, global$7.DOM.styleSheetLoader);
        } else return Promise.resolve();
    };
    const loadSkin = (isInline, editor)=>{
        const skinUrl = getSkinUrl(editor);
        if (skinUrl) editor.contentCSS.push(skinUrl + (isInline ? '/content.inline' : '/content') + '.min.css');
        if (!isSkinDisabled(editor) && isString(skinUrl)) Promise.all([
            loadUiSkins(editor, skinUrl),
            loadShadowDomUiSkins(editor, skinUrl)
        ]).then(fireSkinLoaded(editor), fireSkinLoadError(editor, 'Skin could not be loaded'));
        else fireSkinLoaded(editor)();
    };
    const iframe1 = curry(loadSkin, false);
    const inline = curry(loadSkin, true);
    const onSetupFormatToggle = (editor, name)=>(api)=>{
            const boundCallback = unbindable();
            const init = ()=>{
                api.setActive(editor.formatter.match(name));
                const binding = editor.formatter.formatChanged(name, api.setActive);
                boundCallback.set(binding);
            };
            editor.initialized ? init() : editor.once('init', init);
            return ()=>{
                editor.off('init', init);
                boundCallback.clear();
            };
        }
    ;
    const onSetupEvent = (editor, event, f)=>(api)=>{
            const handleEvent = ()=>f(api)
            ;
            const init = ()=>{
                f(api);
                editor.on(event, handleEvent);
            };
            editor.initialized ? init() : editor.once('init', init);
            return ()=>{
                editor.off('init', init);
                editor.off(event, handleEvent);
            };
        }
    ;
    const onActionToggleFormat$1 = (editor)=>(rawItem)=>()=>{
                editor.undoManager.transact(()=>{
                    editor.focus();
                    editor.execCommand('mceToggleFormat', false, rawItem.format);
                });
            }
    ;
    const onActionExecCommand = (editor, command)=>()=>editor.execCommand(command)
    ;
    const generateSelectItems = (_editor, backstage1, spec)=>{
        const generateItem = (rawItem, response, invalid, value)=>{
            const translatedText = backstage1.shared.providers.translate(rawItem.title);
            if (rawItem.type === 'separator') return Optional.some({
                type: 'separator',
                text: translatedText
            });
            else if (rawItem.type === 'submenu') {
                const items = bind$3(rawItem.getStyleItems(), (si)=>validate(si, response, value)
                );
                if (response === 0 && items.length <= 0) return Optional.none();
                else return Optional.some({
                    type: 'nestedmenuitem',
                    text: translatedText,
                    enabled: items.length > 0,
                    getSubmenuItems: ()=>bind$3(rawItem.getStyleItems(), (si)=>validate(si, response, value)
                        )
                });
            } else return Optional.some({
                type: 'togglemenuitem',
                text: translatedText,
                icon: rawItem.icon,
                active: rawItem.isSelected(value),
                enabled: !invalid,
                onAction: spec.onAction(rawItem),
                ...rawItem.getStylePreview().fold(()=>({})
                , (preview)=>({
                        meta: {
                            style: preview
                        }
                    })
                )
            });
        };
        const validate = (item, response, value)=>{
            const invalid = item.type === 'formatter' && spec.isInvalid(item);
            if (response === 0) return invalid ? [] : generateItem(item, response, false, value).toArray();
            else return generateItem(item, response, invalid, value).toArray();
        };
        const validateItems = (preItems)=>{
            const value = spec.getCurrentValue();
            const response = spec.shouldHide ? 0 : 1;
            return bind$3(preItems, (item)=>validate(item, response, value)
            );
        };
        const getFetch = (backstage, getStyleItems)=>(comp, callback)=>{
                const preItems = getStyleItems();
                const items = validateItems(preItems);
                const menu = build1(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, false);
                callback(menu);
            }
        ;
        return {
            validateItems,
            getFetch
        };
    };
    const createMenuItems = (editor, backstage, spec)=>{
        const dataset = spec.dataset;
        const getStyleItems = dataset.type === 'basic' ? ()=>map$2(dataset.data, (d)=>processBasic(d, spec.isSelectedFor, spec.getPreviewFor)
            )
         : dataset.getData;
        return {
            items: generateSelectItems(editor, backstage, spec),
            getStyleItems
        };
    };
    const createSelectButton = (editor, backstage, spec)=>{
        const { items , getStyleItems  } = createMenuItems(editor, backstage, spec);
        const getApi = (comp)=>({
                getComponent: constant$1(comp)
            })
        ;
        const onSetup = onSetupEvent(editor, 'NodeChange', (api)=>{
            const comp = api.getComponent();
            spec.updateText(comp);
        });
        return renderCommonDropdown({
            text: spec.icon.isSome() ? Optional.none() : spec.text,
            icon: spec.icon,
            tooltip: Optional.from(spec.tooltip),
            role: Optional.none(),
            fetch: items.getFetch(backstage, getStyleItems),
            onSetup,
            getApi,
            columns: 1,
            presets: 'normal',
            classes: spec.icon.isSome() ? [] : [
                'bespoke'
            ],
            dropdownBehaviours: []
        }, 'tox-tbtn', backstage.shared);
    };
    const process = (rawFormats)=>map$2(rawFormats, (item)=>{
            let title = item, format = item;
            const values = item.split('=');
            if (values.length > 1) {
                title = values[0];
                format = values[1];
            }
            return {
                title,
                format
            };
        })
    ;
    const buildBasicStaticDataset = (data)=>({
            type: 'basic',
            data
        })
    ;
    var Delimiter1;
    (function(Delimiter) {
        Delimiter[Delimiter['SemiColon'] = 0] = 'SemiColon';
        Delimiter[Delimiter['Space'] = 1] = 'Space';
    })(Delimiter1 || (Delimiter1 = {}));
    const split = (rawFormats, delimiter)=>{
        if (delimiter === Delimiter1.SemiColon) return rawFormats.replace(/;$/, '').split(';');
        else return rawFormats.split(' ');
    };
    const buildBasicSettingsDataset = (editor, settingName, delimiter)=>{
        const rawFormats = editor.options.get(settingName);
        const data = process(split(rawFormats, delimiter));
        return {
            type: 'basic',
            data
        };
    };
    const alignMenuItems = [
        {
            title: 'Left',
            icon: 'align-left',
            format: 'alignleft',
            command: 'JustifyLeft'
        },
        {
            title: 'Center',
            icon: 'align-center',
            format: 'aligncenter',
            command: 'JustifyCenter'
        },
        {
            title: 'Right',
            icon: 'align-right',
            format: 'alignright',
            command: 'JustifyRight'
        },
        {
            title: 'Justify',
            icon: 'align-justify',
            format: 'alignjustify',
            command: 'JustifyFull'
        }
    ];
    const getSpec$4 = (editor)=>{
        const getMatchingValue = ()=>find$5(alignMenuItems, (item)=>editor.formatter.match(item.format)
            )
        ;
        const isSelectedFor = (format)=>()=>editor.formatter.match(format)
        ;
        const getPreviewFor = (_format)=>Optional.none
        ;
        const updateSelectMenuIcon = (comp)=>{
            const match = getMatchingValue();
            const alignment = match.fold(constant$1('left'), (item)=>item.title.toLowerCase()
            );
            emitWith(comp, updateMenuIcon, {
                icon: `align-${alignment}`
            });
        };
        const dataset = buildBasicStaticDataset(alignMenuItems);
        const onAction = (rawItem)=>()=>find$5(alignMenuItems, (item)=>item.format === rawItem.format
                ).each((item)=>editor.execCommand(item.command)
                )
        ;
        return {
            tooltip: 'Align',
            text: Optional.none(),
            icon: Optional.some('align-left'),
            isSelectedFor,
            getCurrentValue: Optional.none,
            getPreviewFor,
            onAction,
            updateText: updateSelectMenuIcon,
            dataset,
            shouldHide: false,
            isInvalid: (item)=>!editor.formatter.canApply(item.format)
        };
    };
    const createAlignButton = (editor, backstage)=>createSelectButton(editor, backstage, getSpec$4(editor))
    ;
    const createAlignMenu = (editor, backstage)=>{
        const menuItems = createMenuItems(editor, backstage, getSpec$4(editor));
        editor.ui.registry.addNestedMenuItem('align', {
            text: backstage.shared.providers.translate('Align'),
            getSubmenuItems: ()=>menuItems.items.validateItems(menuItems.getStyleItems())
        });
    };
    const findNearest = (editor, getStyles)=>{
        const styles = getStyles();
        const formats = map$2(styles, (style)=>style.format
        );
        return Optional.from(editor.formatter.closest(formats)).bind((fmt)=>find$5(styles, (data)=>data.format === fmt
            )
        ).orThunk(()=>someIf(editor.formatter.match('p'), {
                title: 'Paragraph',
                format: 'p'
            })
        );
    };
    const getSpec$3 = (editor)=>{
        const fallbackFormat = 'Paragraph';
        const isSelectedFor = (format)=>()=>editor.formatter.match(format)
        ;
        const getPreviewFor = (format)=>()=>{
                const fmt = editor.formatter.get(format);
                return Optional.some({
                    tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || 'div' : 'div',
                    styles: editor.dom.parseStyle(editor.formatter.getCssText(format))
                });
            }
        ;
        const updateSelectMenuText = (comp)=>{
            const detectedFormat = findNearest(editor, ()=>dataset.data
            );
            const text = detectedFormat.fold(constant$1(fallbackFormat), (fmt)=>fmt.title
            );
            emitWith(comp, updateMenuText, {
                text
            });
        };
        const dataset = buildBasicSettingsDataset(editor, 'block_formats', Delimiter1.SemiColon);
        return {
            tooltip: 'Blocks',
            text: Optional.some(fallbackFormat),
            icon: Optional.none(),
            isSelectedFor,
            getCurrentValue: Optional.none,
            getPreviewFor,
            onAction: onActionToggleFormat$1(editor),
            updateText: updateSelectMenuText,
            dataset,
            shouldHide: false,
            isInvalid: (item)=>!editor.formatter.canApply(item.format)
        };
    };
    const createBlocksButton = (editor, backstage)=>createSelectButton(editor, backstage, getSpec$3(editor))
    ;
    const createBlocksMenu = (editor, backstage)=>{
        const menuItems = createMenuItems(editor, backstage, getSpec$3(editor));
        editor.ui.registry.addNestedMenuItem('blocks', {
            text: 'Blocks',
            getSubmenuItems: ()=>menuItems.items.validateItems(menuItems.getStyleItems())
        });
    };
    const systemStackFonts = [
        '-apple-system',
        'Segoe UI',
        'Roboto',
        'Helvetica Neue',
        'sans-serif'
    ];
    const splitFonts = (fontFamily)=>{
        const fonts = fontFamily.split(/\s*,\s*/);
        return map$2(fonts, (font)=>font.replace(/^['"]+|['"]+$/g, '')
        );
    };
    const isSystemFontStack = (fontFamily)=>{
        const matchesSystemStack = ()=>{
            const fonts = splitFonts(fontFamily.toLowerCase());
            return forall(systemStackFonts, (font)=>fonts.indexOf(font.toLowerCase()) > -1
            );
        };
        return fontFamily.indexOf('-apple-system') === 0 && matchesSystemStack();
    };
    const getSpec$2 = (editor)=>{
        const systemFont = 'System Font';
        const getMatchingValue = ()=>{
            const getFirstFont = (fontFamily)=>fontFamily ? splitFonts(fontFamily)[0] : ''
            ;
            const fontFamily1 = editor.queryCommandValue('FontName');
            const items = dataset.data;
            const font = fontFamily1 ? fontFamily1.toLowerCase() : '';
            const matchOpt = find$5(items, (item)=>{
                const format = item.format;
                return format.toLowerCase() === font || getFirstFont(format).toLowerCase() === getFirstFont(font).toLowerCase();
            }).orThunk(()=>{
                return someIf(isSystemFontStack(font), {
                    title: systemFont,
                    format: font
                });
            });
            return {
                matchOpt,
                font: fontFamily1
            };
        };
        const isSelectedFor = (item)=>(valueOpt)=>valueOpt.exists((value)=>value.format === item
                )
        ;
        const getCurrentValue = ()=>{
            const { matchOpt  } = getMatchingValue();
            return matchOpt;
        };
        const getPreviewFor = (item)=>()=>Optional.some({
                    tag: 'div',
                    styles: item.indexOf('dings') === -1 ? {
                        'font-family': item
                    } : {}
                })
        ;
        const onAction = (rawItem)=>()=>{
                editor.undoManager.transact(()=>{
                    editor.focus();
                    editor.execCommand('FontName', false, rawItem.format);
                });
            }
        ;
        const updateSelectMenuText = (comp)=>{
            const { matchOpt , font  } = getMatchingValue();
            const text = matchOpt.fold(constant$1(font), (item)=>item.title
            );
            emitWith(comp, updateMenuText, {
                text
            });
        };
        const dataset = buildBasicSettingsDataset(editor, 'font_family_formats', Delimiter1.SemiColon);
        return {
            tooltip: 'Fonts',
            text: Optional.some(systemFont),
            icon: Optional.none(),
            isSelectedFor,
            getCurrentValue,
            getPreviewFor,
            onAction,
            updateText: updateSelectMenuText,
            dataset,
            shouldHide: false,
            isInvalid: never
        };
    };
    const createFontFamilyButton = (editor, backstage)=>createSelectButton(editor, backstage, getSpec$2(editor))
    ;
    const createFontFamilyMenu = (editor, backstage)=>{
        const menuItems = createMenuItems(editor, backstage, getSpec$2(editor));
        editor.ui.registry.addNestedMenuItem('fontfamily', {
            text: backstage.shared.providers.translate('Fonts'),
            getSubmenuItems: ()=>menuItems.items.validateItems(menuItems.getStyleItems())
        });
    };
    const legacyFontSizes = {
        '8pt': '1',
        '10pt': '2',
        '12pt': '3',
        '14pt': '4',
        '18pt': '5',
        '24pt': '6',
        '36pt': '7'
    };
    const keywordFontSizes = {
        'xx-small': '7pt',
        'x-small': '8pt',
        'small': '10pt',
        'medium': '12pt',
        'large': '14pt',
        'x-large': '18pt',
        'xx-large': '24pt'
    };
    const round1 = (number, precision)=>{
        const factor = Math.pow(10, precision);
        return Math.round(number * factor) / factor;
    };
    const toPt = (fontSize, precision)=>{
        if (/[0-9.]+px$/.test(fontSize)) return round1(parseInt(fontSize, 10) * 72 / 96, precision || 0) + 'pt';
        else return get$g(keywordFontSizes, fontSize).getOr(fontSize);
    };
    const toLegacy = (fontSize)=>get$g(legacyFontSizes, fontSize).getOr('')
    ;
    const getSpec$1 = (editor)=>{
        const getMatchingValue = ()=>{
            let matchOpt = Optional.none();
            const items = dataset.data;
            const fontSize = editor.queryCommandValue('FontSize');
            if (fontSize) for(let precision = 3; matchOpt.isNone() && precision >= 0; precision--){
                const pt = toPt(fontSize, precision);
                const legacy = toLegacy(pt);
                matchOpt = find$5(items, (item)=>item.format === fontSize || item.format === pt || item.format === legacy
                );
            }
            return {
                matchOpt,
                size: fontSize
            };
        };
        const isSelectedFor = (item)=>(valueOpt)=>valueOpt.exists((value)=>value.format === item
                )
        ;
        const getCurrentValue = ()=>{
            const { matchOpt  } = getMatchingValue();
            return matchOpt;
        };
        const getPreviewFor = constant$1(Optional.none);
        const onAction = (rawItem)=>()=>{
                editor.undoManager.transact(()=>{
                    editor.focus();
                    editor.execCommand('FontSize', false, rawItem.format);
                });
            }
        ;
        const updateSelectMenuText = (comp)=>{
            const { matchOpt , size  } = getMatchingValue();
            const text = matchOpt.fold(constant$1(size), (match)=>match.title
            );
            emitWith(comp, updateMenuText, {
                text
            });
        };
        const dataset = buildBasicSettingsDataset(editor, 'font_size_formats', Delimiter1.Space);
        return {
            tooltip: 'Font sizes',
            text: Optional.some('12pt'),
            icon: Optional.none(),
            isSelectedFor,
            getPreviewFor,
            getCurrentValue,
            onAction,
            updateText: updateSelectMenuText,
            dataset,
            shouldHide: false,
            isInvalid: never
        };
    };
    const createFontSizeButton = (editor, backstage)=>createSelectButton(editor, backstage, getSpec$1(editor))
    ;
    const createFontSizeMenu = (editor, backstage)=>{
        const menuItems = createMenuItems(editor, backstage, getSpec$1(editor));
        editor.ui.registry.addNestedMenuItem('fontsize', {
            text: 'Font sizes',
            getSubmenuItems: ()=>menuItems.items.validateItems(menuItems.getStyleItems())
        });
    };
    const getSpec = (editor, dataset)=>{
        const fallbackFormat = 'Paragraph';
        const isSelectedFor = (format)=>()=>editor.formatter.match(format)
        ;
        const getPreviewFor = (format)=>()=>{
                const fmt = editor.formatter.get(format);
                return fmt !== undefined ? Optional.some({
                    tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || 'div' : 'div',
                    styles: editor.dom.parseStyle(editor.formatter.getCssText(format))
                }) : Optional.none();
            }
        ;
        const updateSelectMenuText = (comp)=>{
            const getFormatItems = (fmt)=>{
                const subs = fmt.items;
                return subs !== undefined && subs.length > 0 ? bind$3(subs, getFormatItems) : [
                    {
                        title: fmt.title,
                        format: fmt.format
                    }
                ];
            };
            const flattenedItems = bind$3(getStyleFormats(editor), getFormatItems);
            const detectedFormat = findNearest(editor, constant$1(flattenedItems));
            const text = detectedFormat.fold(constant$1(fallbackFormat), (fmt)=>fmt.title
            );
            emitWith(comp, updateMenuText, {
                text
            });
        };
        return {
            tooltip: 'Formats',
            text: Optional.some(fallbackFormat),
            icon: Optional.none(),
            isSelectedFor,
            getCurrentValue: Optional.none,
            getPreviewFor,
            onAction: onActionToggleFormat$1(editor),
            updateText: updateSelectMenuText,
            shouldHide: shouldAutoHideStyleFormats(editor),
            isInvalid: (item)=>!editor.formatter.canApply(item.format)
            ,
            dataset
        };
    };
    const createStylesButton = (editor, backstage)=>{
        const dataset = {
            type: 'advanced',
            ...backstage.styles
        };
        return createSelectButton(editor, backstage, getSpec(editor, dataset));
    };
    const createStylesMenu = (editor, backstage)=>{
        const dataset = {
            type: 'advanced',
            ...backstage.styles
        };
        const menuItems = createMenuItems(editor, backstage, getSpec(editor, dataset));
        editor.ui.registry.addNestedMenuItem('styles', {
            text: 'Formats',
            getSubmenuItems: ()=>menuItems.items.validateItems(menuItems.getStyleItems())
        });
    };
    const events$3 = (reflectingConfig, reflectingState)=>{
        const update = (component, data)=>{
            reflectingConfig.updateState.each((updateState)=>{
                const newState = updateState(component, data);
                reflectingState.set(newState);
            });
            reflectingConfig.renderComponents.each((renderComponents)=>{
                const newComponents = renderComponents(data, reflectingState.get());
                const replacer = reflectingConfig.reuseDom ? withReuse : withoutReuse;
                replacer(component, newComponents);
            });
        };
        return derive$2([
            run$1(receive(), (component, message)=>{
                const receivingData = message;
                if (!receivingData.universal) {
                    const channel = reflectingConfig.channel;
                    if (contains$2(receivingData.channels, channel)) update(component, receivingData.data);
                }
            }),
            runOnAttached((comp, _se)=>{
                reflectingConfig.initialData.each((rawData)=>{
                    update(comp, rawData);
                });
            })
        ]);
    };
    var ActiveReflecting = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        events: events$3
    });
    const getState = (component, replaceConfig, reflectState)=>reflectState
    ;
    var ReflectingApis = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        getState: getState
    });
    var ReflectingSchema = [
        required$1('channel'),
        option$3('renderComponents'),
        option$3('updateState'),
        option$3('initialData'),
        defaultedBoolean('reuseDom', true)
    ];
    const init$3 = ()=>{
        const cell = Cell(Optional.none());
        const clear = ()=>cell.set(Optional.none())
        ;
        const readState = ()=>cell.get().getOr('none')
        ;
        return {
            readState,
            get: cell.get,
            set: cell.set,
            clear
        };
    };
    var ReflectingState = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        init: init$3
    });
    const Reflecting = create$3({
        fields: ReflectingSchema,
        name: 'reflecting',
        active: ActiveReflecting,
        apis: ReflectingApis,
        state: ReflectingState
    });
    const schema$7 = constant$1([
        required$1('toggleClass'),
        required$1('fetch'),
        onStrictHandler('onExecute'),
        defaulted('getHotspot', Optional.some),
        defaulted('getAnchorOverrides', constant$1({})),
        schema$y(),
        onStrictHandler('onItemExecute'),
        option$3('lazySink'),
        required$1('dom'),
        onHandler('onOpen'),
        field1('splitDropdownBehaviours', [
            Coupling,
            Keying,
            Focusing
        ]),
        defaulted('matchWidth', false),
        defaulted('useMinWidth', false),
        defaulted('eventOrder', {}),
        option$3('role')
    ].concat(sandboxFields()));
    const arrowPart = required1({
        factory: Button,
        schema: [
            required$1('dom')
        ],
        name: 'arrow',
        defaults: ()=>{
            return {
                buttonBehaviours: derive$1([
                    Focusing.revoke()
                ])
            };
        },
        overrides: (detail)=>{
            return {
                dom: {
                    tag: 'span',
                    attributes: {
                        role: 'presentation'
                    }
                },
                action: (arrow)=>{
                    arrow.getSystem().getByUid(detail.uid).each(emitExecute1);
                },
                buttonBehaviours: derive$1([
                    Toggling.config({
                        toggleOnExecute: false,
                        toggleClass: detail.toggleClass
                    })
                ])
            };
        }
    });
    const buttonPart = required1({
        factory: Button,
        schema: [
            required$1('dom')
        ],
        name: 'button',
        defaults: ()=>{
            return {
                buttonBehaviours: derive$1([
                    Focusing.revoke()
                ])
            };
        },
        overrides: (detail)=>{
            return {
                dom: {
                    tag: 'span',
                    attributes: {
                        role: 'presentation'
                    }
                },
                action: (btn)=>{
                    btn.getSystem().getByUid(detail.uid).each((splitDropdown)=>{
                        detail.onExecute(splitDropdown, btn);
                    });
                }
            };
        }
    });
    const parts$3 = constant$1([
        arrowPart,
        buttonPart,
        optional1({
            factory: {
                sketch: (spec)=>{
                    return {
                        uid: spec.uid,
                        dom: {
                            tag: 'span',
                            styles: {
                                display: 'none'
                            },
                            attributes: {
                                'aria-hidden': 'true'
                            },
                            innerHtml: spec.text
                        }
                    };
                }
            },
            schema: [
                required$1('text')
            ],
            name: 'aria-descriptor'
        }),
        external({
            schema: [
                tieredMenuMarkers()
            ],
            name: 'menu',
            defaults: (detail)=>{
                return {
                    onExecute: (tmenu, item)=>{
                        tmenu.getSystem().getByUid(detail.uid).each((splitDropdown)=>{
                            detail.onItemExecute(splitDropdown, tmenu, item);
                        });
                    }
                };
            }
        }),
        partType$1()
    ]);
    const factory$5 = (detail, components, spec, externals)=>{
        const switchToMenu = (sandbox)=>{
            Composing.getCurrent(sandbox).each((current)=>{
                Highlighting.highlightFirst(current);
                Keying.focusIn(current);
            });
        };
        const action = (component)=>{
            const onOpenSync = switchToMenu;
            togglePopup(detail, identity, component, externals, onOpenSync, HighlightOnOpen1.HighlightFirst).get(noop);
        };
        const openMenu = (comp)=>{
            action(comp);
            return Optional.some(true);
        };
        const executeOnButton = (comp)=>{
            const button = getPartOrDie(comp, detail, 'button');
            emitExecute1(button);
            return Optional.some(true);
        };
        const buttonEvents = {
            ...derive$2([
                runOnAttached((component, _simulatedEvent)=>{
                    const ariaDescriptor = getPart(component, detail, 'aria-descriptor');
                    ariaDescriptor.each((descriptor)=>{
                        const descriptorId = generate$6('aria');
                        set$9(descriptor.element, 'id', descriptorId);
                        set$9(component.element, 'aria-describedby', descriptorId);
                    });
                })
            ]),
            ...events$a(Optional.some(action))
        };
        const apis = {
            repositionMenus: (comp)=>{
                if (Toggling.isOn(comp)) repositionMenus1(comp);
            }
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            apis,
            eventOrder: {
                ...detail.eventOrder,
                [execute$5()]: [
                    'disabling',
                    'toggling',
                    'alloy.base.behaviour'
                ]
            },
            events: buttonEvents,
            behaviours: augment(detail.splitDropdownBehaviours, [
                Coupling.config({
                    others: {
                        sandbox: (hotspot)=>{
                            const arrow = getPartOrDie(hotspot, detail, 'arrow');
                            const extras = {
                                onOpen: ()=>{
                                    Toggling.on(arrow);
                                    Toggling.on(hotspot);
                                },
                                onClose: ()=>{
                                    Toggling.off(arrow);
                                    Toggling.off(hotspot);
                                }
                            };
                            return makeSandbox$1(detail, hotspot, extras);
                        }
                    }
                }),
                Keying.config({
                    mode: 'special',
                    onSpace: executeOnButton,
                    onEnter: executeOnButton,
                    onDown: openMenu
                }),
                Focusing.config({}),
                Toggling.config({
                    toggleOnExecute: false,
                    aria: {
                        mode: 'expanded'
                    }
                })
            ]),
            domModification: {
                attributes: {
                    'role': detail.role.getOr('button'),
                    'aria-haspopup': true
                }
            }
        };
    };
    const SplitDropdown = composite({
        name: 'SplitDropdown',
        configFields: schema$7(),
        partFields: parts$3(),
        factory: factory$5,
        apis: {
            repositionMenus: (apis, comp)=>apis.repositionMenus(comp)
        }
    });
    const getButtonApi = (component)=>({
            isEnabled: ()=>!Disabling.isDisabled(component)
            ,
            setEnabled: (state)=>Disabling.set(component, !state)
        })
    ;
    const getToggleApi = (component)=>({
            setActive: (state)=>{
                Toggling.set(component, state);
            },
            isActive: ()=>Toggling.isOn(component)
            ,
            isEnabled: ()=>!Disabling.isDisabled(component)
            ,
            setEnabled: (state)=>Disabling.set(component, !state)
        })
    ;
    const getTooltipAttributes = (tooltip1, providersBackstage)=>tooltip1.map((tooltip)=>({
                'aria-label': providersBackstage.translate(tooltip),
                'title': providersBackstage.translate(tooltip)
            })
        ).getOr({})
    ;
    const focusButtonEvent = generate$6('focus-button');
    const renderCommonStructure = (icon, text3, tooltip, receiver, behaviours, providersBackstage)=>{
        return {
            dom: {
                tag: 'button',
                classes: [
                    'tox-tbtn'
                ].concat(text3.isSome() ? [
                    'tox-tbtn--select'
                ] : []),
                attributes: getTooltipAttributes(tooltip, providersBackstage)
            },
            components: componentRenderPipeline([
                icon.map((iconName)=>renderIconFromPack(iconName, providersBackstage.icons)
                ),
                text3.map((text)=>renderLabel(text, 'tox-tbtn', providersBackstage)
                )
            ]),
            eventOrder: {
                [mousedown()]: [
                    'focusing',
                    'alloy.base.behaviour',
                    'common-button-display-events'
                ]
            },
            buttonBehaviours: derive$1([
                DisablingConfigs.toolbarButton(providersBackstage.isDisabled),
                receivingConfig(),
                config1('common-button-display-events', [
                    run$1(mousedown(), (button, se)=>{
                        se.event.prevent();
                        emit(button, focusButtonEvent);
                    })
                ])
            ].concat(receiver.map((r)=>Reflecting.config({
                    channel: r,
                    initialData: {
                        icon,
                        text: text3
                    },
                    renderComponents: (data, _state)=>componentRenderPipeline([
                            data.icon.map((iconName)=>renderIconFromPack(iconName, providersBackstage.icons)
                            ),
                            data.text.map((text)=>renderLabel(text, 'tox-tbtn', providersBackstage)
                            )
                        ])
                })
            ).toArray()).concat(behaviours.getOr([])))
        };
    };
    const renderFloatingToolbarButton = (spec, backstage, identifyButtons, attributes)=>{
        const sharedBackstage = backstage.shared;
        return FloatingToolbarButton.sketch({
            lazySink: sharedBackstage.getSink,
            fetch: ()=>Future.nu((resolve)=>{
                    resolve(map$2(identifyButtons(spec.items), renderToolbarGroup));
                })
            ,
            markers: {
                toggledClass: 'tox-tbtn--enabled'
            },
            parts: {
                button: renderCommonStructure(spec.icon, spec.text, spec.tooltip, Optional.none(), Optional.none(), sharedBackstage.providers),
                toolbar: {
                    dom: {
                        tag: 'div',
                        classes: [
                            'tox-toolbar__overflow'
                        ],
                        attributes
                    }
                }
            }
        });
    };
    const renderCommonToolbarButton = (spec, specialisation, providersBackstage)=>{
        const editorOffCell = Cell(noop);
        const structure = renderCommonStructure(spec.icon, spec.text, spec.tooltip, Optional.none(), Optional.none(), providersBackstage);
        return Button.sketch({
            dom: structure.dom,
            components: structure.components,
            eventOrder: toolbarButtonEventOrder,
            buttonBehaviours: derive$1([
                config1('toolbar-button-events', [
                    onToolbarButtonExecute({
                        onAction: spec.onAction,
                        getApi: specialisation.getApi
                    }),
                    onControlAttached(specialisation, editorOffCell),
                    onControlDetached(specialisation, editorOffCell)
                ]),
                DisablingConfigs.toolbarButton(()=>!spec.enabled || providersBackstage.isDisabled()
                ),
                receivingConfig()
            ].concat(specialisation.toolbarButtonBehaviours))
        });
    };
    const renderToolbarButton = (spec, providersBackstage)=>renderToolbarButtonWith(spec, providersBackstage, [])
    ;
    const renderToolbarButtonWith = (spec, providersBackstage, bonusEvents)=>renderCommonToolbarButton(spec, {
            toolbarButtonBehaviours: [].concat(bonusEvents.length > 0 ? [
                config1('toolbarButtonWith', bonusEvents)
            ] : []),
            getApi: getButtonApi,
            onSetup: spec.onSetup
        }, providersBackstage)
    ;
    const renderToolbarToggleButton = (spec, providersBackstage)=>renderToolbarToggleButtonWith(spec, providersBackstage, [])
    ;
    const renderToolbarToggleButtonWith = (spec, providersBackstage, bonusEvents)=>deepMerge(renderCommonToolbarButton(spec, {
            toolbarButtonBehaviours: [
                Replacing.config({}),
                Toggling.config({
                    toggleClass: 'tox-tbtn--enabled',
                    aria: {
                        mode: 'pressed'
                    },
                    toggleOnExecute: false
                })
            ].concat(bonusEvents.length > 0 ? [
                config1('toolbarToggleButtonWith', bonusEvents)
            ] : []),
            getApi: getToggleApi,
            onSetup: spec.onSetup
        }, providersBackstage))
    ;
    const fetchChoices = (getApi, spec, providersBackstage)=>(comp1)=>Future.nu((callback)=>spec.fetch(callback)
            ).map((items)=>Optional.from(createTieredDataFrom(deepMerge(createPartialChoiceMenu(generate$6('menu-value'), items, (value)=>{
                    spec.onItemAction(getApi(comp1), value);
                }, spec.columns, spec.presets, ItemResponse$1.CLOSE_ON_EXECUTE, spec.select.getOr(never), providersBackstage), {
                    movement: deriveMenuMovement(spec.columns, spec.presets),
                    menuBehaviours: SimpleBehaviours.unnamedEvents(spec.columns !== 'auto' ? [] : [
                        runOnAttached((comp, _se)=>{
                            detectSize(comp, 4, classForPreset(spec.presets)).each(({ numRows , numColumns  })=>{
                                Keying.setGridSize(comp, numRows, numColumns);
                            });
                        })
                    ])
                })))
            )
    ;
    const renderSplitButton = (spec, sharedBackstage)=>{
        const displayChannel = generate$6('channel-update-split-dropdown-display');
        const getApi = (comp)=>({
                isEnabled: ()=>!Disabling.isDisabled(comp)
                ,
                setEnabled: (state)=>Disabling.set(comp, !state)
                ,
                setIconFill: (id, value)=>{
                    descendant(comp.element, 'svg path[id="' + id + '"], rect[id="' + id + '"]').each((underlinePath)=>{
                        set$9(underlinePath, 'fill', value);
                    });
                },
                setActive: (state)=>{
                    set$9(comp.element, 'aria-pressed', state);
                    descendant(comp.element, 'span').each((button)=>{
                        comp.getSystem().getByDom(button).each((buttonComp)=>Toggling.set(buttonComp, state)
                        );
                    });
                },
                isActive: ()=>descendant(comp.element, 'span').exists((button)=>comp.getSystem().getByDom(button).exists(Toggling.isOn)
                    )
            })
        ;
        const editorOffCell = Cell(noop);
        const specialisation = {
            getApi,
            onSetup: spec.onSetup
        };
        return SplitDropdown.sketch({
            dom: {
                tag: 'div',
                classes: [
                    'tox-split-button'
                ],
                attributes: {
                    'aria-pressed': false,
                    ...getTooltipAttributes(spec.tooltip, sharedBackstage.providers)
                }
            },
            onExecute: (button)=>{
                spec.onAction(getApi(button));
            },
            onItemExecute: (_a, _b, _c)=>{},
            splitDropdownBehaviours: derive$1([
                DisablingConfigs.splitButton(sharedBackstage.providers.isDisabled),
                receivingConfig(),
                config1('split-dropdown-events', [
                    run$1(focusButtonEvent, Focusing.focus),
                    onControlAttached(specialisation, editorOffCell),
                    onControlDetached(specialisation, editorOffCell)
                ]),
                Unselecting.config({})
            ]),
            eventOrder: {
                [attachedToDom()]: [
                    'alloy.base.behaviour',
                    'split-dropdown-events'
                ]
            },
            toggleClass: 'tox-tbtn--enabled',
            lazySink: sharedBackstage.getSink,
            fetch: fetchChoices(getApi, spec, sharedBackstage.providers),
            parts: {
                menu: part1(false, spec.columns, spec.presets)
            },
            components: [
                SplitDropdown.parts.button(renderCommonStructure(spec.icon, spec.text, Optional.none(), Optional.some(displayChannel), Optional.some([
                    Toggling.config({
                        toggleClass: 'tox-tbtn--enabled',
                        toggleOnExecute: false
                    })
                ]), sharedBackstage.providers)),
                SplitDropdown.parts.arrow({
                    dom: {
                        tag: 'button',
                        classes: [
                            'tox-tbtn',
                            'tox-split-button__chevron'
                        ],
                        innerHtml: get$2('chevron-down', sharedBackstage.providers.icons)
                    },
                    buttonBehaviours: derive$1([
                        DisablingConfigs.splitButton(sharedBackstage.providers.isDisabled),
                        receivingConfig(),
                        addFocusableBehaviour()
                    ])
                }),
                SplitDropdown.parts['aria-descriptor']({
                    text: sharedBackstage.providers.translate('To open the popup, press Shift+Enter')
                })
            ]
        });
    };
    const defaultToolbar = [
        {
            name: 'history',
            items: [
                'undo',
                'redo'
            ]
        },
        {
            name: 'styles',
            items: [
                'styles'
            ]
        },
        {
            name: 'formatting',
            items: [
                'bold',
                'italic'
            ]
        },
        {
            name: 'alignment',
            items: [
                'alignleft',
                'aligncenter',
                'alignright',
                'alignjustify'
            ]
        },
        {
            name: 'indentation',
            items: [
                'outdent',
                'indent'
            ]
        },
        {
            name: 'permanent pen',
            items: [
                'permanentpen'
            ]
        },
        {
            name: 'comments',
            items: [
                'addcomment'
            ]
        }
    ];
    const renderFromBridge = (bridgeBuilder, render)=>(spec, extras, editor)=>{
            const internal = bridgeBuilder(spec).mapError((errInfo)=>formatError(errInfo)
            ).getOrDie();
            return render(internal, extras, editor);
        }
    ;
    const types1 = {
        button: renderFromBridge(createToolbarButton, (s, extras)=>renderToolbarButton(s, extras.backstage.shared.providers)
        ),
        togglebutton: renderFromBridge(createToggleButton, (s, extras)=>renderToolbarToggleButton(s, extras.backstage.shared.providers)
        ),
        menubutton: renderFromBridge(createMenuButton, (s, extras)=>renderMenuButton(s, 'tox-tbtn', extras.backstage, Optional.none())
        ),
        splitbutton: renderFromBridge(createSplitButton, (s, extras)=>renderSplitButton(s, extras.backstage.shared)
        ),
        grouptoolbarbutton: renderFromBridge(createGroupToolbarButton, (s, extras, editor)=>{
            const buttons = editor.ui.registry.getAll().buttons;
            const identify = (toolbar)=>identifyButtons1(editor, {
                    buttons,
                    toolbar,
                    allowToolbarGroups: false
                }, extras, Optional.none())
            ;
            const attributes = {
                [Attribute]: extras.backstage.shared.header.isPositionedAtTop() ? AttributeValue1.TopToBottom : AttributeValue1.BottomToTop
            };
            switch(getToolbarMode(editor)){
                case ToolbarMode$1.floating:
                    return renderFloatingToolbarButton(s, extras.backstage, identify, attributes);
                default:
                    throw new Error('Toolbar groups are only supported when using floating toolbar mode');
            }
        }),
        styleSelectButton: (editor, extras)=>createStylesButton(editor, extras.backstage)
        ,
        fontsizeSelectButton: (editor, extras)=>createFontSizeButton(editor, extras.backstage)
        ,
        fontSelectButton: (editor, extras)=>createFontFamilyButton(editor, extras.backstage)
        ,
        formatButton: (editor, extras)=>createBlocksButton(editor, extras.backstage)
        ,
        alignMenuButton: (editor, extras)=>createAlignButton(editor, extras.backstage)
    };
    const extractFrom = (spec, extras, editor)=>get$g(types1, spec.type).fold(()=>{
            console.error('skipping button defined by', spec);
            return Optional.none();
        }, (render)=>Optional.some(render(spec, extras, editor))
        )
    ;
    const bespokeButtons = {
        styles: types1.styleSelectButton,
        fontsize: types1.fontsizeSelectButton,
        fontfamily: types1.fontSelectButton,
        blocks: types1.formatButton,
        align: types1.alignMenuButton
    };
    const removeUnusedDefaults = (buttons)=>{
        const filteredItemGroups = map$2(defaultToolbar, (group)=>{
            const items = filter$2(group.items, (subItem)=>has$2(buttons, subItem) || has$2(bespokeButtons, subItem)
            );
            return {
                name: group.name,
                items
            };
        });
        return filter$2(filteredItemGroups, (group)=>group.items.length > 0
        );
    };
    const convertStringToolbar = (strToolbar)=>{
        const groupsStrings = strToolbar.split('|');
        return map$2(groupsStrings, (g)=>({
                items: g.trim().split(' ')
            })
        );
    };
    const isToolbarGroupSettingArray = (toolbar)=>isArrayOf(toolbar, (t)=>has$2(t, 'name') && has$2(t, 'items')
        )
    ;
    const createToolbar = (toolbarConfig)=>{
        const toolbar = toolbarConfig.toolbar;
        const buttons = toolbarConfig.buttons;
        if (toolbar === false) return [];
        else if (toolbar === undefined || toolbar === true) return removeUnusedDefaults(buttons);
        else if (isString(toolbar)) return convertStringToolbar(toolbar);
        else if (isToolbarGroupSettingArray(toolbar)) return toolbar;
        else {
            console.error('Toolbar type should be string, string[], boolean or ToolbarGroup[]');
            return [];
        }
    };
    const lookupButton = (editor, buttons, toolbarItem, allowToolbarGroups, extras, prefixes)=>get$g(buttons, toolbarItem.toLowerCase()).orThunk(()=>prefixes.bind((ps)=>findMap(ps, (prefix)=>get$g(buttons, prefix + toolbarItem.toLowerCase())
                )
            )
        ).fold(()=>get$g(bespokeButtons, toolbarItem.toLowerCase()).map((r)=>r(editor, extras)
            ).orThunk(()=>Optional.none()
            )
        , (spec)=>{
            if (spec.type === 'grouptoolbarbutton' && !allowToolbarGroups) {
                console.warn(`Ignoring the '${toolbarItem}' toolbar button. Group toolbar buttons are only supported when using floating toolbar mode and cannot be nested.`);
                return Optional.none();
            } else return extractFrom(spec, extras, editor);
        })
    ;
    const identifyButtons1 = (editor, toolbarConfig, extras, prefixes)=>{
        const toolbarGroups = createToolbar(toolbarConfig);
        const groups = map$2(toolbarGroups, (group)=>{
            const items = bind$3(group.items, (toolbarItem)=>toolbarItem.trim().length === 0 ? [] : lookupButton(editor, toolbarConfig.buttons, toolbarItem, toolbarConfig.allowToolbarGroups, extras, prefixes).toArray()
            );
            return {
                title: Optional.from(editor.translate(group.name)),
                items
            };
        });
        return filter$2(groups, (group)=>group.items.length > 0
        );
    };
    const setToolbar = (editor, uiComponents, rawUiConfig, backstage)=>{
        const comp = uiComponents.outerContainer;
        const toolbarConfig = rawUiConfig.toolbar;
        const toolbarButtonsConfig = rawUiConfig.buttons;
        if (isArrayOf(toolbarConfig, isString)) {
            const toolbars = toolbarConfig.map((t)=>{
                const config = {
                    toolbar: t,
                    buttons: toolbarButtonsConfig,
                    allowToolbarGroups: rawUiConfig.allowToolbarGroups
                };
                return identifyButtons1(editor, config, {
                    backstage
                }, Optional.none());
            });
            OuterContainer.setToolbars(comp, toolbars);
        } else OuterContainer.setToolbar(comp, identifyButtons1(editor, rawUiConfig, {
            backstage
        }, Optional.none()));
    };
    const detection1 = detect$1();
    const isiOS12 = detection1.os.isiOS() && detection1.os.version.major <= 12;
    const setupEvents$1 = (editor, uiComponents)=>{
        const dom = editor.dom;
        let contentWindow = editor.getWin();
        const initialDocEle = editor.getDoc().documentElement;
        const lastWindowDimensions = Cell(SugarPosition(contentWindow.innerWidth, contentWindow.innerHeight));
        const lastDocumentDimensions = Cell(SugarPosition(initialDocEle.offsetWidth, initialDocEle.offsetHeight));
        const resizeWindow = ()=>{
            const outer = lastWindowDimensions.get();
            if (outer.left !== contentWindow.innerWidth || outer.top !== contentWindow.innerHeight) {
                lastWindowDimensions.set(SugarPosition(contentWindow.innerWidth, contentWindow.innerHeight));
                fireResizeContent(editor);
            }
        };
        const resizeDocument = ()=>{
            const docEle = editor.getDoc().documentElement;
            const inner = lastDocumentDimensions.get();
            if (inner.left !== docEle.offsetWidth || inner.top !== docEle.offsetHeight) {
                lastDocumentDimensions.set(SugarPosition(docEle.offsetWidth, docEle.offsetHeight));
                fireResizeContent(editor);
            }
        };
        const scroll = (e)=>fireScrollContent(editor, e)
        ;
        dom.bind(contentWindow, 'resize', resizeWindow);
        dom.bind(contentWindow, 'scroll', scroll);
        const elementLoad = capture(SugarElement.fromDom(editor.getBody()), 'load', resizeDocument);
        const mothership = uiComponents.uiMothership.element;
        editor.on('hide', ()=>{
            set$8(mothership, 'display', 'none');
        });
        editor.on('show', ()=>{
            remove$6(mothership, 'display');
        });
        editor.on('NodeChange', resizeDocument);
        editor.on('remove', ()=>{
            elementLoad.unbind();
            dom.unbind(contentWindow, 'resize', resizeWindow);
            dom.unbind(contentWindow, 'scroll', scroll);
            contentWindow = null;
        });
    };
    const render$1 = (editor, uiComponents, rawUiConfig, backstage, args)=>{
        const lastToolbarWidth = Cell(0);
        const outerContainer = uiComponents.outerContainer;
        iframe1(editor);
        const eTargetNode = SugarElement.fromDom(args.targetNode);
        const uiRoot = getContentContainer(getRootNode(eTargetNode));
        attachSystemAfter(eTargetNode, uiComponents.mothership);
        attachSystem(uiRoot, uiComponents.uiMothership);
        editor.on('PostRender', ()=>{
            setToolbar(editor, uiComponents, rawUiConfig, backstage);
            lastToolbarWidth.set(editor.getWin().innerWidth);
            OuterContainer.setMenubar(outerContainer, identifyMenus(editor, rawUiConfig));
            OuterContainer.setSidebar(outerContainer, rawUiConfig.sidebar);
            setupEvents$1(editor, uiComponents);
        });
        const socket = OuterContainer.getSocket(outerContainer).getOrDie('Could not find expected socket element');
        if (isiOS12) {
            setAll(socket.element, {
                'overflow': 'scroll',
                '-webkit-overflow-scrolling': 'touch'
            });
            const limit = first1(()=>{
                editor.dispatch('ScrollContent');
            }, 20);
            const unbinder = bind1(socket.element, 'scroll', limit.throttle);
            editor.on('remove', unbinder.unbind);
        }
        setupReadonlyModeSwitch(editor, uiComponents);
        editor.addCommand('ToggleSidebar', (_ui, value)=>{
            OuterContainer.toggleSidebar(outerContainer, value);
            editor.dispatch('ToggleSidebar');
        });
        editor.addQueryValueHandler('ToggleSidebar', ()=>OuterContainer.whichSidebar(outerContainer)
        );
        const toolbarMode = getToolbarMode(editor);
        const refreshDrawer = ()=>{
            OuterContainer.refreshToolbar(uiComponents.outerContainer);
        };
        if (toolbarMode === ToolbarMode$1.sliding || toolbarMode === ToolbarMode$1.floating) editor.on('ResizeWindow ResizeEditor ResizeContent', ()=>{
            const width = editor.getWin().innerWidth;
            if (width !== lastToolbarWidth.get()) {
                refreshDrawer();
                lastToolbarWidth.set(width);
            }
        });
        const api = {
            setEnabled: (state)=>{
                broadcastReadonly(uiComponents, !state);
            },
            isEnabled: ()=>!Disabling.isDisabled(outerContainer)
        };
        return {
            iframeContainer: socket.element.dom,
            editorContainer: outerContainer.element.dom,
            api
        };
    };
    var Iframe = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        render: render$1
    });
    const parseToInt = (val)=>{
        const re = /^[0-9\.]+(|px)$/i;
        if (re.test('' + val)) return Optional.some(parseInt('' + val, 10));
        return Optional.none();
    };
    const numToPx = (val)=>isNumber(val) ? val + 'px' : val
    ;
    const calcCappedSize = (size, minSize, maxSize)=>{
        const minOverride = minSize.filter((min)=>size < min
        );
        const maxOverride = maxSize.filter((max)=>size > max
        );
        return minOverride.or(maxOverride).getOr(size);
    };
    const getHeight = (editor)=>{
        const baseHeight = getHeightOption(editor);
        const minHeight = getMinHeightOption(editor);
        const maxHeight = getMaxHeightOption(editor);
        return parseToInt(baseHeight).map((height)=>calcCappedSize(height, minHeight, maxHeight)
        );
    };
    const getHeightWithFallback = (editor)=>{
        const height = getHeight(editor);
        return height.getOr(getHeightOption(editor));
    };
    const getWidth = (editor)=>{
        const baseWidth = getWidthOption(editor);
        const minWidth = getMinWidthOption(editor);
        const maxWidth = getMaxWidthOption(editor);
        return parseToInt(baseWidth).map((width)=>calcCappedSize(width, minWidth, maxWidth)
        );
    };
    const getWidthWithFallback = (editor)=>{
        const width = getWidth(editor);
        return width.getOr(getWidthOption(editor));
    };
    const { ToolbarLocation: ToolbarLocation1 , ToolbarMode: ToolbarMode1  } = Options;
    const InlineHeader = (editor, targetElm, uiComponents, backstage, floatContainer)=>{
        const { uiMothership , outerContainer  } = uiComponents;
        const DOM = global$7.DOM;
        const useFixedToolbarContainer = useFixedContainer(editor);
        const isSticky = isStickyToolbar1(editor);
        const editorMaxWidthOpt = getMaxWidthOption(editor).or(getWidth(editor));
        const headerBackstage = backstage.shared.header;
        const isPositionedAtTop = headerBackstage.isPositionedAtTop;
        const toolbarMode = getToolbarMode(editor);
        const isSplitToolbar = toolbarMode === ToolbarMode1.sliding || toolbarMode === ToolbarMode1.floating;
        const visible = Cell(false);
        const isVisible = ()=>visible.get() && !editor.removed
        ;
        const calcToolbarOffset = (toolbar)=>isSplitToolbar ? toolbar.fold(constant$1(0), (tbar)=>tbar.components().length > 1 ? get$d(tbar.components()[1].element) : 0
            ) : 0
        ;
        const calcMode = (container)=>{
            switch(getToolbarLocation(editor)){
                case ToolbarLocation1.auto:
                    const toolbar = OuterContainer.getToolbar(outerContainer);
                    const offset = calcToolbarOffset(toolbar);
                    const toolbarHeight = get$d(container.element) - offset;
                    const targetBounds = box$1(targetElm);
                    const roomAtTop = targetBounds.y > toolbarHeight;
                    if (roomAtTop) return 'top';
                    else {
                        const doc = documentElement(targetElm);
                        const docHeight = Math.max(doc.dom.scrollHeight, get$d(doc));
                        const roomAtBottom = targetBounds.bottom < docHeight - toolbarHeight;
                        if (roomAtBottom) return 'bottom';
                        else {
                            const winBounds = win1();
                            const isRoomAtBottomViewport = winBounds.bottom < targetBounds.bottom - toolbarHeight;
                            return isRoomAtBottomViewport ? 'bottom' : 'top';
                        }
                    }
                case ToolbarLocation1.bottom:
                    return 'bottom';
                case ToolbarLocation1.top:
                default:
                    return 'top';
            }
        };
        const setupMode = (mode)=>{
            const container = floatContainer.get();
            Docking.setModes(container, [
                mode
            ]);
            headerBackstage.setDockingMode(mode);
            const verticalDir = isPositionedAtTop() ? AttributeValue1.TopToBottom : AttributeValue1.BottomToTop;
            set$9(container.element, Attribute, verticalDir);
        };
        const updateChromeWidth = ()=>{
            const maxWidth = editorMaxWidthOpt.getOrThunk(()=>{
                const bodyMargin = parseToInt(get$e(body1(), 'margin-left')).getOr(0);
                return get$c(body1()) - absolute$3(targetElm).left + bodyMargin;
            });
            set$8(floatContainer.get().element, 'max-width', maxWidth + 'px');
        };
        const updateChromePosition = ()=>{
            const toolbar = OuterContainer.getToolbar(outerContainer);
            const offset = calcToolbarOffset(toolbar);
            const targetBounds = box$1(targetElm);
            const top = isPositionedAtTop() ? Math.max(targetBounds.y - get$d(floatContainer.get().element) + offset, 0) : targetBounds.bottom;
            setAll(outerContainer.element, {
                position: 'absolute',
                top: Math.round(top) + 'px',
                left: Math.round(targetBounds.x) + 'px'
            });
        };
        const repositionPopups$1 = ()=>{
            uiMothership.broadcastOn([
                repositionPopups()
            ], {});
        };
        const updateChromeUi = (resetDocking = false)=>{
            if (!isVisible()) return;
            if (!useFixedToolbarContainer) updateChromeWidth();
            if (isSplitToolbar) OuterContainer.refreshToolbar(outerContainer);
            if (!useFixedToolbarContainer) updateChromePosition();
            if (isSticky) {
                const floatContainerComp = floatContainer.get();
                resetDocking ? Docking.reset(floatContainerComp) : Docking.refresh(floatContainerComp);
            }
            repositionPopups$1();
        };
        const updateMode = (updateUi = true)=>{
            if (useFixedToolbarContainer || !isSticky || !isVisible()) return;
            const currentMode = headerBackstage.getDockingMode();
            const newMode = calcMode(floatContainer.get());
            if (newMode !== currentMode) {
                setupMode(newMode);
                if (updateUi) updateChromeUi(true);
            }
        };
        const show = ()=>{
            visible.set(true);
            set$8(outerContainer.element, 'display', 'flex');
            DOM.addClass(editor.getBody(), 'mce-edit-focus');
            remove$6(uiMothership.element, 'display');
            updateMode(false);
            updateChromeUi();
        };
        const hide = ()=>{
            visible.set(false);
            if (uiComponents.outerContainer) {
                set$8(outerContainer.element, 'display', 'none');
                DOM.removeClass(editor.getBody(), 'mce-edit-focus');
            }
            set$8(uiMothership.element, 'display', 'none');
        };
        return {
            isVisible,
            isPositionedAtTop,
            show,
            hide,
            update: updateChromeUi,
            updateMode,
            repositionPopups: repositionPopups$1
        };
    };
    const getTargetPosAndBounds = (targetElm, isToolbarTop)=>{
        const bounds = box$1(targetElm);
        return {
            pos: isToolbarTop ? bounds.y : bounds.bottom,
            bounds
        };
    };
    const setupEvents = (editor, targetElm, ui, toolbarPersist)=>{
        const prevPosAndBounds = Cell(getTargetPosAndBounds(targetElm, ui.isPositionedAtTop()));
        const resizeContent = (e)=>{
            const { pos , bounds  } = getTargetPosAndBounds(targetElm, ui.isPositionedAtTop());
            const { pos: prevPos , bounds: prevBounds  } = prevPosAndBounds.get();
            const hasResized = bounds.height !== prevBounds.height || bounds.width !== prevBounds.width;
            prevPosAndBounds.set({
                pos,
                bounds
            });
            if (hasResized) fireResizeContent(editor, e);
            if (ui.isVisible()) {
                if (prevPos !== pos) ui.update(true);
                else if (hasResized) {
                    ui.updateMode();
                    ui.repositionPopups();
                }
            }
        };
        if (!toolbarPersist) {
            editor.on('activate', ui.show);
            editor.on('deactivate', ui.hide);
        }
        editor.on('SkinLoaded ResizeWindow', ()=>ui.update(true)
        );
        editor.on('NodeChange keydown', (e)=>{
            requestAnimationFrame(()=>resizeContent(e)
            );
        });
        editor.on('ScrollWindow', ()=>ui.updateMode()
        );
        const elementLoad = unbindable();
        elementLoad.set(capture(SugarElement.fromDom(editor.getBody()), 'load', resizeContent));
        editor.on('remove', ()=>{
            elementLoad.clear();
        });
    };
    const render1 = (editor, uiComponents, rawUiConfig, backstage, args)=>{
        const { mothership , uiMothership , outerContainer  } = uiComponents;
        const floatContainer = Cell(null);
        const targetElm = SugarElement.fromDom(args.targetNode);
        const ui = InlineHeader(editor, targetElm, uiComponents, backstage, floatContainer);
        const toolbarPersist = isToolbarPersist(editor);
        inline(editor);
        const render = ()=>{
            if (floatContainer.get()) {
                ui.show();
                return;
            }
            floatContainer.set(OuterContainer.getHeader(outerContainer).getOrDie());
            const uiContainer = getUiContainer(editor);
            attachSystem(uiContainer, mothership);
            attachSystem(uiContainer, uiMothership);
            setToolbar(editor, uiComponents, rawUiConfig, backstage);
            OuterContainer.setMenubar(outerContainer, identifyMenus(editor, rawUiConfig));
            ui.show();
            setupEvents(editor, targetElm, ui, toolbarPersist);
            editor.nodeChanged();
        };
        const delayedRender = ()=>global$9.setEditorTimeout(editor, render, 0)
        ;
        editor.on('show', render);
        editor.on('hide', ui.hide);
        if (!toolbarPersist) {
            editor.on('focus', delayedRender);
            editor.on('blur', ui.hide);
        }
        editor.on('init', ()=>{
            if (editor.hasFocus() || toolbarPersist) delayedRender();
        });
        setupReadonlyModeSwitch(editor, uiComponents);
        const api = {
            show: ()=>{
                render();
            },
            hide: ()=>{
                ui.hide();
            },
            setEnabled: (state)=>{
                broadcastReadonly(uiComponents, !state);
            },
            isEnabled: ()=>!Disabling.isDisabled(outerContainer)
        };
        return {
            editorContainer: outerContainer.element.dom,
            api
        };
    };
    var Inline = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        render: render1
    });
    const showContextToolbarEvent = 'contexttoolbar-show';
    const hideContextToolbarEvent = 'contexttoolbar-hide';
    const getFormApi = (input)=>({
            hide: ()=>emit(input, sandboxClose())
            ,
            getValue: ()=>Representing.getValue(input)
        })
    ;
    const runOnExecute = (memInput, original)=>run$1(internalToolbarButtonExecute, (comp, se)=>{
            const input = memInput.get(comp);
            const formApi = getFormApi(input);
            original.onAction(formApi, se.event.buttonApi);
        })
    ;
    const renderContextButton = (memInput, button, extras)=>{
        const { primary , ...rest } = button.original;
        const bridged = getOrDie(createToolbarButton({
            ...rest,
            type: 'button',
            onAction: noop
        }));
        return renderToolbarButtonWith(bridged, extras.backstage.shared.providers, [
            runOnExecute(memInput, button)
        ]);
    };
    const renderContextToggleButton = (memInput, button, extras)=>{
        const { primary , ...rest } = button.original;
        const bridged = getOrDie(createToggleButton({
            ...rest,
            type: 'togglebutton',
            onAction: noop
        }));
        return renderToolbarToggleButtonWith(bridged, extras.backstage.shared.providers, [
            runOnExecute(memInput, button)
        ]);
    };
    const generateOne = (memInput, button, providersBackstage)=>{
        const extras = {
            backstage: {
                shared: {
                    providers: providersBackstage
                }
            }
        };
        if (button.type === 'contextformtogglebutton') return renderContextToggleButton(memInput, button, extras);
        else return renderContextButton(memInput, button, extras);
    };
    const generate = (memInput, buttons, providersBackstage)=>{
        const mementos = map$2(buttons, (button)=>record1(generateOne(memInput, button, providersBackstage))
        );
        const asSpecs = ()=>map$2(mementos, (mem)=>mem.asSpec()
            )
        ;
        const findPrimary = (compInSystem)=>findMap(buttons, (button, i)=>{
                if (button.primary) return Optional.from(mementos[i]).bind((mem)=>mem.getOpt(compInSystem)
                ).filter(not(Disabling.isDisabled));
                else return Optional.none();
            })
        ;
        return {
            asSpecs,
            findPrimary
        };
    };
    const buildInitGroups = (ctx, providers)=>{
        const inputAttributes = ctx.label.fold(()=>({})
        , (label)=>({
                'aria-label': label
            })
        );
        const memInput = record1(Input.sketch({
            inputClasses: [
                'tox-toolbar-textfield',
                'tox-toolbar-nav-js'
            ],
            data: ctx.initValue(),
            inputAttributes,
            selectOnFocus: true,
            inputBehaviours: derive$1([
                Keying.config({
                    mode: 'special',
                    onEnter: (input)=>commands.findPrimary(input).map((primary)=>{
                            emitExecute1(primary);
                            return true;
                        })
                    ,
                    onLeft: (comp, se)=>{
                        se.cut();
                        return Optional.none();
                    },
                    onRight: (comp, se)=>{
                        se.cut();
                        return Optional.none();
                    }
                })
            ])
        }));
        const commands = generate(memInput, ctx.commands, providers);
        return [
            {
                title: Optional.none(),
                items: [
                    memInput.asSpec()
                ]
            },
            {
                title: Optional.none(),
                items: commands.asSpecs()
            }
        ];
    };
    const renderContextForm = (toolbarType, ctx, providers)=>renderToolbar({
            type: toolbarType,
            uid: generate$6('context-toolbar'),
            initGroups: buildInitGroups(ctx, providers),
            onEscape: Optional.none,
            cyclicKeying: true,
            providers
        })
    ;
    const ContextForm = {
        renderContextForm,
        buildInitGroups
    };
    const isVerticalOverlap = (a, b, threshold = 0.01)=>b.bottom - a.y >= threshold && a.bottom - b.y >= threshold
    ;
    const getRangeRect = (rng)=>{
        const rect = rng.getBoundingClientRect();
        if (rect.height <= 0 && rect.width <= 0) {
            const leaf$1 = leaf(SugarElement.fromDom(rng.startContainer), rng.startOffset).element;
            const elm = isText(leaf$1) ? parent1(leaf$1) : Optional.some(leaf$1);
            return elm.filter(isElement$1).map((e)=>e.dom.getBoundingClientRect()
            ).getOr(rect);
        } else return rect;
    };
    const getSelectionBounds = (editor)=>{
        const rng = editor.selection.getRng();
        const rect = getRangeRect(rng);
        if (editor.inline) {
            const scroll = get$b();
            return bounds1(scroll.left + rect.left, scroll.top + rect.top, rect.width, rect.height);
        } else {
            const bodyPos = absolute$2(SugarElement.fromDom(editor.getBody()));
            return bounds1(bodyPos.x + rect.left, bodyPos.y + rect.top, rect.width, rect.height);
        }
    };
    const getAnchorElementBounds = (editor, lastElement)=>lastElement.filter(inBody).map(absolute$2).getOrThunk(()=>getSelectionBounds(editor)
        )
    ;
    const getHorizontalBounds = (contentAreaBox, viewportBounds, margin)=>{
        const x = Math.max(contentAreaBox.x + margin, viewportBounds.x);
        const right = Math.min(contentAreaBox.right - margin, viewportBounds.right);
        return {
            x,
            width: right - x
        };
    };
    const getVerticalBounds = (editor, contentAreaBox, viewportBounds, isToolbarLocationTop, toolbarType, margin)=>{
        const container = SugarElement.fromDom(editor.getContainer());
        const header = descendant(container, '.tox-editor-header').getOr(container);
        const headerBox = box$1(header);
        const isToolbarBelowContentArea = headerBox.y >= contentAreaBox.bottom;
        const isToolbarAbove = isToolbarLocationTop && !isToolbarBelowContentArea;
        if (editor.inline && isToolbarAbove) return {
            y: Math.max(headerBox.bottom + margin, viewportBounds.y),
            bottom: viewportBounds.bottom
        };
        if (editor.inline && !isToolbarAbove) return {
            y: viewportBounds.y,
            bottom: Math.min(headerBox.y - margin, viewportBounds.bottom)
        };
        const containerBounds = toolbarType === 'line' ? box$1(container) : contentAreaBox;
        if (isToolbarAbove) return {
            y: Math.max(headerBox.bottom + margin, viewportBounds.y),
            bottom: Math.min(containerBounds.bottom - margin, viewportBounds.bottom)
        };
        return {
            y: Math.max(containerBounds.y + margin, viewportBounds.y),
            bottom: Math.min(headerBox.y - margin, viewportBounds.bottom)
        };
    };
    const getContextToolbarBounds = (editor, sharedBackstage, toolbarType, margin = 0)=>{
        const viewportBounds = getBounds$3(window);
        const contentAreaBox = box$1(SugarElement.fromDom(editor.getContentAreaContainer()));
        const toolbarOrMenubarEnabled = isMenubarEnabled(editor) || isToolbarEnabled(editor) || isMultipleToolbars(editor);
        const { x , width  } = getHorizontalBounds(contentAreaBox, viewportBounds, margin);
        if (editor.inline && !toolbarOrMenubarEnabled) return bounds1(x, viewportBounds.y, width, viewportBounds.height);
        else {
            const isToolbarTop = sharedBackstage.header.isPositionedAtTop();
            const { y , bottom  } = getVerticalBounds(editor, contentAreaBox, viewportBounds, isToolbarTop, toolbarType, margin);
            return bounds1(x, y, width, bottom - y);
        }
    };
    const bubbleSize$1 = 12;
    const bubbleAlignments$1 = {
        valignCentre: [],
        alignCentre: [],
        alignLeft: [
            'tox-pop--align-left'
        ],
        alignRight: [
            'tox-pop--align-right'
        ],
        right: [
            'tox-pop--right'
        ],
        left: [
            'tox-pop--left'
        ],
        bottom: [
            'tox-pop--bottom'
        ],
        top: [
            'tox-pop--top'
        ],
        inset: [
            'tox-pop--inset'
        ]
    };
    const anchorOverrides1 = {
        maxHeightFunction: expandable$1(),
        maxWidthFunction: expandable()
    };
    const isEntireElementSelected = (editor, elem)=>{
        const rng = editor.selection.getRng();
        const leaf$1 = leaf(SugarElement.fromDom(rng.startContainer), rng.startOffset);
        return rng.startContainer === rng.endContainer && rng.startOffset === rng.endOffset - 1 && eq(leaf$1.element, elem);
    };
    const preservePosition = (elem, position, f)=>{
        const currentPosition = getRaw(elem, 'position');
        set$8(elem, 'position', position);
        const result = f(elem);
        currentPosition.each((pos)=>set$8(elem, 'position', pos)
        );
        return result;
    };
    const shouldUseInsetLayouts = (position)=>position === 'node'
    ;
    const determineInsetLayout = (editor, contextbar, elem, data, bounds)=>{
        const selectionBounds = getSelectionBounds(editor);
        const isSameAnchorElement = data.lastElement().exists((prev)=>eq(elem, prev)
        );
        if (isEntireElementSelected(editor, elem)) return isSameAnchorElement ? preserve : north1;
        else if (isSameAnchorElement) return preservePosition(contextbar, data.getMode(), ()=>{
            const isOverlapping = isVerticalOverlap(selectionBounds, box$1(contextbar));
            return isOverlapping && !data.isReposition() ? flip : preserve;
        });
        else {
            const yBounds = data.getMode() === 'fixed' ? bounds.y + get$b().top : bounds.y;
            const contextbarHeight = get$d(contextbar) + bubbleSize$1;
            return yBounds + contextbarHeight <= selectionBounds.y ? north1 : south1;
        }
    };
    const getAnchorSpec$2 = (editor, mobile, data, position)=>{
        const smartInsetLayout = (elem)=>(anchor, element, bubbles, placee, bounds)=>{
                const layout = determineInsetLayout(editor, placee, elem, data, bounds);
                const newAnchor = {
                    ...anchor,
                    y: bounds.y,
                    height: bounds.height
                };
                return {
                    ...layout(newAnchor, element, bubbles, placee, bounds),
                    alwaysFit: true
                };
            }
        ;
        const getInsetLayouts = (elem)=>shouldUseInsetLayouts(position) ? [
                smartInsetLayout(elem)
            ] : []
        ;
        const desktopAnchorSpecLayouts = {
            onLtr: (elem)=>[
                    north$2,
                    south$2,
                    northeast$2,
                    southeast$2,
                    northwest$2,
                    southwest$2
                ].concat(getInsetLayouts(elem))
            ,
            onRtl: (elem)=>[
                    north$2,
                    south$2,
                    northwest$2,
                    southwest$2,
                    northeast$2,
                    southeast$2
                ].concat(getInsetLayouts(elem))
        };
        const mobileAnchorSpecLayouts = {
            onLtr: (elem)=>[
                    south$2,
                    southeast$2,
                    southwest$2,
                    northeast$2,
                    northwest$2,
                    north$2
                ].concat(getInsetLayouts(elem))
            ,
            onRtl: (elem)=>[
                    south$2,
                    southwest$2,
                    southeast$2,
                    northwest$2,
                    northeast$2,
                    north$2
                ].concat(getInsetLayouts(elem))
        };
        return mobile ? mobileAnchorSpecLayouts : desktopAnchorSpecLayouts;
    };
    const getAnchorLayout = (editor, position, isTouch, data)=>{
        if (position === 'line') return {
            bubble: nu$5(bubbleSize$1, 0, bubbleAlignments$1),
            layouts: {
                onLtr: ()=>[
                        east$2
                    ]
                ,
                onRtl: ()=>[
                        west$2
                    ]
            },
            overrides: anchorOverrides1
        };
        else return {
            bubble: nu$5(0, bubbleSize$1, bubbleAlignments$1, 1 / bubbleSize$1),
            layouts: getAnchorSpec$2(editor, isTouch, data, position),
            overrides: anchorOverrides1
        };
    };
    const matchTargetWith = (elem, candidates)=>{
        const ctxs = filter$2(candidates, (toolbarApi)=>toolbarApi.predicate(elem.dom)
        );
        const { pass , fail  } = partition$3(ctxs, (t)=>t.type === 'contexttoolbar'
        );
        return {
            contextToolbars: pass,
            contextForms: fail
        };
    };
    const filterByPositionForStartNode = (toolbars)=>{
        if (toolbars.length <= 1) return toolbars;
        else {
            const doesPositionExist = (value)=>exists(toolbars, (t)=>t.position === value
                )
            ;
            const filterToolbarsByPosition = (value)=>filter$2(toolbars, (t)=>t.position === value
                )
            ;
            const hasSelectionToolbars = doesPositionExist('selection');
            const hasNodeToolbars = doesPositionExist('node');
            if (hasSelectionToolbars || hasNodeToolbars) {
                if (hasNodeToolbars && hasSelectionToolbars) {
                    const nodeToolbars = filterToolbarsByPosition('node');
                    const selectionToolbars = map$2(filterToolbarsByPosition('selection'), (t)=>({
                            ...t,
                            position: 'node'
                        })
                    );
                    return nodeToolbars.concat(selectionToolbars);
                } else return hasSelectionToolbars ? filterToolbarsByPosition('selection') : filterToolbarsByPosition('node');
            } else return filterToolbarsByPosition('line');
        }
    };
    const filterByPositionForAncestorNode = (toolbars)=>{
        if (toolbars.length <= 1) return toolbars;
        else {
            const findPosition = (value)=>find$5(toolbars, (t)=>t.position === value
                )
            ;
            const basePosition = findPosition('selection').orThunk(()=>findPosition('node')
            ).orThunk(()=>findPosition('line')
            ).map((t)=>t.position
            );
            return basePosition.fold(()=>[]
            , (pos)=>filter$2(toolbars, (t)=>t.position === pos
                )
            );
        }
    };
    const matchStartNode = (elem, nodeCandidates, editorCandidates)=>{
        const nodeMatches = matchTargetWith(elem, nodeCandidates);
        if (nodeMatches.contextForms.length > 0) return Optional.some({
            elem,
            toolbars: [
                nodeMatches.contextForms[0]
            ]
        });
        else {
            const editorMatches = matchTargetWith(elem, editorCandidates);
            if (editorMatches.contextForms.length > 0) return Optional.some({
                elem,
                toolbars: [
                    editorMatches.contextForms[0]
                ]
            });
            else if (nodeMatches.contextToolbars.length > 0 || editorMatches.contextToolbars.length > 0) {
                const toolbars = filterByPositionForStartNode(nodeMatches.contextToolbars.concat(editorMatches.contextToolbars));
                return Optional.some({
                    elem,
                    toolbars
                });
            } else return Optional.none();
        }
    };
    const matchAncestor = (isRoot, startNode, scopes)=>{
        if (isRoot(startNode)) return Optional.none();
        else return ancestor$2(startNode, (ancestorElem)=>{
            if (isElement$1(ancestorElem)) {
                const { contextToolbars , contextForms  } = matchTargetWith(ancestorElem, scopes.inNodeScope);
                const toolbars = contextForms.length > 0 ? contextForms : filterByPositionForAncestorNode(contextToolbars);
                return toolbars.length > 0 ? Optional.some({
                    elem: ancestorElem,
                    toolbars
                }) : Optional.none();
            } else return Optional.none();
        }, isRoot);
    };
    const lookup$1 = (scopes, editor)=>{
        const rootElem = SugarElement.fromDom(editor.getBody());
        const isRoot = (elem)=>eq(elem, rootElem)
        ;
        const isOutsideRoot = (startNode)=>!isRoot(startNode) && !contains(rootElem, startNode)
        ;
        const startNode1 = SugarElement.fromDom(editor.selection.getNode());
        if (isOutsideRoot(startNode1)) return Optional.none();
        return matchStartNode(startNode1, scopes.inNodeScope, scopes.inEditorScope).orThunk(()=>matchAncestor(isRoot, startNode1, scopes)
        );
    };
    const categorise = (contextToolbars, navigate)=>{
        const forms = {};
        const inNodeScope = [];
        const inEditorScope = [];
        const formNavigators = {};
        const lookupTable = {};
        const registerForm = (key, toolbarSpec)=>{
            const contextForm = getOrDie(createContextForm(toolbarSpec));
            forms[key] = contextForm;
            contextForm.launch.map((launch)=>{
                formNavigators['form:' + key + ''] = {
                    ...toolbarSpec.launch,
                    type: launch.type === 'contextformtogglebutton' ? 'togglebutton' : 'button',
                    onAction: ()=>{
                        navigate(contextForm);
                    }
                };
            });
            if (contextForm.scope === 'editor') inEditorScope.push(contextForm);
            else inNodeScope.push(contextForm);
            lookupTable[key] = contextForm;
        };
        const registerToolbar = (key, toolbarSpec)=>{
            createContextToolbar(toolbarSpec).each((contextToolbar)=>{
                if (toolbarSpec.scope === 'editor') inEditorScope.push(contextToolbar);
                else inNodeScope.push(contextToolbar);
                lookupTable[key] = contextToolbar;
            });
        };
        const keys$1 = keys1(contextToolbars);
        each$1(keys$1, (key)=>{
            const toolbarApi = contextToolbars[key];
            if (toolbarApi.type === 'contextform') registerForm(key, toolbarApi);
            else if (toolbarApi.type === 'contexttoolbar') registerToolbar(key, toolbarApi);
        });
        return {
            forms,
            inNodeScope,
            inEditorScope,
            lookupTable,
            formNavigators
        };
    };
    const forwardSlideEvent = generate$6('forward-slide');
    const backSlideEvent = generate$6('backward-slide');
    const changeSlideEvent = generate$6('change-slide-event');
    const resizingClass = 'tox-pop--resizing';
    const renderContextToolbar = (spec)=>{
        const stack = Cell([]);
        return InlineView.sketch({
            dom: {
                tag: 'div',
                classes: [
                    'tox-pop'
                ]
            },
            fireDismissalEventInstead: {
                event: 'doNotDismissYet'
            },
            onShow: (comp)=>{
                stack.set([]);
                InlineView.getContent(comp).each((c)=>{
                    remove$6(c.element, 'visibility');
                });
                remove$2(comp.element, resizingClass);
                remove$6(comp.element, 'width');
            },
            inlineBehaviours: derive$1([
                config1('context-toolbar-events', [
                    runOnSource(transitionend(), (comp, se)=>{
                        if (se.event.raw.propertyName === 'width') {
                            remove$2(comp.element, resizingClass);
                            remove$6(comp.element, 'width');
                        }
                    }),
                    run$1(changeSlideEvent, (comp, se)=>{
                        const elem = comp.element;
                        remove$6(elem, 'width');
                        const currentWidth = get$c(elem);
                        InlineView.setContent(comp, se.event.contents);
                        add$2(elem, resizingClass);
                        const newWidth = get$c(elem);
                        set$8(elem, 'width', currentWidth + 'px');
                        InlineView.getContent(comp).each((newContents)=>{
                            se.event.focus.bind((f)=>{
                                focus$3(f);
                                return search1(elem);
                            }).orThunk(()=>{
                                Keying.focusIn(newContents);
                                return active$1(getRootNode(elem));
                            });
                        });
                        setTimeout(()=>{
                            set$8(comp.element, 'width', newWidth + 'px');
                        }, 0);
                    }),
                    run$1(forwardSlideEvent, (comp, se)=>{
                        InlineView.getContent(comp).each((oldContents)=>{
                            stack.set(stack.get().concat([
                                {
                                    bar: oldContents,
                                    focus: active$1(getRootNode(comp.element))
                                }
                            ]));
                        });
                        emitWith(comp, changeSlideEvent, {
                            contents: se.event.forwardContents,
                            focus: Optional.none()
                        });
                    }),
                    run$1(backSlideEvent, (comp, _se)=>{
                        last$1(stack.get()).each((last)=>{
                            stack.set(stack.get().slice(0, stack.get().length - 1));
                            emitWith(comp, changeSlideEvent, {
                                contents: premade(last.bar),
                                focus: last.focus
                            });
                        });
                    })
                ]),
                Keying.config({
                    mode: 'special',
                    onEscape: (comp)=>last$1(stack.get()).fold(()=>spec.onEscape()
                        , (_)=>{
                            emit(comp, backSlideEvent);
                            return Optional.some(true);
                        })
                })
            ]),
            lazySink: ()=>Result.value(spec.sink)
        });
    };
    const transitionClass = 'tox-pop--transition';
    const register$9 = (editor, registryContextToolbars, sink, extras)=>{
        const backstage = extras.backstage;
        const sharedBackstage = backstage.shared;
        const isTouch = detect$1().deviceType.isTouch;
        const lastElement = value$2();
        const lastTrigger = value$2();
        const lastContextPosition = value$2();
        const contextbar = build$1(renderContextToolbar({
            sink,
            onEscape: ()=>{
                editor.focus();
                return Optional.some(true);
            }
        }));
        const getBounds = ()=>{
            const position = lastContextPosition.get().getOr('node');
            const margin = shouldUseInsetLayouts(position) ? 1 : 0;
            return getContextToolbarBounds(editor, sharedBackstage, position, margin);
        };
        const canLaunchToolbar = ()=>{
            return !editor.removed && !(isTouch() && backstage.isContextMenuOpen());
        };
        const isSameLaunchElement = (elem)=>is$11(lift2(elem, lastElement.get(), eq), true)
        ;
        const shouldContextToolbarHide = ()=>{
            if (!canLaunchToolbar()) return true;
            else {
                const contextToolbarBounds = getBounds();
                const anchorBounds = is$11(lastContextPosition.get(), 'node') ? getAnchorElementBounds(editor, lastElement.get()) : getSelectionBounds(editor);
                return contextToolbarBounds.height <= 0 || !isVerticalOverlap(anchorBounds, contextToolbarBounds);
            }
        };
        const close = ()=>{
            lastElement.clear();
            lastTrigger.clear();
            lastContextPosition.clear();
            InlineView.hide(contextbar);
        };
        const hideOrRepositionIfNecessary = ()=>{
            if (InlineView.isOpen(contextbar)) {
                const contextBarEle = contextbar.element;
                remove$6(contextBarEle, 'display');
                if (shouldContextToolbarHide()) set$8(contextBarEle, 'display', 'none');
                else {
                    lastTrigger.set(0);
                    InlineView.reposition(contextbar);
                }
            }
        };
        const wrapInPopDialog = (toolbarSpec)=>({
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-pop__dialog'
                    ]
                },
                components: [
                    toolbarSpec
                ],
                behaviours: derive$1([
                    Keying.config({
                        mode: 'acyclic'
                    }),
                    config1('pop-dialog-wrap-events', [
                        runOnAttached((comp)=>{
                            editor.shortcuts.add('ctrl+F9', 'focus statusbar', ()=>Keying.focusIn(comp)
                            );
                        }),
                        runOnDetached((_comp)=>{
                            editor.shortcuts.remove('ctrl+F9');
                        })
                    ])
                ])
            })
        ;
        const getScopes = cached(()=>categorise(registryContextToolbars, (toolbarApi)=>{
                const alloySpec = buildToolbar([
                    toolbarApi
                ]);
                emitWith(contextbar, forwardSlideEvent, {
                    forwardContents: wrapInPopDialog(alloySpec)
                });
            })
        );
        const buildContextToolbarGroups = (allButtons, ctx)=>identifyButtons1(editor, {
                buttons: allButtons,
                toolbar: ctx.items,
                allowToolbarGroups: false
            }, extras, Optional.some([
                'form:'
            ]))
        ;
        const buildContextFormGroups = (ctx, providers)=>ContextForm.buildInitGroups(ctx, providers)
        ;
        const buildToolbar = (toolbars)=>{
            const { buttons  } = editor.ui.registry.getAll();
            const scopes = getScopes();
            const allButtons = {
                ...buttons,
                ...scopes.formNavigators
            };
            const toolbarType = getToolbarMode(editor) === ToolbarMode$1.scrolling ? ToolbarMode$1.scrolling : ToolbarMode$1.default;
            const initGroups = flatten1(map$2(toolbars, (ctx)=>ctx.type === 'contexttoolbar' ? buildContextToolbarGroups(allButtons, ctx) : buildContextFormGroups(ctx, sharedBackstage.providers)
            ));
            return renderToolbar({
                type: toolbarType,
                uid: generate$6('context-toolbar'),
                initGroups,
                onEscape: Optional.none,
                cyclicKeying: true,
                providers: sharedBackstage.providers
            });
        };
        const getAnchor = (position, element)=>{
            const anchorage = position === 'node' ? sharedBackstage.anchors.node(element) : sharedBackstage.anchors.cursor();
            const anchorLayout = getAnchorLayout(editor, position, isTouch(), {
                lastElement: lastElement.get,
                isReposition: ()=>is$11(lastTrigger.get(), 0)
                ,
                getMode: ()=>Positioning.getMode(sink)
            });
            return deepMerge(anchorage, anchorLayout);
        };
        const launchContext = (toolbarApi, elem)=>{
            launchContextToolbar.cancel();
            if (!canLaunchToolbar()) return;
            const toolbarSpec = buildToolbar(toolbarApi);
            const position = toolbarApi[0].position;
            const anchor = getAnchor(position, elem);
            lastContextPosition.set(position);
            lastTrigger.set(1);
            const contextBarEle = contextbar.element;
            remove$6(contextBarEle, 'display');
            if (!isSameLaunchElement(elem)) {
                remove$2(contextBarEle, transitionClass);
                Positioning.reset(sink, contextbar);
            }
            InlineView.showWithinBounds(contextbar, wrapInPopDialog(toolbarSpec), {
                anchor,
                transition: {
                    classes: [
                        transitionClass
                    ],
                    mode: 'placement'
                }
            }, ()=>Optional.some(getBounds())
            );
            elem.fold(lastElement.clear, lastElement.set);
            if (shouldContextToolbarHide()) set$8(contextBarEle, 'display', 'none');
        };
        const launchContextToolbar = last1(()=>{
            if (!editor.hasFocus() || editor.removed) return;
            if (has(contextbar.element, transitionClass)) launchContextToolbar.throttle();
            else {
                const scopes = getScopes();
                lookup$1(scopes, editor).fold(close, (info)=>{
                    launchContext(info.toolbars, Optional.some(info.elem));
                });
            }
        }, 17);
        editor.on('init', ()=>{
            editor.on('remove', close);
            editor.on('ScrollContent ScrollWindow ObjectResized ResizeEditor longpress', hideOrRepositionIfNecessary);
            editor.on('click keyup focus SetContent', launchContextToolbar.throttle);
            editor.on(hideContextToolbarEvent, close);
            editor.on(showContextToolbarEvent, (e)=>{
                const scopes = getScopes();
                get$g(scopes.lookupTable, e.toolbarKey).each((ctx)=>{
                    launchContext([
                        ctx
                    ], someIf(e.target !== editor, e.target));
                    InlineView.getContent(contextbar).each(Keying.focusIn);
                });
            });
            editor.on('focusout', (_e)=>{
                global$9.setEditorTimeout(editor, ()=>{
                    if (search1(sink.element).isNone() && search1(contextbar.element).isNone()) close();
                }, 0);
            });
            editor.on('SwitchMode', ()=>{
                if (editor.mode.isReadOnly()) close();
            });
            editor.on('AfterProgressState', (event)=>{
                if (event.state) close();
                else if (editor.hasFocus()) launchContextToolbar.throttle();
            });
            editor.on('NodeChange', (_e)=>{
                search1(contextbar.element).fold(launchContextToolbar.throttle, noop);
            });
        });
    };
    const register$8 = (editor)=>{
        const alignToolbarButtons = [
            {
                name: 'alignleft',
                text: 'Align left',
                cmd: 'JustifyLeft',
                icon: 'align-left'
            },
            {
                name: 'aligncenter',
                text: 'Align center',
                cmd: 'JustifyCenter',
                icon: 'align-center'
            },
            {
                name: 'alignright',
                text: 'Align right',
                cmd: 'JustifyRight',
                icon: 'align-right'
            },
            {
                name: 'alignjustify',
                text: 'Justify',
                cmd: 'JustifyFull',
                icon: 'align-justify'
            }
        ];
        each$1(alignToolbarButtons, (item)=>{
            editor.ui.registry.addToggleButton(item.name, {
                tooltip: item.text,
                icon: item.icon,
                onAction: onActionExecCommand(editor, item.cmd),
                onSetup: onSetupFormatToggle(editor, item.name)
            });
        });
        editor.ui.registry.addButton('alignnone', {
            tooltip: 'No alignment',
            icon: 'align-none',
            onAction: onActionExecCommand(editor, 'JustifyNone')
        });
    };
    const units1 = {
        unsupportedLength: [
            'em',
            'ex',
            'cap',
            'ch',
            'ic',
            'rem',
            'lh',
            'rlh',
            'vw',
            'vh',
            'vi',
            'vb',
            'vmin',
            'vmax',
            'cm',
            'mm',
            'Q',
            'in',
            'pc',
            'pt',
            'px'
        ],
        fixed: [
            'px',
            'pt'
        ],
        relative: [
            '%'
        ],
        empty: [
            ''
        ]
    };
    const pattern1 = (()=>{
        const decimalDigits = '[0-9]+';
        const signedInteger = '[+-]?' + decimalDigits;
        const exponentPart = '[eE]' + signedInteger;
        const dot = '\\.';
        const opt = (input)=>`(?:${input})?`
        ;
        const unsignedDecimalLiteral = [
            'Infinity',
            decimalDigits + dot + opt(decimalDigits) + opt(exponentPart),
            dot + decimalDigits + opt(exponentPart),
            decimalDigits + opt(exponentPart)
        ].join('|');
        const float = `[+-]?(?:${unsignedDecimalLiteral})`;
        return new RegExp(`^(${float})(.*)$`);
    })();
    const isUnit = (unit, accepted)=>exists(accepted, (acc)=>exists(units1[acc], (check)=>unit === check
            )
        )
    ;
    const parse1 = (input, accepted)=>{
        const match = Optional.from(pattern1.exec(input));
        return match.bind((array)=>{
            const value = Number(array[1]);
            const unitRaw = array[2];
            if (isUnit(unitRaw, accepted)) return Optional.some({
                value,
                unit: unitRaw
            });
            else return Optional.none();
        });
    };
    const normalise = (input, accepted)=>parse1(input, accepted).map(({ value , unit  })=>value + unit
        )
    ;
    const registerController = (editor, spec)=>{
        const getMenuItems = ()=>{
            const options = spec.getOptions(editor);
            const initial = spec.getCurrent(editor).map(spec.hash);
            const current = value$2();
            return map$2(options, (value)=>({
                    type: 'togglemenuitem',
                    text: spec.display(value),
                    onSetup: (api)=>{
                        const setActive = (active)=>{
                            if (active) {
                                current.on((oldApi)=>oldApi.setActive(false)
                                );
                                current.set(api);
                            }
                            api.setActive(active);
                        };
                        setActive(is$11(initial, spec.hash(value)));
                        const unbindWatcher = spec.watcher(editor, value, setActive);
                        return ()=>{
                            current.clear();
                            unbindWatcher();
                        };
                    },
                    onAction: ()=>spec.setCurrent(editor, value)
                })
            );
        };
        editor.ui.registry.addMenuButton(spec.name, {
            tooltip: spec.text,
            icon: spec.icon,
            fetch: (callback)=>callback(getMenuItems())
            ,
            onSetup: spec.onToolbarSetup
        });
        editor.ui.registry.addNestedMenuItem(spec.name, {
            type: 'nestedmenuitem',
            text: spec.text,
            getSubmenuItems: getMenuItems,
            onSetup: spec.onMenuSetup
        });
    };
    const lineHeightSpec = {
        name: 'lineheight',
        text: 'Line height',
        icon: 'line-height',
        getOptions: getLineHeightFormats,
        hash: (input)=>normalise(input, [
                'fixed',
                'relative',
                'empty'
            ]).getOr(input)
        ,
        display: identity,
        watcher: (editor, value, callback)=>editor.formatter.formatChanged('lineheight', callback, false, {
                value
            }).unbind
        ,
        getCurrent: (editor)=>Optional.from(editor.queryCommandValue('LineHeight'))
        ,
        setCurrent: (editor, value)=>editor.execCommand('LineHeight', false, value)
    };
    const languageSpec = (editor1)=>{
        const settingsOpt = Optional.from(getContentLanguages(editor1));
        return settingsOpt.map((settings)=>({
                name: 'language',
                text: 'Language',
                icon: 'language',
                getOptions: constant$1(settings),
                hash: (input)=>isUndefined(input.customCode) ? input.code : `${input.code}/${input.customCode}`
                ,
                display: (input)=>input.title
                ,
                watcher: (editor, value, callback)=>editor.formatter.formatChanged('lang', callback, false, {
                        value: value.code,
                        customValue: value.customCode
                    }).unbind
                ,
                getCurrent: (editor)=>{
                    const node = SugarElement.fromDom(editor.selection.getNode());
                    return closest$4(node, (n)=>Optional.some(n).filter(isElement$1).bind((ele)=>{
                            const codeOpt = getOpt1(ele, 'lang');
                            return codeOpt.map((code)=>{
                                const customCode = getOpt1(ele, 'data-mce-lang').getOrUndefined();
                                return {
                                    code,
                                    customCode,
                                    title: ''
                                };
                            });
                        })
                    );
                },
                setCurrent: (editor, lang)=>editor.execCommand('Lang', false, lang)
                ,
                onToolbarSetup: (api)=>{
                    const unbinder = unbindable();
                    api.setActive(editor1.formatter.match('lang', {}, undefined, true));
                    unbinder.set(editor1.formatter.formatChanged('lang', api.setActive, true));
                    return unbinder.clear;
                }
            })
        );
    };
    const register$7 = (editor)=>{
        registerController(editor, lineHeightSpec);
        languageSpec(editor).each((spec)=>registerController(editor, spec)
        );
    };
    const register$6 = (editor, backstage)=>{
        createAlignMenu(editor, backstage);
        createFontFamilyMenu(editor, backstage);
        createStylesMenu(editor, backstage);
        createBlocksMenu(editor, backstage);
        createFontSizeMenu(editor, backstage);
    };
    const onSetupOutdentState = (editor)=>onSetupEvent(editor, 'NodeChange', (api)=>{
            api.setEnabled(editor.queryCommandState('outdent'));
        })
    ;
    const registerButtons$2 = (editor)=>{
        editor.ui.registry.addButton('outdent', {
            tooltip: 'Decrease indent',
            icon: 'outdent',
            onSetup: onSetupOutdentState(editor),
            onAction: onActionExecCommand(editor, 'outdent')
        });
        editor.ui.registry.addButton('indent', {
            tooltip: 'Increase indent',
            icon: 'indent',
            onAction: onActionExecCommand(editor, 'indent')
        });
    };
    const register$5 = (editor)=>{
        registerButtons$2(editor);
    };
    const makeSetupHandler = (editor, pasteAsText)=>(api)=>{
            api.setActive(pasteAsText.get());
            const pastePlainTextToggleHandler = (e)=>{
                pasteAsText.set(e.state);
                api.setActive(e.state);
            };
            editor.on('PastePlainTextToggle', pastePlainTextToggleHandler);
            return ()=>editor.off('PastePlainTextToggle', pastePlainTextToggleHandler)
            ;
        }
    ;
    const register$4 = (editor)=>{
        const pasteAsText = Cell(getPasteAsText(editor));
        const onAction = ()=>editor.execCommand('mceTogglePlainTextPaste')
        ;
        editor.ui.registry.addToggleButton('pastetext', {
            active: false,
            icon: 'paste-text',
            tooltip: 'Paste as text',
            onAction,
            onSetup: makeSetupHandler(editor, pasteAsText)
        });
        editor.ui.registry.addToggleMenuItem('pastetext', {
            text: 'Paste as text',
            icon: 'paste-text',
            onAction,
            onSetup: makeSetupHandler(editor, pasteAsText)
        });
    };
    const onActionToggleFormat = (editor, fmt)=>()=>{
            editor.execCommand('mceToggleFormat', false, fmt);
        }
    ;
    const registerFormatButtons = (editor)=>{
        global$1.each([
            {
                name: 'bold',
                text: 'Bold',
                icon: 'bold'
            },
            {
                name: 'italic',
                text: 'Italic',
                icon: 'italic'
            },
            {
                name: 'underline',
                text: 'Underline',
                icon: 'underline'
            },
            {
                name: 'strikethrough',
                text: 'Strikethrough',
                icon: 'strike-through'
            },
            {
                name: 'subscript',
                text: 'Subscript',
                icon: 'subscript'
            },
            {
                name: 'superscript',
                text: 'Superscript',
                icon: 'superscript'
            }
        ], (btn, _idx)=>{
            editor.ui.registry.addToggleButton(btn.name, {
                tooltip: btn.text,
                icon: btn.icon,
                onSetup: onSetupFormatToggle(editor, btn.name),
                onAction: onActionToggleFormat(editor, btn.name)
            });
        });
        for(let i = 1; i <= 6; i++){
            const name = 'h' + i;
            editor.ui.registry.addToggleButton(name, {
                text: name.toUpperCase(),
                tooltip: 'Heading ' + i,
                onSetup: onSetupFormatToggle(editor, name),
                onAction: onActionToggleFormat(editor, name)
            });
        }
    };
    const registerCommandButtons = (editor)=>{
        global$1.each([
            {
                name: 'cut',
                text: 'Cut',
                action: 'Cut',
                icon: 'cut'
            },
            {
                name: 'copy',
                text: 'Copy',
                action: 'Copy',
                icon: 'copy'
            },
            {
                name: 'paste',
                text: 'Paste',
                action: 'Paste',
                icon: 'paste'
            },
            {
                name: 'help',
                text: 'Help',
                action: 'mceHelp',
                icon: 'help'
            },
            {
                name: 'selectall',
                text: 'Select all',
                action: 'SelectAll',
                icon: 'select-all'
            },
            {
                name: 'newdocument',
                text: 'New document',
                action: 'mceNewDocument',
                icon: 'new-document'
            },
            {
                name: 'removeformat',
                text: 'Clear formatting',
                action: 'RemoveFormat',
                icon: 'remove-formatting'
            },
            {
                name: 'remove',
                text: 'Remove',
                action: 'Delete',
                icon: 'remove'
            },
            {
                name: 'print',
                text: 'Print',
                action: 'mcePrint',
                icon: 'print'
            },
            {
                name: 'hr',
                text: 'Horizontal line',
                action: 'InsertHorizontalRule',
                icon: 'horizontal-rule'
            }
        ], (btn)=>{
            editor.ui.registry.addButton(btn.name, {
                tooltip: btn.text,
                icon: btn.icon,
                onAction: onActionExecCommand(editor, btn.action)
            });
        });
    };
    const registerCommandToggleButtons = (editor)=>{
        global$1.each([
            {
                name: 'blockquote',
                text: 'Blockquote',
                action: 'mceBlockQuote',
                icon: 'quote'
            }
        ], (btn)=>{
            editor.ui.registry.addToggleButton(btn.name, {
                tooltip: btn.text,
                icon: btn.icon,
                onAction: onActionExecCommand(editor, btn.action),
                onSetup: onSetupFormatToggle(editor, btn.name)
            });
        });
    };
    const registerButtons$1 = (editor)=>{
        registerFormatButtons(editor);
        registerCommandButtons(editor);
        registerCommandToggleButtons(editor);
    };
    const registerMenuItems$2 = (editor)=>{
        global$1.each([
            {
                name: 'bold',
                text: 'Bold',
                action: 'Bold',
                icon: 'bold',
                shortcut: 'Meta+B'
            },
            {
                name: 'italic',
                text: 'Italic',
                action: 'Italic',
                icon: 'italic',
                shortcut: 'Meta+I'
            },
            {
                name: 'underline',
                text: 'Underline',
                action: 'Underline',
                icon: 'underline',
                shortcut: 'Meta+U'
            },
            {
                name: 'strikethrough',
                text: 'Strikethrough',
                action: 'Strikethrough',
                icon: 'strike-through'
            },
            {
                name: 'subscript',
                text: 'Subscript',
                action: 'Subscript',
                icon: 'subscript'
            },
            {
                name: 'superscript',
                text: 'Superscript',
                action: 'Superscript',
                icon: 'superscript'
            },
            {
                name: 'removeformat',
                text: 'Clear formatting',
                action: 'RemoveFormat',
                icon: 'remove-formatting'
            },
            {
                name: 'newdocument',
                text: 'New document',
                action: 'mceNewDocument',
                icon: 'new-document'
            },
            {
                name: 'cut',
                text: 'Cut',
                action: 'Cut',
                icon: 'cut',
                shortcut: 'Meta+X'
            },
            {
                name: 'copy',
                text: 'Copy',
                action: 'Copy',
                icon: 'copy',
                shortcut: 'Meta+C'
            },
            {
                name: 'paste',
                text: 'Paste',
                action: 'Paste',
                icon: 'paste',
                shortcut: 'Meta+V'
            },
            {
                name: 'selectall',
                text: 'Select all',
                action: 'SelectAll',
                icon: 'select-all',
                shortcut: 'Meta+A'
            },
            {
                name: 'print',
                text: 'Print...',
                action: 'mcePrint',
                icon: 'print',
                shortcut: 'Meta+P'
            },
            {
                name: 'hr',
                text: 'Horizontal line',
                action: 'InsertHorizontalRule',
                icon: 'horizontal-rule'
            }
        ], (menuitem)=>{
            editor.ui.registry.addMenuItem(menuitem.name, {
                text: menuitem.text,
                icon: menuitem.icon,
                shortcut: menuitem.shortcut,
                onAction: onActionExecCommand(editor, menuitem.action)
            });
        });
        editor.ui.registry.addMenuItem('codeformat', {
            text: 'Code',
            icon: 'sourcecode',
            onAction: onActionToggleFormat(editor, 'code')
        });
    };
    const register$3 = (editor)=>{
        registerButtons$1(editor);
        registerMenuItems$2(editor);
    };
    const onSetupUndoRedoState = (editor, type)=>onSetupEvent(editor, 'Undo Redo AddUndo TypingUndo ClearUndos SwitchMode', (api)=>{
            api.setEnabled(!editor.mode.isReadOnly() && editor.undoManager[type]());
        })
    ;
    const registerMenuItems$1 = (editor)=>{
        editor.ui.registry.addMenuItem('undo', {
            text: 'Undo',
            icon: 'undo',
            shortcut: 'Meta+Z',
            onSetup: onSetupUndoRedoState(editor, 'hasUndo'),
            onAction: onActionExecCommand(editor, 'undo')
        });
        editor.ui.registry.addMenuItem('redo', {
            text: 'Redo',
            icon: 'redo',
            shortcut: 'Meta+Y',
            onSetup: onSetupUndoRedoState(editor, 'hasRedo'),
            onAction: onActionExecCommand(editor, 'redo')
        });
    };
    const registerButtons = (editor)=>{
        editor.ui.registry.addButton('undo', {
            tooltip: 'Undo',
            icon: 'undo',
            enabled: false,
            onSetup: onSetupUndoRedoState(editor, 'hasUndo'),
            onAction: onActionExecCommand(editor, 'undo')
        });
        editor.ui.registry.addButton('redo', {
            tooltip: 'Redo',
            icon: 'redo',
            enabled: false,
            onSetup: onSetupUndoRedoState(editor, 'hasRedo'),
            onAction: onActionExecCommand(editor, 'redo')
        });
    };
    const register$2 = (editor)=>{
        registerMenuItems$1(editor);
        registerButtons(editor);
    };
    const onSetupVisualAidState = (editor)=>onSetupEvent(editor, 'VisualAid', (api)=>{
            api.setActive(editor.hasVisual);
        })
    ;
    const registerMenuItems = (editor)=>{
        editor.ui.registry.addToggleMenuItem('visualaid', {
            text: 'Visual aids',
            onSetup: onSetupVisualAidState(editor),
            onAction: onActionExecCommand(editor, 'mceToggleVisualAid')
        });
    };
    const registerToolbarButton = (editor)=>{
        editor.ui.registry.addButton('visualaid', {
            tooltip: 'Visual aids',
            text: 'Visual aids',
            onAction: onActionExecCommand(editor, 'mceToggleVisualAid')
        });
    };
    const register$1 = (editor)=>{
        registerToolbarButton(editor);
        registerMenuItems(editor);
    };
    const setup$6 = (editor, backstage)=>{
        register$8(editor);
        register$3(editor);
        register$6(editor, backstage);
        register$2(editor);
        register$c(editor);
        register$1(editor);
        register$5(editor);
        register$7(editor);
        register$4(editor);
    };
    const patchPipeConfig = (config)=>isString(config) ? config.split(/[ ,]/) : config
    ;
    const option1 = (name)=>(editor)=>editor.options.get(name)
    ;
    const register1 = (editor)=>{
        const registerOption = editor.options.register;
        registerOption('contextmenu_avoid_overlap', {
            processor: 'string',
            default: ''
        });
        registerOption('contextmenu_never_use_native', {
            processor: 'boolean',
            default: false
        });
        registerOption('contextmenu', {
            processor: (value)=>{
                if (value === false) return {
                    value: [],
                    valid: true
                };
                else if (isString(value) || isArrayOf(value, isString)) return {
                    value: patchPipeConfig(value),
                    valid: true
                };
                else return {
                    valid: false,
                    message: 'Must be false or a string.'
                };
            },
            default: 'link linkchecker image editimage table spellchecker configurepermanentpen'
        });
    };
    const shouldNeverUseNative = option1('contextmenu_never_use_native');
    const getAvoidOverlapSelector = option1('contextmenu_avoid_overlap');
    const isContextMenuDisabled = (editor)=>getContextMenu(editor).length === 0
    ;
    const getContextMenu = (editor)=>{
        const contextMenus = editor.ui.registry.getAll().contextMenus;
        const contextMenu = editor.options.get('contextmenu');
        if (editor.options.isSet('contextmenu')) return contextMenu;
        else return filter$2(contextMenu, (item)=>has$2(contextMenus, item)
        );
    };
    const nu1 = (x, y)=>({
            type: 'makeshift',
            x,
            y
        })
    ;
    const transpose = (pos, dx, dy)=>{
        return nu1(pos.x + dx, pos.y + dy);
    };
    const isTouchEvent = (e)=>e.type === 'longpress' || e.type.indexOf('touch') === 0
    ;
    const fromPageXY = (e)=>{
        if (isTouchEvent(e)) {
            const touch = e.touches[0];
            return nu1(touch.pageX, touch.pageY);
        } else return nu1(e.pageX, e.pageY);
    };
    const fromClientXY = (e)=>{
        if (isTouchEvent(e)) {
            const touch = e.touches[0];
            return nu1(touch.clientX, touch.clientY);
        } else return nu1(e.clientX, e.clientY);
    };
    const transposeContentAreaContainer = (element, pos)=>{
        const containerPos = global$7.DOM.getPos(element);
        return transpose(pos, containerPos.x, containerPos.y);
    };
    const getPointAnchor = (editor, e)=>{
        if (e.type === 'contextmenu' || e.type === 'longpress') {
            if (editor.inline) return fromPageXY(e);
            else return transposeContentAreaContainer(editor.getContentAreaContainer(), fromClientXY(e));
        } else return getSelectionAnchor(editor);
    };
    const getSelectionAnchor = (editor)=>{
        return {
            type: 'selection',
            root: SugarElement.fromDom(editor.selection.getNode())
        };
    };
    const getNodeAnchor = (editor)=>({
            type: 'node',
            node: Optional.some(SugarElement.fromDom(editor.selection.getNode())),
            root: SugarElement.fromDom(editor.getBody())
        })
    ;
    const getAnchorSpec$1 = (editor, e, anchorType)=>{
        switch(anchorType){
            case 'node':
                return getNodeAnchor(editor);
            case 'point':
                return getPointAnchor(editor, e);
            case 'selection':
                return getSelectionAnchor(editor);
        }
    };
    const initAndShow$1 = (editor, e, buildMenu, backstage, contextmenu, anchorType)=>{
        const items = buildMenu();
        const anchorSpec = getAnchorSpec$1(editor, e, anchorType);
        build1(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, false).map((menuData)=>{
            e.preventDefault();
            InlineView.showMenuAt(contextmenu, {
                anchor: anchorSpec
            }, {
                menu: {
                    markers: markers('normal')
                },
                data: menuData
            });
        });
    };
    const layouts1 = {
        onLtr: ()=>[
                south$2,
                southeast$2,
                southwest$2,
                northeast$2,
                northwest$2,
                north$2,
                north1,
                south1,
                northeast1,
                southeast1,
                northwest1,
                southwest1
            ]
        ,
        onRtl: ()=>[
                south$2,
                southwest$2,
                southeast$2,
                northwest$2,
                northeast$2,
                north$2,
                north1,
                south1,
                northwest1,
                southwest1,
                northeast1,
                southeast1
            ]
    };
    const bubbleSize1 = 12;
    const bubbleAlignments = {
        valignCentre: [],
        alignCentre: [],
        alignLeft: [
            'tox-pop--align-left'
        ],
        alignRight: [
            'tox-pop--align-right'
        ],
        right: [
            'tox-pop--right'
        ],
        left: [
            'tox-pop--left'
        ],
        bottom: [
            'tox-pop--bottom'
        ],
        top: [
            'tox-pop--top'
        ]
    };
    const isTouchWithinSelection = (editor, e)=>{
        const selection = editor.selection;
        if (selection.isCollapsed() || e.touches.length < 1) return false;
        else {
            const touch = e.touches[0];
            const rng = selection.getRng();
            const rngRectOpt = getFirstRect(editor.getWin(), SimSelection.domRange(rng));
            return rngRectOpt.exists((rngRect)=>rngRect.left <= touch.clientX && rngRect.right >= touch.clientX && rngRect.top <= touch.clientY && rngRect.bottom >= touch.clientY
            );
        }
    };
    const setupiOSOverrides = (editor)=>{
        const originalSelection = editor.selection.getRng();
        const selectionReset = ()=>{
            global$9.setEditorTimeout(editor, ()=>{
                editor.selection.setRng(originalSelection);
            }, 10);
            unbindEventListeners();
        };
        editor.once('touchend', selectionReset);
        const preventMousedown = (e)=>{
            e.preventDefault();
            e.stopImmediatePropagation();
        };
        editor.on('mousedown', preventMousedown, true);
        const clearSelectionReset = ()=>unbindEventListeners()
        ;
        editor.once('longpresscancel', clearSelectionReset);
        const unbindEventListeners = ()=>{
            editor.off('touchend', selectionReset);
            editor.off('longpresscancel', clearSelectionReset);
            editor.off('mousedown', preventMousedown);
        };
    };
    const getAnchorSpec = (editor, e, anchorType)=>{
        const anchorSpec = getAnchorSpec$1(editor, e, anchorType);
        const bubbleYOffset = anchorType === 'point' ? bubbleSize1 : 0;
        return {
            bubble: nu$5(0, bubbleYOffset, bubbleAlignments),
            layouts: layouts1,
            overrides: {
                maxWidthFunction: expandable(),
                maxHeightFunction: expandable$1()
            },
            ...anchorSpec
        };
    };
    const show1 = (editor, e, items, backstage, contextmenu, anchorType, highlightImmediately)=>{
        const anchorSpec = getAnchorSpec(editor, e, anchorType);
        build1(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, true).map((menuData)=>{
            e.preventDefault();
            InlineView.showMenuWithinBounds(contextmenu, {
                anchor: anchorSpec
            }, {
                menu: {
                    markers: markers('normal'),
                    highlightImmediately
                },
                data: menuData,
                type: 'horizontal'
            }, ()=>Optional.some(getContextToolbarBounds(editor, backstage.shared, anchorType === 'node' ? 'node' : 'selection'))
            );
            editor.dispatch(hideContextToolbarEvent);
        });
    };
    const initAndShow = (editor, e, buildMenu, backstage, contextmenu, anchorType)=>{
        const detection = detect$1();
        const isiOS = detection.os.isiOS();
        const isMacOS = detection.os.isMacOS();
        const isAndroid = detection.os.isAndroid();
        const isTouch = detection.deviceType.isTouch();
        const shouldHighlightImmediately = ()=>!(isAndroid || isiOS || isMacOS && isTouch)
        ;
        const open = ()=>{
            const items = buildMenu();
            show1(editor, e, items, backstage, contextmenu, anchorType, shouldHighlightImmediately());
        };
        if ((isMacOS || isiOS) && anchorType !== 'node') {
            const openiOS = ()=>{
                setupiOSOverrides(editor);
                open();
            };
            if (isTouchWithinSelection(editor, e)) openiOS();
            else {
                editor.once('selectionchange', openiOS);
                editor.once('touchend', ()=>editor.off('selectionchange', openiOS)
                );
            }
        } else open();
    };
    const isSeparator1 = (item)=>isString(item) ? item === '|' : item.type === 'separator'
    ;
    const separator = {
        type: 'separator'
    };
    const makeContextItem = (item2)=>{
        const commonMenuItem = (item)=>({
                text: item.text,
                icon: item.icon,
                enabled: item.enabled,
                shortcut: item.shortcut
            })
        ;
        if (isString(item2)) return item2;
        else switch(item2.type){
            case 'separator':
                return separator;
            case 'submenu':
                return {
                    type: 'nestedmenuitem',
                    ...commonMenuItem(item2),
                    getSubmenuItems: ()=>{
                        const items = item2.getSubmenuItems();
                        if (isString(items)) return items;
                        else return map$2(items, makeContextItem);
                    }
                };
            default:
                return {
                    type: 'menuitem',
                    ...commonMenuItem(item2),
                    onAction: noarg(item2.onAction)
                };
        }
    };
    const addContextMenuGroup = (xs, groupItems)=>{
        if (groupItems.length === 0) return xs;
        const lastMenuItem = last$1(xs).filter((item)=>!isSeparator1(item)
        );
        const before = lastMenuItem.fold(()=>[]
        , (_)=>[
                separator
            ]
        );
        return xs.concat(before).concat(groupItems).concat([
            separator
        ]);
    };
    const generateContextMenu = (contextMenus, menuConfig, selectedElement)=>{
        const sections = foldl(menuConfig, (acc, name)=>{
            return get$g(contextMenus, name.toLowerCase()).map((menu)=>{
                const items = menu.update(selectedElement);
                if (isString(items)) return addContextMenuGroup(acc, items.split(' '));
                else if (items.length > 0) {
                    const allItems = map$2(items, makeContextItem);
                    return addContextMenuGroup(acc, allItems);
                } else return acc;
            }).getOrThunk(()=>acc.concat([
                    name
                ])
            );
        }, []);
        if (sections.length > 0 && isSeparator1(sections[sections.length - 1])) sections.pop();
        return sections;
    };
    const isNativeOverrideKeyEvent = (editor, e)=>e.ctrlKey && !shouldNeverUseNative(editor)
    ;
    const isTriggeredByKeyboard = (editor, e)=>e.type !== 'longpress' && (e.button !== 2 || e.target === editor.getBody() && e.pointerType === '')
    ;
    const getSelectedElement = (editor, e)=>isTriggeredByKeyboard(editor, e) ? editor.selection.getStart(true) : e.target
    ;
    const getAnchorType = (editor, e)=>{
        const selector = getAvoidOverlapSelector(editor);
        const anchorType = isTriggeredByKeyboard(editor, e) ? 'selection' : 'point';
        if (isNotEmpty(selector)) {
            const target = getSelectedElement(editor, e);
            const selectorExists = closest1(SugarElement.fromDom(target), selector);
            return selectorExists ? 'node' : anchorType;
        } else return anchorType;
    };
    const setup$5 = (editor, lazySink, backstage)=>{
        const detection = detect$1();
        const isTouch = detection.deviceType.isTouch;
        const contextmenu = build$1(InlineView.sketch({
            dom: {
                tag: 'div'
            },
            lazySink,
            onEscape: ()=>editor.focus()
            ,
            onShow: ()=>backstage.setContextMenuState(true)
            ,
            onHide: ()=>backstage.setContextMenuState(false)
            ,
            fireDismissalEventInstead: {},
            inlineBehaviours: derive$1([
                config1('dismissContextMenu', [
                    run$1(dismissRequested(), (comp, _se)=>{
                        Sandboxing.close(comp);
                        editor.focus();
                    })
                ])
            ])
        }));
        const hideContextMenu = (_e)=>InlineView.hide(contextmenu)
        ;
        const showContextMenu = (e)=>{
            if (shouldNeverUseNative(editor)) e.preventDefault();
            if (isNativeOverrideKeyEvent(editor, e) || isContextMenuDisabled(editor)) return;
            const anchorType = getAnchorType(editor, e);
            const buildMenu = ()=>{
                const selectedElement = getSelectedElement(editor, e);
                const registry = editor.ui.registry.getAll();
                const menuConfig = getContextMenu(editor);
                return generateContextMenu(registry.contextMenus, menuConfig, selectedElement);
            };
            const initAndShow$2 = isTouch() ? initAndShow : initAndShow$1;
            initAndShow$2(editor, e, buildMenu, backstage, contextmenu, anchorType);
        };
        editor.on('init', ()=>{
            const hideEvents = 'ResizeEditor ScrollContent ScrollWindow longpresscancel' + (isTouch() ? '' : ' ResizeWindow');
            editor.on(hideEvents, hideContextMenu);
            editor.on('longpress contextmenu', showContextMenu);
        });
    };
    const adt1 = Adt.generate([
        {
            offset: [
                'x',
                'y'
            ]
        },
        {
            absolute: [
                'x',
                'y'
            ]
        },
        {
            fixed: [
                'x',
                'y'
            ]
        }
    ]);
    const subtract = (change)=>(point)=>point.translate(-change.left, -change.top)
    ;
    const add1 = (change)=>(point)=>point.translate(change.left, change.top)
    ;
    const transform1 = (changes)=>(x, y)=>foldl(changes, (rest, f)=>f(rest)
            , SugarPosition(x, y))
    ;
    const asFixed = (coord, scroll, origin)=>coord.fold(transform1([
            add1(origin),
            subtract(scroll)
        ]), transform1([
            subtract(scroll)
        ]), transform1([]))
    ;
    const asAbsolute = (coord, scroll, origin)=>coord.fold(transform1([
            add1(origin)
        ]), transform1([]), transform1([
            add1(scroll)
        ]))
    ;
    const asOffset = (coord, scroll, origin)=>coord.fold(transform1([]), transform1([
            subtract(origin)
        ]), transform1([
            add1(scroll),
            subtract(origin)
        ]))
    ;
    const withinRange = (coord1, coord2, xRange, yRange, scroll, origin)=>{
        const a1 = asAbsolute(coord1, scroll, origin);
        const a2 = asAbsolute(coord2, scroll, origin);
        return Math.abs(a1.left - a2.left) <= xRange && Math.abs(a1.top - a2.top) <= yRange;
    };
    const getDeltas = (coord1, coord2, xRange, yRange, scroll, origin)=>{
        const a1 = asAbsolute(coord1, scroll, origin);
        const a2 = asAbsolute(coord2, scroll, origin);
        const left = Math.abs(a1.left - a2.left);
        const top = Math.abs(a1.top - a2.top);
        return SugarPosition(left, top);
    };
    const toStyles = (coord, scroll, origin)=>{
        const stylesOpt = coord.fold((x, y)=>({
                position: Optional.some('absolute'),
                left: Optional.some(x + 'px'),
                top: Optional.some(y + 'px')
            })
        , (x, y)=>({
                position: Optional.some('absolute'),
                left: Optional.some(x - origin.left + 'px'),
                top: Optional.some(y - origin.top + 'px')
            })
        , (x, y)=>({
                position: Optional.some('fixed'),
                left: Optional.some(x + 'px'),
                top: Optional.some(y + 'px')
            })
        );
        return {
            right: Optional.none(),
            bottom: Optional.none(),
            ...stylesOpt
        };
    };
    const translate1 = (coord, deltaX, deltaY)=>coord.fold((x, y)=>offset1(x + deltaX, y + deltaY)
        , (x, y)=>absolute(x + deltaX, y + deltaY)
        , (x, y)=>fixed(x + deltaX, y + deltaY)
        )
    ;
    const absorb = (partialCoord, originalCoord, scroll, origin)=>{
        const absorbOne = (stencil, nu)=>(optX, optY)=>{
                const original = stencil(originalCoord, scroll, origin);
                return nu(optX.getOr(original.left), optY.getOr(original.top));
            }
        ;
        return partialCoord.fold(absorbOne(asOffset, offset1), absorbOne(asAbsolute, absolute), absorbOne(asFixed, fixed));
    };
    const offset1 = adt1.offset;
    const absolute = adt1.absolute;
    const fixed = adt1.fixed;
    const parseAttrToInt = (element, name)=>{
        const value = get$f(element, name);
        return isUndefined(value) ? NaN : parseInt(value, 10);
    };
    const get1 = (component, snapsInfo)=>{
        const element = component.element;
        const x = parseAttrToInt(element, snapsInfo.leftAttr);
        const y = parseAttrToInt(element, snapsInfo.topAttr);
        return isNaN(x) || isNaN(y) ? Optional.none() : Optional.some(SugarPosition(x, y));
    };
    const set1 = (component, snapsInfo, pt)=>{
        const element = component.element;
        set$9(element, snapsInfo.leftAttr, pt.left + 'px');
        set$9(element, snapsInfo.topAttr, pt.top + 'px');
    };
    const clear1 = (component, snapsInfo)=>{
        const element = component.element;
        remove$7(element, snapsInfo.leftAttr);
        remove$7(element, snapsInfo.topAttr);
    };
    const getCoords = (component, snapInfo, coord, delta)=>get1(component, snapInfo).fold(()=>coord
        , (fixed$1)=>fixed(fixed$1.left + delta.left, fixed$1.top + delta.top)
        )
    ;
    const moveOrSnap = (component, snapInfo, coord, delta, scroll, origin)=>{
        const newCoord = getCoords(component, snapInfo, coord, delta);
        const snap = snapInfo.mustSnap ? findClosestSnap(component, snapInfo, newCoord, scroll, origin) : findSnap(component, snapInfo, newCoord, scroll, origin);
        const fixedCoord = asFixed(newCoord, scroll, origin);
        set1(component, snapInfo, fixedCoord);
        return snap.fold(()=>({
                coord: fixed(fixedCoord.left, fixedCoord.top),
                extra: Optional.none()
            })
        , (spanned)=>({
                coord: spanned.output,
                extra: spanned.extra
            })
        );
    };
    const stopDrag = (component, snapInfo)=>{
        clear1(component, snapInfo);
    };
    const findMatchingSnap = (snaps, newCoord, scroll, origin)=>findMap(snaps, (snap)=>{
            const sensor = snap.sensor;
            const inRange = withinRange(newCoord, sensor, snap.range.left, snap.range.top, scroll, origin);
            return inRange ? Optional.some({
                output: absorb(snap.output, newCoord, scroll, origin),
                extra: snap.extra
            }) : Optional.none();
        })
    ;
    const findClosestSnap = (component, snapInfo, newCoord, scroll, origin)=>{
        const snaps = snapInfo.getSnapPoints(component);
        const matchSnap = findMatchingSnap(snaps, newCoord, scroll, origin);
        return matchSnap.orThunk(()=>{
            const bestSnap = foldl(snaps, (acc, snap)=>{
                const sensor = snap.sensor;
                const deltas = getDeltas(newCoord, sensor, snap.range.left, snap.range.top, scroll, origin);
                return acc.deltas.fold(()=>({
                        deltas: Optional.some(deltas),
                        snap: Optional.some(snap)
                    })
                , (bestDeltas)=>{
                    const currAvg = (deltas.left + deltas.top) / 2;
                    const bestAvg = (bestDeltas.left + bestDeltas.top) / 2;
                    if (currAvg <= bestAvg) return {
                        deltas: Optional.some(deltas),
                        snap: Optional.some(snap)
                    };
                    else return acc;
                });
            }, {
                deltas: Optional.none(),
                snap: Optional.none()
            });
            return bestSnap.snap.map((snap)=>({
                    output: absorb(snap.output, newCoord, scroll, origin),
                    extra: snap.extra
                })
            );
        });
    };
    const findSnap = (component, snapInfo, newCoord, scroll, origin)=>{
        const snaps = snapInfo.getSnapPoints(component);
        return findMatchingSnap(snaps, newCoord, scroll, origin);
    };
    const snapTo$1 = (snap, scroll, origin)=>({
            coord: absorb(snap.output, snap.output, scroll, origin),
            extra: snap.extra
        })
    ;
    const snapTo1 = (component, dragConfig, _state, snap)=>{
        const target = dragConfig.getTarget(component.element);
        if (dragConfig.repositionTarget) {
            const doc = owner$4(component.element);
            const scroll = get$b(doc);
            const origin = getOrigin(target);
            const snapPin = snapTo$1(snap, scroll, origin);
            const styles = toStyles(snapPin.coord, scroll, origin);
            setOptions(target, styles);
        }
    };
    var DraggingApis = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        snapTo: snapTo1
    });
    const initialAttribute = 'data-initial-z-index';
    const resetZIndex = (blocker)=>{
        parent1(blocker.element).filter(isElement$1).each((root)=>{
            getOpt1(root, initialAttribute).fold(()=>remove$6(root, 'z-index')
            , (zIndex)=>set$8(root, 'z-index', zIndex)
            );
            remove$7(root, initialAttribute);
        });
    };
    const changeZIndex = (blocker)=>{
        parent1(blocker.element).filter(isElement$1).each((root)=>{
            getRaw(root, 'z-index').each((zindex)=>{
                set$9(root, initialAttribute, zindex);
            });
            set$8(root, 'z-index', get$e(blocker.element, 'z-index'));
        });
    };
    const instigate = (anyComponent, blocker)=>{
        anyComponent.getSystem().addToGui(blocker);
        changeZIndex(blocker);
    };
    const discard = (blocker)=>{
        resetZIndex(blocker);
        blocker.getSystem().removeFromGui(blocker);
    };
    const createComponent = (component, blockerClass, blockerEvents)=>component.getSystem().build(Container.sketch({
            dom: {
                styles: {
                    'left': '0px',
                    'top': '0px',
                    'width': '100%',
                    'height': '100%',
                    'position': 'fixed',
                    'z-index': '1000000000000000'
                },
                classes: [
                    blockerClass
                ]
            },
            events: blockerEvents
        }))
    ;
    var SnapSchema = optionObjOf('snaps', [
        required$1('getSnapPoints'),
        onHandler('onSensor'),
        required$1('leftAttr'),
        required$1('topAttr'),
        defaulted('lazyViewport', win1),
        defaulted('mustSnap', false)
    ]);
    const schema$6 = [
        defaulted('useFixed', never),
        required$1('blockerClass'),
        defaulted('getTarget', identity),
        defaulted('onDrag', noop),
        defaulted('repositionTarget', true),
        defaulted('onDrop', noop),
        defaultedFunction('getBounds', win1),
        SnapSchema
    ];
    const getCurrentCoord = (target)=>lift3(getRaw(target, 'left'), getRaw(target, 'top'), getRaw(target, 'position'), (left, top, position)=>{
            const nu = position === 'fixed' ? fixed : offset1;
            return nu(parseInt(left, 10), parseInt(top, 10));
        }).getOrThunk(()=>{
            const location = absolute$3(target);
            return absolute(location.left, location.top);
        })
    ;
    const clampCoords = (component, coords, scroll, origin, startData)=>{
        const bounds = startData.bounds;
        const absoluteCoord = asAbsolute(coords, scroll, origin);
        const newX = clamp(absoluteCoord.left, bounds.x, bounds.x + bounds.width - startData.width);
        const newY = clamp(absoluteCoord.top, bounds.y, bounds.y + bounds.height - startData.height);
        const newCoords = absolute(newX, newY);
        return coords.fold(()=>{
            const offset$1 = asOffset(newCoords, scroll, origin);
            return offset1(offset$1.left, offset$1.top);
        }, constant$1(newCoords), ()=>{
            const fixed$1 = asFixed(newCoords, scroll, origin);
            return fixed(fixed$1.left, fixed$1.top);
        });
    };
    const calcNewCoord = (component, optSnaps, currentCoord, scroll, origin, delta, startData)=>{
        const newCoord = optSnaps.fold(()=>{
            const translated = translate1(currentCoord, delta.left, delta.top);
            const fixedCoord = asFixed(translated, scroll, origin);
            return fixed(fixedCoord.left, fixedCoord.top);
        }, (snapInfo)=>{
            const snapping = moveOrSnap(component, snapInfo, currentCoord, delta, scroll, origin);
            snapping.extra.each((extra)=>{
                snapInfo.onSensor(component, extra);
            });
            return snapping.coord;
        });
        return clampCoords(component, newCoord, scroll, origin, startData);
    };
    const dragBy = (component, dragConfig, startData, delta)=>{
        const target = dragConfig.getTarget(component.element);
        if (dragConfig.repositionTarget) {
            const doc = owner$4(component.element);
            const scroll = get$b(doc);
            const origin = getOrigin(target);
            const currentCoord = getCurrentCoord(target);
            const newCoord = calcNewCoord(component, dragConfig.snaps, currentCoord, scroll, origin, delta, startData);
            const styles = toStyles(newCoord, scroll, origin);
            setOptions(target, styles);
        }
        dragConfig.onDrag(component, target, delta);
    };
    const calcStartData = (dragConfig, comp)=>({
            bounds: dragConfig.getBounds(),
            height: getOuter$2(comp.element),
            width: getOuter$1(comp.element)
        })
    ;
    const move1 = (component, dragConfig, dragState, dragMode, event)=>{
        const delta = dragState.update(dragMode, event);
        const dragStartData = dragState.getStartData().getOrThunk(()=>calcStartData(dragConfig, component)
        );
        delta.each((dlt)=>{
            dragBy(component, dragConfig, dragStartData, dlt);
        });
    };
    const stop1 = (component, blocker, dragConfig, dragState)=>{
        blocker.each(discard);
        dragConfig.snaps.each((snapInfo)=>{
            stopDrag(component, snapInfo);
        });
        const target = dragConfig.getTarget(component.element);
        dragState.reset();
        dragConfig.onDrop(component, target);
    };
    const handlers1 = (events)=>(dragConfig, dragState)=>{
            const updateStartState = (comp)=>{
                dragState.setStartData(calcStartData(dragConfig, comp));
            };
            return derive$2([
                run$1(windowScroll(), (comp)=>{
                    dragState.getStartData().each(()=>updateStartState(comp)
                    );
                }),
                ...events(dragConfig, dragState, updateStartState)
            ]);
        }
    ;
    const init$2 = (dragApi)=>derive$2([
            run$1(mousedown(), dragApi.forceDrop),
            run$1(mouseup(), dragApi.drop),
            run$1(mousemove(), (comp, simulatedEvent)=>{
                dragApi.move(simulatedEvent.event);
            }),
            run$1(mouseout(), dragApi.delayDrop)
        ])
    ;
    const getData$1 = (event)=>Optional.from(SugarPosition(event.x, event.y))
    ;
    const getDelta$1 = (old, nu)=>SugarPosition(nu.left - old.left, nu.top - old.top)
    ;
    var MouseData = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        getData: getData$1,
        getDelta: getDelta$1
    });
    const events$2 = (dragConfig, dragState, updateStartState)=>[
            run$1(mousedown(), (component, simulatedEvent)=>{
                const raw = simulatedEvent.event.raw;
                if (raw.button !== 0) return;
                simulatedEvent.stop();
                const stop$1 = ()=>stop1(component, Optional.some(blocker), dragConfig, dragState)
                ;
                const delayDrop = DelayedFunction(stop$1, 200);
                const dragApi = {
                    drop: stop$1,
                    delayDrop: delayDrop.schedule,
                    forceDrop: stop$1,
                    move: (event)=>{
                        delayDrop.cancel();
                        move1(component, dragConfig, dragState, MouseData, event);
                    }
                };
                const blocker = createComponent(component, dragConfig.blockerClass, init$2(dragApi));
                const start = ()=>{
                    updateStartState(component);
                    instigate(component, blocker);
                };
                start();
            })
        ]
    ;
    const schema$5 = [
        ...schema$6,
        output$1('dragger', {
            handlers: handlers1(events$2)
        })
    ];
    const init$1 = (dragApi)=>derive$2([
            run$1(touchstart(), dragApi.forceDrop),
            run$1(touchend(), dragApi.drop),
            run$1(touchcancel(), dragApi.drop),
            run$1(touchmove(), (comp, simulatedEvent)=>{
                dragApi.move(simulatedEvent.event);
            })
        ])
    ;
    const getDataFrom = (touches)=>{
        const touch = touches[0];
        return Optional.some(SugarPosition(touch.clientX, touch.clientY));
    };
    const getData1 = (event)=>{
        const raw = event.raw;
        const touches = raw.touches;
        return touches.length === 1 ? getDataFrom(touches) : Optional.none();
    };
    const getDelta = (old, nu)=>SugarPosition(nu.left - old.left, nu.top - old.top)
    ;
    var TouchData = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        getData: getData1,
        getDelta: getDelta
    });
    const events$1 = (dragConfig, dragState, updateStartState)=>{
        const blockerSingleton = value$2();
        const stopBlocking = (component)=>{
            stop1(component, blockerSingleton.get(), dragConfig, dragState);
            blockerSingleton.clear();
        };
        return [
            run$1(touchstart(), (component, simulatedEvent)=>{
                simulatedEvent.stop();
                const stop = ()=>stopBlocking(component)
                ;
                const dragApi = {
                    drop: stop,
                    delayDrop: noop,
                    forceDrop: stop,
                    move: (event)=>{
                        move1(component, dragConfig, dragState, TouchData, event);
                    }
                };
                const blocker = createComponent(component, dragConfig.blockerClass, init$1(dragApi));
                blockerSingleton.set(blocker);
                const start = ()=>{
                    updateStartState(component);
                    instigate(component, blocker);
                };
                start();
            }),
            run$1(touchmove(), (component, simulatedEvent)=>{
                simulatedEvent.stop();
                move1(component, dragConfig, dragState, TouchData, simulatedEvent.event);
            }),
            run$1(touchend(), (component, simulatedEvent)=>{
                simulatedEvent.stop();
                stopBlocking(component);
            }),
            run$1(touchcancel(), stopBlocking)
        ];
    };
    const schema$4 = [
        ...schema$6,
        output$1('dragger', {
            handlers: handlers1(events$1)
        })
    ];
    const events1 = (dragConfig, dragState, updateStartState)=>[
            ...events$2(dragConfig, dragState, updateStartState),
            ...events$1(dragConfig, dragState, updateStartState)
        ]
    ;
    const schema$3 = [
        ...schema$6,
        output$1('dragger', {
            handlers: handlers1(events1)
        })
    ];
    const mouse = schema$5;
    const touch1 = schema$4;
    const mouseOrTouch = schema$3;
    var DraggingBranches = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        mouse: mouse,
        touch: touch1,
        mouseOrTouch: mouseOrTouch
    });
    const init1 = ()=>{
        let previous = Optional.none();
        let startData = Optional.none();
        const reset = ()=>{
            previous = Optional.none();
            startData = Optional.none();
        };
        const calculateDelta = (mode, nu)=>{
            const result = previous.map((old)=>mode.getDelta(old, nu)
            );
            previous = Optional.some(nu);
            return result;
        };
        const update = (mode, dragEvent)=>mode.getData(dragEvent).bind((nuData)=>calculateDelta(mode, nuData)
            )
        ;
        const setStartData = (data)=>{
            startData = Optional.some(data);
        };
        const getStartData = ()=>startData
        ;
        const readState = constant$1({});
        return nu$8({
            readState,
            reset,
            update,
            getStartData,
            setStartData
        });
    };
    var DragState = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        init: init1
    });
    const Dragging = createModes({
        branchKey: 'mode',
        branches: DraggingBranches,
        name: 'dragging',
        active: {
            events: (dragConfig, dragState)=>{
                const dragger = dragConfig.dragger;
                return dragger.handlers(dragConfig, dragState);
            }
        },
        extra: {
            snap: (sConfig)=>({
                    sensor: sConfig.sensor,
                    range: sConfig.range,
                    output: sConfig.output,
                    extra: Optional.from(sConfig.extra)
                })
        },
        state: DragState,
        apis: DraggingApis
    });
    const snapWidth = 40;
    const snapOffset = snapWidth / 2;
    const calcSnap = (selectorOpt, td, x, y, width, height)=>selectorOpt.fold(()=>Dragging.snap({
                sensor: absolute(x - snapOffset, y - snapOffset),
                range: SugarPosition(width, height),
                output: absolute(Optional.some(x), Optional.some(y)),
                extra: {
                    td
                }
            })
        , (selectorHandle)=>{
            const sensorLeft = x - snapOffset;
            const sensorTop = y - snapOffset;
            const sensorWidth = snapWidth;
            const sensorHeight = snapWidth;
            const rect = selectorHandle.element.dom.getBoundingClientRect();
            return Dragging.snap({
                sensor: absolute(sensorLeft, sensorTop),
                range: SugarPosition(sensorWidth, sensorHeight),
                output: absolute(Optional.some(x - rect.width / 2), Optional.some(y - rect.height / 2)),
                extra: {
                    td
                }
            });
        })
    ;
    const getSnapsConfig = (getSnapPoints, cell, onChange)=>{
        const isSameCell = (cellOpt, td)=>cellOpt.exists((currentTd)=>eq(currentTd, td)
            )
        ;
        return {
            getSnapPoints,
            leftAttr: 'data-drag-left',
            topAttr: 'data-drag-top',
            onSensor: (component, extra)=>{
                const td = extra.td;
                if (!isSameCell(cell.get(), td)) {
                    cell.set(td);
                    onChange(td);
                }
            },
            mustSnap: true
        };
    };
    const createSelector = (snaps)=>record1(Button.sketch({
            dom: {
                tag: 'div',
                classes: [
                    'tox-selector'
                ]
            },
            buttonBehaviours: derive$1([
                Dragging.config({
                    mode: 'mouseOrTouch',
                    blockerClass: 'blocker',
                    snaps
                }),
                Unselecting.config({})
            ]),
            eventOrder: {
                mousedown: [
                    'dragging',
                    'alloy.base.behaviour'
                ],
                touchstart: [
                    'dragging',
                    'alloy.base.behaviour'
                ]
            }
        }))
    ;
    const setup$4 = (editor, sink)=>{
        const tlTds = Cell([]);
        const brTds = Cell([]);
        const isVisible = Cell(false);
        const startCell = value$2();
        const finishCell = value$2();
        const getTopLeftSnap = (td)=>{
            const box = absolute$2(td);
            return calcSnap(memTopLeft.getOpt(sink), td, box.x, box.y, box.width, box.height);
        };
        const getTopLeftSnaps = ()=>map$2(tlTds.get(), (td)=>getTopLeftSnap(td)
            )
        ;
        const getBottomRightSnap = (td)=>{
            const box = absolute$2(td);
            return calcSnap(memBottomRight.getOpt(sink), td, box.right, box.bottom, box.width, box.height);
        };
        const getBottomRightSnaps = ()=>map$2(brTds.get(), (td)=>getBottomRightSnap(td)
            )
        ;
        const topLeftSnaps = getSnapsConfig(getTopLeftSnaps, startCell, (start)=>{
            finishCell.get().each((finish)=>{
                editor.dispatch('TableSelectorChange', {
                    start,
                    finish
                });
            });
        });
        const bottomRightSnaps = getSnapsConfig(getBottomRightSnaps, finishCell, (finish)=>{
            startCell.get().each((start)=>{
                editor.dispatch('TableSelectorChange', {
                    start,
                    finish
                });
            });
        });
        const memTopLeft = createSelector(topLeftSnaps);
        const memBottomRight = createSelector(bottomRightSnaps);
        const topLeft = build$1(memTopLeft.asSpec());
        const bottomRight = build$1(memBottomRight.asSpec());
        const showOrHideHandle = (selector, cell, isAbove, isBelow)=>{
            const cellRect = cell.dom.getBoundingClientRect();
            remove$6(selector.element, 'display');
            const viewportHeight = defaultView(SugarElement.fromDom(editor.getBody())).dom.innerHeight;
            const aboveViewport = isAbove(cellRect);
            const belowViewport = isBelow(cellRect, viewportHeight);
            if (aboveViewport || belowViewport) set$8(selector.element, 'display', 'none');
        };
        const snapTo = (selector, cell, getSnapConfig, pos)=>{
            const snap = getSnapConfig(cell);
            Dragging.snapTo(selector, snap);
            const isAbove = (rect)=>rect[pos] < 0
            ;
            const isBelow = (rect, viewportHeight)=>rect[pos] > viewportHeight
            ;
            showOrHideHandle(selector, cell, isAbove, isBelow);
        };
        const snapTopLeft = (cell)=>snapTo(topLeft, cell, getTopLeftSnap, 'top')
        ;
        const snapLastTopLeft = ()=>startCell.get().each(snapTopLeft)
        ;
        const snapBottomRight = (cell)=>snapTo(bottomRight, cell, getBottomRightSnap, 'bottom')
        ;
        const snapLastBottomRight = ()=>finishCell.get().each(snapBottomRight)
        ;
        if (detect$1().deviceType.isTouch()) {
            editor.on('TableSelectionChange', (e)=>{
                if (!isVisible.get()) {
                    attach1(sink, topLeft);
                    attach1(sink, bottomRight);
                    isVisible.set(true);
                }
                startCell.set(e.start);
                finishCell.set(e.finish);
                e.otherCells.each((otherCells)=>{
                    tlTds.set(otherCells.upOrLeftCells);
                    brTds.set(otherCells.downOrRightCells);
                    snapTopLeft(e.start);
                    snapBottomRight(e.finish);
                });
            });
            editor.on('ResizeEditor ResizeWindow ScrollContent', ()=>{
                snapLastTopLeft();
                snapLastBottomRight();
            });
            editor.on('TableSelectionClear', ()=>{
                if (isVisible.get()) {
                    detach(topLeft);
                    detach(bottomRight);
                    isVisible.set(false);
                }
                startCell.clear();
                finishCell.clear();
            });
        }
    };
    var Logo = "<svg width=\"50px\" height=\"16px\" viewBox=\"0 0 50 16\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M10.143 0c2.608.015 5.186 2.178 5.186 5.331 0 0 .077 3.812-.084 4.87-.361 2.41-2.164 4.074-4.65 4.496-1.453.284-2.523.49-3.212.623-.373.071-.634.122-.785.152-.184.038-.997.145-1.35.145-2.732 0-5.21-2.04-5.248-5.33 0 0 0-3.514.03-4.442.093-2.4 1.758-4.342 4.926-4.963 0 0 3.875-.752 4.036-.782.368-.07.775-.1 1.15-.1Zm1.826 2.8L5.83 3.989v2.393l-2.455.475v5.968l6.137-1.189V9.243l2.456-.476V2.8ZM5.83 6.382l3.682-.713v3.574l-3.682.713V6.382Zm27.173-1.64-.084-1.066h-2.226v9.132h2.456V7.743c-.008-1.151.998-2.064 2.149-2.072 1.15-.008 1.987.92 1.995 2.072v5.065h2.455V7.359c-.015-2.18-1.657-3.929-3.837-3.913a3.993 3.993 0 0 0-2.908 1.296Zm-6.3-4.266L29.16 0v2.387l-2.456.475V.476Zm0 3.2v9.132h2.456V3.676h-2.456Zm18.179 11.787L49.11 3.676H46.58l-1.612 4.527-.46 1.382-.384-1.382-1.611-4.527H39.98l3.3 9.132L42.15 16l2.732-.537ZM22.867 9.738c0 .752.568 1.075.921 1.075.353 0 .668-.047.998-.154l.537 1.765c-.23.154-.92.537-2.225.537-1.305 0-2.655-.997-2.686-2.686a136.877 136.877 0 0 1 0-4.374H18.8V3.676h1.612v-1.98l2.455-.476v2.456h2.302V5.9h-2.302v3.837Z\"/>\n</svg>\n";
    const isHidden1 = (elm)=>elm.nodeName === 'BR' || !!elm.getAttribute('data-mce-bogus') || elm.getAttribute('data-mce-type') === 'bookmark'
    ;
    const renderElementPath = (editor, settings, providersBackstage)=>{
        var _a;
        const delimiter = (_a = settings.delimiter) !== null && _a !== void 0 ? _a : '\u203A';
        const renderElement = (name, element, index)=>Button.sketch({
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-statusbar__path-item'
                    ],
                    attributes: {
                        'data-index': index,
                        'aria-level': index + 1
                    }
                },
                components: [
                    text$1(name)
                ],
                action: (_btn)=>{
                    editor.focus();
                    editor.selection.select(element);
                    editor.nodeChanged();
                },
                buttonBehaviours: derive$1([
                    DisablingConfigs.button(providersBackstage.isDisabled),
                    receivingConfig()
                ])
            })
        ;
        const renderDivider = ()=>({
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-statusbar__path-divider'
                    ],
                    attributes: {
                        'aria-hidden': true
                    }
                },
                components: [
                    text$1(` ${delimiter} `)
                ]
            })
        ;
        const renderPathData = (data)=>foldl(data, (acc, path, index)=>{
                const element = renderElement(path.name, path.element, index);
                if (index === 0) return acc.concat([
                    element
                ]);
                else return acc.concat([
                    renderDivider(),
                    element
                ]);
            }, [])
        ;
        const updatePath = (parents)=>{
            const newPath = [];
            let i = parents.length;
            while(i-- > 0){
                const parent = parents[i];
                if (parent.nodeType === 1 && !isHidden1(parent)) {
                    const args = editor.dispatch('ResolveName', {
                        name: parent.nodeName.toLowerCase(),
                        target: parent
                    });
                    if (!args.isDefaultPrevented()) newPath.push({
                        name: args.name,
                        element: parent
                    });
                    if (args.isPropagationStopped()) break;
                }
            }
            return newPath;
        };
        return {
            dom: {
                tag: 'div',
                classes: [
                    'tox-statusbar__path'
                ],
                attributes: {
                    role: 'navigation'
                }
            },
            behaviours: derive$1([
                Keying.config({
                    mode: 'flow',
                    selector: 'div[role=button]'
                }),
                Disabling.config({
                    disabled: providersBackstage.isDisabled
                }),
                receivingConfig(),
                Tabstopping.config({}),
                Replacing.config({}),
                config1('elementPathEvents', [
                    runOnAttached((comp, _e)=>{
                        editor.shortcuts.add('alt+F11', 'focus statusbar elementpath', ()=>Keying.focusIn(comp)
                        );
                        editor.on('NodeChange', (e)=>{
                            const newPath = updatePath(e.parents);
                            const newChildren = newPath.length > 0 ? renderPathData(newPath) : [];
                            Replacing.set(comp, newChildren);
                        });
                    })
                ])
            ]),
            components: []
        };
    };
    var ResizeTypes1;
    (function(ResizeTypes) {
        ResizeTypes[ResizeTypes['None'] = 0] = 'None';
        ResizeTypes[ResizeTypes['Both'] = 1] = 'Both';
        ResizeTypes[ResizeTypes['Vertical'] = 2] = 'Vertical';
    })(ResizeTypes1 || (ResizeTypes1 = {}));
    const getDimensions = (editor, deltas, resizeType, originalHeight, originalWidth)=>{
        const dimensions = {};
        dimensions.height = calcCappedSize(originalHeight + deltas.top, getMinHeightOption(editor), getMaxHeightOption(editor));
        if (resizeType === ResizeTypes1.Both) dimensions.width = calcCappedSize(originalWidth + deltas.left, getMinWidthOption(editor), getMaxWidthOption(editor));
        return dimensions;
    };
    const resize1 = (editor, deltas, resizeType)=>{
        const container = SugarElement.fromDom(editor.getContainer());
        const dimensions = getDimensions(editor, deltas, resizeType, get$d(container), get$c(container));
        each(dimensions, (val, dim)=>set$8(container, dim, numToPx(val))
        );
        fireResizeEditor(editor);
    };
    const getResizeType = (editor)=>{
        const resize = getResize(editor);
        if (resize === false) return ResizeTypes1.None;
        else if (resize === 'both') return ResizeTypes1.Both;
        else return ResizeTypes1.Vertical;
    };
    const keyboardHandler = (editor, resizeType, x, y)=>{
        const scale = 20;
        const delta = SugarPosition(x * scale, y * scale);
        resize1(editor, delta, resizeType);
        return Optional.some(true);
    };
    const renderResizeHandler = (editor, providersBackstage)=>{
        const resizeType = getResizeType(editor);
        if (resizeType === ResizeTypes1.None) return Optional.none();
        return Optional.some(render$3('resize-handle', {
            tag: 'div',
            classes: [
                'tox-statusbar__resize-handle'
            ],
            attributes: {
                title: providersBackstage.translate('Resize')
            },
            behaviours: [
                Dragging.config({
                    mode: 'mouse',
                    repositionTarget: false,
                    onDrag: (_comp, _target, delta)=>resize1(editor, delta, resizeType)
                    ,
                    blockerClass: 'tox-blocker'
                }),
                Keying.config({
                    mode: 'special',
                    onLeft: ()=>keyboardHandler(editor, resizeType, -1, 0)
                    ,
                    onRight: ()=>keyboardHandler(editor, resizeType, 1, 0)
                    ,
                    onUp: ()=>keyboardHandler(editor, resizeType, 0, -1)
                    ,
                    onDown: ()=>keyboardHandler(editor, resizeType, 0, 1)
                }),
                Tabstopping.config({}),
                Focusing.config({})
            ]
        }, providersBackstage.icons));
    };
    const renderWordCount = (editor, providersBackstage)=>{
        const replaceCountText = (comp, count, mode)=>Replacing.set(comp, [
                text$1(providersBackstage.translate([
                    '{0} ' + mode,
                    count[mode]
                ]))
            ])
        ;
        return Button.sketch({
            dom: {
                tag: 'button',
                classes: [
                    'tox-statusbar__wordcount'
                ]
            },
            components: [],
            buttonBehaviours: derive$1([
                DisablingConfigs.button(providersBackstage.isDisabled),
                receivingConfig(),
                Tabstopping.config({}),
                Replacing.config({}),
                Representing.config({
                    store: {
                        mode: 'memory',
                        initialValue: {
                            mode: 'words',
                            count: {
                                words: 0,
                                characters: 0
                            }
                        }
                    }
                }),
                config1('wordcount-events', [
                    runOnExecute$1((comp)=>{
                        const currentVal = Representing.getValue(comp);
                        const newMode = currentVal.mode === 'words' ? 'characters' : 'words';
                        Representing.setValue(comp, {
                            mode: newMode,
                            count: currentVal.count
                        });
                        replaceCountText(comp, currentVal.count, newMode);
                    }),
                    runOnAttached((comp)=>{
                        editor.on('wordCountUpdate', (e)=>{
                            const { mode  } = Representing.getValue(comp);
                            Representing.setValue(comp, {
                                mode,
                                count: e.wordCount
                            });
                            replaceCountText(comp, e.wordCount, mode);
                        });
                    })
                ])
            ]),
            eventOrder: {
                [execute$5()]: [
                    'disabling',
                    'alloy.base.behaviour',
                    'wordcount-events'
                ]
            }
        });
    };
    const renderStatusbar = (editor, providersBackstage)=>{
        const renderBranding = ()=>{
            return {
                dom: {
                    tag: 'span',
                    classes: [
                        'tox-statusbar__branding'
                    ]
                },
                components: [
                    {
                        dom: {
                            tag: 'a',
                            attributes: {
                                'href': 'https://www.tiny.cloud/powered-by-tiny?utm_campaign=editor_referral&utm_medium=poweredby&utm_source=tinymce&utm_content=v6',
                                'rel': 'noopener',
                                'target': '_blank',
                                'aria-label': global$8.translate([
                                    'Powered by {0}',
                                    'Tiny'
                                ])
                            },
                            innerHtml: Logo.trim()
                        },
                        behaviours: derive$1([
                            Focusing.config({})
                        ])
                    }
                ]
            };
        };
        const getTextComponents = ()=>{
            const components = [];
            if (useElementPath(editor)) components.push(renderElementPath(editor, {}, providersBackstage));
            if (editor.hasPlugin('wordcount')) components.push(renderWordCount(editor, providersBackstage));
            if (useBranding(editor)) components.push(renderBranding());
            if (components.length > 0) return [
                {
                    dom: {
                        tag: 'div',
                        classes: [
                            'tox-statusbar__text-container'
                        ]
                    },
                    components
                }
            ];
            return [];
        };
        const getComponents = ()=>{
            const components = getTextComponents();
            const resizeHandler = renderResizeHandler(editor, providersBackstage);
            return components.concat(resizeHandler.toArray());
        };
        return {
            dom: {
                tag: 'div',
                classes: [
                    'tox-statusbar'
                ]
            },
            components: getComponents()
        };
    };
    const getLazyMothership = (singleton)=>singleton.get().getOrDie('UI has not been rendered')
    ;
    const setup$3 = (editor)=>{
        const isInline = editor.inline;
        const mode = isInline ? Inline : Iframe;
        const header = isStickyToolbar1(editor) ? StickyHeader : StaticHeader;
        const lazySink = value$2();
        const lazyOuterContainer = value$2();
        const lazyMothership = value$2();
        const lazyUiMothership = value$2();
        const platform = detect$1();
        const isTouch = platform.deviceType.isTouch();
        const touchPlatformClass = 'tox-platform-touch';
        const deviceClasses = isTouch ? [
            touchPlatformClass
        ] : [];
        const isToolbarBottom = isToolbarLocationBottom(editor);
        const toolbarMode = getToolbarMode(editor);
        const memAnchorBar = record1({
            dom: {
                tag: 'div',
                classes: [
                    'tox-anchorbar'
                ]
            }
        });
        const lazyHeader = ()=>lazyOuterContainer.get().bind(OuterContainer.getHeader)
        ;
        const lazySinkResult = ()=>Result.fromOption(lazySink.get(), 'UI has not been rendered')
        ;
        const lazyAnchorBar = ()=>lazyOuterContainer.get().bind((container)=>memAnchorBar.getOpt(container)
            ).getOrDie('Could not find a anchor bar element')
        ;
        const lazyToolbar = ()=>lazyOuterContainer.get().bind((container)=>OuterContainer.getToolbar(container)
            ).getOrDie('Could not find more toolbar element')
        ;
        const lazyThrobber = ()=>lazyOuterContainer.get().bind((container)=>OuterContainer.getThrobber(container)
            ).getOrDie('Could not find throbber element')
        ;
        const backstage = init$7(lazySinkResult, editor, lazyAnchorBar);
        const makeHeaderPart = ()=>{
            const verticalDirAttributes = {
                attributes: {
                    [Attribute]: isToolbarBottom ? AttributeValue1.BottomToTop : AttributeValue1.TopToBottom
                }
            };
            const partMenubar = OuterContainer.parts.menubar({
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-menubar'
                    ]
                },
                backstage,
                onEscape: ()=>{
                    editor.focus();
                }
            });
            const partToolbar = OuterContainer.parts.toolbar({
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-toolbar'
                    ]
                },
                getSink: lazySinkResult,
                providers: backstage.shared.providers,
                onEscape: ()=>{
                    editor.focus();
                },
                type: toolbarMode,
                lazyToolbar,
                lazyHeader: ()=>lazyHeader().getOrDie('Could not find header element')
                ,
                ...verticalDirAttributes
            });
            const partMultipleToolbar = OuterContainer.parts['multiple-toolbar']({
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-toolbar-overlord'
                    ]
                },
                providers: backstage.shared.providers,
                onEscape: ()=>{
                    editor.focus();
                },
                type: toolbarMode
            });
            const hasMultipleToolbar = isMultipleToolbars(editor);
            const hasToolbar = isToolbarEnabled(editor);
            const hasMenubar = isMenubarEnabled(editor);
            const getPartToolbar = ()=>{
                if (hasMultipleToolbar) return [
                    partMultipleToolbar
                ];
                else if (hasToolbar) return [
                    partToolbar
                ];
                else return [];
            };
            return OuterContainer.parts.header({
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-editor-header'
                    ],
                    ...verticalDirAttributes
                },
                components: flatten1([
                    hasMenubar ? [
                        partMenubar
                    ] : [],
                    getPartToolbar(),
                    useFixedContainer(editor) ? [] : [
                        memAnchorBar.asSpec()
                    ]
                ]),
                sticky: isStickyToolbar1(editor),
                editor,
                sharedBackstage: backstage.shared
            });
        };
        const makeSidebarDefinition = ()=>{
            const partSocket = OuterContainer.parts.socket({
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-edit-area'
                    ]
                }
            });
            const partSidebar = OuterContainer.parts.sidebar({
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-sidebar'
                    ]
                }
            });
            return {
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-sidebar-wrap'
                    ]
                },
                components: [
                    partSocket,
                    partSidebar
                ]
            };
        };
        const renderSink = ()=>{
            const uiContainer = getUiContainer(editor);
            const isGridUiContainer = eq(body1(), uiContainer) && get$e(uiContainer, 'display') === 'grid';
            const sinkSpec = {
                dom: {
                    tag: 'div',
                    classes: [
                        'tox',
                        'tox-silver-sink',
                        'tox-tinymce-aux'
                    ].concat(deviceClasses),
                    attributes: {
                        ...global$8.isRtl() ? {
                            dir: 'rtl'
                        } : {}
                    }
                },
                behaviours: derive$1([
                    Positioning.config({
                        useFixed: ()=>header.isDocked(lazyHeader)
                    })
                ])
            };
            const reactiveWidthSpec = {
                dom: {
                    styles: {
                        width: document.body.clientWidth + 'px'
                    }
                },
                events: derive$2([
                    run$1(windowResize(), (comp)=>{
                        set$8(comp.element, 'width', document.body.clientWidth + 'px');
                    })
                ])
            };
            const sink = build$1(deepMerge(sinkSpec, isGridUiContainer ? reactiveWidthSpec : {}));
            const uiMothership = takeover(sink);
            lazySink.set(sink);
            lazyUiMothership.set(uiMothership);
            return {
                sink,
                uiMothership
            };
        };
        const renderContainer = ()=>{
            const partHeader = makeHeaderPart();
            const sidebarContainer = makeSidebarDefinition();
            const partThrobber = OuterContainer.parts.throbber({
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-throbber'
                    ]
                },
                backstage
            });
            const statusbar = useStatusBar(editor) && !isInline ? Optional.some(renderStatusbar(editor, backstage.shared.providers)) : Optional.none();
            const editorComponents = flatten1([
                isToolbarBottom ? [] : [
                    partHeader
                ],
                isInline ? [] : [
                    sidebarContainer
                ],
                isToolbarBottom ? [
                    partHeader
                ] : []
            ]);
            const editorContainer = {
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-editor-container'
                    ]
                },
                components: editorComponents
            };
            const containerComponents = flatten1([
                [
                    editorContainer
                ],
                isInline ? [] : statusbar.toArray(),
                [
                    partThrobber
                ]
            ]);
            const isHidden = isDistractionFree(editor);
            const attributes = {
                role: 'application',
                ...global$8.isRtl() ? {
                    dir: 'rtl'
                } : {},
                ...isHidden ? {
                    'aria-hidden': 'true'
                } : {}
            };
            const outerContainer = build$1(OuterContainer.sketch({
                dom: {
                    tag: 'div',
                    classes: [
                        'tox',
                        'tox-tinymce'
                    ].concat(isInline ? [
                        'tox-tinymce-inline'
                    ] : []).concat(isToolbarBottom ? [
                        'tox-tinymce--toolbar-bottom'
                    ] : []).concat(deviceClasses),
                    styles: {
                        visibility: 'hidden',
                        ...isHidden ? {
                            opacity: '0',
                            border: '0'
                        } : {}
                    },
                    attributes
                },
                components: containerComponents,
                behaviours: derive$1([
                    receivingConfig(),
                    Disabling.config({
                        disableClass: 'tox-tinymce--disabled'
                    }),
                    Keying.config({
                        mode: 'cyclic',
                        selector: '.tox-menubar, .tox-toolbar, .tox-toolbar__primary, .tox-toolbar__overflow--open, .tox-sidebar__overflow--open, .tox-statusbar__path, .tox-statusbar__wordcount, .tox-statusbar__branding a, .tox-statusbar__resize-handle'
                    })
                ])
            }));
            const mothership = takeover(outerContainer);
            lazyOuterContainer.set(outerContainer);
            lazyMothership.set(mothership);
            return {
                mothership,
                outerContainer
            };
        };
        const setEditorSize = (outerContainer)=>{
            const parsedHeight = numToPx(getHeightWithFallback(editor));
            const parsedWidth = numToPx(getWidthWithFallback(editor));
            if (!editor.inline) {
                if (isValidValue('div', 'width', parsedWidth)) set$8(outerContainer.element, 'width', parsedWidth);
                if (isValidValue('div', 'height', parsedHeight)) set$8(outerContainer.element, 'height', parsedHeight);
                else set$8(outerContainer.element, 'height', '400px');
            }
            return parsedHeight;
        };
        const setupShortcutsAndCommands = (outerContainer)=>{
            editor.addShortcut('alt+F9', 'focus menubar', ()=>{
                OuterContainer.focusMenubar(outerContainer);
            });
            editor.addShortcut('alt+F10', 'focus toolbar', ()=>{
                OuterContainer.focusToolbar(outerContainer);
            });
            editor.addCommand('ToggleToolbarDrawer', ()=>{
                OuterContainer.toggleToolbarDrawer(outerContainer);
            });
            editor.addQueryStateHandler('ToggleToolbarDrawer', ()=>OuterContainer.isToolbarDrawerToggled(outerContainer)
            );
        };
        const renderUI = ()=>{
            const { mothership , outerContainer  } = renderContainer();
            const { uiMothership , sink  } = renderSink();
            map$1(getToolbarGroups(editor), (toolbarGroupButtonConfig, name)=>{
                editor.ui.registry.addGroupToolbarButton(name, toolbarGroupButtonConfig);
            });
            const { buttons , menuItems , contextToolbars , sidebars  } = editor.ui.registry.getAll();
            const toolbarOpt = getMultipleToolbarsOption(editor);
            const rawUiConfig = {
                menuItems,
                menus: getMenus1(editor),
                menubar: getMenubar(editor),
                toolbar: toolbarOpt.getOrThunk(()=>getToolbar(editor)
                ),
                allowToolbarGroups: toolbarMode === ToolbarMode$1.floating,
                buttons,
                sidebar: sidebars
            };
            setupShortcutsAndCommands(outerContainer);
            setup$b(editor, mothership, uiMothership);
            header.setup(editor, backstage.shared, lazyHeader);
            setup$6(editor, backstage);
            setup$5(editor, lazySinkResult, backstage);
            setup$8(editor);
            setup$7(editor, lazyThrobber, backstage.shared);
            register$9(editor, contextToolbars, sink, {
                backstage
            });
            setup$4(editor, sink);
            const elm = editor.getElement();
            const height = setEditorSize(outerContainer);
            const uiComponents = {
                mothership,
                uiMothership,
                outerContainer,
                sink
            };
            const args = {
                targetNode: elm,
                height
            };
            return mode.render(editor, uiComponents, rawUiConfig, backstage, args);
        };
        const getMothership = ()=>getLazyMothership(lazyMothership)
        ;
        const getUiMothership = ()=>getLazyMothership(lazyUiMothership)
        ;
        return {
            getMothership,
            getUiMothership,
            backstage,
            renderUI
        };
    };
    const describedBy = (describedElement, describeElement)=>{
        const describeId = Optional.from(get$f(describedElement, 'id')).fold(()=>{
            const id = generate$6('dialog-describe');
            set$9(describeElement, 'id', id);
            return id;
        }, identity);
        set$9(describedElement, 'aria-describedby', describeId);
    };
    const labelledBy = (labelledElement, labelElement)=>{
        const labelId = getOpt1(labelledElement, 'id').fold(()=>{
            const id = generate$6('dialog-label');
            set$9(labelElement, 'id', id);
            return id;
        }, identity);
        set$9(labelledElement, 'aria-labelledby', labelId);
    };
    const schema$2 = constant$1([
        required$1('lazySink'),
        option$3('dragBlockClass'),
        defaultedFunction('getBounds', win1),
        defaulted('useTabstopAt', always),
        defaulted('eventOrder', {}),
        field1('modalBehaviours', [
            Keying
        ]),
        onKeyboardHandler('onExecute'),
        onStrictKeyboardHandler('onEscape')
    ]);
    const basic = {
        sketch: identity
    };
    const parts$2 = constant$1([
        optional1({
            name: 'draghandle',
            overrides: (detail, spec)=>{
                return {
                    behaviours: derive$1([
                        Dragging.config({
                            mode: 'mouse',
                            getTarget: (handle)=>{
                                return ancestor1(handle, '[role="dialog"]').getOr(handle);
                            },
                            blockerClass: detail.dragBlockClass.getOrDie(new Error('The drag blocker class was not specified for a dialog with a drag handle: \n' + JSON.stringify(spec, null, 2)).message),
                            getBounds: detail.getDragBounds
                        })
                    ])
                };
            }
        }),
        required1({
            schema: [
                required$1('dom')
            ],
            name: 'title'
        }),
        required1({
            factory: basic,
            schema: [
                required$1('dom')
            ],
            name: 'close'
        }),
        required1({
            factory: basic,
            schema: [
                required$1('dom')
            ],
            name: 'body'
        }),
        optional1({
            factory: basic,
            schema: [
                required$1('dom')
            ],
            name: 'footer'
        }),
        external({
            factory: {
                sketch: (spec, detail)=>({
                        ...spec,
                        dom: detail.dom,
                        components: detail.components
                    })
            },
            schema: [
                defaulted('dom', {
                    tag: 'div',
                    styles: {
                        position: 'fixed',
                        left: '0px',
                        top: '0px',
                        right: '0px',
                        bottom: '0px'
                    }
                }),
                defaulted('components', [])
            ],
            name: 'blocker'
        })
    ]);
    const factory$4 = (detail, components, spec, externals)=>{
        const dialogComp = value$2();
        const showDialog = (dialog)=>{
            dialogComp.set(dialog);
            const sink = detail.lazySink(dialog).getOrDie();
            const externalBlocker = externals.blocker();
            const blocker = sink.getSystem().build({
                ...externalBlocker,
                components: externalBlocker.components.concat([
                    premade(dialog)
                ]),
                behaviours: derive$1([
                    Focusing.config({}),
                    config1('dialog-blocker-events', [
                        runOnSource(focusin(), ()=>{
                            Keying.focusIn(dialog);
                        })
                    ])
                ])
            });
            attach1(sink, blocker);
            Keying.focusIn(dialog);
        };
        const hideDialog = (dialog)=>{
            dialogComp.clear();
            parent1(dialog.element).each((blockerDom)=>{
                dialog.getSystem().getByDom(blockerDom).each((blocker)=>{
                    detach(blocker);
                });
            });
        };
        const getDialogBody = (dialog)=>getPartOrDie(dialog, detail, 'body')
        ;
        const getDialogFooter = (dialog)=>getPartOrDie(dialog, detail, 'footer')
        ;
        const setBusy = (dialog, getBusySpec)=>{
            Blocking.block(dialog, getBusySpec);
        };
        const setIdle = (dialog)=>{
            Blocking.unblock(dialog);
        };
        const modalEventsId = generate$6('modal-events');
        const eventOrder = {
            ...detail.eventOrder,
            [attachedToDom()]: [
                modalEventsId
            ].concat(detail.eventOrder['alloy.system.attached'] || [])
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            apis: {
                show: showDialog,
                hide: hideDialog,
                getBody: getDialogBody,
                getFooter: getDialogFooter,
                setIdle,
                setBusy
            },
            eventOrder,
            domModification: {
                attributes: {
                    'role': 'dialog',
                    'aria-modal': 'true'
                }
            },
            behaviours: augment(detail.modalBehaviours, [
                Replacing.config({}),
                Keying.config({
                    mode: 'cyclic',
                    onEnter: detail.onExecute,
                    onEscape: detail.onEscape,
                    useTabstopAt: detail.useTabstopAt
                }),
                Blocking.config({
                    getRoot: dialogComp.get
                }),
                config1(modalEventsId, [
                    runOnAttached((c)=>{
                        labelledBy(c.element, getPartOrDie(c, detail, 'title').element);
                        describedBy(c.element, getPartOrDie(c, detail, 'body').element);
                    })
                ])
            ])
        };
    };
    const ModalDialog = composite({
        name: 'ModalDialog',
        configFields: schema$2(),
        partFields: parts$2(),
        factory: factory$4,
        apis: {
            show: (apis, dialog)=>{
                apis.show(dialog);
            },
            hide: (apis, dialog)=>{
                apis.hide(dialog);
            },
            getBody: (apis, dialog)=>apis.getBody(dialog)
            ,
            getFooter: (apis, dialog)=>apis.getFooter(dialog)
            ,
            setBusy: (apis, dialog, getBusySpec)=>{
                apis.setBusy(dialog, getBusySpec);
            },
            setIdle: (apis, dialog)=>{
                apis.setIdle(dialog);
            }
        }
    });
    const dialogToggleMenuItemSchema = objOf([
        type1,
        name$1
    ].concat(commonMenuItemFields));
    const dialogToggleMenuItemDataProcessor = boolean;
    const baseFooterButtonFields = [
        generatedName('button'),
        optionalIcon,
        defaultedStringEnum('align', 'end', [
            'start',
            'end'
        ]),
        primary1,
        enabled,
        optionStringEnum('buttonType', [
            'primary',
            'secondary'
        ])
    ];
    const dialogFooterButtonFields = [
        ...baseFooterButtonFields,
        text1
    ];
    const normalFooterButtonFields = [
        requiredStringEnum('type', [
            'submit',
            'cancel',
            'custom'
        ]),
        ...dialogFooterButtonFields
    ];
    const menuFooterButtonFields = [
        requiredStringEnum('type', [
            'menu'
        ]),
        optionalText,
        optionalTooltip,
        optionalIcon,
        requiredArrayOf('items', dialogToggleMenuItemSchema),
        ...baseFooterButtonFields
    ];
    const dialogFooterButtonSchema = choose$1('type', {
        submit: normalFooterButtonFields,
        cancel: normalFooterButtonFields,
        custom: normalFooterButtonFields,
        menu: menuFooterButtonFields
    });
    const alertBannerFields = [
        type1,
        text1,
        requiredStringEnum('level', [
            'info',
            'warn',
            'error',
            'success'
        ]),
        icon1,
        defaulted('url', '')
    ];
    const alertBannerSchema = objOf(alertBannerFields);
    const createBarFields = (itemsField)=>[
            type1,
            itemsField
        ]
    ;
    const buttonFields = [
        type1,
        text1,
        enabled,
        generatedName('button'),
        optionalIcon,
        borderless,
        optionStringEnum('buttonType', [
            'primary',
            'secondary',
            'toolbar'
        ]),
        primary1
    ];
    const buttonSchema = objOf(buttonFields);
    const formComponentFields = [
        type1,
        name$1
    ];
    const formComponentWithLabelFields = formComponentFields.concat([
        optionalLabel
    ]);
    const checkboxFields = formComponentFields.concat([
        label1,
        enabled
    ]);
    const checkboxSchema = objOf(checkboxFields);
    const checkboxDataProcessor = boolean;
    const collectionFields = formComponentWithLabelFields.concat([
        defaultedColumns('auto')
    ]);
    const collectionSchema = objOf(collectionFields);
    const collectionDataProcessor = arrOfObj([
        value$1,
        text1,
        icon1
    ]);
    const colorInputFields = formComponentWithLabelFields;
    const colorInputSchema = objOf(colorInputFields);
    const colorInputDataProcessor = string;
    const colorPickerFields = formComponentWithLabelFields;
    const colorPickerSchema = objOf(colorPickerFields);
    const colorPickerDataProcessor = string;
    const customEditorFields = formComponentFields.concat([
        defaultedString('tag', 'textarea'),
        requiredString('scriptId'),
        requiredString('scriptUrl'),
        defaultedPostMsg('settings', undefined)
    ]);
    const customEditorFieldsOld = formComponentFields.concat([
        defaultedString('tag', 'textarea'),
        requiredFunction('init')
    ]);
    const customEditorSchema = valueOf((v)=>asRaw('customeditor.old', objOfOnly(customEditorFieldsOld), v).orThunk(()=>asRaw('customeditor.new', objOfOnly(customEditorFields), v)
        )
    );
    const customEditorDataProcessor = string;
    const dropZoneFields = formComponentWithLabelFields;
    const dropZoneSchema = objOf(dropZoneFields);
    const dropZoneDataProcessor = arrOfVal();
    const createGridFields = (itemsField)=>[
            type1,
            requiredNumber('columns'),
            itemsField
        ]
    ;
    const htmlPanelFields = [
        type1,
        requiredString('html'),
        defaultedStringEnum('presets', 'presentation', [
            'presentation',
            'document'
        ])
    ];
    const htmlPanelSchema = objOf(htmlPanelFields);
    const iframeFields = formComponentWithLabelFields.concat([
        defaultedBoolean('sandboxed', true)
    ]);
    const iframeSchema = objOf(iframeFields);
    const iframeDataProcessor = string;
    const imagePreviewSchema = objOf(formComponentFields.concat([
        optionString('height')
    ]));
    const imagePreviewDataProcessor = objOf([
        requiredString('url'),
        optionNumber('zoom'),
        optionNumber('cachedWidth'),
        optionNumber('cachedHeight')
    ]);
    const inputFields = formComponentWithLabelFields.concat([
        optionString('inputMode'),
        optionString('placeholder'),
        defaultedBoolean('maximized', false),
        enabled
    ]);
    const inputSchema = objOf(inputFields);
    const inputDataProcessor = string;
    const createLabelFields = (itemsField)=>[
            type1,
            label1,
            itemsField
        ]
    ;
    const listBoxSingleItemFields = [
        text1,
        value$1
    ];
    const listBoxNestedItemFields = [
        text1,
        requiredArrayOf('items', thunkOf('items', ()=>listBoxItemSchema
        ))
    ];
    const listBoxItemSchema = oneOf([
        objOf(listBoxSingleItemFields),
        objOf(listBoxNestedItemFields)
    ]);
    const listBoxFields = formComponentWithLabelFields.concat([
        requiredArrayOf('items', listBoxItemSchema),
        enabled
    ]);
    const listBoxSchema = objOf(listBoxFields);
    const listBoxDataProcessor = string;
    const selectBoxFields = formComponentWithLabelFields.concat([
        requiredArrayOfObj('items', [
            text1,
            value$1
        ]),
        defaultedNumber('size', 1),
        enabled
    ]);
    const selectBoxSchema = objOf(selectBoxFields);
    const selectBoxDataProcessor = string;
    const sizeInputFields = formComponentWithLabelFields.concat([
        defaultedBoolean('constrain', true),
        enabled
    ]);
    const sizeInputSchema = objOf(sizeInputFields);
    const sizeInputDataProcessor = objOf([
        requiredString('width'),
        requiredString('height')
    ]);
    const sliderFields = formComponentFields.concat([
        label1,
        defaultedNumber('min', 0),
        defaultedNumber('max', 0)
    ]);
    const sliderSchema = objOf(sliderFields);
    const sliderInputDataProcessor = number1;
    const tableFields = [
        type1,
        requiredArrayOf('header', string),
        requiredArrayOf('cells', arrOf(string))
    ];
    const tableSchema = objOf(tableFields);
    const textAreaFields = formComponentWithLabelFields.concat([
        optionString('placeholder'),
        defaultedBoolean('maximized', false),
        enabled
    ]);
    const textAreaSchema = objOf(textAreaFields);
    const textAreaDataProcessor = string;
    const urlInputFields = formComponentWithLabelFields.concat([
        defaultedStringEnum('filetype', 'file', [
            'image',
            'media',
            'file'
        ]),
        enabled
    ]);
    const urlInputSchema = objOf(urlInputFields);
    const urlInputDataProcessor = objOf([
        value$1,
        defaultedMeta
    ]);
    const createItemsField = (name)=>field$1('items', 'items', required$2(), arrOf(valueOf((v)=>asRaw(`Checking item of ${name}`, itemSchema, v).fold((sErr)=>Result.error(formatError(sErr))
            , (passValue)=>Result.value(passValue)
            )
        )))
    ;
    const itemSchema = valueThunk1(()=>choose$2('type', {
            alertbanner: alertBannerSchema,
            bar: objOf(createBarFields(createItemsField('bar'))),
            button: buttonSchema,
            checkbox: checkboxSchema,
            colorinput: colorInputSchema,
            colorpicker: colorPickerSchema,
            dropzone: dropZoneSchema,
            grid: objOf(createGridFields(createItemsField('grid'))),
            iframe: iframeSchema,
            input: inputSchema,
            listbox: listBoxSchema,
            selectbox: selectBoxSchema,
            sizeinput: sizeInputSchema,
            slider: sliderSchema,
            textarea: textAreaSchema,
            urlinput: urlInputSchema,
            customeditor: customEditorSchema,
            htmlpanel: htmlPanelSchema,
            imagepreview: imagePreviewSchema,
            collection: collectionSchema,
            label: objOf(createLabelFields(createItemsField('label'))),
            table: tableSchema,
            panel: panelSchema
        })
    );
    const panelFields = [
        type1,
        defaulted('classes', []),
        requiredArrayOf('items', itemSchema)
    ];
    const panelSchema = objOf(panelFields);
    const tabFields = [
        generatedName('tab'),
        title1,
        requiredArrayOf('items', itemSchema)
    ];
    const tabPanelFields = [
        type1,
        requiredArrayOfObj('tabs', tabFields)
    ];
    const tabPanelSchema = objOf(tabPanelFields);
    const dialogButtonFields = dialogFooterButtonFields;
    const dialogButtonSchema = dialogFooterButtonSchema;
    const dialogSchema = objOf([
        requiredString('title'),
        requiredOf('body', choose$2('type', {
            panel: panelSchema,
            tabpanel: tabPanelSchema
        })),
        defaultedString('size', 'normal'),
        requiredArrayOf('buttons', dialogButtonSchema),
        defaulted('initialData', {}),
        defaultedFunction('onAction', noop),
        defaultedFunction('onChange', noop),
        defaultedFunction('onSubmit', noop),
        defaultedFunction('onClose', noop),
        defaultedFunction('onCancel', noop),
        defaultedFunction('onTabChange', noop)
    ]);
    const createDialog = (spec)=>asRaw('dialog', dialogSchema, spec)
    ;
    const urlDialogButtonSchema = objOf([
        requiredStringEnum('type', [
            'cancel',
            'custom'
        ]),
        ...dialogButtonFields
    ]);
    const urlDialogSchema = objOf([
        requiredString('title'),
        requiredString('url'),
        optionNumber('height'),
        optionNumber('width'),
        optionArrayOf('buttons', urlDialogButtonSchema),
        defaultedFunction('onAction', noop),
        defaultedFunction('onCancel', noop),
        defaultedFunction('onClose', noop),
        defaultedFunction('onMessage', noop)
    ]);
    const createUrlDialog = (spec)=>asRaw('dialog', urlDialogSchema, spec)
    ;
    const getAllObjects = (obj)=>{
        if (isObject(obj)) return [
            obj
        ].concat(bind$3(values1(obj), getAllObjects));
        else if (isArray(obj)) return bind$3(obj, getAllObjects);
        else return [];
    };
    const isNamedItem = (obj)=>isString(obj.type) && isString(obj.name)
    ;
    const dataProcessors = {
        checkbox: checkboxDataProcessor,
        colorinput: colorInputDataProcessor,
        colorpicker: colorPickerDataProcessor,
        dropzone: dropZoneDataProcessor,
        input: inputDataProcessor,
        iframe: iframeDataProcessor,
        imagepreview: imagePreviewDataProcessor,
        selectbox: selectBoxDataProcessor,
        sizeinput: sizeInputDataProcessor,
        slider: sliderInputDataProcessor,
        listbox: listBoxDataProcessor,
        size: sizeInputDataProcessor,
        textarea: textAreaDataProcessor,
        urlinput: urlInputDataProcessor,
        customeditor: customEditorDataProcessor,
        collection: collectionDataProcessor,
        togglemenuitem: dialogToggleMenuItemDataProcessor
    };
    const getDataProcessor = (item)=>Optional.from(dataProcessors[item.type])
    ;
    const getNamedItems = (structure)=>filter$2(getAllObjects(structure), isNamedItem)
    ;
    const createDataValidator = (structure)=>{
        const namedItems = getNamedItems(structure);
        const fields = bind$3(namedItems, (item)=>getDataProcessor(item).fold(()=>[]
            , (schema)=>[
                    requiredOf(item.name, schema)
                ]
            )
        );
        return objOf(fields);
    };
    const extract1 = (structure)=>{
        const internalDialog = getOrDie(createDialog(structure));
        const dataValidator = createDataValidator(structure);
        const initialData = structure.initialData;
        return {
            internalDialog,
            dataValidator,
            initialData
        };
    };
    const DialogManager = {
        open: (factory, structure)=>{
            const extraction = extract1(structure);
            return factory(extraction.internalDialog, extraction.initialData, extraction.dataValidator);
        },
        openUrl: (factory, structure)=>{
            const internalDialog = getOrDie(createUrlDialog(structure));
            return factory(internalDialog);
        },
        redial: (structure)=>extract1(structure)
    };
    const toValidValues = (values)=>{
        const errors = [];
        const result = {};
        each(values, (value, name)=>{
            value.fold(()=>{
                errors.push(name);
            }, (v)=>{
                result[name] = v;
            });
        });
        return errors.length > 0 ? Result.error(errors) : Result.value(result);
    };
    const renderBodyPanel = (spec, dialogData, backstage)=>{
        const memForm = record1(Form.sketch((parts)=>({
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-form'
                    ].concat(spec.classes)
                },
                components: map$2(spec.items, (item)=>interpretInForm(parts, item, dialogData, backstage)
                )
            })
        ));
        return {
            dom: {
                tag: 'div',
                classes: [
                    'tox-dialog__body'
                ]
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: [
                            'tox-dialog__body-content'
                        ]
                    },
                    components: [
                        memForm.asSpec()
                    ]
                }
            ],
            behaviours: derive$1([
                Keying.config({
                    mode: 'acyclic',
                    useTabstopAt: not(isPseudoStop)
                }),
                ComposingConfigs.memento(memForm),
                RepresentingConfigs.memento(memForm, {
                    postprocess: (formValue)=>toValidValues(formValue).fold((err)=>{
                            console.error(err);
                            return {};
                        }, identity)
                })
            ])
        };
    };
    const factory$3 = (detail, _spec)=>({
            uid: detail.uid,
            dom: detail.dom,
            components: detail.components,
            events: events$a(detail.action),
            behaviours: augment(detail.tabButtonBehaviours, [
                Focusing.config({}),
                Keying.config({
                    mode: 'execution',
                    useSpace: true,
                    useEnter: true
                }),
                Representing.config({
                    store: {
                        mode: 'memory',
                        initialValue: detail.value
                    }
                })
            ]),
            domModification: detail.domModification
        })
    ;
    const TabButton = single({
        name: 'TabButton',
        configFields: [
            defaulted('uid', undefined),
            required$1('value'),
            field$1('dom', 'dom', mergeWithThunk(()=>({
                    attributes: {
                        'role': 'tab',
                        'id': generate$6('aria'),
                        'aria-selected': 'false'
                    }
                })
            ), anyValue()),
            option$3('action'),
            defaulted('domModification', {}),
            field1('tabButtonBehaviours', [
                Focusing,
                Keying,
                Representing
            ]),
            required$1('view')
        ],
        factory: factory$3
    });
    const schema$1 = constant$1([
        required$1('tabs'),
        required$1('dom'),
        defaulted('clickToDismiss', false),
        field1('tabbarBehaviours', [
            Highlighting,
            Keying
        ]),
        markers$1([
            'tabClass',
            'selectedClass'
        ])
    ]);
    const tabsPart = group1({
        factory: TabButton,
        name: 'tabs',
        unit: 'tab',
        overrides: (barDetail)=>{
            const dismissTab$1 = (tabbar, button)=>{
                Highlighting.dehighlight(tabbar, button);
                emitWith(tabbar, dismissTab(), {
                    tabbar,
                    button
                });
            };
            const changeTab$1 = (tabbar, button)=>{
                Highlighting.highlight(tabbar, button);
                emitWith(tabbar, changeTab(), {
                    tabbar,
                    button
                });
            };
            return {
                action: (button)=>{
                    const tabbar = button.getSystem().getByUid(barDetail.uid).getOrDie();
                    const activeButton = Highlighting.isHighlighted(tabbar, button);
                    const response = (()=>{
                        if (activeButton && barDetail.clickToDismiss) return dismissTab$1;
                        else if (!activeButton) return changeTab$1;
                        else return noop;
                    })();
                    response(tabbar, button);
                },
                domModification: {
                    classes: [
                        barDetail.markers.tabClass
                    ]
                }
            };
        }
    });
    const parts$1 = constant$1([
        tabsPart
    ]);
    const factory$2 = (detail, components, _spec, _externals)=>({
            'uid': detail.uid,
            'dom': detail.dom,
            components,
            'debug.sketcher': 'Tabbar',
            'domModification': {
                attributes: {
                    role: 'tablist'
                }
            },
            'behaviours': augment(detail.tabbarBehaviours, [
                Highlighting.config({
                    highlightClass: detail.markers.selectedClass,
                    itemClass: detail.markers.tabClass,
                    onHighlight: (tabbar, tab)=>{
                        set$9(tab.element, 'aria-selected', 'true');
                    },
                    onDehighlight: (tabbar, tab)=>{
                        set$9(tab.element, 'aria-selected', 'false');
                    }
                }),
                Keying.config({
                    mode: 'flow',
                    getInitial: (tabbar)=>{
                        return Highlighting.getHighlighted(tabbar).map((tab)=>tab.element
                        );
                    },
                    selector: '.' + detail.markers.tabClass,
                    executeOnMove: true
                })
            ])
        })
    ;
    const Tabbar = composite({
        name: 'Tabbar',
        configFields: schema$1(),
        partFields: parts$1(),
        factory: factory$2
    });
    const factory$1 = (detail, _spec)=>({
            uid: detail.uid,
            dom: detail.dom,
            behaviours: augment(detail.tabviewBehaviours, [
                Replacing.config({})
            ]),
            domModification: {
                attributes: {
                    role: 'tabpanel'
                }
            }
        })
    ;
    const Tabview = single({
        name: 'Tabview',
        configFields: [
            field1('tabviewBehaviours', [
                Replacing
            ])
        ],
        factory: factory$1
    });
    const schema1 = constant$1([
        defaulted('selectFirst', true),
        onHandler('onChangeTab'),
        onHandler('onDismissTab'),
        defaulted('tabs', []),
        field1('tabSectionBehaviours', [])
    ]);
    const barPart = required1({
        factory: Tabbar,
        schema: [
            required$1('dom'),
            requiredObjOf('markers', [
                required$1('tabClass'),
                required$1('selectedClass')
            ])
        ],
        name: 'tabbar',
        defaults: (detail)=>{
            return {
                tabs: detail.tabs
            };
        }
    });
    const viewPart = required1({
        factory: Tabview,
        name: 'tabview'
    });
    const parts1 = constant$1([
        barPart,
        viewPart
    ]);
    const factory1 = (detail, components, _spec, _externals)=>{
        const changeTab$1 = (button)=>{
            const tabValue = Representing.getValue(button);
            getPart(button, detail, 'tabview').each((tabview)=>{
                const tabWithValue = find$5(detail.tabs, (t)=>t.value === tabValue
                );
                tabWithValue.each((tabData)=>{
                    const panel = tabData.view();
                    getOpt1(button.element, 'id').each((id)=>{
                        set$9(tabview.element, 'aria-labelledby', id);
                    });
                    Replacing.set(tabview, panel);
                    detail.onChangeTab(tabview, button, panel);
                });
            });
        };
        const changeTabBy = (section, byPred)=>{
            getPart(section, detail, 'tabbar').each((tabbar)=>{
                byPred(tabbar).each(emitExecute1);
            });
        };
        return {
            uid: detail.uid,
            dom: detail.dom,
            components,
            behaviours: get$3(detail.tabSectionBehaviours),
            events: derive$2(flatten1([
                detail.selectFirst ? [
                    runOnAttached((section, _simulatedEvent)=>{
                        changeTabBy(section, Highlighting.getFirst);
                    })
                ] : [],
                [
                    run$1(changeTab(), (section, simulatedEvent)=>{
                        const button = simulatedEvent.event.button;
                        changeTab$1(button);
                    }),
                    run$1(dismissTab(), (section, simulatedEvent)=>{
                        const button = simulatedEvent.event.button;
                        detail.onDismissTab(section, button);
                    })
                ]
            ])),
            apis: {
                getViewItems: (section)=>{
                    return getPart(section, detail, 'tabview').map((tabview)=>Replacing.contents(tabview)
                    ).getOr([]);
                },
                showTab: (section, tabKey)=>{
                    const getTabIfNotActive = (tabbar)=>{
                        const candidates = Highlighting.getCandidates(tabbar);
                        const optTab = find$5(candidates, (c)=>Representing.getValue(c) === tabKey
                        );
                        return optTab.filter((tab)=>!Highlighting.isHighlighted(tabbar, tab)
                        );
                    };
                    changeTabBy(section, getTabIfNotActive);
                }
            }
        };
    };
    const TabSection = composite({
        name: 'TabSection',
        configFields: schema1(),
        partFields: parts1(),
        factory: factory1,
        apis: {
            getViewItems: (apis, component)=>apis.getViewItems(component)
            ,
            showTab: (apis, component, tabKey)=>{
                apis.showTab(component, tabKey);
            }
        }
    });
    const measureHeights = (allTabs, tabview, tabviewComp)=>map$2(allTabs, (_tab, i)=>{
            Replacing.set(tabviewComp, allTabs[i].view());
            const rect = tabview.dom.getBoundingClientRect();
            Replacing.set(tabviewComp, []);
            return rect.height;
        })
    ;
    const getMaxHeight = (heights)=>head(sort(heights, (a, b)=>{
            if (a > b) return -1;
            else if (a < b) return 1;
            else return 0;
        }))
    ;
    const getMaxTabviewHeight = (dialog, tabview, tablist)=>{
        const documentElement$1 = documentElement(dialog).dom;
        const rootElm = ancestor1(dialog, '.tox-dialog-wrap').getOr(dialog);
        const isFixed = get$e(rootElm, 'position') === 'fixed';
        let maxHeight;
        if (isFixed) maxHeight = Math.max(documentElement$1.clientHeight, window.innerHeight);
        else maxHeight = Math.max(documentElement$1.offsetHeight, documentElement$1.scrollHeight);
        const tabviewHeight = get$d(tabview);
        const isTabListBeside = tabview.dom.offsetLeft >= tablist.dom.offsetLeft + get$c(tablist);
        const currentTabHeight = isTabListBeside ? Math.max(get$d(tablist), tabviewHeight) : tabviewHeight;
        const dialogTopMargin = parseInt(get$e(dialog, 'margin-top'), 10) || 0;
        const dialogBottomMargin = parseInt(get$e(dialog, 'margin-bottom'), 10) || 0;
        const dialogHeight = get$d(dialog) + dialogTopMargin + dialogBottomMargin;
        const chromeHeight = dialogHeight - currentTabHeight;
        return maxHeight - chromeHeight;
    };
    const showTab1 = (allTabs, comp)=>{
        head(allTabs).each((tab)=>TabSection.showTab(comp, tab.value)
        );
    };
    const setTabviewHeight = (tabview, height)=>{
        set$8(tabview, 'height', height + 'px');
        set$8(tabview, 'flex-basis', height + 'px');
    };
    const updateTabviewHeight = (dialogBody, tabview, maxTabHeight)=>{
        ancestor1(dialogBody, '[role="dialog"]').each((dialog)=>{
            descendant(dialog, '[role="tablist"]').each((tablist)=>{
                maxTabHeight.get().map((height)=>{
                    set$8(tabview, 'height', '0');
                    set$8(tabview, 'flex-basis', '0');
                    return Math.min(height, getMaxTabviewHeight(dialog, tabview, tablist));
                }).each((height)=>{
                    setTabviewHeight(tabview, height);
                });
            });
        });
    };
    const getTabview = (dialog)=>descendant(dialog, '[role="tabpanel"]')
    ;
    const setMode = (allTabs)=>{
        const smartTabHeight = (()=>{
            const maxTabHeight = value$2();
            const extraEvents = [
                runOnAttached((comp)=>{
                    const dialog = comp.element;
                    getTabview(dialog).each((tabview)=>{
                        set$8(tabview, 'visibility', 'hidden');
                        comp.getSystem().getByDom(tabview).toOptional().each((tabviewComp)=>{
                            const heights = measureHeights(allTabs, tabview, tabviewComp);
                            const maxTabHeightOpt = getMaxHeight(heights);
                            maxTabHeightOpt.fold(maxTabHeight.clear, maxTabHeight.set);
                        });
                        updateTabviewHeight(dialog, tabview, maxTabHeight);
                        remove$6(tabview, 'visibility');
                        showTab1(allTabs, comp);
                        requestAnimationFrame(()=>{
                            updateTabviewHeight(dialog, tabview, maxTabHeight);
                        });
                    });
                }),
                run$1(windowResize(), (comp)=>{
                    const dialog = comp.element;
                    getTabview(dialog).each((tabview)=>{
                        updateTabviewHeight(dialog, tabview, maxTabHeight);
                    });
                }),
                run$1(formResizeEvent, (comp, _se)=>{
                    const dialog = comp.element;
                    getTabview(dialog).each((tabview)=>{
                        const oldFocus = active$1(getRootNode(tabview));
                        set$8(tabview, 'visibility', 'hidden');
                        const oldHeight = getRaw(tabview, 'height').map((h)=>parseInt(h, 10)
                        );
                        remove$6(tabview, 'height');
                        remove$6(tabview, 'flex-basis');
                        const newHeight = tabview.dom.getBoundingClientRect().height;
                        const hasGrown = oldHeight.forall((h)=>newHeight > h
                        );
                        if (hasGrown) {
                            maxTabHeight.set(newHeight);
                            updateTabviewHeight(dialog, tabview, maxTabHeight);
                        } else oldHeight.each((h)=>{
                            setTabviewHeight(tabview, h);
                        });
                        remove$6(tabview, 'visibility');
                        oldFocus.each(focus$3);
                    });
                })
            ];
            const selectFirst = false;
            return {
                extraEvents,
                selectFirst
            };
        })();
        const naiveTabHeight = (()=>{
            const extraEvents = [];
            const selectFirst = true;
            return {
                extraEvents,
                selectFirst
            };
        })();
        return {
            smartTabHeight,
            naiveTabHeight
        };
    };
    const SendDataToSectionChannel = 'send-data-to-section';
    const SendDataToViewChannel = 'send-data-to-view';
    const renderTabPanel = (spec, dialogData, backstage)=>{
        const storedValue = Cell({});
        const updateDataWithForm = (form)=>{
            const formData = Representing.getValue(form);
            const validData = toValidValues(formData).getOr({});
            const currentData = storedValue.get();
            const newData = deepMerge(currentData, validData);
            storedValue.set(newData);
        };
        const setDataOnForm = (form)=>{
            const tabData = storedValue.get();
            Representing.setValue(form, tabData);
        };
        const oldTab = Cell(null);
        const allTabs = map$2(spec.tabs, (tab)=>{
            return {
                value: tab.name,
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-dialog__body-nav-item'
                    ]
                },
                components: [
                    text$1(backstage.shared.providers.translate(tab.title))
                ],
                view: ()=>{
                    return [
                        Form.sketch((parts)=>({
                                dom: {
                                    tag: 'div',
                                    classes: [
                                        'tox-form'
                                    ]
                                },
                                components: map$2(tab.items, (item)=>interpretInForm(parts, item, dialogData, backstage)
                                ),
                                formBehaviours: derive$1([
                                    Keying.config({
                                        mode: 'acyclic',
                                        useTabstopAt: not(isPseudoStop)
                                    }),
                                    config1('TabView.form.events', [
                                        runOnAttached(setDataOnForm),
                                        runOnDetached(updateDataWithForm)
                                    ]),
                                    Receiving.config({
                                        channels: wrapAll([
                                            {
                                                key: SendDataToSectionChannel,
                                                value: {
                                                    onReceive: updateDataWithForm
                                                }
                                            },
                                            {
                                                key: SendDataToViewChannel,
                                                value: {
                                                    onReceive: setDataOnForm
                                                }
                                            }
                                        ])
                                    })
                                ])
                            })
                        )
                    ];
                }
            };
        });
        const tabMode = setMode(allTabs).smartTabHeight;
        return TabSection.sketch({
            dom: {
                tag: 'div',
                classes: [
                    'tox-dialog__body'
                ]
            },
            onChangeTab: (section, button, _viewItems)=>{
                const name = Representing.getValue(button);
                emitWith(section, formTabChangeEvent, {
                    name,
                    oldName: oldTab.get()
                });
                oldTab.set(name);
            },
            tabs: allTabs,
            components: [
                TabSection.parts.tabbar({
                    dom: {
                        tag: 'div',
                        classes: [
                            'tox-dialog__body-nav'
                        ]
                    },
                    components: [
                        Tabbar.parts.tabs({})
                    ],
                    markers: {
                        tabClass: 'tox-tab',
                        selectedClass: 'tox-dialog__body-nav-item--active'
                    },
                    tabbarBehaviours: derive$1([
                        Tabstopping.config({})
                    ])
                }),
                TabSection.parts.tabview({
                    dom: {
                        tag: 'div',
                        classes: [
                            'tox-dialog__body-content'
                        ]
                    }
                })
            ],
            selectFirst: tabMode.selectFirst,
            tabSectionBehaviours: derive$1([
                config1('tabpanel', tabMode.extraEvents),
                Keying.config({
                    mode: 'acyclic'
                }),
                Composing.config({
                    find: (comp)=>head(TabSection.getViewItems(comp))
                }),
                RepresentingConfigs.withComp(Optional.none(), (tsection)=>{
                    tsection.getSystem().broadcastOn([
                        SendDataToSectionChannel
                    ], {});
                    return storedValue.get();
                }, (tsection, value)=>{
                    storedValue.set(value);
                    tsection.getSystem().broadcastOn([
                        SendDataToViewChannel
                    ], {});
                })
            ])
        });
    };
    const dialogChannel = generate$6('update-dialog');
    const titleChannel = generate$6('update-title');
    const bodyChannel = generate$6('update-body');
    const footerChannel = generate$6('update-footer');
    const bodySendMessageChannel = generate$6('body-send-message');
    const renderBody = (spec, dialogId, contentId, backstage, ariaAttrs)=>{
        const renderComponents = (incoming)=>{
            const body = incoming.body;
            switch(body.type){
                case 'tabpanel':
                    return [
                        renderTabPanel(body, incoming.initialData, backstage)
                    ];
                default:
                    return [
                        renderBodyPanel(body, incoming.initialData, backstage)
                    ];
            }
        };
        const updateState = (_comp, incoming)=>Optional.some({
                isTabPanel: ()=>incoming.body.type === 'tabpanel'
            })
        ;
        const ariaAttributes = {
            'aria-live': 'polite'
        };
        return {
            dom: {
                tag: 'div',
                classes: [
                    'tox-dialog__content-js'
                ],
                attributes: {
                    ...contentId.map((x)=>({
                            id: x
                        })
                    ).getOr({}),
                    ...ariaAttrs ? ariaAttributes : {}
                }
            },
            components: [],
            behaviours: derive$1([
                ComposingConfigs.childAt(0),
                Reflecting.config({
                    channel: `${bodyChannel}-${dialogId}`,
                    updateState,
                    renderComponents,
                    initialData: spec
                })
            ])
        };
    };
    const renderInlineBody = (spec, dialogId, contentId, backstage, ariaAttrs)=>renderBody(spec, dialogId, Optional.some(contentId), backstage, ariaAttrs)
    ;
    const renderModalBody = (spec, dialogId, backstage)=>{
        const bodySpec = renderBody(spec, dialogId, Optional.none(), backstage, false);
        return ModalDialog.parts.body(bodySpec);
    };
    const renderIframeBody = (spec)=>{
        const bodySpec = {
            dom: {
                tag: 'div',
                classes: [
                    'tox-dialog__content-js'
                ]
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: [
                            'tox-dialog__body-iframe'
                        ]
                    },
                    components: [
                        craft({
                            dom: {
                                tag: 'iframe',
                                attributes: {
                                    src: spec.url
                                }
                            },
                            behaviours: derive$1([
                                Tabstopping.config({}),
                                Focusing.config({})
                            ])
                        })
                    ]
                }
            ],
            behaviours: derive$1([
                Keying.config({
                    mode: 'acyclic',
                    useTabstopAt: not(isPseudoStop)
                })
            ])
        };
        return ModalDialog.parts.body(bodySpec);
    };
    const isTouch1 = global$5.deviceType.isTouch();
    const hiddenHeader = (title, close)=>({
            dom: {
                tag: 'div',
                styles: {
                    display: 'none'
                },
                classes: [
                    'tox-dialog__header'
                ]
            },
            components: [
                title,
                close
            ]
        })
    ;
    const pClose1 = (onClose, providersBackstage)=>ModalDialog.parts.close(Button.sketch({
            dom: {
                tag: 'button',
                classes: [
                    'tox-button',
                    'tox-button--icon',
                    'tox-button--naked'
                ],
                attributes: {
                    'type': 'button',
                    'aria-label': providersBackstage.translate('Close')
                }
            },
            action: onClose,
            buttonBehaviours: derive$1([
                Tabstopping.config({})
            ])
        }))
    ;
    const pUntitled = ()=>ModalDialog.parts.title({
            dom: {
                tag: 'div',
                classes: [
                    'tox-dialog__title'
                ],
                innerHtml: '',
                styles: {
                    display: 'none'
                }
            }
        })
    ;
    const pBodyMessage = (message, providersBackstage)=>ModalDialog.parts.body({
            dom: {
                tag: 'div',
                classes: [
                    'tox-dialog__body'
                ]
            },
            components: [
                {
                    dom: {
                        tag: 'div',
                        classes: [
                            'tox-dialog__body-content'
                        ]
                    },
                    components: [
                        {
                            dom: fromHtml(`<p>${providersBackstage.translate(message)}</p>`)
                        }
                    ]
                }
            ]
        })
    ;
    const pFooter = (buttons)=>ModalDialog.parts.footer({
            dom: {
                tag: 'div',
                classes: [
                    'tox-dialog__footer'
                ]
            },
            components: buttons
        })
    ;
    const pFooterGroup = (startButtons, endButtons)=>[
            Container.sketch({
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-dialog__footer-start'
                    ]
                },
                components: startButtons
            }),
            Container.sketch({
                dom: {
                    tag: 'div',
                    classes: [
                        'tox-dialog__footer-end'
                    ]
                },
                components: endButtons
            })
        ]
    ;
    const renderDialog$1 = (spec)=>{
        const dialogClass = 'tox-dialog';
        const blockerClass = dialogClass + '-wrap';
        const blockerBackdropClass = blockerClass + '__backdrop';
        const scrollLockClass = dialogClass + '__disable-scroll';
        return ModalDialog.sketch({
            lazySink: spec.lazySink,
            onEscape: (comp)=>{
                spec.onEscape(comp);
                return Optional.some(true);
            },
            useTabstopAt: (elem)=>!isPseudoStop(elem)
            ,
            dom: {
                tag: 'div',
                classes: [
                    dialogClass
                ].concat(spec.extraClasses),
                styles: {
                    position: 'relative',
                    ...spec.extraStyles
                }
            },
            components: [
                spec.header,
                spec.body,
                ...spec.footer.toArray()
            ],
            parts: {
                blocker: {
                    dom: fromHtml(`<div class="${blockerClass}"></div>`),
                    components: [
                        {
                            dom: {
                                tag: 'div',
                                classes: isTouch1 ? [
                                    blockerBackdropClass,
                                    blockerBackdropClass + '--opaque'
                                ] : [
                                    blockerBackdropClass
                                ]
                            }
                        }
                    ]
                }
            },
            dragBlockClass: blockerClass,
            modalBehaviours: derive$1([
                Focusing.config({}),
                config1('dialog-events', spec.dialogEvents.concat([
                    runOnSource(focusin(), (comp, _se)=>{
                        Keying.focusIn(comp);
                    })
                ])),
                config1('scroll-lock', [
                    runOnAttached(()=>{
                        add$2(body1(), scrollLockClass);
                    }),
                    runOnDetached(()=>{
                        remove$2(body1(), scrollLockClass);
                    })
                ]),
                ...spec.extraBehaviours
            ]),
            eventOrder: {
                [execute$5()]: [
                    'dialog-events'
                ],
                [attachedToDom()]: [
                    'scroll-lock',
                    'dialog-events',
                    'alloy.base.behaviour'
                ],
                [detachedFromDom()]: [
                    'alloy.base.behaviour',
                    'dialog-events',
                    'scroll-lock'
                ],
                ...spec.eventOrder
            }
        });
    };
    const renderClose = (providersBackstage)=>Button.sketch({
            dom: {
                tag: 'button',
                classes: [
                    'tox-button',
                    'tox-button--icon',
                    'tox-button--naked'
                ],
                attributes: {
                    'type': 'button',
                    'aria-label': providersBackstage.translate('Close'),
                    'title': providersBackstage.translate('Close')
                }
            },
            components: [
                render$3('close', {
                    tag: 'div',
                    classes: [
                        'tox-icon'
                    ]
                }, providersBackstage.icons)
            ],
            action: (comp)=>{
                emit(comp, formCancelEvent);
            }
        })
    ;
    const renderTitle = (spec, dialogId, titleId, providersBackstage)=>{
        const renderComponents = (data)=>[
                text$1(providersBackstage.translate(data.title))
            ]
        ;
        return {
            dom: {
                tag: 'div',
                classes: [
                    'tox-dialog__title'
                ],
                attributes: {
                    ...titleId.map((x)=>({
                            id: x
                        })
                    ).getOr({})
                }
            },
            components: [],
            behaviours: derive$1([
                Reflecting.config({
                    channel: `${titleChannel}-${dialogId}`,
                    initialData: spec,
                    renderComponents
                })
            ])
        };
    };
    const renderDragHandle = ()=>({
            dom: fromHtml('<div class="tox-dialog__draghandle"></div>')
        })
    ;
    const renderInlineHeader = (spec, dialogId, titleId, providersBackstage)=>Container.sketch({
            dom: fromHtml('<div class="tox-dialog__header"></div>'),
            components: [
                renderTitle(spec, dialogId, Optional.some(titleId), providersBackstage),
                renderDragHandle(),
                renderClose(providersBackstage)
            ],
            containerBehaviours: derive$1([
                Dragging.config({
                    mode: 'mouse',
                    blockerClass: 'blocker',
                    getTarget: (handle)=>{
                        return closest$1(handle, '[role="dialog"]').getOrDie();
                    },
                    snaps: {
                        getSnapPoints: ()=>[]
                        ,
                        leftAttr: 'data-drag-left',
                        topAttr: 'data-drag-top'
                    }
                })
            ])
        })
    ;
    const renderModalHeader = (spec, dialogId, providersBackstage)=>{
        const pTitle = ModalDialog.parts.title(renderTitle(spec, dialogId, Optional.none(), providersBackstage));
        const pHandle = ModalDialog.parts.draghandle(renderDragHandle());
        const pClose = ModalDialog.parts.close(renderClose(providersBackstage));
        const components = [
            pTitle
        ].concat(spec.draggable ? [
            pHandle
        ] : []).concat([
            pClose
        ]);
        return Container.sketch({
            dom: fromHtml('<div class="tox-dialog__header"></div>'),
            components
        });
    };
    const getHeader = (title, dialogId, backstage)=>renderModalHeader({
            title: backstage.shared.providers.translate(title),
            draggable: backstage.dialog.isDraggableModal()
        }, dialogId, backstage.shared.providers)
    ;
    const getBusySpec1 = (message, bs, providers)=>({
            dom: {
                tag: 'div',
                classes: [
                    'tox-dialog__busy-spinner'
                ],
                attributes: {
                    'aria-label': providers.translate(message)
                },
                styles: {
                    left: '0px',
                    right: '0px',
                    bottom: '0px',
                    top: '0px',
                    position: 'absolute'
                }
            },
            behaviours: bs,
            components: [
                {
                    dom: fromHtml('<div class="tox-spinner"><div></div><div></div><div></div></div>')
                }
            ]
        })
    ;
    const getEventExtras = (lazyDialog, providers, extra)=>({
            onClose: ()=>extra.closeWindow()
            ,
            onBlock: (blockEvent)=>{
                ModalDialog.setBusy(lazyDialog(), (_comp, bs)=>getBusySpec1(blockEvent.message, bs, providers)
                );
            },
            onUnblock: ()=>{
                ModalDialog.setIdle(lazyDialog());
            }
        })
    ;
    const renderModalDialog = (spec, initialData, dialogEvents, backstage)=>{
        const updateState = (_comp, incoming)=>Optional.some(incoming)
        ;
        return build$1(renderDialog$1({
            ...spec,
            lazySink: backstage.shared.getSink,
            extraBehaviours: [
                Reflecting.config({
                    channel: `${dialogChannel}-${spec.id}`,
                    updateState,
                    initialData
                }),
                RepresentingConfigs.memory({}),
                ...spec.extraBehaviours
            ],
            onEscape: (comp)=>{
                emit(comp, formCancelEvent);
            },
            dialogEvents,
            eventOrder: {
                [receive()]: [
                    Reflecting.name(),
                    Receiving.name()
                ],
                [attachedToDom()]: [
                    'scroll-lock',
                    Reflecting.name(),
                    'messages',
                    'dialog-events',
                    'alloy.base.behaviour'
                ],
                [detachedFromDom()]: [
                    'alloy.base.behaviour',
                    'dialog-events',
                    'messages',
                    Reflecting.name(),
                    'scroll-lock'
                ]
            }
        }));
    };
    const mapMenuButtons = (buttons)=>{
        const mapItems = (button)=>{
            const items = map$2(button.items, (item)=>{
                const cell = Cell(false);
                return {
                    ...item,
                    storage: cell
                };
            });
            return {
                ...button,
                items
            };
        };
        return map$2(buttons, (button)=>{
            if (button.type === 'menu') return mapItems(button);
            return button;
        });
    };
    const extractCellsToObject = (buttons)=>foldl(buttons, (acc, button)=>{
            if (button.type === 'menu') {
                const menuButton = button;
                return foldl(menuButton.items, (innerAcc, item)=>{
                    innerAcc[item.name] = item.storage;
                    return innerAcc;
                }, acc);
            }
            return acc;
        }, {})
    ;
    const initCommonEvents = (fireApiEvent, extras)=>[
            runWithTarget(focusin(), onFocus),
            fireApiEvent(formCloseEvent, (_api, spec)=>{
                extras.onClose();
                spec.onClose();
            }),
            fireApiEvent(formCancelEvent, (api, spec, _event, self)=>{
                spec.onCancel(api);
                emit(self, formCloseEvent);
            }),
            run$1(formUnblockEvent, (_c, _se)=>extras.onUnblock()
            ),
            run$1(formBlockEvent, (_c, se)=>extras.onBlock(se.event)
            )
        ]
    ;
    const initUrlDialog = (getInstanceApi, extras)=>{
        const fireApiEvent = (eventName, f)=>run$1(eventName, (c, se)=>{
                withSpec(c, (spec, _c)=>{
                    f(getInstanceApi(), spec, se.event, c);
                });
            })
        ;
        const withSpec = (c, f)=>{
            Reflecting.getState(c).get().each((currentDialog)=>{
                f(currentDialog, c);
            });
        };
        return [
            ...initCommonEvents(fireApiEvent, extras),
            fireApiEvent(formActionEvent, (api, spec, event)=>{
                spec.onAction(api, {
                    name: event.name
                });
            })
        ];
    };
    const initDialog = (getInstanceApi, extras, getSink)=>{
        const fireApiEvent = (eventName, f)=>run$1(eventName, (c, se)=>{
                withSpec(c, (spec, _c)=>{
                    f(getInstanceApi(), spec, se.event, c);
                });
            })
        ;
        const withSpec = (c, f)=>{
            Reflecting.getState(c).get().each((currentDialogInit)=>{
                f(currentDialogInit.internalDialog, c);
            });
        };
        return [
            ...initCommonEvents(fireApiEvent, extras),
            fireApiEvent(formSubmitEvent, (api, spec)=>spec.onSubmit(api)
            ),
            fireApiEvent(formChangeEvent, (api, spec, event)=>{
                spec.onChange(api, {
                    name: event.name
                });
            }),
            fireApiEvent(formActionEvent, (api, spec, event, component)=>{
                const focusIn = ()=>Keying.focusIn(component)
                ;
                const isDisabled = (focused)=>has$1(focused, 'disabled') || getOpt1(focused, 'aria-disabled').exists((val)=>val === 'true'
                    )
                ;
                const rootNode = getRootNode(component.element);
                const current = active$1(rootNode);
                spec.onAction(api, {
                    name: event.name,
                    value: event.value
                });
                active$1(rootNode).fold(focusIn, (focused)=>{
                    if (isDisabled(focused)) focusIn();
                    else if (current.exists((cur)=>contains(focused, cur) && isDisabled(cur)
                    )) focusIn();
                    else getSink().toOptional().filter((sink)=>!contains(sink.element, focused)
                    ).each(focusIn);
                });
            }),
            fireApiEvent(formTabChangeEvent, (api, spec, event)=>{
                spec.onTabChange(api, {
                    newTabName: event.name,
                    oldTabName: event.oldName
                });
            }),
            runOnDetached((component)=>{
                const api = getInstanceApi();
                Representing.setValue(component, api.getData());
            })
        ];
    };
    const SilverDialogEvents = {
        initUrlDialog,
        initDialog
    };
    const makeButton = (button, backstage)=>renderFooterButton(button, button.type, backstage)
    ;
    const lookup1 = (compInSystem, footerButtons, buttonName)=>find$5(footerButtons, (button)=>button.name === buttonName
        ).bind((memButton)=>memButton.memento.getOpt(compInSystem)
        )
    ;
    const renderComponents1 = (_data, state)=>{
        const footerButtons = state.map((s)=>s.footerButtons
        ).getOr([]);
        const buttonGroups = partition$3(footerButtons, (button)=>button.align === 'start'
        );
        const makeGroup = (edge, buttons)=>Container.sketch({
                dom: {
                    tag: 'div',
                    classes: [
                        `tox-dialog__footer-${edge}`
                    ]
                },
                components: map$2(buttons, (button)=>button.memento.asSpec()
                )
            })
        ;
        const startButtons = makeGroup('start', buttonGroups.pass);
        const endButtons = makeGroup('end', buttonGroups.fail);
        return [
            startButtons,
            endButtons
        ];
    };
    const renderFooter = (initSpec, dialogId, backstage)=>{
        const updateState = (comp, data)=>{
            const footerButtons = map$2(data.buttons, (button)=>{
                const memButton = record1(makeButton(button, backstage));
                return {
                    name: button.name,
                    align: button.align,
                    memento: memButton
                };
            });
            const lookupByName = (buttonName)=>lookup1(comp, footerButtons, buttonName)
            ;
            return Optional.some({
                lookupByName,
                footerButtons
            });
        };
        return {
            dom: fromHtml('<div class="tox-dialog__footer"></div>'),
            components: [],
            behaviours: derive$1([
                Reflecting.config({
                    channel: `${footerChannel}-${dialogId}`,
                    initialData: initSpec,
                    updateState,
                    renderComponents: renderComponents1
                })
            ])
        };
    };
    const renderInlineFooter = (initSpec, dialogId, backstage)=>renderFooter(initSpec, dialogId, backstage)
    ;
    const renderModalFooter = (initSpec, dialogId, backstage)=>ModalDialog.parts.footer(renderFooter(initSpec, dialogId, backstage))
    ;
    const getCompByName = (access, name)=>{
        const root = access.getRoot();
        if (root.getSystem().isConnected()) {
            const form = Composing.getCurrent(access.getFormWrapper()).getOr(access.getFormWrapper());
            return Form.getField(form, name).orThunk(()=>{
                const footer = access.getFooter();
                const footerState = Reflecting.getState(footer).get();
                return footerState.bind((f)=>f.lookupByName(name)
                );
            });
        } else return Optional.none();
    };
    const validateData$1 = (access, data)=>{
        const root = access.getRoot();
        return Reflecting.getState(root).get().map((dialogState)=>getOrDie(asRaw('data', dialogState.dataValidator, data))
        ).getOr(data);
    };
    const getDialogApi = (access, doRedial, menuItemStates)=>{
        const withRoot = (f)=>{
            const root = access.getRoot();
            if (root.getSystem().isConnected()) f(root);
        };
        const getData = ()=>{
            const root = access.getRoot();
            const valueComp = root.getSystem().isConnected() ? access.getFormWrapper() : root;
            const representedValues = Representing.getValue(valueComp);
            const menuItemCurrentState = map$1(menuItemStates, (cell)=>cell.get()
            );
            return {
                ...representedValues,
                ...menuItemCurrentState
            };
        };
        const setData = (newData)=>{
            withRoot((_)=>{
                const prevData = instanceApi.getData();
                const mergedData = deepMerge(prevData, newData);
                const newInternalData = validateData$1(access, mergedData);
                const form = access.getFormWrapper();
                Representing.setValue(form, newInternalData);
                each(menuItemStates, (v, k)=>{
                    if (has$2(mergedData, k)) v.set(mergedData[k]);
                });
            });
        };
        const setEnabled = (name, state)=>{
            getCompByName(access, name).each(state ? Disabling.enable : Disabling.disable);
        };
        const focus = (name)=>{
            getCompByName(access, name).each(Focusing.focus);
        };
        const block = (message)=>{
            if (!isString(message)) throw new Error('The dialogInstanceAPI.block function should be passed a blocking message of type string as an argument');
            withRoot((root)=>{
                emitWith(root, formBlockEvent, {
                    message
                });
            });
        };
        const unblock = ()=>{
            withRoot((root)=>{
                emit(root, formUnblockEvent);
            });
        };
        const showTab = (name)=>{
            withRoot((_)=>{
                const body = access.getBody();
                const bodyState = Reflecting.getState(body);
                if (bodyState.get().exists((b)=>b.isTabPanel()
                )) Composing.getCurrent(body).each((tabSection)=>{
                    TabSection.showTab(tabSection, name);
                });
            });
        };
        const redial = (d)=>{
            withRoot((root)=>{
                const id = access.getId();
                const dialogInit = doRedial(d);
                root.getSystem().broadcastOn([
                    `${dialogChannel}-${id}`
                ], dialogInit);
                root.getSystem().broadcastOn([
                    `${titleChannel}-${id}`
                ], dialogInit.internalDialog);
                root.getSystem().broadcastOn([
                    `${bodyChannel}-${id}`
                ], dialogInit.internalDialog);
                root.getSystem().broadcastOn([
                    `${footerChannel}-${id}`
                ], dialogInit.internalDialog);
                instanceApi.setData(dialogInit.initialData);
            });
        };
        const close = ()=>{
            withRoot((root)=>{
                emit(root, formCloseEvent);
            });
        };
        const instanceApi = {
            getData,
            setData,
            setEnabled,
            focus,
            block,
            unblock,
            showTab,
            redial,
            close
        };
        return instanceApi;
    };
    const getDialogSizeClasses = (size)=>{
        switch(size){
            case 'large':
                return [
                    'tox-dialog--width-lg'
                ];
            case 'medium':
                return [
                    'tox-dialog--width-md'
                ];
            default:
                return [];
        }
    };
    const renderDialog = (dialogInit, extra, backstage)=>{
        const dialogId = generate$6('dialog');
        const internalDialog = dialogInit.internalDialog;
        const header = getHeader(internalDialog.title, dialogId, backstage);
        const body = renderModalBody({
            body: internalDialog.body,
            initialData: internalDialog.initialData
        }, dialogId, backstage);
        const storagedMenuButtons = mapMenuButtons(internalDialog.buttons);
        const objOfCells = extractCellsToObject(storagedMenuButtons);
        const footer = renderModalFooter({
            buttons: storagedMenuButtons
        }, dialogId, backstage);
        const dialogEvents = SilverDialogEvents.initDialog(()=>instanceApi
        , getEventExtras(()=>dialog
        , backstage.shared.providers, extra), backstage.shared.getSink);
        const dialogSize = getDialogSizeClasses(internalDialog.size);
        const spec = {
            id: dialogId,
            header,
            body,
            footer: Optional.some(footer),
            extraClasses: dialogSize,
            extraBehaviours: [],
            extraStyles: {}
        };
        const dialog = renderModalDialog(spec, dialogInit, dialogEvents, backstage);
        const modalAccess = (()=>{
            const getForm = ()=>{
                const outerForm = ModalDialog.getBody(dialog);
                return Composing.getCurrent(outerForm).getOr(outerForm);
            };
            return {
                getId: constant$1(dialogId),
                getRoot: constant$1(dialog),
                getBody: ()=>ModalDialog.getBody(dialog)
                ,
                getFooter: ()=>ModalDialog.getFooter(dialog)
                ,
                getFormWrapper: getForm
            };
        })();
        const instanceApi = getDialogApi(modalAccess, extra.redial, objOfCells);
        return {
            dialog,
            instanceApi
        };
    };
    const renderInlineDialog = (dialogInit, extra, backstage, ariaAttrs)=>{
        const dialogId = generate$6('dialog');
        const dialogLabelId = generate$6('dialog-label');
        const dialogContentId = generate$6('dialog-content');
        const internalDialog = dialogInit.internalDialog;
        const updateState = (_comp, incoming)=>Optional.some(incoming)
        ;
        const memHeader = record1(renderInlineHeader({
            title: internalDialog.title,
            draggable: true
        }, dialogId, dialogLabelId, backstage.shared.providers));
        const memBody = record1(renderInlineBody({
            body: internalDialog.body,
            initialData: internalDialog.initialData
        }, dialogId, dialogContentId, backstage, ariaAttrs));
        const storagedMenuButtons = mapMenuButtons(internalDialog.buttons);
        const objOfCells = extractCellsToObject(storagedMenuButtons);
        const memFooter = record1(renderInlineFooter({
            buttons: storagedMenuButtons
        }, dialogId, backstage));
        const dialogEvents = SilverDialogEvents.initDialog(()=>instanceApi
        , {
            onBlock: (event)=>{
                Blocking.block(dialog, (_comp, bs)=>getBusySpec1(event.message, bs, backstage.shared.providers)
                );
            },
            onUnblock: ()=>{
                Blocking.unblock(dialog);
            },
            onClose: ()=>extra.closeWindow()
        }, backstage.shared.getSink);
        const dialog = build$1({
            dom: {
                tag: 'div',
                classes: [
                    'tox-dialog',
                    'tox-dialog-inline'
                ],
                attributes: {
                    role: 'dialog',
                    ['aria-labelledby']: dialogLabelId,
                    ['aria-describedby']: dialogContentId
                }
            },
            eventOrder: {
                [receive()]: [
                    Reflecting.name(),
                    Receiving.name()
                ],
                [execute$5()]: [
                    'execute-on-form'
                ],
                [attachedToDom()]: [
                    'reflecting',
                    'execute-on-form'
                ]
            },
            behaviours: derive$1([
                Keying.config({
                    mode: 'cyclic',
                    onEscape: (c)=>{
                        emit(c, formCloseEvent);
                        return Optional.some(true);
                    },
                    useTabstopAt: (elem)=>!isPseudoStop(elem) && (name$3(elem) !== 'button' || get$f(elem, 'disabled') !== 'disabled')
                }),
                Reflecting.config({
                    channel: `${dialogChannel}-${dialogId}`,
                    updateState,
                    initialData: dialogInit
                }),
                Focusing.config({}),
                config1('execute-on-form', dialogEvents.concat([
                    runOnSource(focusin(), (comp, _se)=>{
                        Keying.focusIn(comp);
                    })
                ])),
                Blocking.config({
                    getRoot: ()=>Optional.some(dialog)
                }),
                Replacing.config({}),
                RepresentingConfigs.memory({})
            ]),
            components: [
                memHeader.asSpec(),
                memBody.asSpec(),
                memFooter.asSpec()
            ]
        });
        const instanceApi = getDialogApi({
            getId: constant$1(dialogId),
            getRoot: constant$1(dialog),
            getFooter: ()=>memFooter.get(dialog)
            ,
            getBody: ()=>memBody.get(dialog)
            ,
            getFormWrapper: ()=>{
                const body = memBody.get(dialog);
                return Composing.getCurrent(body).getOr(body);
            }
        }, extra.redial, objOfCells);
        return {
            dialog,
            instanceApi
        };
    };
    var global = tinymce.util.Tools.resolve('tinymce.util.URI');
    const getUrlDialogApi = (root1)=>{
        const withRoot = (f)=>{
            if (root1.getSystem().isConnected()) f(root1);
        };
        const block = (message)=>{
            if (!isString(message)) throw new Error('The urlDialogInstanceAPI.block function should be passed a blocking message of type string as an argument');
            withRoot((root)=>{
                emitWith(root, formBlockEvent, {
                    message
                });
            });
        };
        const unblock = ()=>{
            withRoot((root)=>{
                emit(root, formUnblockEvent);
            });
        };
        const close = ()=>{
            withRoot((root)=>{
                emit(root, formCloseEvent);
            });
        };
        const sendMessage = (data)=>{
            withRoot((root)=>{
                root.getSystem().broadcastOn([
                    bodySendMessageChannel
                ], data);
            });
        };
        return {
            block,
            unblock,
            close,
            sendMessage
        };
    };
    const SUPPORTED_MESSAGE_ACTIONS = [
        'insertContent',
        'setContent',
        'execCommand',
        'close',
        'block',
        'unblock'
    ];
    const isSupportedMessage = (data)=>isObject(data) && SUPPORTED_MESSAGE_ACTIONS.indexOf(data.mceAction) !== -1
    ;
    const isCustomMessage = (data)=>!isSupportedMessage(data) && isObject(data) && has$2(data, 'mceAction')
    ;
    const handleMessage = (editor, api, data)=>{
        switch(data.mceAction){
            case 'insertContent':
                editor.insertContent(data.content);
                break;
            case 'setContent':
                editor.setContent(data.content);
                break;
            case 'execCommand':
                const ui = isBoolean(data.ui) ? data.ui : false;
                editor.execCommand(data.cmd, ui, data.value);
                break;
            case 'close':
                api.close();
                break;
            case 'block':
                api.block(data.message);
                break;
            case 'unblock':
                api.unblock();
                break;
        }
    };
    const renderUrlDialog = (internalDialog, extra, editor, backstage)=>{
        const dialogId = generate$6('dialog');
        const header = getHeader(internalDialog.title, dialogId, backstage);
        const body = renderIframeBody(internalDialog);
        const footer = internalDialog.buttons.bind((buttons)=>{
            if (buttons.length === 0) return Optional.none();
            else return Optional.some(renderModalFooter({
                buttons
            }, dialogId, backstage));
        });
        const dialogEvents = SilverDialogEvents.initUrlDialog(()=>instanceApi
        , getEventExtras(()=>dialog
        , backstage.shared.providers, extra));
        const styles = {
            ...internalDialog.height.fold(()=>({})
            , (height)=>({
                    'height': height + 'px',
                    'max-height': height + 'px'
                })
            ),
            ...internalDialog.width.fold(()=>({})
            , (width)=>({
                    'width': width + 'px',
                    'max-width': width + 'px'
                })
            )
        };
        const classes = internalDialog.width.isNone() && internalDialog.height.isNone() ? [
            'tox-dialog--width-lg'
        ] : [];
        const iframeUri = new global(internalDialog.url, {
            base_uri: new global(window.location.href)
        });
        const iframeDomain = `${iframeUri.protocol}://${iframeUri.host}${iframeUri.port ? ':' + iframeUri.port : ''}`;
        const messageHandlerUnbinder = unbindable();
        const extraBehaviours = [
            config1('messages', [
                runOnAttached(()=>{
                    const unbind = bind1(SugarElement.fromDom(window), 'message', (e)=>{
                        if (iframeUri.isSameOrigin(new global(e.raw.origin))) {
                            const data = e.raw.data;
                            if (isSupportedMessage(data)) handleMessage(editor, instanceApi, data);
                            else if (isCustomMessage(data)) internalDialog.onMessage(instanceApi, data);
                        }
                    });
                    messageHandlerUnbinder.set(unbind);
                }),
                runOnDetached(messageHandlerUnbinder.clear)
            ]),
            Receiving.config({
                channels: {
                    [bodySendMessageChannel]: {
                        onReceive: (comp, data)=>{
                            descendant(comp.element, 'iframe').each((iframeEle)=>{
                                const iframeWin = iframeEle.dom.contentWindow;
                                iframeWin.postMessage(data, iframeDomain);
                            });
                        }
                    }
                }
            })
        ];
        const spec = {
            id: dialogId,
            header,
            body,
            footer,
            extraClasses: classes,
            extraBehaviours,
            extraStyles: styles
        };
        const dialog = renderModalDialog(spec, internalDialog, dialogEvents, backstage);
        const instanceApi = getUrlDialogApi(dialog);
        return {
            dialog,
            instanceApi
        };
    };
    const setup$2 = (extras)=>{
        const sharedBackstage = extras.backstage.shared;
        const open = (message, callback)=>{
            const closeDialog = ()=>{
                ModalDialog.hide(alertDialog);
                callback();
            };
            const memFooterClose = record1(renderFooterButton({
                name: 'close-alert',
                text: 'OK',
                primary: true,
                buttonType: Optional.some('primary'),
                align: 'end',
                enabled: true,
                icon: Optional.none()
            }, 'cancel', extras.backstage));
            const titleSpec = pUntitled();
            const closeSpec = pClose1(closeDialog, sharedBackstage.providers);
            const alertDialog = build$1(renderDialog$1({
                lazySink: ()=>sharedBackstage.getSink()
                ,
                header: hiddenHeader(titleSpec, closeSpec),
                body: pBodyMessage(message, sharedBackstage.providers),
                footer: Optional.some(pFooter(pFooterGroup([], [
                    memFooterClose.asSpec()
                ]))),
                onEscape: closeDialog,
                extraClasses: [
                    'tox-alert-dialog'
                ],
                extraBehaviours: [],
                extraStyles: {},
                dialogEvents: [
                    run$1(formCancelEvent, closeDialog)
                ],
                eventOrder: {}
            }));
            ModalDialog.show(alertDialog);
            const footerCloseButton = memFooterClose.get(alertDialog);
            Focusing.focus(footerCloseButton);
        };
        return {
            open
        };
    };
    const setup$1 = (extras)=>{
        const sharedBackstage = extras.backstage.shared;
        const open = (message, callback)=>{
            const closeDialog = (state)=>{
                ModalDialog.hide(confirmDialog);
                callback(state);
            };
            const memFooterYes = record1(renderFooterButton({
                name: 'yes',
                text: 'Yes',
                primary: true,
                buttonType: Optional.some('primary'),
                align: 'end',
                enabled: true,
                icon: Optional.none()
            }, 'submit', extras.backstage));
            const footerNo = renderFooterButton({
                name: 'no',
                text: 'No',
                primary: false,
                buttonType: Optional.some('secondary'),
                align: 'end',
                enabled: true,
                icon: Optional.none()
            }, 'cancel', extras.backstage);
            const titleSpec = pUntitled();
            const closeSpec = pClose1(()=>closeDialog(false)
            , sharedBackstage.providers);
            const confirmDialog = build$1(renderDialog$1({
                lazySink: ()=>sharedBackstage.getSink()
                ,
                header: hiddenHeader(titleSpec, closeSpec),
                body: pBodyMessage(message, sharedBackstage.providers),
                footer: Optional.some(pFooter(pFooterGroup([], [
                    footerNo,
                    memFooterYes.asSpec()
                ]))),
                onEscape: ()=>closeDialog(false)
                ,
                extraClasses: [
                    'tox-confirm-dialog'
                ],
                extraBehaviours: [],
                extraStyles: {},
                dialogEvents: [
                    run$1(formCancelEvent, ()=>closeDialog(false)
                    ),
                    run$1(formSubmitEvent, ()=>closeDialog(true)
                    )
                ],
                eventOrder: {}
            }));
            ModalDialog.show(confirmDialog);
            const footerYesButton = memFooterYes.get(confirmDialog);
            Focusing.focus(footerYesButton);
        };
        return {
            open
        };
    };
    const validateData = (data, validator)=>getOrDie(asRaw('data', validator, data))
    ;
    const isAlertOrConfirmDialog = (target)=>closest1(target, '.tox-alert-dialog') || closest1(target, '.tox-confirm-dialog')
    ;
    const inlineAdditionalBehaviours = (editor, isStickyToolbar, isToolbarLocationTop)=>{
        if (isStickyToolbar && isToolbarLocationTop) return [];
        else return [
            Docking.config({
                contextual: {
                    lazyContext: ()=>Optional.some(box$1(SugarElement.fromDom(editor.getContentAreaContainer())))
                    ,
                    fadeInClass: 'tox-dialog-dock-fadein',
                    fadeOutClass: 'tox-dialog-dock-fadeout',
                    transitionClass: 'tox-dialog-dock-transition'
                },
                modes: [
                    'top'
                ]
            })
        ];
    };
    const setup1 = (extras)=>{
        const backstage = extras.backstage;
        const editor = extras.editor;
        const isStickyToolbar$1 = isStickyToolbar1(editor);
        const alertDialog = setup$2(extras);
        const confirmDialog = setup$1(extras);
        const open = (config, params, closeWindow)=>{
            if (params !== undefined && params.inline === 'toolbar') return openInlineDialog(config, backstage.shared.anchors.inlineDialog(), closeWindow, params.ariaAttrs);
            else if (params !== undefined && params.inline === 'cursor') return openInlineDialog(config, backstage.shared.anchors.cursor(), closeWindow, params.ariaAttrs);
            else return openModalDialog(config, closeWindow);
        };
        const openUrl = (config, closeWindow)=>openModalUrlDialog(config, closeWindow)
        ;
        const openModalUrlDialog = (config, closeWindow)=>{
            const factory = (contents)=>{
                const dialog = renderUrlDialog(contents, {
                    closeWindow: ()=>{
                        ModalDialog.hide(dialog.dialog);
                        closeWindow(dialog.instanceApi);
                    }
                }, editor, backstage);
                ModalDialog.show(dialog.dialog);
                return dialog.instanceApi;
            };
            return DialogManager.openUrl(factory, config);
        };
        const openModalDialog = (config, closeWindow)=>{
            const factory = (contents, internalInitialData, dataValidator)=>{
                const initialData = internalInitialData;
                const dialogInit = {
                    dataValidator,
                    initialData,
                    internalDialog: contents
                };
                const dialog = renderDialog(dialogInit, {
                    redial: DialogManager.redial,
                    closeWindow: ()=>{
                        ModalDialog.hide(dialog.dialog);
                        closeWindow(dialog.instanceApi);
                    }
                }, backstage);
                ModalDialog.show(dialog.dialog);
                dialog.instanceApi.setData(initialData);
                return dialog.instanceApi;
            };
            return DialogManager.open(factory, config);
        };
        const openInlineDialog = (config$1, anchor, closeWindow, ariaAttrs)=>{
            const factory = (contents, internalInitialData, dataValidator)=>{
                const initialData = validateData(internalInitialData, dataValidator);
                const inlineDialog = value$2();
                const isToolbarLocationTop = backstage.shared.header.isPositionedAtTop();
                const dialogInit = {
                    dataValidator,
                    initialData,
                    internalDialog: contents
                };
                const refreshDocking = ()=>inlineDialog.on((dialog)=>{
                        InlineView.reposition(dialog);
                        Docking.refresh(dialog);
                    })
                ;
                const dialogUi = renderInlineDialog(dialogInit, {
                    redial: DialogManager.redial,
                    closeWindow: ()=>{
                        inlineDialog.on(InlineView.hide);
                        editor.off('ResizeEditor', refreshDocking);
                        inlineDialog.clear();
                        closeWindow(dialogUi.instanceApi);
                    }
                }, backstage, ariaAttrs);
                const inlineDialogComp = build$1(InlineView.sketch({
                    lazySink: backstage.shared.getSink,
                    dom: {
                        tag: 'div',
                        classes: []
                    },
                    fireDismissalEventInstead: {},
                    ...isToolbarLocationTop ? {} : {
                        fireRepositionEventInstead: {}
                    },
                    inlineBehaviours: derive$1([
                        config1('window-manager-inline-events', [
                            run$1(dismissRequested(), (_comp, _se)=>{
                                emit(dialogUi.dialog, formCancelEvent);
                            })
                        ]),
                        ...inlineAdditionalBehaviours(editor, isStickyToolbar$1, isToolbarLocationTop)
                    ]),
                    isExtraPart: (_comp, target)=>isAlertOrConfirmDialog(target)
                }));
                inlineDialog.set(inlineDialogComp);
                InlineView.showWithin(inlineDialogComp, premade(dialogUi.dialog), {
                    anchor
                }, Optional.some(body1()));
                if (!isStickyToolbar$1 || !isToolbarLocationTop) {
                    Docking.refresh(inlineDialogComp);
                    editor.on('ResizeEditor', refreshDocking);
                }
                dialogUi.instanceApi.setData(initialData);
                Keying.focusIn(dialogUi.dialog);
                return dialogUi.instanceApi;
            };
            return DialogManager.open(factory, config$1);
        };
        const confirm = (message, callback)=>{
            confirmDialog.open(message, (state)=>{
                callback(state);
            });
        };
        const alert = (message, callback)=>{
            alertDialog.open(message, ()=>{
                callback();
            });
        };
        const close = (instanceApi)=>{
            instanceApi.close();
        };
        return {
            open,
            openUrl,
            alert,
            close,
            confirm
        };
    };
    const registerOptions = (editor)=>{
        register$e(editor);
        register$d(editor);
        register1(editor);
    };
    var Theme = ()=>{
        global$a.add('silver', (editor)=>{
            registerOptions(editor);
            const { getUiMothership , backstage , renderUI  } = setup$3(editor);
            Autocompleter.register(editor, backstage.shared);
            const windowMgr = setup1({
                editor,
                backstage
            });
            return {
                renderUI,
                getWindowManagerImpl: constant$1(windowMgr),
                getNotificationManagerImpl: ()=>NotificationManagerImpl(editor, {
                        backstage
                    }, getUiMothership())
            };
        });
    };
    Theme();
})();


</script>
  <script referrerpolicy="origin">
tinymce.IconManager.add('default', {
    icons: {
        'accessibility-check': '<svg width="24" height="24"><path d="M12 2a2 2 0 012 2 2 2 0 01-2 2 2 2 0 01-2-2c0-1.1.9-2 2-2zm8 7h-5v12c0 .6-.4 1-1 1a1 1 0 01-1-1v-5c0-.6-.4-1-1-1a1 1 0 00-1 1v5c0 .6-.4 1-1 1a1 1 0 01-1-1V9H4a1 1 0 110-2h16c.6 0 1 .4 1 1s-.4 1-1 1z" fill-rule="nonzero"/></svg>',
        'action-next': '<svg width="24" height="24"><path fill-rule="nonzero" d="M5.7 7.3a1 1 0 00-1.4 1.4l7.7 7.7 7.7-7.7a1 1 0 10-1.4-1.4L12 13.6 5.7 7.3z"/></svg>',
        'action-prev': '<svg width="24" height="24"><path fill-rule="nonzero" d="M18.3 15.7a1 1 0 001.4-1.4L12 6.6l-7.7 7.7a1 1 0 001.4 1.4L12 9.4l6.3 6.3z"/></svg>',
        'align-center': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm3 4h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 110-2zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 010-2zm-3-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2z" fill-rule="evenodd"/></svg>',
        'align-justify': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2z" fill-rule="evenodd"/></svg>',
        'align-left': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm0 4h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2zm0-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2z" fill-rule="evenodd"/></svg>',
        'align-none': '<svg width="24" height="24"><path d="M14.2 5L13 7H5a1 1 0 110-2h9.2zm4 0h.8a1 1 0 010 2h-2l1.2-2zm-6.4 4l-1.2 2H5a1 1 0 010-2h6.8zm4 0H19a1 1 0 010 2h-4.4l1.2-2zm-6.4 4l-1.2 2H5a1 1 0 010-2h4.4zm4 0H19a1 1 0 010 2h-6.8l1.2-2zM7 17l-1.2 2H5a1 1 0 010-2h2zm4 0h8a1 1 0 010 2H9.8l1.2-2zm5.2-13.5l1.3.7-9.7 16.3-1.3-.7 9.7-16.3z" fill-rule="evenodd"/></svg>',
        'align-right': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm6 4h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm-6-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2z" fill-rule="evenodd"/></svg>',
        'arrow-left': '<svg width="24" height="24"><path d="M5.6 13l12 6a1 1 0 001.4-1V6a1 1 0 00-1.4-.9l-12 6a1 1 0 000 1.8z" fill-rule="evenodd"/></svg>',
        'arrow-right': '<svg width="24" height="24"><path d="M18.5 13l-12 6A1 1 0 015 18V6a1 1 0 011.4-.9l12 6a1 1 0 010 1.8z" fill-rule="evenodd"/></svg>',
        'bold': '<svg width="24" height="24"><path d="M7.8 19c-.3 0-.5 0-.6-.2l-.2-.5V5.7c0-.2 0-.4.2-.5l.6-.2h5c1.5 0 2.7.3 3.5 1 .7.6 1.1 1.4 1.1 2.5a3 3 0 01-.6 1.9c-.4.6-1 1-1.6 1.2.4.1.9.3 1.3.6s.8.7 1 1.2c.4.4.5 1 .5 1.6 0 1.3-.4 2.3-1.3 3-.8.7-2.1 1-3.8 1H7.8zm5-8.3c.6 0 1.2-.1 1.6-.5.4-.3.6-.7.6-1.3 0-1.1-.8-1.7-2.3-1.7H9.3v3.5h3.4zm.5 6c.7 0 1.3-.1 1.7-.4.4-.4.6-.9.6-1.5s-.2-1-.7-1.4c-.4-.3-1-.4-2-.4H9.4v3.8h4z" fill-rule="evenodd"/></svg>',
        'bookmark': '<svg width="24" height="24"><path d="M6 4v17l6-4 6 4V4c0-.6-.4-1-1-1H7a1 1 0 00-1 1z" fill-rule="nonzero"/></svg>',
        'border-style': '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="2" x="3" y="6" rx="1"/><rect width="2.8" height="2" x="3" y="16" rx="1"/><rect width="2.8" height="2" x="6.8" y="16" rx="1"/><rect width="2.8" height="2" x="10.6" y="16" rx="1"/><rect width="2.8" height="2" x="14.4" y="16" rx="1"/><rect width="2.8" height="2" x="18.2" y="16" rx="1"/><rect width="8" height="2" x="3" y="11" rx="1"/><rect width="8" height="2" x="13" y="11" rx="1"/></g></svg>',
        'border-width': '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="5" x="3" y="5" rx="1"/><rect width="18" height="3.5" x="3" y="11.5" rx="1"/><rect width="18" height="2" x="3" y="17" rx="1"/></g></svg>',
        'brightness': '<svg width="24" height="24"><path d="M12 17c.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 01-.7.3 1 1 0 01-.7-.3 1 1 0 01-.3-.7v-1c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3zm0-10a1 1 0 01-.7-.3A1 1 0 0111 6V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 01-.7.3zm7 4c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 01-.7.3h-1a1 1 0 01-.7-.3 1 1 0 01-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1zM7 12c0 .3-.1.5-.3.7a1 1 0 01-.7.3H5a1 1 0 01-.7-.3A1 1 0 014 12c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1c.3 0 .5.1.7.3.2.2.3.4.3.7zm10 3.5l.7.8c.2.1.3.4.3.6 0 .3-.1.6-.3.8a1 1 0 01-.8.3 1 1 0 01-.6-.3l-.8-.7a1 1 0 01-.3-.8c0-.2.1-.5.3-.7a1 1 0 011.4 0zm-10-7l-.7-.8a1 1 0 01-.3-.6c0-.3.1-.6.3-.8.2-.2.5-.3.8-.3.2 0 .5.1.7.3l.7.7c.2.2.3.5.3.8 0 .2-.1.5-.3.7a1 1 0 01-.7.3 1 1 0 01-.8-.3zm10 0a1 1 0 01-.8.3 1 1 0 01-.7-.3 1 1 0 01-.3-.7c0-.3.1-.6.3-.8l.8-.7c.1-.2.4-.3.6-.3.3 0 .6.1.8.3.2.2.3.5.3.8 0 .2-.1.5-.3.7l-.7.7zm-10 7c.2-.2.5-.3.8-.3.2 0 .5.1.7.3a1 1 0 010 1.4l-.8.8a1 1 0 01-.6.3 1 1 0 01-.8-.3 1 1 0 01-.3-.8c0-.2.1-.5.3-.6l.7-.8zM12 8a4 4 0 013.7 2.4 4 4 0 010 3.2A4 4 0 0112 16a4 4 0 01-3.7-2.4 4 4 0 010-3.2A4 4 0 0112 8zm0 6.5c.7 0 1.3-.2 1.8-.7.5-.5.7-1.1.7-1.8s-.2-1.3-.7-1.8c-.5-.5-1.1-.7-1.8-.7s-1.3.2-1.8.7c-.5.5-.7 1.1-.7 1.8s.2 1.3.7 1.8c.5.5 1.1.7 1.8.7z" fill-rule="evenodd"/></svg>',
        'browse': '<svg width="24" height="24"><path d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2h-4v-2h4V8H5v10h4v2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm-8 9.4l-2.3 2.3a1 1 0 11-1.4-1.4l4-4a1 1 0 011.4 0l4 4a1 1 0 01-1.4 1.4L13 13.4V20a1 1 0 01-2 0v-6.6z" fill-rule="nonzero"/></svg>',
        'cancel': '<svg width="24" height="24"><path d="M12 4.6a7.4 7.4 0 110 14.8 7.4 7.4 0 010-14.8zM12 3a9 9 0 100 18 9 9 0 000-18zm0 8L14.8 8l1 1.1-2.7 2.8 2.7 2.7-1.1 1.1-2.7-2.7-2.7 2.7-1-1.1 2.6-2.7-2.7-2.7 1-1.1 2.8 2.7z" fill-rule="nonzero"/></svg>',
        'cell-background-color': '<svg width="24" height="24"><path d="M15.7 2l1.6 1.6-2.7 2.6 5.9 5.8c.7.7.7 1.7 0 2.4l-6.3 6.1a1.7 1.7 0 01-2.4 0l-6.3-6.1c-.7-.7-.7-1.7 0-2.4L15.7 2zM18 12l-4.5-4L9 12h9zM4 16s2 2.4 2 3.8C6 21 5.1 22 4 22s-2-1-2-2.2C2 18.4 4 16 4 16z"/></svg>',
        'cell-border-color': '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M5 13v5h2v2H5a2 2 0 01-2-2v-5h2zm8-7V4h6a2 2 0 012 2h-8z" opacity=".2"/><path fill-rule="nonzero" d="M13 4v2H5v7H3V6c0-1.1.9-2 2-2h8zm-2.6 14.1l.1-.1.1.1.2.3.2.2.2.2c.4.6.8 1.2.8 1.7 0 .8-.7 1.5-1.5 1.5S9 21.3 9 20.5c0-.5.4-1.1.8-1.7l.2-.2.2-.2.2-.3z"/><path d="M13 11l-2 2H5v-2h6V6h2z"/><path fill-rule="nonzero" d="M18.4 8l1 1-1.8 1.9 4 4c.5.4.5 1.1 0 1.6l-4.3 4.2a1.2 1.2 0 01-1.6 0l-4.4-4.2c-.4-.5-.4-1.2 0-1.7l7-6.8zm1.6 7l-3-3-3 3h6z"/></g></svg>',
        'change-case': '<svg width="24" height="24"><path d="M18.4 18.2v-.6c-.5.8-1.3 1.2-2.4 1.2-2.2 0-3.3-1.6-3.3-4.8 0-3.1 1-4.7 3.3-4.7 1.1 0 1.8.3 2.4 1.1v-.6c0-.5.4-.8.8-.8s.8.3.8.8v8.4c0 .5-.4.8-.8.8a.8.8 0 01-.8-.8zm-2-7.4c-1.3 0-1.8.9-1.8 3.2 0 2.4.5 3.3 1.7 3.3 1.3 0 1.8-.9 1.8-3.2 0-2.4-.5-3.3-1.7-3.3zM10 15.7H5.5l-.8 2.6a1 1 0 01-1 .7h-.2a.7.7 0 01-.7-1l4-12a1 1 0 012 0l4 12a.7.7 0 01-.8 1h-.2a1 1 0 01-1-.7l-.8-2.6zm-.3-1.5l-2-6.5-1.9 6.5h3.9z" fill-rule="evenodd"/></svg>',
        'character-count': '<svg width="24" height="24"><path d="M4 11.5h16v1H4v-1zm4.8-6.8V10H7.7V5.8h-1v-1h2zM11 8.3V9h2v1h-3V7.7l2-1v-.9h-2v-1h3v2.4l-2 1zm6.3-3.4V10h-3.1V9h2.1V8h-2.1V6.8h2.1v-1h-2.1v-1h3.1zM5.8 16.4c0-.5.2-.8.5-1 .2-.2.6-.3 1.2-.3l.8.1c.2 0 .4.2.5.3l.4.4v2.8l.2.3H8.2v-.1-.2l-.6.3H7c-.4 0-.7 0-1-.2a1 1 0 01-.3-.9c0-.3 0-.6.3-.8.3-.2.7-.4 1.2-.4l.6-.2h.3v-.2l-.1-.2a.8.8 0 00-.5-.1 1 1 0 00-.4 0l-.3.4h-1zm2.3.8h-.2l-.2.1-.4.1a1 1 0 00-.4.2l-.2.2.1.3.5.1h.4l.4-.4v-.6zm2-3.4h1.2v1.7l.5-.3h.5c.5 0 .9.1 1.2.5.3.4.5.8.5 1.4 0 .6-.2 1.1-.5 1.5-.3.4-.7.6-1.3.6l-.6-.1-.4-.4v.4h-1.1v-5.4zm1.1 3.3c0 .3 0 .6.2.8a.7.7 0 001.2 0l.2-.8c0-.4 0-.6-.2-.8a.7.7 0 00-.6-.3l-.6.3-.2.8zm6.1-.5c0-.2 0-.3-.2-.4a.8.8 0 00-.5-.2c-.3 0-.5.1-.6.3l-.2.9c0 .3 0 .6.2.8.1.2.3.3.6.3.2 0 .4 0 .5-.2l.2-.4h1.1c0 .5-.3.8-.6 1.1a2 2 0 01-1.3.4c-.5 0-1-.2-1.3-.6a2 2 0 01-.5-1.4c0-.6.1-1.1.5-1.5.3-.4.8-.5 1.4-.5.5 0 1 0 1.2.3.4.3.5.7.5 1.2h-1v-.1z" fill-rule="evenodd"/></svg>',
        'checklist-rtl': '<svg width="24" height="24"><path d="M5 17h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm14.2 11c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 8c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z" fill-rule="evenodd"/></svg>',
        'checklist': '<svg width="24" height="24"><path d="M11 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0-6h8a1 1 0 010 2h-8a1 1 0 010-2zM7.2 16c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 8c-.2.3-.7.4-1 0L3.8 6.9a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z" fill-rule="evenodd"/></svg>',
        'checkmark': '<svg width="24" height="24"><path d="M18.2 5.4a1 1 0 011.6 1.2l-8 12a1 1 0 01-1.5.1l-5-5a1 1 0 111.4-1.4l4.1 4.1 7.4-11z" fill-rule="nonzero"/></svg>',
        'chevron-down': '<svg width="10" height="10"><path d="M8.7 2.2c.3-.3.8-.3 1 0 .4.4.4.9 0 1.2L5.7 7.8c-.3.3-.9.3-1.2 0L.2 3.4a.8.8 0 010-1.2c.3-.3.8-.3 1.1 0L5 6l3.7-3.8z" fill-rule="nonzero"/></svg>',
        'chevron-left': '<svg width="10" height="10"><path d="M7.8 1.3L4 5l3.8 3.7c.3.3.3.8 0 1-.4.4-.9.4-1.2 0L2.2 5.7a.8.8 0 010-1.2L6.6.2C7 0 7.4 0 7.8.2c.3.3.3.8 0 1.1z" fill-rule="nonzero"/></svg>',
        'chevron-right': '<svg width="10" height="10"><path d="M2.2 1.3a.8.8 0 010-1c.4-.4.9-.4 1.2 0l4.4 4.1c.3.4.3.9 0 1.2L3.4 9.8c-.3.3-.8.3-1.2 0a.8.8 0 010-1.1L6 5 2.2 1.3z" fill-rule="nonzero"/></svg>',
        'chevron-up': '<svg width="10" height="10"><path d="M8.7 7.8L5 4 1.3 7.8c-.3.3-.8.3-1 0a.8.8 0 010-1.2l4.1-4.4c.3-.3.9-.3 1.2 0l4.2 4.4c.3.3.3.9 0 1.2-.3.3-.8.3-1.1 0z" fill-rule="nonzero"/></svg>',
        'close': '<svg width="24" height="24"><path d="M17.3 8.2L13.4 12l3.9 3.8a1 1 0 01-1.5 1.5L12 13.4l-3.8 3.9a1 1 0 01-1.5-1.5l3.9-3.8-3.9-3.8a1 1 0 011.5-1.5l3.8 3.9 3.8-3.9a1 1 0 011.5 1.5z" fill-rule="evenodd"/></svg>',
        'code-sample': '<svg width="24" height="26"><path d="M7.1 11a2.8 2.8 0 01-.8 2 2.8 2.8 0 01.8 2v1.7c0 .3.1.6.4.8.2.3.5.4.8.4.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.7 0-1.4-.3-2-.8-.5-.6-.8-1.3-.8-2V15c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 01-.4-.4v-.8c0-.2.2-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V9.3c0-.7.3-1.4.8-2 .6-.5 1.3-.8 2-.8.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8V11zm9.8 0V9.3c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 01-.4-.4V7c0-.2.1-.4.4-.4.7 0 1.4.3 2 .8.5.6.8 1.3.8 2V11c0 .3.1.6.4.8.2.3.5.4.8.4.2 0 .4.2.4.4v.8c0 .2-.2.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8v1.7c0 .7-.3 1.4-.8 2-.6.5-1.3.8-2 .8a.4.4 0 01-.4-.4v-.8c0-.2.1-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V15a2.8 2.8 0 01.8-2 2.8 2.8 0 01-.8-2zm-3.3-.4c0 .4-.1.8-.5 1.1-.3.3-.7.5-1.1.5-.4 0-.8-.2-1.1-.5-.4-.3-.5-.7-.5-1.1 0-.5.1-.9.5-1.2.3-.3.7-.4 1.1-.4.4 0 .8.1 1.1.4.4.3.5.7.5 1.2zM12 13c.4 0 .8.1 1.1.5.4.3.5.7.5 1.1 0 1-.1 1.6-.5 2a3 3 0 01-1.1 1c-.4.3-.8.4-1.1.4a.5.5 0 01-.5-.5V17a3 3 0 001-.2l.6-.6c-.6 0-1-.2-1.3-.5-.2-.3-.3-.7-.3-1 0-.5.1-1 .5-1.2.3-.4.7-.5 1.1-.5z" fill-rule="evenodd"/></svg>',
        'color-levels': '<svg width="24" height="24"><path d="M17.5 11.4A9 9 0 0118 14c0 .5 0 1-.2 1.4 0 .4-.3.9-.5 1.3a6.2 6.2 0 01-3.7 3 5.7 5.7 0 01-3.2 0A5.9 5.9 0 017.6 18a6.2 6.2 0 01-1.4-2.6 6.7 6.7 0 010-2.8c0-.4.1-.9.3-1.3a13.6 13.6 0 012.3-4A20 20 0 0112 4a26.4 26.4 0 013.2 3.4 18.2 18.2 0 012.3 4zm-2 4.5c.4-.7.5-1.4.5-2a7.3 7.3 0 00-1-3.2c.2.6.2 1.2.2 1.9a4.5 4.5 0 01-1.3 3 5.3 5.3 0 01-2.3 1.5 4.9 4.9 0 01-2 .1 4.3 4.3 0 002.4.8 4 4 0 002-.6 4 4 0 001.5-1.5z" fill-rule="evenodd"/></svg>',
        'color-picker': '<svg width="24" height="24"><path d="M12 3a9 9 0 000 18 1.5 1.5 0 001.1-2.5c-.2-.3-.4-.6-.4-1 0-.8.7-1.5 1.5-1.5H16a5 5 0 005-5c0-4.4-4-8-9-8zm-5.5 9a1.5 1.5 0 110-3 1.5 1.5 0 010 3zm3-4a1.5 1.5 0 110-3 1.5 1.5 0 010 3zm5 0a1.5 1.5 0 110-3 1.5 1.5 0 010 3zm3 4a1.5 1.5 0 110-3 1.5 1.5 0 010 3z" fill-rule="nonzero"/></svg>',
        'color-swatch-remove-color': '<svg width="24" height="24"><path stroke="#000" stroke-width="2" d="M21 3L3 21" fill-rule="evenodd"/></svg>',
        'color-swatch': '<svg width="24" height="24"><rect x="3" y="3" width="18" height="18" rx="1" fill-rule="evenodd"/></svg>',
        'comment-add': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M9 19l3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 00-1 1v10c0 .6.4 1 1 1h4v2zm-2 4v-4H5a3 3 0 01-3-3V6a3 3 0 013-3h14a3 3 0 013 3v10a3 3 0 01-3 3h-6.4L7 23z"/><path d="M13 10h2a1 1 0 010 2h-2v2a1 1 0 01-2 0v-2H9a1 1 0 010-2h2V8a1 1 0 012 0v2z"/></g></svg>',
        'comment': '<svg width="24" height="24"><path fill-rule="nonzero" d="M9 19l3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 00-1 1v10c0 .6.4 1 1 1h4v2zm-2 4v-4H5a3 3 0 01-3-3V6a3 3 0 013-3h14a3 3 0 013 3v10a3 3 0 01-3 3h-6.4L7 23z"/></svg>',
        'contrast': '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 015.7 2.3A8 8 0 1112 4zm-6 8a6 6 0 006 6V6a6 6 0 00-6 6z" fill-rule="evenodd"/></svg>',
        'copy': '<svg width="24" height="24"><path d="M16 3H6a2 2 0 00-2 2v11h2V5h10V3zm1 4a2 2 0 012 2v10a2 2 0 01-2 2h-7a2 2 0 01-2-2V9c0-1.2.9-2 2-2h7zm0 12V9h-7v10h7z" fill-rule="nonzero"/></svg>',
        'crop': '<svg width="24" height="24"><path d="M17 8v7h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v2c0 .6-.4 1-1 1a1 1 0 01-1-1v-2H7V9H5a1 1 0 110-2h2V5c0-.6.4-1 1-1s1 .4 1 1v2h7l3-3 1 1-3 3zM9 9v5l5-5H9zm1 6h5v-5l-5 5z" fill-rule="evenodd"/></svg>',
        'cut-column': '<svg width="24" height="24"><path fill-rule="evenodd" d="M7.2 4.5c.9 0 1.6.4 2.2 1A3.7 3.7 0 0110.5 8v.5l1 1 4-4 1-.5a3.3 3.3 0 012 0c.4 0 .7.3 1 .5L17 8h4v13h-6V10l-1.5 1.5.5.5v4l-2.5-2.5-1 1v.5c0 .4 0 .8-.3 1.2-.2.5-.4.9-.8 1.2-.6.7-1.3 1-2.2 1-.8.2-1.5 0-2-.6l-.5-.8-.2-1c0-.4 0-.8.3-1.2A3.9 3.9 0 017 12.7c.5-.2 1-.3 1.5-.2l1-1-1-1c-.5 0-1 0-1.5-.2-.5-.1-1-.4-1.4-.9-.4-.3-.6-.7-.8-1.2L4.5 7c0-.4 0-.7.2-1 0-.3.3-.6.5-.8.5-.5 1.2-.8 2-.7zm12.3 5h-3v10h3v-10zM8 13.8h-.3l-.4.2a2.8 2.8 0 00-.7.4v.1a2.8 2.8 0 00-.6.8l-.1.4v.7l.2.5.5.2h.7a2.6 2.6 0 00.8-.3 2.4 2.4 0 00.7-.7 2.5 2.5 0 00.3-.8 1.5 1.5 0 000-.8 1 1 0 00-.2-.4 1 1 0 00-.5-.2H8zm3.5-3.7c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4zM7 5.8h-.4a1 1 0 00-.5.3 1 1 0 00-.2.5v.7a2.5 2.5 0 00.3.8l.2.3h.1l.4.4.4.2.4.1h.7L9 9l.2-.4a1.6 1.6 0 000-.8 2.6 2.6 0 00-.3-.8A2.5 2.5 0 007.7 6l-.4-.1H7z"/></svg>',
        'cut-row': '<svg width="24" height="24"><path fill-rule="evenodd" d="M22 3v5H9l3 3 2-2h4l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8.7.6 1 1.3 1 2.2.2.8 0 1.5-.6 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 01-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 018.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 010-2c0-.4.3-.7.5-1l2 2V3h14zM8.5 15.3h-.3a2.6 2.6 0 00-.8.4 2.5 2.5 0 00-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 00.8-.3L9 18V18l.4-.4.2-.4.1-.4v-.3-.4a1 1 0 00-.2-.5 1 1 0 00-.4-.2h-.5zm7 0H15a1 1 0 00-.4.3 1 1 0 00-.2.5 1.5 1.5 0 000 .7v.4a2.8 2.8 0 00.5.7h.1a2.8 2.8 0 00.8.6l.4.1h.7l.5-.2.2-.5v-.4-.3a2.6 2.6 0 00-.3-.8 2.4 2.4 0 00-.7-.7 2.5 2.5 0 00-.8-.3h-.3zM12 11.6c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4zm8.5-7.1h-11v2h11v-2z"/></svg>',
        'cut': '<svg width="24" height="24"><path d="M18 15c.6.7 1 1.4 1 2.3 0 .8-.2 1.5-.7 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 01-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 018.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 010-2c0-.4.3-.7.5-1l6 6 6-6 .5 1a3.3 3.3 0 010 2c0 .4-.3.7-.5 1l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8zm-8.5 2.2l.1-.4v-.3-.4a1 1 0 00-.2-.5 1 1 0 00-.4-.2 1.6 1.6 0 00-.8 0 2.6 2.6 0 00-.8.3 2.5 2.5 0 00-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 00.8-.3 2.8 2.8 0 001-1zm2.5-2.8c.4 0 .7-.1 1-.4.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4s-.7.1-1 .4c-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4zm5.4 4l.2-.5v-.4-.3a2.6 2.6 0 00-.3-.8 2.4 2.4 0 00-.7-.7 2.5 2.5 0 00-.8-.3 1.5 1.5 0 00-.8 0 1 1 0 00-.4.2 1 1 0 00-.2.5 1.5 1.5 0 000 .7v.4l.3.4.3.4a2.8 2.8 0 00.8.5l.4.1h.7l.5-.2z" fill-rule="evenodd"/></svg>',
        'document-properties': '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 00-2 2v14c0 1.1.9 2 2 2h10a2 2 0 002-2V7.6L14.4 3zM17 19H7V5h6v4h4v10z" fill-rule="nonzero"/></svg>',
        'drag': '<svg width="24" height="24"><path d="M13 5h2v2h-2V5zm0 4h2v2h-2V9zM9 9h2v2H9V9zm4 4h2v2h-2v-2zm-4 0h2v2H9v-2zm0 4h2v2H9v-2zm4 0h2v2h-2v-2zM9 5h2v2H9V5z" fill-rule="evenodd"/></svg>',
        'duplicate-column': '<svg width="24" height="24"><path d="M17 6v16h-7V6h7zm-2 2h-3v12h3V8zm-2-6v2H8v15H6V2h7z"/></svg>',
        'duplicate-row': '<svg width="24" height="24"><path d="M22 11v7H6v-7h16zm-2 2H8v3h12v-3zm-1-6v2H4v5H2V7h17z"/></svg>',
        'duplicate': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M16 3v2H6v11H4V5c0-1.1.9-2 2-2h10zm3 8h-2V9h-7v10h9a2 2 0 01-2 2h-7a2 2 0 01-2-2V9c0-1.2.9-2 2-2h7a2 2 0 012 2v2z"/><path d="M17 14h1a1 1 0 010 2h-1v1a1 1 0 01-2 0v-1h-1a1 1 0 010-2h1v-1a1 1 0 012 0v1z"/></g></svg>',
        'edit-block': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19.8 8.8l-9.4 9.4c-.2.2-.5.4-.9.4l-5.4 1.2 1.2-5.4.5-.8 9.4-9.4c.7-.7 1.8-.7 2.5 0l2.1 2.1c.7.7.7 1.8 0 2.5zm-2-.2l1-.9v-.3l-2.2-2.2a.3.3 0 00-.3 0l-1 1L18 8.5zm-1 1l-2.5-2.4-6 6 2.5 2.5 6-6zm-7 7.1l-2.6-2.4-.3.3-.1.2-.7 3 3.1-.6h.1l.4-.5z"/></svg>',
        'edit-image': '<svg width="24" height="24"><path d="M18 16h2V7a2 2 0 00-2-2H7v2h11v9zM6 17h15a1 1 0 010 2h-1v1a1 1 0 01-2 0v-1H6a2 2 0 01-2-2V7H3a1 1 0 110-2h1V4a1 1 0 112 0v13zm3-5.3l1.3 2 3-4.7 3.7 6H7l2-3.3z" fill-rule="nonzero"/></svg>',
        'embed-page': '<svg width="24" height="24"><path d="M19 6V5H5v14h2A13 13 0 0119 6zm0 1.4c-.8.8-1.6 2.4-2.2 4.6H19V7.4zm0 5.6h-2.4c-.4 1.8-.6 3.8-.6 6h3v-6zm-4 6c0-2.2.2-4.2.6-6H13c-.7 1.8-1.1 3.8-1.1 6h3zm-4 0c0-2.2.4-4.2 1-6H9.6A12 12 0 008 19h3zM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 01-1-1V4c0-.6.4-1 1-1zm11.8 9c.4-1.9 1-3.4 1.8-4.5a9.2 9.2 0 00-4 4.5h2.2zm-3.4 0a12 12 0 012.8-4 12 12 0 00-5 4h2.2z" fill-rule="nonzero"/></svg>',
        'embed': '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 01-1-1V4c0-.6.4-1 1-1zm1 2v14h14V5H5zm4.8 2.6l5.6 4a.5.5 0 010 .8l-5.6 4A.5.5 0 019 16V8a.5.5 0 01.8-.4z" fill-rule="nonzero"/></svg>',
        'emoji': '<svg width="24" height="24"><path d="M9 11c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 00-1 1c0 .6.4 1 1 1zm6 0c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 00-1 1c0 .6.4 1 1 1zm-3 5.5c2.1 0 4-1.5 4.4-3.5H7.6c.5 2 2.3 3.5 4.4 3.5zM12 4a8 8 0 100 16 8 8 0 000-16zm0 14.5a6.5 6.5 0 110-13 6.5 6.5 0 010 13z" fill-rule="nonzero"/></svg>',
        'export': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M14.4 3L18 7v1h-5V5H7v14h9a1 1 0 012 0c0 1-.8 2-1.9 2H7c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2h7.5z"/><path d="M18.1 12c.5 0 .9.4.9 1 0 .5-.3 1-.8 1h-7.3c-.5 0-.9-.4-.9-1 0-.5.3-1 .8-1h7.3z"/><path d="M16.4 9.2a1 1 0 011.4.2l2.4 3.6-2.4 3.6a1 1 0 01-1.7-1v-.2l1.7-2.4-1.6-2.4a1 1 0 01.2-1.4z"/></g></svg>',
        'fill': '<svg width="24" height="26"><path d="M16.6 12l-9-9-1.4 1.4 2.4 2.4-5.2 5.1c-.5.6-.5 1.6 0 2.2L9 19.6a1.5 1.5 0 002.2 0l5.5-5.5c.5-.6.5-1.6 0-2.2zM5.2 13L10 8.2l4.8 4.8H5.2zM19 14.5s-2 2.2-2 3.5c0 1.1.9 2 2 2a2 2 0 002-2c0-1.3-2-3.5-2-3.5z" fill-rule="nonzero"/></svg>',
        'flip-horizontally': '<svg width="24" height="24"><path d="M14 19h2v-2h-2v2zm4-8h2V9h-2v2zM4 7v10c0 1.1.9 2 2 2h3v-2H6V7h3V5H6a2 2 0 00-2 2zm14-2v2h2a2 2 0 00-2-2zm-7 16h2V3h-2v18zm7-6h2v-2h-2v2zm-4-8h2V5h-2v2zm4 12a2 2 0 002-2h-2v2z" fill-rule="nonzero"/></svg>',
        'flip-vertically': '<svg width="24" height="24"><path d="M5 14v2h2v-2H5zm8 4v2h2v-2h-2zm4-14H7a2 2 0 00-2 2v3h2V6h10v3h2V6a2 2 0 00-2-2zm2 14h-2v2a2 2 0 002-2zM3 11v2h18v-2H3zm6 7v2h2v-2H9zm8-4v2h2v-2h-2zM5 18c0 1.1.9 2 2 2v-2H5z" fill-rule="nonzero"/></svg>',
        'format-painter': '<svg width="24" height="24"><path d="M18 5V4c0-.5-.4-1-1-1H5a1 1 0 00-1 1v4c0 .6.5 1 1 1h12c.6 0 1-.4 1-1V7h1v4H9v9c0 .6.4 1 1 1h2c.6 0 1-.4 1-1v-7h8V5h-3z" fill-rule="nonzero"/></svg>',
        'format': '<svg width="24" height="24"><path fill-rule="evenodd" d="M17 5a1 1 0 010 2h-4v11a1 1 0 01-2 0V7H7a1 1 0 110-2h10z"/></svg>',
        'fullscreen': '<svg width="24" height="24"><path d="M15.3 10l-1.2-1.3 2.9-3h-2.3a.9.9 0 110-1.7H19c.5 0 .9.4.9.9v4.4a.9.9 0 11-1.8 0V7l-2.9 3zm0 4l3 3v-2.3a.9.9 0 111.7 0V19c0 .5-.4.9-.9.9h-4.4a.9.9 0 110-1.8H17l-3-2.9 1.3-1.2zM10 15.4l-2.9 3h2.3a.9.9 0 110 1.7H5a.9.9 0 01-.9-.9v-4.4a.9.9 0 111.8 0V17l2.9-3 1.2 1.3zM8.7 10L5.7 7v2.3a.9.9 0 01-1.7 0V5c0-.5.4-.9.9-.9h4.4a.9.9 0 010 1.8H7l3 2.9-1.3 1.2z" fill-rule="nonzero"/></svg>',
        'gallery': '<svg width="24" height="24"><path fill-rule="nonzero" d="M5 15.7l2.3-2.2c.3-.3.7-.3 1 0L11 16l5.1-5c.3-.4.8-.4 1 0l2 1.9V8H5v7.7zM5 18V19h3l1.8-1.9-2-2L5 17.9zm14-3l-2.5-2.4-6.4 6.5H19v-4zM4 6h16c.6 0 1 .4 1 1v13c0 .6-.4 1-1 1H4a1 1 0 01-1-1V7c0-.6.4-1 1-1zm6 7a2 2 0 110-4 2 2 0 010 4zM4.5 4h15a.5.5 0 110 1h-15a.5.5 0 010-1zm2-2h11a.5.5 0 110 1h-11a.5.5 0 010-1z"/></svg>',
        'gamma': '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 01-1-1V4c0-.6.4-1 1-1zm1 2v14h14V5H5zm6.5 11.8V14L9.2 8.7a5.1 5.1 0 00-.4-.8l-.1-.2H8 8v-1l.3-.1.3-.1h.7a1 1 0 01.6.5l.1.3a8.5 8.5 0 01.3.6l1.9 4.6 2-5.2a1 1 0 011-.6.5.5 0 01.5.6L13 14v2.8a.7.7 0 01-1.4 0z" fill-rule="nonzero"/></svg>',
        'help': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M12 5.5a6.5 6.5 0 00-6 9 6.3 6.3 0 001.4 2l1 1a6.3 6.3 0 003.6 1 6.5 6.5 0 006-9 6.3 6.3 0 00-1.4-2l-1-1a6.3 6.3 0 00-3.6-1zM12 4a7.8 7.8 0 015.7 2.3A8 8 0 1112 4z"/><path d="M9.6 9.7a.7.7 0 01-.7-.8c0-1.1 1.5-1.8 3.2-1.8 1.8 0 3.2.8 3.2 2.4 0 1.4-.4 2.1-1.5 2.8-.2 0-.3.1-.3.2a2 2 0 00-.8.8.8.8 0 01-1.4-.6c.3-.7.8-1 1.3-1.5l.4-.2c.7-.4.8-.6.8-1.5 0-.5-.6-.9-1.7-.9-.5 0-1 .1-1.4.3-.2 0-.3.1-.3.2v-.2c0 .4-.4.8-.8.8z" fill-rule="nonzero"/><circle cx="12" cy="16" r="1"/></g></svg>',
        'highlight-bg-color': '<svg width="24" height="24"><g fill-rule="evenodd"><path id="tox-icon-highlight-bg-color__color" d="M3 18h18v3H3z"/><path fill-rule="nonzero" d="M7.7 16.7H3l3.3-3.3-.7-.8L10.2 8l4 4.1-4 4.2c-.2.2-.6.2-.8 0l-.6-.7-1.1 1.1zm5-7.5L11 7.4l3-2.9a2 2 0 012.6 0L18 6c.7.7.7 2 0 2.7l-2.9 2.9-1.8-1.8-.5-.6"/></g></svg>',
        'home': '<svg width="24" height="24"><path fill-rule="nonzero" d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>',
        'horizontal-rule': '<svg width="24" height="24"><path d="M4 11h16v2H4z" fill-rule="evenodd"/></svg>',
        'image-options': '<svg width="24" height="24"><path d="M6 10a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2zm12 0a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2zm-6 0a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2z" fill-rule="nonzero"/></svg>',
        'image': '<svg width="24" height="24"><path d="M5 15.7l3.3-3.2c.3-.3.7-.3 1 0L12 15l4.1-4c.3-.4.8-.4 1 0l2 1.9V5H5v10.7zM5 18V19h3l2.8-2.9-2-2L5 17.9zm14-3l-2.5-2.4-6.4 6.5H19v-4zM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 01-1-1V4c0-.6.4-1 1-1zm6 8a2 2 0 100-4 2 2 0 000 4z" fill-rule="nonzero"/></svg>',
        'indent': '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 110-2zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 010-2zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 010-2zm-5 4h12a1 1 0 010 2H7a1 1 0 010-2zm-2.6-3.8L6.2 12l-1.8-1.2a1 1 0 011.2-1.6l3 2a1 1 0 010 1.6l-3 2a1 1 0 11-1.2-1.6z" fill-rule="evenodd"/></svg>',
        'info': '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 015.7 2.3A8 8 0 1112 4zm-1 3v2h2V7h-2zm3 10v-1h-1v-5h-3v1h1v4h-1v1h4z" fill-rule="evenodd"/></svg>',
        'insert-character': '<svg width="24" height="24"><path d="M15 18h4l1-2v4h-6v-3.3l1.4-1a6 6 0 001.8-2.9 6.3 6.3 0 00-.1-4.1 5.8 5.8 0 00-3-3.2c-.6-.3-1.3-.5-2.1-.5a5.1 5.1 0 00-3.9 1.8 6.3 6.3 0 00-1.3 6 6.2 6.2 0 001.8 3l1.4.9V20H4v-4l1 2h4v-.5l-2-1L5.4 15A6.5 6.5 0 014 11c0-1 .2-1.9.6-2.7A7 7 0 016.3 6C7.1 5.4 8 5 9 4.5c1-.3 2-.5 3.1-.5a8.8 8.8 0 015.7 2 7 7 0 011.7 2.3 6 6 0 01.2 4.8c-.2.7-.6 1.3-1 1.9a7.6 7.6 0 01-3.6 2.5v.5z" fill-rule="evenodd"/></svg>',
        'insert-time': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M12 19a7 7 0 100-14 7 7 0 000 14zm0 2a9 9 0 110-18 9 9 0 010 18z"/><path d="M16 12h-3V7c0-.6-.4-1-1-1a1 1 0 00-1 1v7h5c.6 0 1-.4 1-1s-.4-1-1-1z"/></g></svg>',
        'invert': '<svg width="24" height="24"><path d="M18 19.3L16.5 18a5.8 5.8 0 01-3.1 1.9 6.1 6.1 0 01-5.5-1.6A5.8 5.8 0 016 14v-.3l.1-1.2A13.9 13.9 0 017.7 9l-3-3 .7-.8 2.8 2.9 9 8.9 1.5 1.6-.7.6zm0-5.5v.3l-.1 1.1-.4 1-1.2-1.2a4.3 4.3 0 00.2-1v-.2c0-.4 0-.8-.2-1.3l-.5-1.4a14.8 14.8 0 00-3-4.2L12 6a26.1 26.1 0 00-2.2 2.5l-1-1a20.9 20.9 0 012.9-3.3L12 4l1 .8a22.2 22.2 0 014 5.4c.6 1.2 1 2.4 1 3.6z" fill-rule="evenodd"/></svg>',
        'italic': '<svg width="24" height="24"><path d="M16.7 4.7l-.1.9h-.3c-.6 0-1 0-1.4.3-.3.3-.4.6-.5 1.1l-2.1 9.8v.6c0 .5.4.8 1.4.8h.2l-.2.8H8l.2-.8h.2c1.1 0 1.8-.5 2-1.5l2-9.8.1-.5c0-.6-.4-.8-1.4-.8h-.3l.2-.9h5.8z" fill-rule="evenodd"/></svg>',
        'language': '<svg width="24" height="24"><path d="M12 3a9 9 0 110 18 9 9 0 010-18zm4.3 13.3c-.5 1-1.2 2-2 2.9a7.5 7.5 0 003.2-2.1l-.2-.2a6 6 0 00-1-.6zm-8.6 0c-.5.2-.9.5-1.2.8.9 1 2 1.7 3.2 2a10 10 0 01-2-2.8zm3.6-.8c-.8 0-1.6.1-2.2.3.5 1 1.2 1.9 2.1 2.7zm1.5 0v3c.9-.8 1.6-1.7 2.1-2.7-.6-.2-1.4-.3-2.1-.3zm-6-2.7H4.5c.2 1 .5 2.1 1 3h.3l1.3-1a10 10 0 01-.3-2zm12.7 0h-2.3c0 .7-.1 1.4-.3 2l1.6 1.1c.5-1 .9-2 1-3.1zm-3.8 0h-3V14c1 0 2 .1 2.7.4.2-.5.3-1 .3-1.6zm-4.4 0h-3l.3 1.6c.8-.3 1.7-.4 2.7-.4v-1.3zm-5.5-5c-.7 1-1.1 2.2-1.3 3.5h2.3c0-1 .2-1.8.5-2.6l-1.5-1zm2.9 1.4v.1c-.2.6-.4 1.3-.4 2h3V9.4c-1 0-1.8-.1-2.6-.3zm6.6 0h-.1l-2.4.3v1.8h3l-.5-2.1zm3-1.4l-.3.1-1.3.8c.3.8.5 1.6.5 2.6h2.3a7.5 7.5 0 00-1.3-3.5zm-9 0l2 .2V5.5a9 9 0 00-2 2.2zm3.5-2.3V8c.6 0 1.3 0 1.9-.2a9 9 0 00-2-2.3zm-3-.7h-.1c-1.1.4-2.1 1-3 1.8l1.2.7a10 10 0 011.9-2.5zm4.4 0l.1.1a10 10 0 011.8 2.4l1.1-.7a7.5 7.5 0 00-3-1.8z"/></svg>',
        'line-height': '<svg width="24" height="24"><path d="M21 5a1 1 0 01.1 2H13a1 1 0 01-.1-2H21zm0 4a1 1 0 01.1 2H13a1 1 0 01-.1-2H21zm0 4a1 1 0 01.1 2H13a1 1 0 01-.1-2H21zm0 4a1 1 0 01.1 2H13a1 1 0 01-.1-2H21zM7 3.6l3.7 3.7a1 1 0 01-1.3 1.5h-.1L8 7.3v9.2l1.3-1.3a1 1 0 011.3 0h.1c.4.4.4 1 0 1.3v.1L7 20.4l-3.7-3.7a1 1 0 011.3-1.5h.1L6 16.7V7.4L4.7 8.7a1 1 0 01-1.3 0h-.1a1 1 0 010-1.3v-.1L7 3.6z"/></svg>',
        'line': '<svg width="24" height="24"><path d="M15 9l-8 8H4v-3l8-8 3 3zm1-1l-3-3 1-1h1c-.2 0 0 0 0 0l2 2s0 .2 0 0v1l-1 1zM4 18h16v2H4v-2z" fill-rule="evenodd"/></svg>',
        'link': '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 011.4 1.4l-2.1 2a2 2 0 102.7 2.8l4.8-4.8a1 1 0 000-1.4 1 1 0 111.4-1.3 2.9 2.9 0 010 4L9.6 20a3.9 3.9 0 01-5.5-5.5l2-2zm11.6-.6a1 1 0 01-1.4-1.4l2-2a2 2 0 10-2.6-2.8L11 10.3a1 1 0 000 1.4A1 1 0 119.6 13a2.9 2.9 0 010-4L14.4 4a3.9 3.9 0 015.5 5.5l-2 2z" fill-rule="nonzero"/></svg>',
        'list-bull-circle': '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M11 16a2 2 0 100-4 2 2 0 000 4zm0 1a3 3 0 110-6 3 3 0 010 6zM11 26a2 2 0 100-4 2 2 0 000 4zm0 1a3 3 0 110-6 3 3 0 010 6zM11 36a2 2 0 100-4 2 2 0 000 4zm0 1a3 3 0 110-6 3 3 0 010 6z" fill-rule="nonzero"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
        'list-bull-default': '<svg width="48" height="48"><g fill-rule="evenodd"><circle cx="11" cy="14" r="3"/><circle cx="11" cy="24" r="3"/><circle cx="11" cy="34" r="3"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
        'list-bull-square': '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M8 11h6v6H8zM8 21h6v6H8zM8 31h6v6H8z"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
        'list-num-default-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 17v-4.8l-1.6 1v-1.1l1.6-1h1.2V17zM33.3 17.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm1.7 5.7c0-1.2 1-2 2.2-2 1.3 0 2.1.8 2.1 1.8 0 .7-.3 1.2-1.3 2.2l-1.2 1v.2h2.6v1h-4.3v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H35zm-1.7 4.3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm3.2 7.3v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H35c0-1.1 1-1.8 2.2-1.8 1.2 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.7.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .6 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm-3.3 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z"/></g></svg>',
        'list-num-default': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10 17v-4.8l-1.5 1v-1.1l1.6-1h1.2V17h-1.2zm3.6.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zm-5 5.7c0-1.2.8-2 2.1-2s2.1.8 2.1 1.8c0 .7-.3 1.2-1.4 2.2l-1.1 1v.2h2.6v1H8.6v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H8.5zm6.3 4.3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zM10 34.4v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H8.6c0-1.1 1-1.8 2.2-1.8 1.3 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.8.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .7 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm4.7 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z"/></g></svg>',
        'list-num-lower-alpha-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M36.5 16c-.9 0-1.5-.5-1.5-1.3s.6-1.3 1.8-1.4h1v-.4c0-.4-.2-.6-.7-.6-.4 0-.7.1-.8.4h-1.1c0-.8.8-1.4 2-1.4S39 12 39 13V16h-1.2v-.6c-.3.4-.8.7-1.4.7zm.4-.8c.6 0 1-.4 1-.9V14h-1c-.5.1-.7.3-.7.6 0 .4.3.6.7.6zM33.1 16.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zM37.7 26c-.7 0-1.2-.2-1.5-.7v.7H35v-6.3h1.2v2.5c.3-.5.8-.9 1.5-.9 1.1 0 1.8 1 1.8 2.4 0 1.5-.7 2.4-1.8 2.4zm-.5-3.6c-.6 0-1 .5-1 1.3s.4 1.4 1 1.4c.7 0 1-.6 1-1.4 0-.8-.3-1.3-1-1.3zM33.2 26.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm6 7h-1c-.1-.5-.4-.8-1-.8s-1 .5-1 1.4c0 1 .4 1.4 1 1.4.5 0 .9-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm-6.1 3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
        'list-num-lower-alpha': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.3 15.2c.5 0 1-.4 1-.9V14h-1c-.5.1-.8.3-.8.6 0 .4.3.6.8.6zm-.4.9c-1 0-1.5-.6-1.5-1.4 0-.8.6-1.3 1.7-1.4h1.1v-.4c0-.4-.2-.6-.7-.6-.5 0-.8.1-.9.4h-1c0-.8.8-1.4 2-1.4 1.1 0 1.8.6 1.8 1.6V16h-1.1v-.6h-.1c-.2.4-.7.7-1.3.7zm4.6 0c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm-3.2 10c-.6 0-1.2-.3-1.4-.8v.7H8.5v-6.3H10v2.5c.3-.5.8-.9 1.4-.9 1.2 0 1.9 1 1.9 2.4 0 1.5-.7 2.4-1.9 2.4zm-.4-3.7c-.7 0-1 .5-1 1.3s.3 1.4 1 1.4c.6 0 1-.6 1-1.4 0-.8-.4-1.3-1-1.3zm4 3.7c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm-2.2 7h-1.2c0-.5-.4-.8-.9-.8-.6 0-1 .5-1 1.4 0 1 .4 1.4 1 1.4.5 0 .8-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm1.8 3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
        'list-num-lower-greek-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 16c-1.2 0-2-.8-2-2.3 0-1.5.8-2.4 2-2.4.6 0 1 .4 1.3 1v-.9H40v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1-.7h-.2c-.2.4-.7.8-1.3.8zm.3-1c.6 0 1-.5 1-1.3s-.4-1.3-1-1.3-1 .5-1 1.3.4 1.4 1 1.4zM33.3 16.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zM36 21.9c0-1.5.8-2.3 2.1-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.9 1.3.9.3 1.3.8 1.3 1.7 0 1.2-.7 1.9-1.8 1.9-.6 0-1.1-.3-1.4-.8v2.2H36V22zm1.8 1.2v-1h.3c.5 0 .9-.2.9-.7 0-.5-.3-.8-.9-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1 1.3s1-.4 1-1-.4-1-1.2-1h-.3zM33.3 26.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zM37.1 34.6L34.8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.2.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2zm.7 1a2 2 0 00-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1zM33.3 36.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
        'list-num-lower-greek': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.5 15c.7 0 1-.5 1-1.3s-.3-1.3-1-1.3c-.5 0-.9.5-.9 1.3s.4 1.4 1 1.4zm-.3 1c-1.1 0-1.8-.8-1.8-2.3 0-1.5.7-2.4 1.8-2.4.7 0 1.1.4 1.3 1h.1v-.9h1.2v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1.1-.7h-.1c-.2.4-.7.8-1.4.8zm5 .1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm-4.9 7v-1h.3c.6 0 1-.2 1-.7 0-.5-.4-.8-1-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1.1 1.3.6 0 1-.4 1-1s-.5-1-1.3-1h-.3zM8.6 22c0-1.5.7-2.3 2-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.8 1.3.8.3 1.3.8 1.3 1.7 0 1.2-.8 1.9-1.9 1.9-.6 0-1.1-.3-1.3-.8v2.2H8.5V22zm6.2 4.2c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zm-4.5 8.5L8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.1.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2zm.7 1a2 2 0 00-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1zm4.5.5c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
        'list-num-lower-roman-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M32.9 16v-1.2h-1.3V16H33zm0 10v-1.2h-1.3V26H33zm0 10v-1.2h-1.3V36H33z"/><path fill-rule="nonzero" d="M36 21h-1.5v5H36zM36 31h-1.5v5H36zM39 21h-1.5v5H39zM39 31h-1.5v5H39zM42 31h-1.5v5H42zM36 11h-1.5v5H36zM36 19h-1.5v1H36zM36 29h-1.5v1H36zM39 19h-1.5v1H39zM39 29h-1.5v1H39zM42 29h-1.5v1H42zM36 9h-1.5v1H36z"/></g></svg>',
        'list-num-lower-roman': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 16v-1.2h1.3V16H15zm0 10v-1.2h1.3V26H15zm0 10v-1.2h1.3V36H15z"/><path fill-rule="nonzero" d="M12 21h1.5v5H12zM12 31h1.5v5H12zM9 21h1.5v5H9zM9 31h1.5v5H9zM6 31h1.5v5H6zM12 11h1.5v5H12zM12 19h1.5v1H12zM12 29h1.5v1H12zM9 19h1.5v1H9zM9 29h1.5v1H9zM6 29h1.5v1H6zM12 9h1.5v1H12z"/></g></svg>',
        'list-num-upper-alpha-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M39.3 17l-.5-1.4h-2l-.5 1.4H35l2-6h1.6l2 6h-1.3zm-1.6-4.7l-.7 2.3h1.6l-.8-2.3zM33.4 17c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zm4.7 9.9h-2.7v-6H38c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7zm-1.4-5v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1zm0 4h1.1c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9h-1.1V26zM33 27.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm4.9 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2zm-4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
        'list-num-upper-alpha': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M12.6 17l-.5-1.4h-2L9.5 17H8.3l2-6H12l2 6h-1.3zM11 12.3l-.7 2.3h1.6l-.8-2.3zm4.7 4.8c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zM11.4 27H8.7v-6h2.6c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7zM10 22v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1zm0 4H11c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9H10V26zm5.4 1.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm-4.1 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2zm4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
        'list-num-upper-roman-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M31.6 17v-1.2H33V17h-1.3zm0 10v-1.2H33V27h-1.3zm0 10v-1.2H33V37h-1.3z"/><path fill-rule="nonzero" d="M34.5 20H36v7h-1.5zM34.5 30H36v7h-1.5zM37.5 20H39v7h-1.5zM37.5 30H39v7h-1.5zM40.5 30H42v7h-1.5zM34.5 10H36v7h-1.5z"/></g></svg>',
        'list-num-upper-roman': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 17v-1.2h1.3V17H15zm0 10v-1.2h1.3V27H15zm0 10v-1.2h1.3V37H15z"/><path fill-rule="nonzero" d="M12 20h1.5v7H12zM12 30h1.5v7H12zM9 20h1.5v7H9zM9 30h1.5v7H9zM6 30h1.5v7H6zM12 10h1.5v7H12z"/></g></svg>',
        'lock': '<svg width="24" height="24"><path d="M16.3 11c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 01-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H8V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h.3zM10 8v3h4V8a1 1 0 00-.3-.7A1 1 0 0013 7h-2a1 1 0 00-.7.3 1 1 0 00-.3.7z" fill-rule="evenodd"/></svg>',
        'ltr': '<svg width="24" height="24"><path d="M11 5h7a1 1 0 010 2h-1v11a1 1 0 01-2 0V7h-2v11a1 1 0 01-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 017.8 10a3.3 3.3 0 010-2.8 3.4 3.4 0 011.8-1.8L11 5zM4.4 16.2L6.2 15l-1.8-1.2a1 1 0 011.2-1.6l3 2a1 1 0 010 1.6l-3 2a1 1 0 11-1.2-1.6z" fill-rule="evenodd"/></svg>',
        'more-drawer': '<svg width="24" height="24"><path d="M6 10a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2zm12 0a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2zm-6 0a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2z" fill-rule="nonzero"/></svg>',
        'new-document': '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 00-2 2v14c0 1.1.9 2 2 2h10a2 2 0 002-2V7.6L14.4 3zM17 19H7V5h6v4h4v10z" fill-rule="nonzero"/></svg>',
        'new-tab': '<svg width="24" height="24"><path d="M15 13l2-2v8H5V7h8l-2 2H7v8h8v-4zm4-8v5.5l-2-2-5.6 5.5H10v-1.4L15.5 7l-2-2H19z" fill-rule="evenodd"/></svg>',
        'non-breaking': '<svg width="24" height="24"><path d="M11 11H8a1 1 0 110-2h3V6c0-.6.4-1 1-1s1 .4 1 1v3h3c.6 0 1 .4 1 1s-.4 1-1 1h-3v3c0 .6-.4 1-1 1a1 1 0 01-1-1v-3zm10 4v5H3v-5c0-.6.4-1 1-1s1 .4 1 1v3h14v-3c0-.6.4-1 1-1s1 .4 1 1z" fill-rule="evenodd"/></svg>',
        'notice': '<svg width="24" height="24"><path d="M17.8 9.8L15.4 4 20 8.5v7L15.5 20h-7L4 15.5v-7L8.5 4h7l2.3 5.8zm0 0l2.2 5.7-2.3-5.8zM13 17v-2h-2v2h2zm0-4V7h-2v6h2z" fill-rule="evenodd"/></svg>',
        'ordered-list-rtl': '<svg width="24" height="24"><path d="M6 17h8a1 1 0 010 2H6a1 1 0 010-2zm0-6h8a1 1 0 010 2H6a1 1 0 010-2zm0-6h8a1 1 0 010 2H6a1 1 0 110-2zm13-1v3.5a.5.5 0 11-1 0V5h-.5a.5.5 0 110-1H19zm-1 8.8l.2.2h1.3a.5.5 0 110 1h-1.6a1 1 0 01-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 00-.2-.2h-1.3a.5.5 0 01-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3zm2 4.2v2c0 .6-.4 1-1 1h-1.5a.5.5 0 010-1h1.2a.3.3 0 100-.6h-1.3a.4.4 0 110-.8h1.3a.3.3 0 000-.6h-1.2a.5.5 0 110-1H19c.6 0 1 .4 1 1z" fill-rule="evenodd"/></svg>',
        'ordered-list': '<svg width="24" height="24"><path d="M10 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 110-2zM6 4v3.5c0 .3-.2.5-.5.5a.5.5 0 01-.5-.5V5h-.5a.5.5 0 010-1H6zm-1 8.8l.2.2h1.3c.3 0 .5.2.5.5s-.2.5-.5.5H4.9a1 1 0 01-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 00-.2-.2H4.5a.5.5 0 01-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3zM7 17v2c0 .6-.4 1-1 1H4.5a.5.5 0 010-1h1.2c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.4a.4.4 0 110-.8h1.3c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.5a.5.5 0 110-1H6c.6 0 1 .4 1 1z" fill-rule="evenodd"/></svg>',
        'orientation': '<svg width="24" height="24"><path d="M7.3 6.4L1 13l6.4 6.5 6.5-6.5-6.5-6.5zM3.7 13l3.6-3.7L11 13l-3.7 3.7-3.6-3.7zM12 6l2.8 2.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0L9.2 5.7a.8.8 0 010-1.2L13.6.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L12 4h1a9 9 0 11-4.3 16.9l1.5-1.5A7 7 0 1013 6h-1z" fill-rule="nonzero"/></svg>',
        'outdent': '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 110-2zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 010-2zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 010-2zm-5 4h12a1 1 0 010 2H7a1 1 0 010-2zm1.6-3.8a1 1 0 01-1.2 1.6l-3-2a1 1 0 010-1.6l3-2a1 1 0 011.2 1.6L6.8 12l1.8 1.2z" fill-rule="evenodd"/></svg>',
        'page-break': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M5 11c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 010-2zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 010-2zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 010-2zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1h-1a1 1 0 010-2zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 010-2zM7 3v5h10V3c0-.6.4-1 1-1s1 .4 1 1v7H5V3c0-.6.4-1 1-1s1 .4 1 1zM6 22a1 1 0 01-1-1v-7h14v7c0 .6-.4 1-1 1a1 1 0 01-1-1v-5H7v5c0 .6-.4 1-1 1z"/></g></svg>',
        'paragraph': '<svg width="24" height="24"><path fill-rule="evenodd" d="M10 5h7a1 1 0 010 2h-1v11a1 1 0 01-2 0V7h-2v11a1 1 0 01-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 016.8 10a3.3 3.3 0 010-2.8 3.4 3.4 0 011.8-1.8L10 5z"/></svg>',
        'paste-column-after': '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 012.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v13h7v2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0112 1zm8 7v12h-6V8h6zm-1.5 1.5h-3v9h3v-9zM12 3a1 1 0 100 2 1 1 0 000-2z"/></svg>',
        'paste-column-before': '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 012.8 2H18c1 0 2 .8 2 1.9V18c0 1-.8 2-1.9 2H11v-2h7V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v2H4V5c0-1 .8-2 1.9-2H9.2A3 3 0 0112 1zm-2 7v12H4V8h6zM8.5 9.5h-3v9h3v-9zM12 3a1 1 0 100 2 1 1 0 000-2z"/></svg>',
        'paste-row-after': '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 012.8 2H18c1 0 2 .8 2 1.9V11h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v13h14c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0112 1zm10 11v5H8v-5h14zm-1.5 1.5h-11v2h11v-2zM12 3a1 1 0 100 2 1 1 0 000-2z"/></svg>',
        'paste-row-before': '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 012.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v13h12v-4h2v4c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0112 1zm10 7v5H8V8h14zm-1.5 1.5h-11v2h11v-2zM12 3a1 1 0 100 2 1 1 0 000-2z"/></svg>',
        'paste-text': '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v13h3V9h9zM9 20H6a2 2 0 01-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0112 1a3 3 0 012.8 2H18a2 2 0 012 2v4h1v12H9v-1zm1.5-9.5v9h9v-9h-9zM12 3a1 1 0 00-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1zm0 9h6v2h-.5l-.5-1h-1v4h.8v1h-3.6v-1h.8v-4h-1l-.5 1H12v-2z" fill-rule="nonzero"/></svg>',
        'paste': '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v13h3V9h9zM9 20H6a2 2 0 01-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0112 1a3 3 0 012.8 2H18a2 2 0 012 2v4h1v12H9v-1zm1.5-9.5v9h9v-9h-9zM12 3a1 1 0 00-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1z" fill-rule="nonzero"/></svg>',
        'permanent-pen': '<svg width="24" height="24"><path d="M10.5 17.5L8 20H3v-3l3.5-3.5a2 2 0 010-3L14 3l1 1-7.3 7.3a1 1 0 000 1.4l3.6 3.6c.4.4 1 .4 1.4 0L20 9l1 1-7.6 7.6a2 2 0 01-2.8 0l-.1-.1z" fill-rule="nonzero"/></svg>',
        'plus': '<svg width="24" height="24"><path d="M12 4c.5 0 1 .4 1 .9V11h6a1 1 0 01.1 2H13v6a1 1 0 01-2 .1V13H5a1 1 0 01-.1-2H11V5c0-.6.4-1 1-1z"/></svg>',
        'preferences': '<svg width="24" height="24"><path d="M20.1 13.5l-1.9.2a5.8 5.8 0 01-.6 1.5l1.2 1.5c.4.4.3 1 0 1.4l-.7.7a1 1 0 01-1.4 0l-1.5-1.2a6.2 6.2 0 01-1.5.6l-.2 1.9c0 .5-.5.9-1 .9h-1a1 1 0 01-1-.9l-.2-1.9a5.8 5.8 0 01-1.5-.6l-1.5 1.2a1 1 0 01-1.4 0l-.7-.7a1 1 0 010-1.4l1.2-1.5a6.2 6.2 0 01-.6-1.5l-1.9-.2a1 1 0 01-.9-1v-1c0-.5.4-1 .9-1l1.9-.2a5.8 5.8 0 01.6-1.5L5.2 7.3a1 1 0 010-1.4l.7-.7a1 1 0 011.4 0l1.5 1.2a6.2 6.2 0 011.5-.6l.2-1.9c0-.5.5-.9 1-.9h1c.5 0 1 .4 1 .9l.2 1.9a5.8 5.8 0 011.5.6l1.5-1.2a1 1 0 011.4 0l.7.7c.3.4.4 1 0 1.4l-1.2 1.5a6.2 6.2 0 01.6 1.5l1.9.2c.5 0 .9.5.9 1v1c0 .5-.4 1-.9 1zM12 15a3 3 0 100-6 3 3 0 000 6z" fill-rule="evenodd"/></svg>',
        'preview': '<svg width="24" height="24"><path d="M3.5 12.5c.5.8 1.1 1.6 1.8 2.3 2 2 4.2 3.2 6.7 3.2s4.7-1.2 6.7-3.2a16.2 16.2 0 002.1-2.8 15.7 15.7 0 00-2.1-2.8c-2-2-4.2-3.2-6.7-3.2a9.3 9.3 0 00-6.7 3.2A16.2 16.2 0 003.2 12c0 .2.2.3.3.5zm-2.4-1l.7-1.2L4 7.8C6.2 5.4 8.9 4 12 4c3 0 5.8 1.4 8.1 3.8a18.2 18.2 0 012.8 3.7v1l-.7 1.2-2.1 2.5c-2.3 2.4-5 3.8-8.1 3.8-3 0-5.8-1.4-8.1-3.8a18.2 18.2 0 01-2.8-3.7 1 1 0 010-1zm12-3.3a2 2 0 102.7 2.6 4 4 0 11-2.6-2.6z" fill-rule="nonzero"/></svg>',
        'print': '<svg width="24" height="24"><path d="M18 8H6a3 3 0 00-3 3v6h2v3h14v-3h2v-6a3 3 0 00-3-3zm-1 10H7v-4h10v4zm.5-5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5 1.5.7 1.5 1.5-.7 1.5-1.5 1.5zm.5-8H6v2h12V5z" fill-rule="nonzero"/></svg>',
        'quote': '<svg width="24" height="24"><path d="M7.5 17h.9c.4 0 .7-.2.9-.6L11 13V8c0-.6-.4-1-1-1H6a1 1 0 00-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 00.8 1.3zm8 0h.9c.4 0 .7-.2.9-.6L19 13V8c0-.6-.4-1-1-1h-4a1 1 0 00-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 00.8 1.3z" fill-rule="nonzero"/></svg>',
        'redo': '<svg width="24" height="24"><path d="M17.6 10H12c-2.8 0-4.4 1.4-4.9 3.5-.4 2 .3 4 1.4 4.6a1 1 0 11-1 1.8c-2-1.2-2.9-4.1-2.3-6.8.6-3 3-5.1 6.8-5.1h5.6l-3.3-3.3a1 1 0 111.4-1.4l5 5a1 1 0 010 1.4l-5 5a1 1 0 01-1.4-1.4l3.3-3.3z" fill-rule="nonzero"/></svg>',
        'reload': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M5 22.1l-1.2-4.7v-.2a1 1 0 011-1l5 .4a1 1 0 11-.2 2l-2.2-.2a7.8 7.8 0 008.4.2 7.5 7.5 0 003.5-6.4 1 1 0 112 0 9.5 9.5 0 01-4.5 8 9.9 9.9 0 01-10.2 0l.4 1.4a1 1 0 11-2 .5zM13.6 7.4c0-.5.5-1 1-.9l2.8.2a8 8 0 00-9.5-1 7.5 7.5 0 00-3.6 7 1 1 0 01-2 0 9.5 9.5 0 014.5-8.6 10 10 0 0110.9.3l-.3-1a1 1 0 012-.5l1.1 4.8a1 1 0 01-1 1.2l-5-.4a1 1 0 01-.9-1z"/></g></svg>',
        'remove-formatting': '<svg width="24" height="24"><path d="M13.2 6a1 1 0 010 .2l-2.6 10a1 1 0 01-1 .8h-.2a.8.8 0 01-.8-1l2.6-10H8a1 1 0 110-2h9a1 1 0 010 2h-3.8zM5 18h7a1 1 0 010 2H5a1 1 0 010-2zm13 1.5L16.5 18 15 19.5a.7.7 0 01-1-1l1.5-1.5-1.5-1.5a.7.7 0 011-1l1.5 1.5 1.5-1.5a.7.7 0 011 1L17.5 17l1.5 1.5a.7.7 0 01-1 1z" fill-rule="evenodd"/></svg>',
        'remove': '<svg width="24" height="24"><path d="M16 7h3a1 1 0 010 2h-1v9a3 3 0 01-3 3H9a3 3 0 01-3-3V9H5a1 1 0 110-2h3V6a3 3 0 013-3h2a3 3 0 013 3v1zm-2 0V6c0-.6-.4-1-1-1h-2a1 1 0 00-1 1v1h4zm2 2H8v9c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V9zm-7 3a1 1 0 012 0v4a1 1 0 01-2 0v-4zm4 0a1 1 0 012 0v4a1 1 0 01-2 0v-4z" fill-rule="nonzero"/></svg>',
        'resize-handle': '<svg width="10" height="10"><g fill-rule="nonzero"><path d="M8.1 1.1A.5.5 0 119 2l-7 7A.5.5 0 111 8l7-7zM8.1 5.1A.5.5 0 119 6l-3 3A.5.5 0 115 8l3-3z"/></g></svg>',
        'resize': '<svg width="24" height="24"><path d="M4 5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h6c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 01-.7.3H7.4L18 16.6V13c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v6c0 .3-.1.5-.3.7a1 1 0 01-.7.3h-6a1 1 0 01-.7-.3 1 1 0 01-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3.6L6 7.4V11c0 .3-.1.5-.3.7a1 1 0 01-.7.3 1 1 0 01-.7-.3A1 1 0 014 11V5z" fill-rule="evenodd"/></svg>',
        'restore-draft': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1z"/><path d="M4.7 10H9a1 1 0 010 2H3a1 1 0 01-1-1V5a1 1 0 112 0v3l2.5-2.4a9.2 9.2 0 0110.8-1.5A9 9 0 0113.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 111.3-1.5 7.2 7.2 0 0011.6-3.7 7 7 0 00-3.5-7.7A7.2 7.2 0 008 7L4.7 10z" fill-rule="nonzero"/></g></svg>',
        'rotate-left': '<svg width="24" height="24"><path d="M4.7 10H9a1 1 0 010 2H3a1 1 0 01-1-1V5a1 1 0 112 0v3l2.5-2.4a9.2 9.2 0 0110.8-1.5A9 9 0 0113.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 111.3-1.5 7.2 7.2 0 0011.6-3.7 7 7 0 00-3.5-7.7A7.2 7.2 0 008 7L4.7 10z" fill-rule="nonzero"/></svg>',
        'rotate-right': '<svg width="24" height="24"><path d="M20 8V5a1 1 0 012 0v6c0 .6-.4 1-1 1h-6a1 1 0 010-2h4.3L16 7A7.2 7.2 0 007.7 6a7 7 0 003 13.1c1.9.1 3.7-.5 5-1.7a1 1 0 011.4 1.5A9.2 9.2 0 012.2 14c-.9-3.9 1-8 4.5-9.9 3.5-1.9 8-1.3 10.8 1.5L20 8z" fill-rule="nonzero"/></svg>',
        'rtl': '<svg width="24" height="24"><path d="M8 5h8v2h-2v12h-2V7h-2v12H8v-7c-.5 0-1 0-1.4-.3A3.4 3.4 0 014.8 10a3.3 3.3 0 010-2.8 3.4 3.4 0 011.8-1.8L8 5zm12 11.2a1 1 0 11-1 1.6l-3-2a1 1 0 010-1.6l3-2a1 1 0 111 1.6L18.4 15l1.8 1.2z" fill-rule="evenodd"/></svg>',
        'save': '<svg width="24" height="24"><path d="M5 16h14a2 2 0 012 2v2a2 2 0 01-2 2H5a2 2 0 01-2-2v-2c0-1.1.9-2 2-2zm0 2v2h14v-2H5zm10 0h2v2h-2v-2zm-4-6.4L8.7 9.3a1 1 0 10-1.4 1.4l4 4c.4.4 1 .4 1.4 0l4-4a1 1 0 10-1.4-1.4L13 11.6V4a1 1 0 00-2 0v7.6z" fill-rule="nonzero"/></svg>',
        'search': '<svg width="24" height="24"><path d="M16 17.3a8 8 0 111.4-1.4l4.3 4.4a1 1 0 01-1.4 1.4l-4.4-4.3zm-5-.3a6 6 0 100-12 6 6 0 000 12z" fill-rule="nonzero"/></svg>',
        'select-all': '<svg width="24" height="24"><path d="M3 5h2V3a2 2 0 00-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2a2 2 0 00-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8a2 2 0 002-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2zM7 17h10V7H7v10zm2-8h6v6H9V9z" fill-rule="nonzero"/></svg>',
        'selected': '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V6c0-1.1.9-2 2-2zm3.6 10.9L7 12.3a.7.7 0 00-1 1L9.6 17 18 8.6a.7.7 0 000-1 .7.7 0 00-1 0l-7.4 7.3z"/></svg>',
        'settings': '<svg width="24" height="24"><path d="M11 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 01-.2-.6V8H5a1 1 0 110-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.5V6zM8 8h2V6H8v2zm9 2.8v.2h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v.3c0 .2 0 .3-.2.5l-.6.2h-2.4c-.3 0-.4 0-.6-.2a.7.7 0 01-.2-.6V13H5a1 1 0 010-2h8v-.3c0-.2 0-.3.2-.5l.6-.2h2.4c.3 0 .4 0 .6.2l.2.6zM14 13h2v-2h-2v2zm-3 2.8v.2h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 01-.2-.6V18H5a1 1 0 010-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.6zM8 18h2v-2H8v2z" fill-rule="evenodd"/></svg>',
        'sharpen': '<svg width="24" height="24"><path d="M16 6l4 4-8 9-8-9 4-4h8zm-4 10.2l5.5-6.2-.1-.1H12v-.3h5.1l-.2-.2H12V9h4.6l-.2-.2H12v-.3h4.1l-.2-.2H12V8h3.6l-.2-.2H8.7L6.5 10l.1.1H12v.3H6.9l.2.2H12v.3H7.3l.2.2H12v.3H7.7l.3.2h4v.3H8.2l.2.2H12v.3H8.6l.3.2H12v.3H9l.3.2H12v.3H9.5l.2.2H12v.3h-2l.2.2H12v.3h-1.6l.2.2H12v.3h-1.1l.2.2h.9v.3h-.7l.2.2h.5v.3h-.3l.3.2z" fill-rule="evenodd"/></svg>',
        'sourcecode': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M9.8 15.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0l-4.4-4.1a.8.8 0 010-1.2l4.4-4.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L6 12l3.8 3.7zM14.2 15.7c-.3.3-.3.8 0 1 .4.4.9.4 1.2 0l4.4-4.1c.3-.3.3-.9 0-1.2l-4.4-4.2a.8.8 0 00-1.2 0c-.3.3-.3.8 0 1.1L18 12l-3.8 3.7z"/></g></svg>',
        'spell-check': '<svg width="24" height="24"><path d="M6 8v3H5V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h2c.3 0 .5.1.7.3.2.2.3.4.3.7v6H8V8H6zm0-3v2h2V5H6zm13 0h-3v5h3v1h-3a1 1 0 01-.7-.3 1 1 0 01-.3-.7V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3v1zm-5 1.5l-.1.7c-.1.2-.3.3-.6.3.3 0 .5.1.6.3l.1.7V10c0 .3-.1.5-.3.7a1 1 0 01-.7.3h-3V4h3c.3 0 .5.1.7.3.2.2.3.4.3.7v1.5zM13 10V8h-2v2h2zm0-3V5h-2v2h2zm3 5l1 1-6.5 7L7 15.5l1.3-1 2.2 2.2L16 12z" fill-rule="evenodd"/></svg>',
        'strike-through': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M15.6 8.5c-.5-.7-1-1.1-1.3-1.3-.6-.4-1.3-.6-2-.6-2.7 0-2.8 1.7-2.8 2.1 0 1.6 1.8 2 3.2 2.3 4.4.9 4.6 2.8 4.6 3.9 0 1.4-.7 4.1-5 4.1A6.2 6.2 0 017 16.4l1.5-1.1c.4.6 1.6 2 3.7 2 1.6 0 2.5-.4 3-1.2.4-.8.3-2-.8-2.6-.7-.4-1.6-.7-2.9-1-1-.2-3.9-.8-3.9-3.6C7.6 6 10.3 5 12.4 5c2.9 0 4.2 1.6 4.7 2.4l-1.5 1.1z"/><path d="M5 11h14a1 1 0 010 2H5a1 1 0 010-2z" fill-rule="nonzero"/></g></svg>',
        'subscript': '<svg width="24" height="24"><path d="M10.4 10l4.6 4.6-1.4 1.4L9 11.4 4.4 16 3 14.6 7.6 10 3 5.4 4.4 4 9 8.6 13.6 4 15 5.4 10.4 10zM21 19h-5v-1l1-.8 1.7-1.6c.3-.4.5-.8.5-1.2 0-.3 0-.6-.2-.7-.2-.2-.5-.3-.9-.3a2 2 0 00-.8.2l-.7.3-.4-1.1 1-.6 1.2-.2c.8 0 1.4.3 1.8.7.4.4.6.9.6 1.5s-.2 1.1-.5 1.6a8 8 0 01-1.3 1.3l-.6.6h2.6V19z" fill-rule="nonzero"/></svg>',
        'superscript': '<svg width="24" height="24"><path d="M15 9.4L10.4 14l4.6 4.6-1.4 1.4L9 15.4 4.4 20 3 18.6 7.6 14 3 9.4 4.4 8 9 12.6 13.6 8 15 9.4zm5.9 1.6h-5v-1l1-.8 1.7-1.6c.3-.5.5-.9.5-1.3 0-.3 0-.5-.2-.7-.2-.2-.5-.3-.9-.3l-.8.2-.7.4-.4-1.2c.2-.2.5-.4 1-.5.3-.2.8-.2 1.2-.2.8 0 1.4.2 1.8.6.4.4.6 1 .6 1.6 0 .5-.2 1-.5 1.5l-1.3 1.4-.6.5h2.6V11z" fill-rule="nonzero"/></svg>',
        'table-caption': '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="12" height="2" x="3" y="4" rx="1"/><path d="M19 8a2 2 0 012 2v8a2 2 0 01-2 2H5a2 2 0 01-2-2v-8c0-1.1.9-2 2-2h14zM5 15v3h6v-3H5zm14 0h-6v3h6v-3zm0-5h-6v3h6v-3zM5 13h6v-3H5v3z"/></g></svg>',
        'table-cell-classes': '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M13 4v9H3V6c0-1.1.9-2 2-2h8zm-2 2H5v5h6V6z"/><path fill-rule="nonzero" d="M13 4h6a2 2 0 012 2v7h-8v-2h6V6h-6V4z" opacity=".2"/><path d="M18 20l-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3 .2-2.3 2 .7 3z"/><path fill-rule="nonzero" d="M3 13v5c0 1.1.9 2 2 2h8v-7h-2v5H5v-5H3z" opacity=".2"/></g></svg>',
        'table-cell-properties': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm-8 9H5v5h6v-5zm8 0h-6v5h6v-5zm-8-7H5v5h6V6z"/></svg>',
        'table-cell-select-all': '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm0 2H5v12h14V6z"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2z" opacity=".2"/></g></svg>',
        'table-cell-select-inner': '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm0 2H5v12h14V6z" opacity=".2"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2z"/></g></svg>',
        'table-classes': '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v7h-8v7H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm-8 9H5v5h6v-5zm8-7h-6v5h6V6zm-8 0H5v5h6V6z"/><path d="M18 20l-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3 .2-2.3 2 .7 3z"/></g></svg>',
        'table-delete-column': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm-4 4h-2V6h-2v2H9V6H5v12h4v-2h2v2h2v-2h2v2h4V6h-4v2zm.3.5l1 1.2-3 2.3 3 2.3-1 1.2L12 13l-3.3 2.6-1-1.2 3-2.3-3-2.3 1-1.2L12 11l3.3-2.5z"/></svg>',
        'table-delete-row': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm0 2H5v3h2.5v2H5v2h2.5v2H5v3h14v-3h-2.5v-2H19v-2h-2.5V9H19V6zm-4.7 1.8l1.2 1L13 12l2.6 3.3-1.2 1-2.3-3-2.3 3-1.2-1L11 12 8.5 8.7l1.2-1 2.3 3 2.3-3z"/></svg>',
        'table-delete-table': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zM5 6v12h14V6H5z"/><path d="M14.4 8.6l1 1-2.3 2.4 2.3 2.4-1 1-2.4-2.3-2.4 2.3-1-1 2.3-2.4-2.3-2.4 1-1 2.4 2.3z"/></g></svg>',
        'table-insert-column-after': '<svg width="24" height="24"><path fill-rule="nonzero" d="M20 4c.6 0 1 .4 1 1v2a1 1 0 01-2 0V6h-8v12h8v-1a1 1 0 012 0v2c0 .5-.4 1-.9 1H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h15zM9 13H5v5h4v-5zm7-5c.5 0 1 .4 1 .9V11h2a1 1 0 01.1 2H17v2a1 1 0 01-2 .1V13h-2a1 1 0 01-.1-2H15V9c0-.6.4-1 1-1zM9 6H5v5h4V6z"/></svg>',
        'table-insert-column-before': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H4a1 1 0 01-1-1v-2a1 1 0 012 0v1h8V6H5v1a1 1 0 11-2 0V5c0-.6.4-1 1-1h15zm0 9h-4v5h4v-5zM8 8c.5 0 1 .4 1 .9V11h2a1 1 0 01.1 2H9v2a1 1 0 01-2 .1V13H5a1 1 0 01-.1-2H7V9c0-.6.4-1 1-1zm11-2h-4v5h4V6z"/></svg>',
        'table-insert-row-above': '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4a1 1 0 110 2H5v6h14V6h-1a1 1 0 010-2h2c.6 0 1 .4 1 1v13a2 2 0 01-2 2H5a2 2 0 01-2-2V5c0-.6.4-1 1-1h2zm5 10H5v4h6v-4zm8 0h-6v4h6v-4zM12 3c.5 0 1 .4 1 .9V6h2a1 1 0 010 2h-2v2a1 1 0 01-2 .1V8H9a1 1 0 010-2h2V4c0-.6.4-1 1-1z"/></svg>',
        'table-insert-row-after': '<svg width="24" height="24"><path fill-rule="nonzero" d="M12 13c.5 0 1 .4 1 .9V16h2a1 1 0 01.1 2H13v2a1 1 0 01-2 .1V18H9a1 1 0 01-.1-2H11v-2c0-.6.4-1 1-1zm6 7a1 1 0 010-2h1v-6H5v6h1a1 1 0 010 2H4a1 1 0 01-1-1V6c0-1.1.9-2 2-2h14a2 2 0 012 2v13c0 .5-.4 1-.9 1H18zM11 6H5v4h6V6zm8 0h-6v4h6V6z"/></svg>',
        'table-left-header': '<svg width="24" height="24"><path d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm0 9h-4v5h4v-5zm-6 0H9v5h4v-5zm0-7H9v5h4V6zm6 0h-4v5h4V6z"/></svg>',
        'table-merge-cells': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zM5 15.5V18h3v-2.5H5zm14-5h-9V18h9v-7.5zM19 6h-4v2.5h4V6zM8 6H5v2.5h3V6zm5 0h-3v2.5h3V6zm-8 7.5h3v-3H5v3z"/></svg>',
        'table-row-numbering-rtl': '<svg width="24" height="24"><path d="M6 4a2 2 0 00-2 2v13c0 1.1.9 2 2 2h12a2 2 0 002-2V6a2 2 0 00-2-2H6zm0 12h8v3H6v-3zm11 0c.6 0 1 .4 1 1v1a1 1 0 01-2 0v-1c0-.6.4-1 1-1zM6 11h8v3H6v-3zm11 0c.6 0 1 .4 1 1v1a1 1 0 01-2 0v-1c0-.6.4-1 1-1zM6 6h8v3H6V6zm11 0c.6 0 1 .4 1 1v1a1 1 0 11-2 0V7c0-.6.4-1 1-1z"/></svg>',
        'table-row-numbering': '<svg width="24" height="24"><path d="M18 4a2 2 0 012 2v13a2 2 0 01-2 2H6a2 2 0 01-2-2V6c0-1.1.9-2 2-2h12zm0 12h-8v3h8v-3zM7 16a1 1 0 00-1 1v1a1 1 0 002 0v-1c0-.6-.4-1-1-1zm11-5h-8v3h8v-3zM7 11a1 1 0 00-1 1v1a1 1 0 002 0v-1c0-.6-.4-1-1-1zm11-5h-8v3h8V6zM7 6a1 1 0 00-1 1v1a1 1 0 102 0V7c0-.6-.4-1-1-1z"/></svg>',
        'table-row-properties': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zM5 15v3h6v-3H5zm14 0h-6v3h6v-3zm0-9h-6v3h6V6zM5 9h6V6H5v3z"/></svg>',
        'table-split-cells': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zM8 15.5H5V18h3v-2.5zm11-5h-9V18h9v-7.5zm-2.5 1l1 1-2 2 2 2-1 1-2-2-2 2-1-1 2-2-2-2 1-1 2 2 2-2zm-8.5-1H5v3h3v-3zM19 6h-4v2.5h4V6zM8 6H5v2.5h3V6zm5 0h-3v2.5h3V6z"/></svg>',
        'table-top-header': '<svg width="24" height="24"><path d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm-8 11H5v3h6v-3zm8 0h-6v3h6v-3zm0-5h-6v3h6v-3zM5 13h6v-3H5v3z"/></svg>',
        'table': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zM5 14v4h6v-4H5zm14 0h-6v4h6v-4zm0-6h-6v4h6V8zM5 12h6V8H5v4z"/></svg>',
        'template': '<svg width="24" height="24"><path d="M19 19v-1H5v1h14zM9 16v-4a5 5 0 116 0v4h4a2 2 0 012 2v3H3v-3c0-1.1.9-2 2-2h4zm4 0v-5l.8-.6a3 3 0 10-3.6 0l.8.6v5h2z" fill-rule="nonzero"/></svg>',
        'temporary-placeholder': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M9 7.6V6h2.5V4.5a.5.5 0 111 0V6H15v1.6a8 8 0 11-6 0zm-2.6 5.3a.5.5 0 00.3.6c.3 0 .6 0 .6-.3l.1-.2a5 5 0 013.3-2.8c.3-.1.4-.4.4-.6-.1-.3-.4-.5-.6-.4a6 6 0 00-4.1 3.7z"/><circle cx="14" cy="4" r="1"/><circle cx="12" cy="2" r="1"/><circle cx="10" cy="4" r="1"/></g></svg>',
        'text-color': '<svg width="24" height="24"><g fill-rule="evenodd"><path id="tox-icon-text-color__color" d="M3 18h18v3H3z"/><path d="M8.7 16h-.8a.5.5 0 01-.5-.6l2.7-9c.1-.3.3-.4.5-.4h2.8c.2 0 .4.1.5.4l2.7 9a.5.5 0 01-.5.6h-.8a.5.5 0 01-.4-.4l-.7-2.2c0-.3-.3-.4-.5-.4h-3.4c-.2 0-.4.1-.5.4l-.7 2.2c0 .3-.2.4-.4.4zm2.6-7.6l-.6 2a.5.5 0 00.5.6h1.6a.5.5 0 00.5-.6l-.6-2c0-.3-.3-.4-.5-.4h-.4c-.2 0-.4.1-.5.4z"/></g></svg>',
        'toc': '<svg width="24" height="24"><path d="M5 5c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 110-2zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 110-2zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 010-2zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 010-2zm0-4c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 110-2zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 010-2zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2z" fill-rule="evenodd"/></svg>',
        'translate': '<svg width="24" height="24"><path d="M12.7 14.3l-.3.7-.4.7-2.2-2.2-3.1 3c-.3.4-.8.4-1 0a.7.7 0 010-1l3.1-3A12.4 12.4 0 016.7 9H8a10.1 10.1 0 001.7 2.4c.5-.5 1-1.1 1.4-1.8l.9-2H4.7a.7.7 0 110-1.5h4.4v-.7c0-.4.3-.8.7-.8.4 0 .7.4.7.8v.7H15c.4 0 .8.3.8.7 0 .4-.4.8-.8.8h-1.4a12.3 12.3 0 01-1 2.4 13.5 13.5 0 01-1.7 2.3l1.9 1.8zm4.3-3l2.7 7.3a.5.5 0 01-.4.7 1 1 0 01-1-.7l-.6-1.5h-3.4l-.6 1.5a1 1 0 01-1 .7.5.5 0 01-.4-.7l2.7-7.4a1 1 0 012 0zm-2.2 4.4h2.4L16 12.5l-1.2 3.2z" fill-rule="evenodd"/></svg>',
        'underline': '<svg width="24" height="24"><path d="M16 5c.6 0 1 .4 1 1v5.5a4 4 0 01-.4 1.8l-1 1.4a5.3 5.3 0 01-5.5 1 5 5 0 01-1.6-1c-.5-.4-.8-.9-1.1-1.4a4 4 0 01-.4-1.8V6c0-.6.4-1 1-1s1 .4 1 1v5.5c0 .3 0 .6.2 1l.6.7a3.3 3.3 0 002.2.8 3.4 3.4 0 002.2-.8c.3-.2.4-.5.6-.8l.2-.9V6c0-.6.4-1 1-1zM8 17h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 010-2z" fill-rule="evenodd"/></svg>',
        'undo': '<svg width="24" height="24"><path d="M6.4 8H12c3.7 0 6.2 2 6.8 5.1.6 2.7-.4 5.6-2.3 6.8a1 1 0 01-1-1.8c1.1-.6 1.8-2.7 1.4-4.6-.5-2.1-2.1-3.5-4.9-3.5H6.4l3.3 3.3a1 1 0 11-1.4 1.4l-5-5a1 1 0 010-1.4l5-5a1 1 0 011.4 1.4L6.4 8z" fill-rule="nonzero"/></svg>',
        'unlink': '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 011.4 1.4l-2 2a2 2 0 102.6 2.8l4.8-4.8a1 1 0 000-1.4 1 1 0 111.4-1.3 2.9 2.9 0 010 4L9.6 20a3.9 3.9 0 01-5.5-5.5l2-2zm11.6-.6a1 1 0 01-1.4-1.4l2.1-2a2 2 0 10-2.7-2.8L11 10.3a1 1 0 000 1.4A1 1 0 119.6 13a2.9 2.9 0 010-4L14.4 4a3.9 3.9 0 015.5 5.5l-2 2zM7.6 6.3a.8.8 0 01-1 1.1L3.3 4.2a.7.7 0 111-1l3.2 3.1zM5.1 8.6a.8.8 0 010 1.5H3a.8.8 0 010-1.5H5zm5-3.5a.8.8 0 01-1.5 0V3a.8.8 0 011.5 0V5zm6 11.8a.8.8 0 011-1l3.2 3.2a.8.8 0 01-1 1L16 17zm-2.2 2a.8.8 0 011.5 0V21a.8.8 0 01-1.5 0V19zm5-3.5a.7.7 0 110-1.5H21a.8.8 0 010 1.5H19z" fill-rule="nonzero"/></svg>',
        'unlock': '<svg width="24" height="24"><path d="M16 5c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h-2V8a1 1 0 00-.3-.7A1 1 0 0016 7h-2a1 1 0 00-.7.3 1 1 0 00-.3.7v3h.3c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H4.8c-.3 0-.4 0-.6-.2a.7.7 0 01-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H11V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2z" fill-rule="evenodd"/></svg>',
        'unordered-list': '<svg width="24" height="24"><path d="M11 5h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zM4.5 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1z" fill-rule="evenodd"/></svg>',
        'unselected': '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V6c0-1.1.9-2 2-2zm0 1a1 1 0 00-1 1v12c0 .6.4 1 1 1h12c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H6z"/></svg>',
        'upload': '<svg width="24" height="24"><path d="M18 19v-2a1 1 0 012 0v3c0 .6-.4 1-1 1H5a1 1 0 01-1-1v-3a1 1 0 012 0v2h12zM11 6.4L8.7 8.7a1 1 0 01-1.4-1.4l4-4a1 1 0 011.4 0l4 4a1 1 0 11-1.4 1.4L13 6.4V16a1 1 0 01-2 0V6.4z" fill-rule="nonzero"/></svg>',
        'user': '<svg width="24" height="24"><path d="M12 24a12 12 0 110-24 12 12 0 010 24zm-8.7-5.3a11 11 0 0017.4 0C19.4 16.3 14.6 15 12 15c-2.6 0-7.4 1.3-8.7 3.7zM12 13c2.2 0 4-2 4-4.5S14.2 4 12 4 8 6 8 8.5 9.8 13 12 13z" fill-rule="nonzero"/></svg>',
        'vertical-align': '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="18" height="2" x="3" y="11" rx="1"/><path d="M12 2c.6 0 1 .4 1 1v4l2-1.3a1 1 0 011.2 1.5l-.1.1-4.1 3-4-3a1 1 0 011-1.7l2 1.5V3c0-.6.4-1 1-1zm0 11.8l4 2.9a1 1 0 01-1 1.7l-2-1.5V21c0 .5-.4 1-.9 1H12a1 1 0 01-1-1v-4l-2 1.3a1 1 0 01-1.2-.1l-.1-.1a1 1 0 01.1-1.3l.1-.1 4.1-3z"/></g></svg>',
        'visualblocks': '<svg width="24" height="24"><path d="M9 19v2H7v-2h2zm-4 0v2a2 2 0 01-2-2h2zm8 0v2h-2v-2h2zm8 0a2 2 0 01-2 2v-2h2zm-4 0v2h-2v-2h2zM15 7a1 1 0 010 2v7a1 1 0 01-2 0V9h-1v7a1 1 0 01-2 0v-4a2.5 2.5 0 01-.2-5H15zM5 15v2H3v-2h2zm16 0v2h-2v-2h2zM5 11v2H3v-2h2zm16 0v2h-2v-2h2zM5 7v2H3V7h2zm16 0v2h-2V7h2zM5 3v2H3c0-1.1.9-2 2-2zm8 0v2h-2V3h2zm6 0a2 2 0 012 2h-2V3zM9 3v2H7V3h2zm8 0v2h-2V3h2z" fill-rule="evenodd"/></svg>',
        'visualchars': '<svg width="24" height="24"><path d="M10 5h7a1 1 0 010 2h-1v11a1 1 0 01-2 0V7h-2v11a1 1 0 01-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 016.8 10a3.3 3.3 0 010-2.8 3.4 3.4 0 011.8-1.8L10 5z" fill-rule="evenodd"/></svg>',
        'warning': '<svg width="24" height="24"><path d="M19.8 18.3c.2.5.3.9 0 1.2-.1.3-.5.5-1 .5H5.2c-.5 0-.9-.2-1-.5-.3-.3-.2-.7 0-1.2L11 4.7l.5-.5.5-.2c.2 0 .3 0 .5.2.2 0 .3.3.5.5l6.8 13.6zM12 18c.3 0 .5-.1.7-.3.2-.2.3-.4.3-.7a1 1 0 00-.3-.7 1 1 0 00-.7-.3 1 1 0 00-.7.3 1 1 0 00-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3zm.7-3l.3-4a1 1 0 00-.3-.7 1 1 0 00-.7-.3 1 1 0 00-.7.3 1 1 0 00-.3.7l.3 4h1.4z" fill-rule="evenodd"/></svg>',
        'zoom-in': '<svg width="24" height="24"><path d="M16 17.3a8 8 0 111.4-1.4l4.3 4.4a1 1 0 01-1.4 1.4l-4.4-4.3zm-5-.3a6 6 0 100-12 6 6 0 000 12zm-1-9a1 1 0 012 0v6a1 1 0 01-2 0V8zm-2 4a1 1 0 010-2h6a1 1 0 010 2H8z" fill-rule="nonzero"/></svg>',
        'zoom-out': '<svg width="24" height="24"><path d="M16 17.3a8 8 0 111.4-1.4l4.3 4.4a1 1 0 01-1.4 1.4l-4.4-4.3zm-5-.3a6 6 0 100-12 6 6 0 000 12zm-3-5a1 1 0 010-2h6a1 1 0 010 2H8z" fill-rule="nonzero"/></svg>'
    }
});


</script>
  <script referrerpolicy="origin">
/**
 * TinyMCE version 6.0.1 (2022-03-23)
 */ (function() {
    var global$1 = tinymce.util.Tools.resolve('tinymce.ModelManager');
    const hasProto = (v, constructor, predicate)=>{
        var _a;
        if (predicate(v, constructor.prototype)) return true;
        else return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;
    };
    const typeOf = (x)=>{
        const t = typeof x;
        if (x === null) return 'null';
        else if (t === 'object' && Array.isArray(x)) return 'array';
        else if (t === 'object' && hasProto(x, String, (o, proto)=>proto.isPrototypeOf(o)
        )) return 'string';
        else return t;
    };
    const isType$1 = (type)=>(value)=>typeOf(value) === type
    ;
    const isSimpleType = (type)=>(value)=>typeof value === type
    ;
    const eq$2 = (t)=>(a)=>t === a
    ;
    const isString = isType$1('string');
    const isObject = isType$1('object');
    const isArray = isType$1('array');
    const isNull = eq$2(null);
    const isBoolean = isSimpleType('boolean');
    const isNullable = (a)=>a === null || a === undefined
    ;
    const isNonNullable = (a)=>!isNullable(a)
    ;
    const isFunction = isSimpleType('function');
    const isNumber = isSimpleType('number');
    const noop = ()=>{};
    const compose = (fa, fb)=>{
        return (...args)=>{
            return fa(fb.apply(null, args));
        };
    };
    const compose1 = (fbc, fab)=>(a)=>fbc(fab(a))
    ;
    const constant = (value)=>{
        return ()=>{
            return value;
        };
    };
    const identity = (x)=>{
        return x;
    };
    const tripleEquals = (a, b)=>{
        return a === b;
    };
    function curry(fn, ...initialArgs) {
        return (...restArgs)=>{
            const all = initialArgs.concat(restArgs);
            return fn.apply(null, all);
        };
    }
    const not = (f)=>(t)=>!f(t)
    ;
    const die = (msg)=>{
        return ()=>{
            throw new Error(msg);
        };
    };
    const apply = (f)=>{
        return f();
    };
    const never = constant(false);
    const always = constant(true);
    class Optional {
        constructor(tag, value){
            this.tag = tag;
            this.value = value;
        }
        static some(value) {
            return new Optional(true, value);
        }
        static none() {
            return Optional.singletonNone;
        }
        fold(onNone, onSome) {
            if (this.tag) return onSome(this.value);
            else return onNone();
        }
        isSome() {
            return this.tag;
        }
        isNone() {
            return !this.tag;
        }
        map(mapper) {
            if (this.tag) return Optional.some(mapper(this.value));
            else return Optional.none();
        }
        bind(binder) {
            if (this.tag) return binder(this.value);
            else return Optional.none();
        }
        exists(predicate) {
            return this.tag && predicate(this.value);
        }
        forall(predicate) {
            return !this.tag || predicate(this.value);
        }
        filter(predicate) {
            if (!this.tag || predicate(this.value)) return this;
            else return Optional.none();
        }
        getOr(replacement) {
            return this.tag ? this.value : replacement;
        }
        or(replacement) {
            return this.tag ? this : replacement;
        }
        getOrThunk(thunk) {
            return this.tag ? this.value : thunk();
        }
        orThunk(thunk) {
            return this.tag ? this : thunk();
        }
        getOrDie(message) {
            if (!this.tag) throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');
            else return this.value;
        }
        static from(value) {
            return isNonNullable(value) ? Optional.some(value) : Optional.none();
        }
        getOrNull() {
            return this.tag ? this.value : null;
        }
        getOrUndefined() {
            return this.value;
        }
        each(worker) {
            if (this.tag) worker(this.value);
        }
        toArray() {
            return this.tag ? [
                this.value
            ] : [];
        }
        toString() {
            return this.tag ? `some(${this.value})` : 'none()';
        }
    }
    Optional.singletonNone = new Optional(false);
    const nativeSlice = Array.prototype.slice;
    const nativeIndexOf = Array.prototype.indexOf;
    const nativePush = Array.prototype.push;
    const rawIndexOf = (ts, t)=>nativeIndexOf.call(ts, t)
    ;
    const contains$2 = (xs, x)=>rawIndexOf(xs, x) > -1
    ;
    const exists = (xs, pred)=>{
        for(let i = 0, len = xs.length; i < len; i++){
            const x = xs[i];
            if (pred(x, i)) return true;
        }
        return false;
    };
    const range$1 = (num, f)=>{
        const r = [];
        for(let i = 0; i < num; i++)r.push(f(i));
        return r;
    };
    const map$1 = (xs, f)=>{
        const len = xs.length;
        const r = new Array(len);
        for(let i = 0; i < len; i++){
            const x = xs[i];
            r[i] = f(x, i);
        }
        return r;
    };
    const each$2 = (xs, f)=>{
        for(let i = 0, len = xs.length; i < len; i++){
            const x = xs[i];
            f(x, i);
        }
    };
    const eachr = (xs, f)=>{
        for(let i = xs.length - 1; i >= 0; i--){
            const x = xs[i];
            f(x, i);
        }
    };
    const partition = (xs, pred)=>{
        const pass = [];
        const fail = [];
        for(let i = 0, len = xs.length; i < len; i++){
            const x = xs[i];
            const arr = pred(x, i) ? pass : fail;
            arr.push(x);
        }
        return {
            pass,
            fail
        };
    };
    const filter$2 = (xs, pred)=>{
        const r = [];
        for(let i = 0, len = xs.length; i < len; i++){
            const x = xs[i];
            if (pred(x, i)) r.push(x);
        }
        return r;
    };
    const foldr = (xs, f, acc)=>{
        eachr(xs, (x, i)=>{
            acc = f(acc, x, i);
        });
        return acc;
    };
    const foldl = (xs, f, acc)=>{
        each$2(xs, (x, i)=>{
            acc = f(acc, x, i);
        });
        return acc;
    };
    const findUntil = (xs, pred, until)=>{
        for(let i = 0, len = xs.length; i < len; i++){
            const x = xs[i];
            if (pred(x, i)) return Optional.some(x);
            else if (until(x, i)) break;
        }
        return Optional.none();
    };
    const find$1 = (xs, pred)=>{
        return findUntil(xs, pred, never);
    };
    const findIndex = (xs, pred)=>{
        for(let i = 0, len = xs.length; i < len; i++){
            const x = xs[i];
            if (pred(x, i)) return Optional.some(i);
        }
        return Optional.none();
    };
    const flatten = (xs)=>{
        const r = [];
        for(let i = 0, len = xs.length; i < len; ++i){
            if (!isArray(xs[i])) throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);
            nativePush.apply(r, xs[i]);
        }
        return r;
    };
    const bind$2 = (xs, f)=>flatten(map$1(xs, f))
    ;
    const forall = (xs, pred)=>{
        for(let i = 0, len = xs.length; i < len; ++i){
            const x = xs[i];
            if (pred(x, i) !== true) return false;
        }
        return true;
    };
    const reverse = (xs)=>{
        const r = nativeSlice.call(xs, 0);
        r.reverse();
        return r;
    };
    const mapToObject = (xs, f)=>{
        const r = {};
        for(let i = 0, len = xs.length; i < len; i++){
            const x = xs[i];
            r[String(x)] = f(x, i);
        }
        return r;
    };
    const sort$1 = (xs, comparator)=>{
        const copy = nativeSlice.call(xs, 0);
        copy.sort(comparator);
        return copy;
    };
    const get$d = (xs, i)=>i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none()
    ;
    const head1 = (xs)=>get$d(xs, 0)
    ;
    const last$2 = (xs)=>get$d(xs, xs.length - 1)
    ;
    const findMap = (arr, f)=>{
        for(let i = 0; i < arr.length; i++){
            const r = f(arr[i], i);
            if (r.isSome()) return r;
        }
        return Optional.none();
    };
    const keys1 = Object.keys;
    const hasOwnProperty = Object.hasOwnProperty;
    const each$1 = (obj, f)=>{
        const props = keys1(obj);
        for(let k = 0, len = props.length; k < len; k++){
            const i = props[k];
            const x = obj[i];
            f(x, i);
        }
    };
    const map = (obj, f)=>{
        return tupleMap(obj, (x, i)=>({
                k: i,
                v: f(x, i)
            })
        );
    };
    const tupleMap = (obj, f)=>{
        const r = {};
        each$1(obj, (x, i)=>{
            const tuple = f(x, i);
            r[tuple.k] = tuple.v;
        });
        return r;
    };
    const objAcc = (r)=>(x, i)=>{
            r[i] = x;
        }
    ;
    const internalFilter = (obj, pred, onTrue, onFalse)=>{
        const r = {};
        each$1(obj, (x, i)=>{
            (pred(x, i) ? onTrue : onFalse)(x, i);
        });
        return r;
    };
    const filter$1 = (obj, pred)=>{
        const t = {};
        internalFilter(obj, pred, objAcc(t), noop);
        return t;
    };
    const mapToArray = (obj, f)=>{
        const r = [];
        each$1(obj, (value, name)=>{
            r.push(f(value, name));
        });
        return r;
    };
    const values1 = (obj)=>{
        return mapToArray(obj, identity);
    };
    const get$c = (obj, key)=>{
        return has$1(obj, key) ? Optional.from(obj[key]) : Optional.none();
    };
    const has$1 = (obj, key)=>hasOwnProperty.call(obj, key)
    ;
    const hasNonNullableKey = (obj, key)=>has$1(obj, key) && obj[key] !== undefined && obj[key] !== null
    ;
    const isEmpty = (r)=>{
        for(const x in r){
            if (hasOwnProperty.call(r, x)) return false;
        }
        return true;
    };
    typeof window !== 'undefined' || Function('return this;')();
    const COMMENT = 8;
    const DOCUMENT = 9;
    const DOCUMENT_FRAGMENT = 11;
    const ELEMENT = 1;
    const TEXT = 3;
    const name1 = (element)=>{
        const r = element.dom.nodeName;
        return r.toLowerCase();
    };
    const type1 = (element)=>element.dom.nodeType
    ;
    const isType = (t)=>(element)=>type1(element) === t
    ;
    const isComment = (element)=>type1(element) === COMMENT || name1(element) === '#comment'
    ;
    const isElement = isType(ELEMENT);
    const isText = isType(TEXT);
    const isDocument = isType(DOCUMENT);
    const isDocumentFragment = isType(DOCUMENT_FRAGMENT);
    const isTag = (tag)=>(e)=>isElement(e) && name1(e) === tag
    ;
    const rawSet = (dom, key, value)=>{
        if (isString(value) || isBoolean(value) || isNumber(value)) dom.setAttribute(key, value + '');
        else {
            console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);
            throw new Error('Attribute value was not simple');
        }
    };
    const set$2 = (element, key, value)=>{
        rawSet(element.dom, key, value);
    };
    const setAll$1 = (element, attrs)=>{
        const dom = element.dom;
        each$1(attrs, (v, k)=>{
            rawSet(dom, k, v);
        });
    };
    const setOptions = (element, attrs)=>{
        each$1(attrs, (v, k)=>{
            v.fold(()=>{
                remove$7(element, k);
            }, (value)=>{
                rawSet(element.dom, k, value);
            });
        });
    };
    const get$b = (element, key)=>{
        const v = element.dom.getAttribute(key);
        return v === null ? undefined : v;
    };
    const getOpt = (element, key)=>Optional.from(get$b(element, key))
    ;
    const remove$7 = (element, key)=>{
        element.dom.removeAttribute(key);
    };
    const clone$2 = (element)=>foldl(element.dom.attributes, (acc, attr)=>{
            acc[attr.name] = attr.value;
            return acc;
        }, {})
    ;
    const fromHtml$1 = (html, scope)=>{
        const doc = scope || document;
        const div = doc.createElement('div');
        div.innerHTML = html;
        if (!div.hasChildNodes() || div.childNodes.length > 1) {
            const message = 'HTML does not have a single root node';
            console.error(message, html);
            throw new Error(message);
        }
        return fromDom$1(div.childNodes[0]);
    };
    const fromTag = (tag, scope)=>{
        const doc = scope || document;
        const node = doc.createElement(tag);
        return fromDom$1(node);
    };
    const fromText = (text, scope)=>{
        const doc = scope || document;
        const node = doc.createTextNode(text);
        return fromDom$1(node);
    };
    const fromDom$1 = (node)=>{
        if (node === null || node === undefined) throw new Error('Node cannot be null or undefined');
        return {
            dom: node
        };
    };
    const fromPoint$1 = (docElm, x, y)=>Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$1)
    ;
    const SugarElement = {
        fromHtml: fromHtml$1,
        fromTag,
        fromText,
        fromDom: fromDom$1,
        fromPoint: fromPoint$1
    };
    const is$2 = (element, selector)=>{
        const dom = element.dom;
        if (dom.nodeType !== ELEMENT) return false;
        else {
            const elem = dom;
            if (elem.matches !== undefined) return elem.matches(selector);
            else if (elem.msMatchesSelector !== undefined) return elem.msMatchesSelector(selector);
            else if (elem.webkitMatchesSelector !== undefined) return elem.webkitMatchesSelector(selector);
            else if (elem.mozMatchesSelector !== undefined) return elem.mozMatchesSelector(selector);
            else throw new Error('Browser lacks native selectors');
        }
    };
    const bypassSelector = (dom)=>dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0
    ;
    const all$1 = (selector, scope)=>{
        const base = scope === undefined ? document : scope.dom;
        return bypassSelector(base) ? [] : map$1(base.querySelectorAll(selector), SugarElement.fromDom);
    };
    const one = (selector, scope)=>{
        const base = scope === undefined ? document : scope.dom;
        return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);
    };
    const eq$1 = (e1, e2)=>e1.dom === e2.dom
    ;
    const contains$1 = (e1, e2)=>{
        const d1 = e1.dom;
        const d2 = e2.dom;
        return d1 === d2 ? false : d1.contains(d2);
    };
    const is$1 = is$2;
    const owner = (element)=>SugarElement.fromDom(element.dom.ownerDocument)
    ;
    const documentOrOwner = (dos)=>isDocument(dos) ? dos : owner(dos)
    ;
    const documentElement = (element)=>SugarElement.fromDom(documentOrOwner(element).dom.documentElement)
    ;
    const defaultView = (element)=>SugarElement.fromDom(documentOrOwner(element).dom.defaultView)
    ;
    const parent1 = (element)=>Optional.from(element.dom.parentNode).map(SugarElement.fromDom)
    ;
    const parentElement = (element)=>Optional.from(element.dom.parentElement).map(SugarElement.fromDom)
    ;
    const parents1 = (element, isRoot)=>{
        const stop = isFunction(isRoot) ? isRoot : never;
        let dom = element.dom;
        const ret = [];
        while(dom.parentNode !== null && dom.parentNode !== undefined){
            const rawParent = dom.parentNode;
            const p = SugarElement.fromDom(rawParent);
            ret.push(p);
            if (stop(p) === true) break;
            else dom = rawParent;
        }
        return ret;
    };
    const prevSibling = (element)=>Optional.from(element.dom.previousSibling).map(SugarElement.fromDom)
    ;
    const nextSibling = (element)=>Optional.from(element.dom.nextSibling).map(SugarElement.fromDom)
    ;
    const children$2 = (element)=>map$1(element.dom.childNodes, SugarElement.fromDom)
    ;
    const child$2 = (element, index)=>{
        const cs = element.dom.childNodes;
        return Optional.from(cs[index]).map(SugarElement.fromDom);
    };
    const firstChild = (element)=>child$2(element, 0)
    ;
    const before$3 = (marker, element)=>{
        const parent$1 = parent1(marker);
        parent$1.each((v)=>{
            v.dom.insertBefore(element.dom, marker.dom);
        });
    };
    const after$5 = (marker, element)=>{
        const sibling = nextSibling(marker);
        sibling.fold(()=>{
            const parent$1 = parent1(marker);
            parent$1.each((v)=>{
                append$1(v, element);
            });
        }, (v)=>{
            before$3(v, element);
        });
    };
    const prepend = (parent, element)=>{
        const firstChild$1 = firstChild(parent);
        firstChild$1.fold(()=>{
            append$1(parent, element);
        }, (v)=>{
            parent.dom.insertBefore(element.dom, v.dom);
        });
    };
    const append$1 = (parent, element)=>{
        parent.dom.appendChild(element.dom);
    };
    const appendAt = (parent, element, index)=>{
        child$2(parent, index).fold(()=>{
            append$1(parent, element);
        }, (v)=>{
            before$3(v, element);
        });
    };
    const wrap = (element, wrapper)=>{
        before$3(element, wrapper);
        append$1(wrapper, element);
    };
    const after$4 = (marker, elements)=>{
        each$2(elements, (x, i)=>{
            const e = i === 0 ? marker : elements[i - 1];
            after$5(e, x);
        });
    };
    const append = (parent, elements)=>{
        each$2(elements, (x)=>{
            append$1(parent, x);
        });
    };
    const empty = (element)=>{
        element.dom.textContent = '';
        each$2(children$2(element), (rogue)=>{
            remove$6(rogue);
        });
    };
    const remove$6 = (element)=>{
        const dom = element.dom;
        if (dom.parentNode !== null) dom.parentNode.removeChild(dom);
    };
    const unwrap = (wrapper)=>{
        const children = children$2(wrapper);
        if (children.length > 0) after$4(wrapper, children);
        remove$6(wrapper);
    };
    const clone$1 = (original, isDeep)=>SugarElement.fromDom(original.dom.cloneNode(isDeep))
    ;
    const shallow = (original)=>clone$1(original, false)
    ;
    const deep = (original)=>clone$1(original, true)
    ;
    const shallowAs = (original, tag)=>{
        const nu = SugarElement.fromTag(tag);
        const attributes = clone$2(original);
        setAll$1(nu, attributes);
        return nu;
    };
    const copy$2 = (original, tag)=>{
        const nu = shallowAs(original, tag);
        const cloneChildren = children$2(deep(original));
        append(nu, cloneChildren);
        return nu;
    };
    const mutate$1 = (original, tag)=>{
        const nu = shallowAs(original, tag);
        after$5(original, nu);
        const children = children$2(original);
        append(nu, children);
        remove$6(original);
        return nu;
    };
    const validSectionList = [
        'tfoot',
        'thead',
        'tbody',
        'colgroup'
    ];
    const isValidSection = (parentName)=>contains$2(validSectionList, parentName)
    ;
    const grid1 = (rows, columns)=>({
            rows,
            columns
        })
    ;
    const address = (row, column)=>({
            row,
            column
        })
    ;
    const detail1 = (element, rowspan, colspan)=>({
            element,
            rowspan,
            colspan
        })
    ;
    const detailnew = (element, rowspan, colspan, isNew)=>({
            element,
            rowspan,
            colspan,
            isNew
        })
    ;
    const extended = (element, rowspan, colspan, row, column, isLocked)=>({
            element,
            rowspan,
            colspan,
            row,
            column,
            isLocked
        })
    ;
    const rowdetail = (element, cells, section)=>({
            element,
            cells,
            section
        })
    ;
    const rowdetailnew = (element, cells, section, isNew)=>({
            element,
            cells,
            section,
            isNew
        })
    ;
    const elementnew = (element, isNew, isLocked)=>({
            element,
            isNew,
            isLocked
        })
    ;
    const rowcells = (element, cells, section, isNew)=>({
            element,
            cells,
            section,
            isNew
        })
    ;
    const bounds1 = (startRow, startCol, finishRow, finishCol)=>({
            startRow,
            startCol,
            finishRow,
            finishCol
        })
    ;
    const columnext = (element, colspan, column)=>({
            element,
            colspan,
            column
        })
    ;
    const colgroup1 = (element, columns)=>({
            element,
            columns
        })
    ;
    const isShadowRoot = (dos)=>isDocumentFragment(dos) && isNonNullable(dos.dom.host)
    ;
    const supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);
    const isSupported$1 = constant(supported);
    const getRootNode = supported ? (e)=>SugarElement.fromDom(e.dom.getRootNode())
     : documentOrOwner;
    const getShadowRoot = (e)=>{
        const r = getRootNode(e);
        return isShadowRoot(r) ? Optional.some(r) : Optional.none();
    };
    const getShadowHost = (e)=>SugarElement.fromDom(e.dom.host)
    ;
    const getOriginalEventTarget = (event)=>{
        if (isSupported$1() && isNonNullable(event.target)) {
            const el = SugarElement.fromDom(event.target);
            if (isElement(el) && isOpenShadowHost(el)) {
                if (event.composed && event.composedPath) {
                    const composedPath = event.composedPath();
                    if (composedPath) return head1(composedPath);
                }
            }
        }
        return Optional.from(event.target);
    };
    const isOpenShadowHost = (element)=>isNonNullable(element.dom.shadowRoot)
    ;
    const inBody = (element)=>{
        const dom = isText(element) ? element.dom.parentNode : element.dom;
        if (dom === undefined || dom === null || dom.ownerDocument === null) return false;
        const doc = dom.ownerDocument;
        return getShadowRoot(SugarElement.fromDom(dom)).fold(()=>doc.body.contains(dom)
        , compose1(inBody, getShadowHost));
    };
    const body$1 = ()=>getBody$1(SugarElement.fromDom(document))
    ;
    const getBody$1 = (doc)=>{
        const b = doc.dom.body;
        if (b === null || b === undefined) throw new Error('Body is not available yet');
        return SugarElement.fromDom(b);
    };
    const ancestors$4 = (scope, predicate, isRoot)=>filter$2(parents1(scope, isRoot), predicate)
    ;
    const children$1 = (scope, predicate)=>filter$2(children$2(scope), predicate)
    ;
    const descendants$1 = (scope, predicate)=>{
        let result = [];
        each$2(children$2(scope), (x)=>{
            if (predicate(x)) result = result.concat([
                x
            ]);
            result = result.concat(descendants$1(x, predicate));
        });
        return result;
    };
    const ancestors$3 = (scope, selector, isRoot)=>ancestors$4(scope, (e)=>is$2(e, selector)
        , isRoot)
    ;
    const children1 = (scope, selector)=>children$1(scope, (e)=>is$2(e, selector)
        )
    ;
    const descendants = (scope, selector)=>all$1(selector, scope)
    ;
    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot)=>{
        if (is(scope, a)) return Optional.some(scope);
        else if (isFunction(isRoot) && isRoot(scope)) return Optional.none();
        else return ancestor(scope, a, isRoot);
    };
    const ancestor$2 = (scope, predicate, isRoot)=>{
        let element = scope.dom;
        const stop = isFunction(isRoot) ? isRoot : never;
        while(element.parentNode){
            element = element.parentNode;
            const el = SugarElement.fromDom(element);
            if (predicate(el)) return Optional.some(el);
            else if (stop(el)) break;
        }
        return Optional.none();
    };
    const closest$2 = (scope, predicate, isRoot)=>{
        const is = (s, test)=>test(s)
        ;
        return ClosestOrAncestor(is, ancestor$2, scope, predicate, isRoot);
    };
    const child$1 = (scope, predicate)=>{
        const pred = (node)=>predicate(SugarElement.fromDom(node))
        ;
        const result = find$1(scope.dom.childNodes, pred);
        return result.map(SugarElement.fromDom);
    };
    const descendant$1 = (scope, predicate)=>{
        const descend = (node)=>{
            for(let i = 0; i < node.childNodes.length; i++){
                const child = SugarElement.fromDom(node.childNodes[i]);
                if (predicate(child)) return Optional.some(child);
                const res = descend(node.childNodes[i]);
                if (res.isSome()) return res;
            }
            return Optional.none();
        };
        return descend(scope.dom);
    };
    const ancestor$1 = (scope, selector, isRoot)=>ancestor$2(scope, (e)=>is$2(e, selector)
        , isRoot)
    ;
    const child1 = (scope, selector)=>child$1(scope, (e)=>is$2(e, selector)
        )
    ;
    const descendant = (scope, selector)=>one(selector, scope)
    ;
    const closest$1 = (scope, selector1, isRoot)=>{
        const is = (element, selector)=>is$2(element, selector)
        ;
        return ClosestOrAncestor(is, ancestor$1, scope, selector1, isRoot);
    };
    const is1 = (lhs, rhs, comparator = tripleEquals)=>lhs.exists((left)=>comparator(left, rhs)
        )
    ;
    const cat = (arr)=>{
        const r = [];
        const push = (x)=>{
            r.push(x);
        };
        for(let i = 0; i < arr.length; i++)arr[i].each(push);
        return r;
    };
    const bindFrom = (a, f)=>a !== undefined && a !== null ? f(a) : Optional.none()
    ;
    const someIf = (b, a)=>b ? Optional.some(a) : Optional.none()
    ;
    const checkRange = (str, substr, start)=>substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr
    ;
    const contains = (str, substr)=>{
        return str.indexOf(substr) !== -1;
    };
    const startsWith = (str, prefix)=>{
        return checkRange(str, prefix, 0);
    };
    const endsWith = (str, suffix)=>{
        return checkRange(str, suffix, str.length - suffix.length);
    };
    const blank = (r)=>(s)=>s.replace(r, '')
    ;
    const trim = blank(/^\s+|\s+$/g);
    const isNotEmpty = (s)=>s.length > 0
    ;
    const toFloat = (value)=>{
        const num = parseFloat(value);
        return isNaN(num) ? Optional.none() : Optional.some(num);
    };
    const isSupported = (dom)=>dom.style !== undefined && isFunction(dom.style.getPropertyValue)
    ;
    const internalSet = (dom, property, value)=>{
        if (!isString(value)) {
            console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);
            throw new Error('CSS value must be a string: ' + value);
        }
        if (isSupported(dom)) dom.style.setProperty(property, value);
    };
    const internalRemove = (dom, property)=>{
        if (isSupported(dom)) dom.style.removeProperty(property);
    };
    const set$1 = (element, property, value)=>{
        const dom = element.dom;
        internalSet(dom, property, value);
    };
    const setAll = (element, css)=>{
        const dom = element.dom;
        each$1(css, (v, k)=>{
            internalSet(dom, k, v);
        });
    };
    const get$a = (element, property)=>{
        const dom = element.dom;
        const styles = window.getComputedStyle(dom);
        const r = styles.getPropertyValue(property);
        return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;
    };
    const getUnsafeProperty = (dom, property)=>isSupported(dom) ? dom.style.getPropertyValue(property) : ''
    ;
    const getRaw$2 = (element, property)=>{
        const dom = element.dom;
        const raw = getUnsafeProperty(dom, property);
        return Optional.from(raw).filter((r)=>r.length > 0
        );
    };
    const remove$5 = (element, property)=>{
        const dom = element.dom;
        internalRemove(dom, property);
        if (is1(getOpt(element, 'style').map(trim), '')) remove$7(element, 'style');
    };
    const copy$1 = (source, target)=>{
        const sourceDom = source.dom;
        const targetDom = target.dom;
        if (isSupported(sourceDom) && isSupported(targetDom)) targetDom.style.cssText = sourceDom.style.cssText;
    };
    const getAttrValue = (cell, name, fallback = 0)=>getOpt(cell, name).map((value)=>parseInt(value, 10)
        ).getOr(fallback)
    ;
    const getSpan = (cell, type)=>getAttrValue(cell, type, 1)
    ;
    const hasColspan = (cellOrCol)=>{
        if (isTag('col')(cellOrCol)) return getAttrValue(cellOrCol, 'span', 1) > 1;
        else return getSpan(cellOrCol, 'colspan') > 1;
    };
    const hasRowspan = (cell)=>getSpan(cell, 'rowspan') > 1
    ;
    const getCssValue = (element, property)=>parseInt(get$a(element, property), 10)
    ;
    const minWidth = constant(10);
    const minHeight = constant(10);
    const firstLayer = (scope, selector)=>{
        return filterFirstLayer(scope, selector, always);
    };
    const filterFirstLayer = (scope, selector, predicate)=>{
        return bind$2(children$2(scope), (x)=>{
            if (is$2(x, selector)) return predicate(x) ? [
                x
            ] : [];
            else return filterFirstLayer(x, selector, predicate);
        });
    };
    const lookup = (tags, element, isRoot = never)=>{
        if (isRoot(element)) return Optional.none();
        if (contains$2(tags, name1(element))) return Optional.some(element);
        const isRootOrUpperTable = (elm)=>is$2(elm, 'table') || isRoot(elm)
        ;
        return ancestor$1(element, tags.join(','), isRootOrUpperTable);
    };
    const cell1 = (element, isRoot)=>lookup([
            'td',
            'th'
        ], element, isRoot)
    ;
    const cells$1 = (ancestor)=>firstLayer(ancestor, 'th,td')
    ;
    const columns$11 = (ancestor)=>{
        if (is$2(ancestor, 'colgroup')) return children1(ancestor, 'col');
        else return bind$2(columnGroups(ancestor), (columnGroup)=>children1(columnGroup, 'col')
        );
    };
    const table1 = (element, isRoot)=>closest$1(element, 'table', isRoot)
    ;
    const rows$11 = (ancestor)=>firstLayer(ancestor, 'tr')
    ;
    const columnGroups = (ancestor)=>table1(ancestor).fold(constant([]), (table)=>children1(table, 'colgroup')
        )
    ;
    const fromRowsOrColGroups = (elems, getSection)=>map$1(elems, (row)=>{
            if (name1(row) === 'colgroup') {
                const cells = map$1(columns$11(row), (column)=>{
                    const colspan = getAttrValue(column, 'span', 1);
                    return detail1(column, 1, colspan);
                });
                return rowdetail(row, cells, 'colgroup');
            } else {
                const cells = map$1(cells$1(row), (cell)=>{
                    const rowspan = getAttrValue(cell, 'rowspan', 1);
                    const colspan = getAttrValue(cell, 'colspan', 1);
                    return detail1(cell, rowspan, colspan);
                });
                return rowdetail(row, cells, getSection(row));
            }
        })
    ;
    const getParentSection = (group)=>parent1(group).map((parent)=>{
            const parentName = name1(parent);
            return isValidSection(parentName) ? parentName : 'tbody';
        }).getOr('tbody')
    ;
    const fromTable$1 = (table)=>{
        const rows = rows$11(table);
        const columnGroups$1 = columnGroups(table);
        const elems = [
            ...columnGroups$1,
            ...rows
        ];
        return fromRowsOrColGroups(elems, getParentSection);
    };
    const fromPastedRows = (elems, section)=>fromRowsOrColGroups(elems, ()=>section
        )
    ;
    const cached = (f)=>{
        let called = false;
        let r;
        return (...args)=>{
            if (!called) {
                called = true;
                r = f.apply(null, args);
            }
            return r;
        };
    };
    const DeviceType = (os, browser, userAgent, mediaMatch)=>{
        const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;
        const isiPhone = os.isiOS() && !isiPad;
        const isMobile = os.isiOS() || os.isAndroid();
        const isTouch = isMobile || mediaMatch('(pointer:coarse)');
        const isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');
        const isPhone = isiPhone || isMobile && !isTablet;
        const iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;
        const isDesktop = !isPhone && !isTablet && !iOSwebview;
        return {
            isiPad: constant(isiPad),
            isiPhone: constant(isiPhone),
            isTablet: constant(isTablet),
            isPhone: constant(isPhone),
            isTouch: constant(isTouch),
            isAndroid: os.isAndroid,
            isiOS: os.isiOS,
            isWebView: constant(iOSwebview),
            isDesktop: constant(isDesktop)
        };
    };
    const firstMatch = (regexes, s)=>{
        for(let i = 0; i < regexes.length; i++){
            const x = regexes[i];
            if (x.test(s)) return x;
        }
        return undefined;
    };
    const find1 = (regexes, agent)=>{
        const r = firstMatch(regexes, agent);
        if (!r) return {
            major: 0,
            minor: 0
        };
        const group = (i)=>{
            return Number(agent.replace(r, '$' + i));
        };
        return nu$2(group(1), group(2));
    };
    const detect$5 = (versionRegexes, agent)=>{
        const cleanedAgent = String(agent).toLowerCase();
        if (versionRegexes.length === 0) return unknown$2();
        return find1(versionRegexes, cleanedAgent);
    };
    const unknown$2 = ()=>{
        return nu$2(0, 0);
    };
    const nu$2 = (major, minor)=>{
        return {
            major,
            minor
        };
    };
    const Version = {
        nu: nu$2,
        detect: detect$5,
        unknown: unknown$2
    };
    const detectBrowser$1 = (browsers, userAgentData)=>{
        return findMap(userAgentData.brands, (uaBrand)=>{
            const lcBrand = uaBrand.brand.toLowerCase();
            return find$1(browsers, (browser)=>{
                var _a;
                return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());
            }).map((info)=>({
                    current: info.name,
                    version: Version.nu(parseInt(uaBrand.version, 10), 0)
                })
            );
        });
    };
    const detect$4 = (candidates, userAgent)=>{
        const agent = String(userAgent).toLowerCase();
        return find$1(candidates, (candidate)=>{
            return candidate.search(agent);
        });
    };
    const detectBrowser = (browsers, userAgent)=>{
        return detect$4(browsers, userAgent).map((browser)=>{
            const version = Version.detect(browser.versionRegexes, userAgent);
            return {
                current: browser.name,
                version
            };
        });
    };
    const detectOs = (oses, userAgent)=>{
        return detect$4(oses, userAgent).map((os)=>{
            const version = Version.detect(os.versionRegexes, userAgent);
            return {
                current: os.name,
                version
            };
        });
    };
    const normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
    const checkContains = (target)=>{
        return (uastring)=>{
            return contains(uastring, target);
        };
    };
    const browsers1 = [
        {
            name: 'Edge',
            versionRegexes: [
                /.*?edge\/ ?([0-9]+)\.([0-9]+)$/
            ],
            search: (uastring)=>{
                return contains(uastring, 'edge/') && contains(uastring, 'chrome') && contains(uastring, 'safari') && contains(uastring, 'applewebkit');
            }
        },
        {
            name: 'Chromium',
            brand: 'Chromium',
            versionRegexes: [
                /.*?chrome\/([0-9]+)\.([0-9]+).*/,
                normalVersionRegex
            ],
            search: (uastring)=>{
                return contains(uastring, 'chrome') && !contains(uastring, 'chromeframe');
            }
        },
        {
            name: 'IE',
            versionRegexes: [
                /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
                /.*?rv:([0-9]+)\.([0-9]+).*/
            ],
            search: (uastring)=>{
                return contains(uastring, 'msie') || contains(uastring, 'trident');
            }
        },
        {
            name: 'Opera',
            versionRegexes: [
                normalVersionRegex,
                /.*?opera\/([0-9]+)\.([0-9]+).*/
            ],
            search: checkContains('opera')
        },
        {
            name: 'Firefox',
            versionRegexes: [
                /.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/
            ],
            search: checkContains('firefox')
        },
        {
            name: 'Safari',
            versionRegexes: [
                normalVersionRegex,
                /.*?cpu os ([0-9]+)_([0-9]+).*/
            ],
            search: (uastring)=>{
                return (contains(uastring, 'safari') || contains(uastring, 'mobile/')) && contains(uastring, 'applewebkit');
            }
        }
    ];
    const oses1 = [
        {
            name: 'Windows',
            search: checkContains('win'),
            versionRegexes: [
                /.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/
            ]
        },
        {
            name: 'iOS',
            search: (uastring)=>{
                return contains(uastring, 'iphone') || contains(uastring, 'ipad');
            },
            versionRegexes: [
                /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
                /.*cpu os ([0-9]+)_([0-9]+).*/,
                /.*cpu iphone os ([0-9]+)_([0-9]+).*/
            ]
        },
        {
            name: 'Android',
            search: checkContains('android'),
            versionRegexes: [
                /.*?android\ ?([0-9]+)\.([0-9]+).*/
            ]
        },
        {
            name: 'macOS',
            search: checkContains('mac os x'),
            versionRegexes: [
                /.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/
            ]
        },
        {
            name: 'Linux',
            search: checkContains('linux'),
            versionRegexes: []
        },
        {
            name: 'Solaris',
            search: checkContains('sunos'),
            versionRegexes: []
        },
        {
            name: 'FreeBSD',
            search: checkContains('freebsd'),
            versionRegexes: []
        },
        {
            name: 'ChromeOS',
            search: checkContains('cros'),
            versionRegexes: [
                /.*?chrome\/([0-9]+)\.([0-9]+).*/
            ]
        }
    ];
    const PlatformInfo = {
        browsers: constant(browsers1),
        oses: constant(oses1)
    };
    const edge = 'Edge';
    const chromium = 'Chromium';
    const ie = 'IE';
    const opera = 'Opera';
    const firefox = 'Firefox';
    const safari = 'Safari';
    const unknown$1 = ()=>{
        return nu$1({
            current: undefined,
            version: Version.unknown()
        });
    };
    const nu$1 = (info)=>{
        const current = info.current;
        const version = info.version;
        const isBrowser = (name)=>()=>current === name
        ;
        return {
            current,
            version,
            isEdge: isBrowser(edge),
            isChromium: isBrowser(chromium),
            isIE: isBrowser(ie),
            isOpera: isBrowser(opera),
            isFirefox: isBrowser(firefox),
            isSafari: isBrowser(safari)
        };
    };
    const Browser = {
        unknown: unknown$1,
        nu: nu$1,
        edge: constant(edge),
        chromium: constant(chromium),
        ie: constant(ie),
        opera: constant(opera),
        firefox: constant(firefox),
        safari: constant(safari)
    };
    const windows = 'Windows';
    const ios = 'iOS';
    const android = 'Android';
    const linux = 'Linux';
    const macos = 'macOS';
    const solaris = 'Solaris';
    const freebsd = 'FreeBSD';
    const chromeos = 'ChromeOS';
    const unknown = ()=>{
        return nu1({
            current: undefined,
            version: Version.unknown()
        });
    };
    const nu1 = (info)=>{
        const current = info.current;
        const version = info.version;
        const isOS = (name)=>()=>current === name
        ;
        return {
            current,
            version,
            isWindows: isOS(windows),
            isiOS: isOS(ios),
            isAndroid: isOS(android),
            isMacOS: isOS(macos),
            isLinux: isOS(linux),
            isSolaris: isOS(solaris),
            isFreeBSD: isOS(freebsd),
            isChromeOS: isOS(chromeos)
        };
    };
    const OperatingSystem = {
        unknown,
        nu: nu1,
        windows: constant(windows),
        ios: constant(ios),
        android: constant(android),
        linux: constant(linux),
        macos: constant(macos),
        solaris: constant(solaris),
        freebsd: constant(freebsd),
        chromeos: constant(chromeos)
    };
    const detect$3 = (userAgent, userAgentDataOpt, mediaMatch)=>{
        const browsers = PlatformInfo.browsers();
        const oses = PlatformInfo.oses();
        const browser = userAgentDataOpt.bind((userAgentData)=>detectBrowser$1(browsers, userAgentData)
        ).orThunk(()=>detectBrowser(browsers, userAgent)
        ).fold(Browser.unknown, Browser.nu);
        const os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);
        const deviceType = DeviceType(os, browser, userAgent, mediaMatch);
        return {
            browser,
            os,
            deviceType
        };
    };
    const PlatformDetection = {
        detect: detect$3
    };
    const mediaMatch1 = (query)=>window.matchMedia(query).matches
    ;
    let platform = cached(()=>PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch1)
    );
    const detect$2 = ()=>platform()
    ;
    const Dimension = (name, getOffset)=>{
        const set = (element, h)=>{
            if (!isNumber(h) && !h.match(/^[0-9]+$/)) throw new Error(name + '.set accepts only positive integer values. Value was ' + h);
            const dom = element.dom;
            if (isSupported(dom)) dom.style[name] = h + 'px';
        };
        const get = (element)=>{
            const r = getOffset(element);
            if (r <= 0 || r === null) {
                const css = get$a(element, name);
                return parseFloat(css) || 0;
            }
            return r;
        };
        const getOuter = get;
        const aggregate = (element, properties)=>foldl(properties, (acc, property)=>{
                const val = get$a(element, property);
                const value = val === undefined ? 0 : parseInt(val, 10);
                return isNaN(value) ? acc : acc + value;
            }, 0)
        ;
        const max = (element, value, properties)=>{
            const cumulativeInclusions = aggregate(element, properties);
            const absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;
            return absoluteMax;
        };
        return {
            set,
            get,
            getOuter,
            aggregate,
            max
        };
    };
    const toNumber = (px, fallback)=>toFloat(px).getOr(fallback)
    ;
    const getProp = (element, name, fallback)=>toNumber(get$a(element, name), fallback)
    ;
    const calcContentBoxSize = (element, size, upper, lower)=>{
        const paddingUpper = getProp(element, `padding-${upper}`, 0);
        const paddingLower = getProp(element, `padding-${lower}`, 0);
        const borderUpper = getProp(element, `border-${upper}-width`, 0);
        const borderLower = getProp(element, `border-${lower}-width`, 0);
        return size - paddingUpper - paddingLower - borderUpper - borderLower;
    };
    const getCalculatedWidth = (element, boxSizing)=>{
        const dom = element.dom;
        const width = dom.getBoundingClientRect().width || dom.offsetWidth;
        return boxSizing === 'border-box' ? width : calcContentBoxSize(element, width, 'left', 'right');
    };
    const getHeight$1 = (element)=>getProp(element, 'height', element.dom.offsetHeight)
    ;
    const getWidth1 = (element)=>getProp(element, 'width', element.dom.offsetWidth)
    ;
    const getInnerWidth = (element)=>getCalculatedWidth(element, 'content-box')
    ;
    const api$2 = Dimension('width', (element)=>element.dom.offsetWidth
    );
    const get$9 = (element)=>api$2.get(element)
    ;
    const getOuter$2 = (element)=>api$2.getOuter(element)
    ;
    const getInner = getInnerWidth;
    const getRuntime$1 = getWidth1;
    const addCells = (gridRow, index, cells)=>{
        const existingCells = gridRow.cells;
        const before = existingCells.slice(0, index);
        const after = existingCells.slice(index);
        const newCells = before.concat(cells).concat(after);
        return setCells(gridRow, newCells);
    };
    const addCell = (gridRow, index, cell)=>addCells(gridRow, index, [
            cell
        ])
    ;
    const mutateCell = (gridRow, index, cell)=>{
        const cells = gridRow.cells;
        cells[index] = cell;
    };
    const setCells = (gridRow, cells)=>rowcells(gridRow.element, cells, gridRow.section, gridRow.isNew)
    ;
    const mapCells = (gridRow, f)=>{
        const cells = gridRow.cells;
        const r = map$1(cells, f);
        return rowcells(gridRow.element, r, gridRow.section, gridRow.isNew);
    };
    const getCell = (gridRow, index)=>gridRow.cells[index]
    ;
    const getCellElement = (gridRow, index)=>getCell(gridRow, index).element
    ;
    const cellLength = (gridRow)=>gridRow.cells.length
    ;
    const extractGridDetails = (grid)=>{
        const result = partition(grid, (row)=>row.section === 'colgroup'
        );
        return {
            rows: result.fail,
            cols: result.pass
        };
    };
    const clone1 = (gridRow, cloneRow, cloneCell)=>{
        const newCells = map$1(gridRow.cells, cloneCell);
        return rowcells(cloneRow(gridRow.element), newCells, gridRow.section, true);
    };
    const LOCKED_COL_ATTR = 'data-snooker-locked-cols';
    const getLockedColumnsFromTable = (table)=>getOpt(table, LOCKED_COL_ATTR).bind((lockedColStr)=>Optional.from(lockedColStr.match(/\d+/g))
        ).map((lockedCols)=>mapToObject(lockedCols, always)
        )
    ;
    const getLockedColumnsFromGrid = (grid)=>{
        const locked = foldl(extractGridDetails(grid).rows, (acc, row)=>{
            each$2(row.cells, (cell, idx)=>{
                if (cell.isLocked) acc[idx] = true;
            });
            return acc;
        }, {});
        const lockedArr = mapToArray(locked, (_val, key)=>parseInt(key, 10)
        );
        return sort$1(lockedArr);
    };
    const key1 = (row, column)=>{
        return row + ',' + column;
    };
    const getAt = (warehouse, row, column)=>Optional.from(warehouse.access[key1(row, column)])
    ;
    const findItem = (warehouse, item, comparator)=>{
        const filtered = filterItems(warehouse, (detail)=>{
            return comparator(item, detail.element);
        });
        return filtered.length > 0 ? Optional.some(filtered[0]) : Optional.none();
    };
    const filterItems = (warehouse, predicate)=>{
        const all = bind$2(warehouse.all, (r)=>{
            return r.cells;
        });
        return filter$2(all, predicate);
    };
    const generateColumns = (rowData)=>{
        const columnsGroup = {};
        let index = 0;
        each$2(rowData.cells, (column)=>{
            const colspan = column.colspan;
            range$1(colspan, (columnIndex)=>{
                const colIndex = index + columnIndex;
                columnsGroup[colIndex] = columnext(column.element, colspan, colIndex);
            });
            index += colspan;
        });
        return columnsGroup;
    };
    const generate$1 = (list)=>{
        const access = {};
        const cells = [];
        const tableOpt = head1(list).map((rowData)=>rowData.element
        ).bind(table1);
        const lockedColumns = tableOpt.bind(getLockedColumnsFromTable).getOr({});
        let maxRows = 0;
        let maxColumns = 0;
        let rowCount = 0;
        const { pass: colgroupRows , fail: rows  } = partition(list, (rowData)=>rowData.section === 'colgroup'
        );
        each$2(rows, (rowData)=>{
            const currentRow = [];
            each$2(rowData.cells, (rowCell)=>{
                let start = 0;
                while(access[key1(rowCount, start)] !== undefined)start++;
                const isLocked = hasNonNullableKey(lockedColumns, start.toString());
                const current = extended(rowCell.element, rowCell.rowspan, rowCell.colspan, rowCount, start, isLocked);
                for(let occupiedColumnPosition = 0; occupiedColumnPosition < rowCell.colspan; occupiedColumnPosition++)for(let occupiedRowPosition = 0; occupiedRowPosition < rowCell.rowspan; occupiedRowPosition++){
                    const rowPosition = rowCount + occupiedRowPosition;
                    const columnPosition = start + occupiedColumnPosition;
                    const newpos = key1(rowPosition, columnPosition);
                    access[newpos] = current;
                    maxColumns = Math.max(maxColumns, columnPosition + 1);
                }
                currentRow.push(current);
            });
            maxRows++;
            cells.push(rowdetail(rowData.element, currentRow, rowData.section));
            rowCount++;
        });
        const { columns: columns2 , colgroups  } = last$2(colgroupRows).map((rowData)=>{
            const columns = generateColumns(rowData);
            const colgroup$1 = colgroup1(rowData.element, values1(columns));
            return {
                colgroups: [
                    colgroup$1
                ],
                columns
            };
        }).getOrThunk(()=>({
                colgroups: [],
                columns: {}
            })
        );
        const grid$1 = grid1(maxRows, maxColumns);
        return {
            grid: grid$1,
            access,
            all: cells,
            columns: columns2,
            colgroups
        };
    };
    const fromTable = (table)=>{
        const list = fromTable$1(table);
        return generate$1(list);
    };
    const justCells = (warehouse)=>bind$2(warehouse.all, (w)=>w.cells
        )
    ;
    const justColumns = (warehouse)=>values1(warehouse.columns)
    ;
    const hasColumns = (warehouse)=>keys1(warehouse.columns).length > 0
    ;
    const getColumnAt = (warehouse, columnIndex)=>Optional.from(warehouse.columns[columnIndex])
    ;
    const Warehouse = {
        fromTable,
        generate: generate$1,
        getAt,
        findItem,
        filterItems,
        justCells,
        justColumns,
        hasColumns,
        getColumnAt
    };
    const columns1 = (warehouse, isValidCell = always)=>{
        const grid = warehouse.grid;
        const cols = range$1(grid.columns, identity);
        const rowsArr = range$1(grid.rows, identity);
        return map$1(cols, (col)=>{
            const getBlock = ()=>bind$2(rowsArr, (r)=>Warehouse.getAt(warehouse, r, col).filter((detail)=>detail.column === col
                    ).toArray()
                )
            ;
            const isValid = (detail)=>detail.colspan === 1 && isValidCell(detail.element)
            ;
            const getFallback = ()=>Warehouse.getAt(warehouse, 0, col)
            ;
            return decide(getBlock, isValid, getFallback);
        });
    };
    const decide = (getBlock, isValid, getFallback)=>{
        const inBlock = getBlock();
        const validInBlock = find$1(inBlock, isValid);
        const detailOption = validInBlock.orThunk(()=>Optional.from(inBlock[0]).orThunk(getFallback)
        );
        return detailOption.map((detail)=>detail.element
        );
    };
    const rows1 = (warehouse)=>{
        const grid = warehouse.grid;
        const rowsArr = range$1(grid.rows, identity);
        const cols = range$1(grid.columns, identity);
        return map$1(rowsArr, (row)=>{
            const getBlock = ()=>bind$2(cols, (c)=>Warehouse.getAt(warehouse, row, c).filter((detail)=>detail.row === row
                    ).fold(constant([]), (detail)=>[
                            detail
                        ]
                    )
                )
            ;
            const isSingle = (detail)=>detail.rowspan === 1
            ;
            const getFallback = ()=>Warehouse.getAt(warehouse, row, 0)
            ;
            return decide(getBlock, isSingle, getFallback);
        });
    };
    const deduce = (xs, index)=>{
        if (index < 0 || index >= xs.length - 1) return Optional.none();
        const current = xs[index].fold(()=>{
            const rest = reverse(xs.slice(0, index));
            return findMap(rest, (a, i)=>a.map((aa)=>({
                        value: aa,
                        delta: i + 1
                    })
                )
            );
        }, (c)=>Optional.some({
                value: c,
                delta: 0
            })
        );
        const next = xs[index + 1].fold(()=>{
            const rest = xs.slice(index + 1);
            return findMap(rest, (a, i)=>a.map((aa)=>({
                        value: aa,
                        delta: i + 1
                    })
                )
            );
        }, (n)=>Optional.some({
                value: n,
                delta: 1
            })
        );
        return current.bind((c)=>next.map((n)=>{
                const extras = n.delta + c.delta;
                return Math.abs(n.value - c.value) / extras;
            })
        );
    };
    const onDirection = (isLtr, isRtl)=>(element)=>getDirection(element) === 'rtl' ? isRtl : isLtr
    ;
    const getDirection = (element)=>get$a(element, 'direction') === 'rtl' ? 'rtl' : 'ltr'
    ;
    const api$1 = Dimension('height', (element)=>{
        const dom = element.dom;
        return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;
    });
    const get$8 = (element)=>api$1.get(element)
    ;
    const getOuter$1 = (element)=>api$1.getOuter(element)
    ;
    const getRuntime = getHeight$1;
    const r1 = (left, top)=>{
        const translate = (x, y)=>r1(left + x, top + y)
        ;
        return {
            left,
            top,
            translate
        };
    };
    const SugarPosition = r1;
    const boxPosition = (dom)=>{
        const box = dom.getBoundingClientRect();
        return SugarPosition(box.left, box.top);
    };
    const firstDefinedOrZero = (a, b)=>{
        if (a !== undefined) return a;
        else return b !== undefined ? b : 0;
    };
    const absolute = (element)=>{
        const doc = element.dom.ownerDocument;
        const body = doc.body;
        const win = doc.defaultView;
        const html = doc.documentElement;
        if (body === element.dom) return SugarPosition(body.offsetLeft, body.offsetTop);
        const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);
        const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);
        const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);
        const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);
        return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);
    };
    const viewport = (element)=>{
        const dom = element.dom;
        const doc = dom.ownerDocument;
        const body = doc.body;
        if (body === dom) return SugarPosition(body.offsetLeft, body.offsetTop);
        if (!inBody(element)) return SugarPosition(0, 0);
        return boxPosition(dom);
    };
    const rowInfo = (row, y)=>({
            row,
            y
        })
    ;
    const colInfo = (col, x)=>({
            col,
            x
        })
    ;
    const rtlEdge = (cell)=>{
        const pos = absolute(cell);
        return pos.left + getOuter$2(cell);
    };
    const ltrEdge = (cell)=>{
        return absolute(cell).left;
    };
    const getLeftEdge = (index, cell)=>{
        return colInfo(index, ltrEdge(cell));
    };
    const getRightEdge = (index, cell)=>{
        return colInfo(index, rtlEdge(cell));
    };
    const getTop$1 = (cell)=>{
        return absolute(cell).top;
    };
    const getTopEdge = (index, cell)=>{
        return rowInfo(index, getTop$1(cell));
    };
    const getBottomEdge = (index, cell)=>{
        return rowInfo(index, getTop$1(cell) + getOuter$1(cell));
    };
    const findPositions = (getInnerEdge, getOuterEdge, array)=>{
        if (array.length === 0) return [];
        const lines = map$1(array.slice(1), (cellOption, index)=>{
            return cellOption.map((cell)=>{
                return getInnerEdge(index, cell);
            });
        });
        const lastLine = array[array.length - 1].map((cell)=>{
            return getOuterEdge(array.length - 1, cell);
        });
        return lines.concat([
            lastLine
        ]);
    };
    const negate = (step)=>{
        return -step;
    };
    const height1 = {
        delta: identity,
        positions: (optElements)=>findPositions(getTopEdge, getBottomEdge, optElements)
        ,
        edge: getTop$1
    };
    const ltr$1 = {
        delta: identity,
        edge: ltrEdge,
        positions: (optElements)=>findPositions(getLeftEdge, getRightEdge, optElements)
    };
    const rtl$1 = {
        delta: negate,
        edge: rtlEdge,
        positions: (optElements)=>findPositions(getRightEdge, getLeftEdge, optElements)
    };
    const detect$1 = onDirection(ltr$1, rtl$1);
    const width1 = {
        delta: (amount, table)=>detect$1(table).delta(amount, table)
        ,
        positions: (cols, table)=>detect$1(table).positions(cols, table)
        ,
        edge: (cell)=>detect$1(cell).edge(cell)
    };
    const units = {
        unsupportedLength: [
            'em',
            'ex',
            'cap',
            'ch',
            'ic',
            'rem',
            'lh',
            'rlh',
            'vw',
            'vh',
            'vi',
            'vb',
            'vmin',
            'vmax',
            'cm',
            'mm',
            'Q',
            'in',
            'pc',
            'pt',
            'px'
        ],
        fixed: [
            'px',
            'pt'
        ],
        relative: [
            '%'
        ],
        empty: [
            ''
        ]
    };
    const pattern = (()=>{
        const decimalDigits = '[0-9]+';
        const signedInteger = '[+-]?' + decimalDigits;
        const exponentPart = '[eE]' + signedInteger;
        const dot = '\\.';
        const opt = (input)=>`(?:${input})?`
        ;
        const unsignedDecimalLiteral = [
            'Infinity',
            decimalDigits + dot + opt(decimalDigits) + opt(exponentPart),
            dot + decimalDigits + opt(exponentPart),
            decimalDigits + opt(exponentPart)
        ].join('|');
        const float = `[+-]?(?:${unsignedDecimalLiteral})`;
        return new RegExp(`^(${float})(.*)$`);
    })();
    const isUnit = (unit, accepted)=>exists(accepted, (acc)=>exists(units[acc], (check)=>unit === check
            )
        )
    ;
    const parse = (input, accepted)=>{
        const match = Optional.from(pattern.exec(input));
        return match.bind((array)=>{
            const value = Number(array[1]);
            const unitRaw = array[2];
            if (isUnit(unitRaw, accepted)) return Optional.some({
                value,
                unit: unitRaw
            });
            else return Optional.none();
        });
    };
    const rPercentageBasedSizeRegex = /(\d+(\.\d+)?)%/;
    const rPixelBasedSizeRegex = /(\d+(\.\d+)?)px|em/;
    const isCol$2 = isTag('col');
    const getPercentSize = (elm, outerGetter, innerGetter)=>{
        const relativeParent = parentElement(elm).getOrThunk(()=>getBody$1(owner(elm))
        );
        return outerGetter(elm) / innerGetter(relativeParent) * 100;
    };
    const setPixelWidth = (cell, amount)=>{
        set$1(cell, 'width', amount + 'px');
    };
    const setPercentageWidth = (cell, amount)=>{
        set$1(cell, 'width', amount + '%');
    };
    const setHeight = (cell, amount)=>{
        set$1(cell, 'height', amount + 'px');
    };
    const getHeightValue = (cell)=>getRuntime(cell) + 'px'
    ;
    const convert = (cell, number, getter, setter)=>{
        const newSize = table1(cell).map((table)=>{
            const total = getter(table);
            return Math.floor(number / 100 * total);
        }).getOr(number);
        setter(cell, newSize);
        return newSize;
    };
    const normalizePixelSize = (value, cell, getter, setter)=>{
        const number = parseFloat(value);
        return endsWith(value, '%') && name1(cell) !== 'table' ? convert(cell, number, getter, setter) : number;
    };
    const getTotalHeight = (cell)=>{
        const value = getHeightValue(cell);
        if (!value) return get$8(cell);
        return normalizePixelSize(value, cell, get$8, setHeight);
    };
    const get$7 = (cell, type, f)=>{
        const v = f(cell);
        const span = getSpan(cell, type);
        return v / span;
    };
    const getRaw$1 = (element, prop)=>{
        return getRaw$2(element, prop).orThunk(()=>{
            return getOpt(element, prop).map((val)=>val + 'px'
            );
        });
    };
    const getRawWidth$1 = (element)=>getRaw$1(element, 'width')
    ;
    const getRawHeight = (element)=>getRaw$1(element, 'height')
    ;
    const getPercentageWidth = (cell)=>getPercentSize(cell, get$9, getInner)
    ;
    const getPixelWidth$1 = (cell)=>isCol$2(cell) ? get$9(cell) : getRuntime$1(cell)
    ;
    const getHeight1 = (cell)=>{
        return get$7(cell, 'rowspan', getTotalHeight);
    };
    const getGenericWidth = (cell)=>{
        const width = getRawWidth$1(cell);
        return width.bind((w)=>parse(w, [
                'fixed',
                'relative',
                'empty'
            ])
        );
    };
    const setGenericWidth = (cell, amount, unit)=>{
        set$1(cell, 'width', amount + unit);
    };
    const getPixelTableWidth = (table)=>get$9(table) + 'px'
    ;
    const getPercentTableWidth = (table)=>getPercentSize(table, get$9, getInner) + '%'
    ;
    const isPercentSizing$1 = (table)=>getRawWidth$1(table).exists((size)=>rPercentageBasedSizeRegex.test(size)
        )
    ;
    const isPixelSizing$1 = (table)=>getRawWidth$1(table).exists((size)=>rPixelBasedSizeRegex.test(size)
        )
    ;
    const isNoneSizing$1 = (table)=>getRawWidth$1(table).isNone()
    ;
    const percentageBasedSizeRegex = constant(rPercentageBasedSizeRegex);
    const isCol$1 = isTag('col');
    const getRawW = (cell)=>{
        return getRawWidth$1(cell).getOrThunk(()=>getPixelWidth$1(cell) + 'px'
        );
    };
    const getRawH = (cell)=>{
        return getRawHeight(cell).getOrThunk(()=>getHeight1(cell) + 'px'
        );
    };
    const justCols = (warehouse)=>map$1(Warehouse.justColumns(warehouse), (column)=>Optional.from(column.element)
        )
    ;
    const isValidColumn = (cell)=>{
        const browser = detect$2().browser;
        const supportsColWidths = browser.isChromium() || browser.isFirefox();
        return isCol$1(cell) ? supportsColWidths : true;
    };
    const getDimension = (cellOpt, index, backups, filter, getter, fallback)=>cellOpt.filter(filter).fold(()=>fallback(deduce(backups, index))
        , (cell)=>getter(cell)
        )
    ;
    const getWidthFrom = (warehouse, table, getWidth, fallback)=>{
        const columnCells = columns1(warehouse);
        const columns$1 = Warehouse.hasColumns(warehouse) ? justCols(warehouse) : columnCells;
        const backups = [
            Optional.some(width1.edge(table))
        ].concat(map$1(width1.positions(columnCells, table), (pos)=>pos.map((p)=>p.x
            )
        ));
        const colFilter = not(hasColspan);
        return map$1(columns$1, (cellOption, c)=>{
            return getDimension(cellOption, c, backups, colFilter, (column)=>{
                if (isValidColumn(column)) return getWidth(column);
                else {
                    const cell2 = bindFrom(columnCells[c], identity);
                    return getDimension(cell2, c, backups, colFilter, (cell)=>fallback(Optional.some(get$9(cell)))
                    , fallback);
                }
            }, fallback);
        });
    };
    const getDeduced = (deduced)=>{
        return deduced.map((d)=>{
            return d + 'px';
        }).getOr('');
    };
    const getRawWidths = (warehouse, table)=>{
        return getWidthFrom(warehouse, table, getRawW, getDeduced);
    };
    const getPercentageWidths = (warehouse, table, tableSize)=>{
        return getWidthFrom(warehouse, table, getPercentageWidth, (deduced)=>{
            return deduced.fold(()=>{
                return tableSize.minCellWidth();
            }, (cellWidth)=>{
                return cellWidth / tableSize.pixelWidth() * 100;
            });
        });
    };
    const getPixelWidths = (warehouse, table, tableSize)=>{
        return getWidthFrom(warehouse, table, getPixelWidth$1, (deduced)=>{
            return deduced.getOrThunk(tableSize.minCellWidth);
        });
    };
    const getHeightFrom = (warehouse, table, direction, getHeight, fallback)=>{
        const rows$1 = rows1(warehouse);
        const backups = [
            Optional.some(direction.edge(table))
        ].concat(map$1(direction.positions(rows$1, table), (pos)=>pos.map((p)=>p.y
            )
        ));
        return map$1(rows$1, (cellOption, c)=>{
            return getDimension(cellOption, c, backups, not(hasRowspan), getHeight, fallback);
        });
    };
    const getPixelHeights = (warehouse, table, direction)=>{
        return getHeightFrom(warehouse, table, direction, getHeight1, (deduced)=>{
            return deduced.getOrThunk(minHeight);
        });
    };
    const getRawHeights = (warehouse, table, direction)=>{
        return getHeightFrom(warehouse, table, direction, getRawH, getDeduced);
    };
    const widthLookup = (table, getter)=>()=>{
            if (inBody(table)) return getter(table);
            else return parseFloat(getRaw$2(table, 'width').getOr('0'));
        }
    ;
    const noneSize = (table)=>{
        const getWidth = widthLookup(table, get$9);
        const zero = constant(0);
        const getWidths = (warehouse, tableSize)=>getPixelWidths(warehouse, table, tableSize)
        ;
        return {
            width: getWidth,
            pixelWidth: getWidth,
            getWidths,
            getCellDelta: zero,
            singleColumnWidth: constant([
                0
            ]),
            minCellWidth: zero,
            setElementWidth: noop,
            adjustTableWidth: noop,
            isRelative: true,
            label: 'none'
        };
    };
    const percentageSize = (table)=>{
        const getFloatWidth = widthLookup(table, (elem)=>parseFloat(getPercentTableWidth(elem))
        );
        const getWidth = widthLookup(table, get$9);
        const getCellDelta = (delta)=>delta / getWidth() * 100
        ;
        const singleColumnWidth = (w, _delta)=>[
                100 - w
            ]
        ;
        const minCellWidth = ()=>minWidth() / getWidth() * 100
        ;
        const adjustTableWidth = (delta)=>{
            const currentWidth = getFloatWidth();
            const change = delta / 100 * currentWidth;
            const newWidth = currentWidth + change;
            setPercentageWidth(table, newWidth);
        };
        const getWidths = (warehouse, tableSize)=>getPercentageWidths(warehouse, table, tableSize)
        ;
        return {
            width: getFloatWidth,
            pixelWidth: getWidth,
            getWidths,
            getCellDelta,
            singleColumnWidth,
            minCellWidth,
            setElementWidth: setPercentageWidth,
            adjustTableWidth,
            isRelative: true,
            label: 'percent'
        };
    };
    const pixelSize = (table)=>{
        const getWidth = widthLookup(table, get$9);
        const getCellDelta = identity;
        const singleColumnWidth = (w, delta)=>{
            const newNext = Math.max(minWidth(), w + delta);
            return [
                newNext - w
            ];
        };
        const adjustTableWidth = (delta)=>{
            const newWidth = getWidth() + delta;
            setPixelWidth(table, newWidth);
        };
        const getWidths = (warehouse, tableSize)=>getPixelWidths(warehouse, table, tableSize)
        ;
        return {
            width: getWidth,
            pixelWidth: getWidth,
            getWidths,
            getCellDelta,
            singleColumnWidth,
            minCellWidth: minWidth,
            setElementWidth: setPixelWidth,
            adjustTableWidth,
            isRelative: false,
            label: 'pixel'
        };
    };
    const chooseSize = (element, width)=>{
        const percentMatch = percentageBasedSizeRegex().exec(width);
        if (percentMatch !== null) return percentageSize(element);
        else return pixelSize(element);
    };
    const getTableSize = (table)=>{
        const width = getRawWidth$1(table);
        return width.fold(()=>noneSize(table)
        , (w)=>chooseSize(table, w)
        );
    };
    const TableSize = {
        getTableSize,
        pixelSize,
        percentageSize,
        noneSize
    };
    const statsStruct = (minRow, minCol, maxRow, maxCol, allCells, selectedCells)=>({
            minRow,
            minCol,
            maxRow,
            maxCol,
            allCells,
            selectedCells
        })
    ;
    const findSelectedStats = (house, isSelected)=>{
        const totalColumns = house.grid.columns;
        const totalRows = house.grid.rows;
        let minRow = totalRows;
        let minCol = totalColumns;
        let maxRow = 0;
        let maxCol = 0;
        const allCells = [];
        const selectedCells = [];
        each$1(house.access, (detail)=>{
            allCells.push(detail);
            if (isSelected(detail)) {
                selectedCells.push(detail);
                const startRow = detail.row;
                const endRow = startRow + detail.rowspan - 1;
                const startCol = detail.column;
                const endCol = startCol + detail.colspan - 1;
                if (startRow < minRow) minRow = startRow;
                else if (endRow > maxRow) maxRow = endRow;
                if (startCol < minCol) minCol = startCol;
                else if (endCol > maxCol) maxCol = endCol;
            }
        });
        return statsStruct(minRow, minCol, maxRow, maxCol, allCells, selectedCells);
    };
    const makeCell = (list, seenSelected, rowIndex)=>{
        const row = list[rowIndex].element;
        const td = SugarElement.fromTag('td');
        append$1(td, SugarElement.fromTag('br'));
        const f = seenSelected ? append$1 : prepend;
        f(row, td);
    };
    const fillInGaps = (list, house, stats, isSelected)=>{
        const rows = filter$2(list, (row)=>row.section !== 'colgroup'
        );
        const totalColumns = house.grid.columns;
        const totalRows = house.grid.rows;
        for(let i = 0; i < totalRows; i++){
            let seenSelected = false;
            for(let j = 0; j < totalColumns; j++)if (!(i < stats.minRow || i > stats.maxRow || j < stats.minCol || j > stats.maxCol)) {
                const needCell = Warehouse.getAt(house, i, j).filter(isSelected).isNone();
                if (needCell) makeCell(rows, seenSelected, i);
                else seenSelected = true;
            }
        }
    };
    const clean = (replica, stats, house, widthDelta)=>{
        each$1(house.columns, (col)=>{
            if (col.column < stats.minCol || col.column > stats.maxCol) remove$6(col.element);
        });
        const emptyRows = filter$2(firstLayer(replica, 'tr'), (row)=>row.dom.childElementCount === 0
        );
        each$2(emptyRows, remove$6);
        if (stats.minCol === stats.maxCol || stats.minRow === stats.maxRow) each$2(firstLayer(replica, 'th,td'), (cell)=>{
            remove$7(cell, 'rowspan');
            remove$7(cell, 'colspan');
        });
        remove$7(replica, LOCKED_COL_ATTR);
        remove$7(replica, 'data-snooker-col-series');
        const tableSize = TableSize.getTableSize(replica);
        tableSize.adjustTableWidth(widthDelta);
    };
    const getTableWidthDelta = (table, warehouse, tableSize, stats)=>{
        if (stats.minCol === 0 && warehouse.grid.columns === stats.maxCol + 1) return 0;
        const colWidths = getPixelWidths(warehouse, table, tableSize);
        const allColsWidth = foldl(colWidths, (acc, width)=>acc + width
        , 0);
        const selectedColsWidth = foldl(colWidths.slice(stats.minCol, stats.maxCol + 1), (acc, width)=>acc + width
        , 0);
        const newWidth = selectedColsWidth / allColsWidth * tableSize.pixelWidth();
        const delta = newWidth - tableSize.pixelWidth();
        return tableSize.getCellDelta(delta);
    };
    const extract$1 = (table, selectedSelector)=>{
        const isSelected = (detail)=>is$2(detail.element, selectedSelector)
        ;
        const replica = deep(table);
        const list = fromTable$1(replica);
        const tableSize = TableSize.getTableSize(table);
        const replicaHouse = Warehouse.generate(list);
        const replicaStats = findSelectedStats(replicaHouse, isSelected);
        const selector = 'th:not(' + selectedSelector + ')' + ',td:not(' + selectedSelector + ')';
        const unselectedCells = filterFirstLayer(replica, 'th,td', (cell)=>is$2(cell, selector)
        );
        each$2(unselectedCells, remove$6);
        fillInGaps(list, replicaHouse, replicaStats, isSelected);
        const house = Warehouse.fromTable(table);
        const widthDelta = getTableWidthDelta(table, house, tableSize, replicaStats);
        clean(replica, replicaStats, replicaHouse, widthDelta);
        return replica;
    };
    const nbsp = '\xA0';
    const NodeValue = (is, name)=>{
        const get = (element)=>{
            if (!is(element)) throw new Error('Can only get ' + name + ' value of a ' + name + ' node');
            return getOption(element).getOr('');
        };
        const getOption = (element)=>is(element) ? Optional.from(element.dom.nodeValue) : Optional.none()
        ;
        const set = (element, value)=>{
            if (!is(element)) throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');
            element.dom.nodeValue = value;
        };
        return {
            get,
            getOption,
            set
        };
    };
    const api = NodeValue(isText, 'text');
    const get$6 = (element)=>api.get(element)
    ;
    const getOption1 = (element)=>api.getOption(element)
    ;
    const set1 = (element, value)=>api.set(element, value)
    ;
    const getEnd = (element)=>name1(element) === 'img' ? 1 : getOption1(element).fold(()=>children$2(element).length
        , (v)=>v.length
        )
    ;
    const isTextNodeWithCursorPosition = (el)=>getOption1(el).filter((text)=>text.trim().length !== 0 || text.indexOf(nbsp) > -1
        ).isSome()
    ;
    const elementsWithCursorPosition = [
        'img',
        'br'
    ];
    const isCursorPosition = (elem)=>{
        const hasCursorPosition = isTextNodeWithCursorPosition(elem);
        return hasCursorPosition || contains$2(elementsWithCursorPosition, name1(elem));
    };
    const first1 = (element)=>descendant$1(element, isCursorPosition)
    ;
    const last$1 = (element)=>descendantRtl(element, isCursorPosition)
    ;
    const descendantRtl = (scope, predicate)=>{
        const descend = (element)=>{
            const children = children$2(element);
            for(let i = children.length - 1; i >= 0; i--){
                const child = children[i];
                if (predicate(child)) return Optional.some(child);
                const res = descend(child);
                if (res.isSome()) return res;
            }
            return Optional.none();
        };
        return descend(scope);
    };
    const transferableAttributes = {
        scope: [
            'row',
            'col'
        ]
    };
    const createCell = (doc)=>()=>{
            const td = SugarElement.fromTag('td', doc.dom);
            append$1(td, SugarElement.fromTag('br', doc.dom));
            return td;
        }
    ;
    const createCol = (doc)=>()=>{
            return SugarElement.fromTag('col', doc.dom);
        }
    ;
    const createColgroup = (doc)=>()=>{
            return SugarElement.fromTag('colgroup', doc.dom);
        }
    ;
    const createRow$1 = (doc)=>()=>{
            return SugarElement.fromTag('tr', doc.dom);
        }
    ;
    const replace$1 = (cell, tag, attrs)=>{
        const replica = copy$2(cell, tag);
        each$1(attrs, (v, k)=>{
            if (v === null) remove$7(replica, k);
            else set$2(replica, k, v);
        });
        return replica;
    };
    const pasteReplace = (cell)=>{
        return cell;
    };
    const cloneFormats1 = (oldCell, newCell, formats)=>{
        const first$1 = first1(oldCell);
        return first$1.map((firstText)=>{
            const formatSelector = formats.join(',');
            const parents = ancestors$3(firstText, formatSelector, (element)=>{
                return eq$1(element, oldCell);
            });
            return foldr(parents, (last, parent)=>{
                const clonedFormat = shallow(parent);
                remove$7(clonedFormat, 'contenteditable');
                append$1(last, clonedFormat);
                return clonedFormat;
            }, newCell);
        }).getOr(newCell);
    };
    const cloneAppropriateAttributes = (original, clone)=>{
        each$1(transferableAttributes, (validAttributes, attributeName)=>getOpt(original, attributeName).filter((attribute)=>contains$2(validAttributes, attribute)
            ).each((attribute)=>set$2(clone, attributeName, attribute)
            )
        );
    };
    const cellOperations = (mutate, doc, formatsToClone)=>{
        const cloneCss = (prev, clone)=>{
            copy$1(prev.element, clone);
            remove$5(clone, 'height');
            if (prev.colspan !== 1) remove$5(clone, 'width');
        };
        const newCell = (prev)=>{
            const td = SugarElement.fromTag(name1(prev.element), doc.dom);
            const formats = formatsToClone.getOr([
                'strong',
                'em',
                'b',
                'i',
                'span',
                'font',
                'h1',
                'h2',
                'h3',
                'h4',
                'h5',
                'h6',
                'p',
                'div'
            ]);
            const lastNode = formats.length > 0 ? cloneFormats1(prev.element, td, formats) : td;
            append$1(lastNode, SugarElement.fromTag('br'));
            cloneCss(prev, td);
            cloneAppropriateAttributes(prev.element, td);
            mutate(prev.element, td);
            return td;
        };
        const newCol = (prev)=>{
            const col = SugarElement.fromTag(name1(prev.element), doc.dom);
            cloneCss(prev, col);
            mutate(prev.element, col);
            return col;
        };
        return {
            col: newCol,
            colgroup: createColgroup(doc),
            row: createRow$1(doc),
            cell: newCell,
            replace: replace$1,
            colGap: createCol(doc),
            gap: createCell(doc)
        };
    };
    const paste$1 = (doc)=>{
        return {
            col: createCol(doc),
            colgroup: createColgroup(doc),
            row: createRow$1(doc),
            cell: createCell(doc),
            replace: pasteReplace,
            colGap: createCol(doc),
            gap: createCell(doc)
        };
    };
    const fromHtml = (html, scope)=>{
        const doc = scope || document;
        const div = doc.createElement('div');
        div.innerHTML = html;
        return children$2(SugarElement.fromDom(div));
    };
    const fromDom = (nodes)=>map$1(nodes, SugarElement.fromDom)
    ;
    const getBody = (editor)=>SugarElement.fromDom(editor.getBody())
    ;
    const getIsRoot1 = (editor)=>(element)=>eq$1(element, getBody(editor))
    ;
    const removeDataStyle = (table)=>{
        remove$7(table, 'data-mce-style');
        const removeStyleAttribute = (element)=>remove$7(element, 'data-mce-style')
        ;
        each$2(cells$1(table), removeStyleAttribute);
        each$2(columns$11(table), removeStyleAttribute);
        each$2(rows$11(table), removeStyleAttribute);
    };
    const getSelectionStart = (editor)=>SugarElement.fromDom(editor.selection.getStart())
    ;
    const getPixelWidth = (elm)=>elm.getBoundingClientRect().width
    ;
    const getPixelHeight = (elm)=>elm.getBoundingClientRect().height
    ;
    const getRawWidth = (editor, elm)=>{
        const raw = editor.dom.getStyle(elm, 'width') || editor.dom.getAttrib(elm, 'width');
        return Optional.from(raw).filter(isNotEmpty);
    };
    const isPercentage$1 = (value)=>/^(\d+(\.\d+)?)%$/.test(value)
    ;
    const isPixel = (value)=>/^(\d+(\.\d+)?)px$/.test(value)
    ;
    const inSelection = (bounds, detail)=>{
        const leftEdge = detail.column;
        const rightEdge = detail.column + detail.colspan - 1;
        const topEdge = detail.row;
        const bottomEdge = detail.row + detail.rowspan - 1;
        return leftEdge <= bounds.finishCol && rightEdge >= bounds.startCol && topEdge <= bounds.finishRow && bottomEdge >= bounds.startRow;
    };
    const isWithin = (bounds, detail)=>{
        return detail.column >= bounds.startCol && detail.column + detail.colspan - 1 <= bounds.finishCol && detail.row >= bounds.startRow && detail.row + detail.rowspan - 1 <= bounds.finishRow;
    };
    const isRectangular = (warehouse, bounds)=>{
        let isRect = true;
        const detailIsWithin = curry(isWithin, bounds);
        for(let i = bounds.startRow; i <= bounds.finishRow; i++)for(let j = bounds.startCol; j <= bounds.finishCol; j++)isRect = isRect && Warehouse.getAt(warehouse, i, j).exists(detailIsWithin);
        return isRect ? Optional.some(bounds) : Optional.none();
    };
    const getBounds = (detailA, detailB)=>{
        return bounds1(Math.min(detailA.row, detailB.row), Math.min(detailA.column, detailB.column), Math.max(detailA.row + detailA.rowspan - 1, detailB.row + detailB.rowspan - 1), Math.max(detailA.column + detailA.colspan - 1, detailB.column + detailB.colspan - 1));
    };
    const getAnyBox = (warehouse, startCell, finishCell)=>{
        const startCoords = Warehouse.findItem(warehouse, startCell, eq$1);
        const finishCoords = Warehouse.findItem(warehouse, finishCell, eq$1);
        return startCoords.bind((sc)=>{
            return finishCoords.map((fc)=>{
                return getBounds(sc, fc);
            });
        });
    };
    const getBox$1 = (warehouse, startCell, finishCell)=>{
        return getAnyBox(warehouse, startCell, finishCell).bind((bounds)=>{
            return isRectangular(warehouse, bounds);
        });
    };
    const moveBy$1 = (warehouse, cell, row, column)=>{
        return Warehouse.findItem(warehouse, cell, eq$1).bind((detail)=>{
            const startRow = row > 0 ? detail.row + detail.rowspan - 1 : detail.row;
            const startCol = column > 0 ? detail.column + detail.colspan - 1 : detail.column;
            const dest = Warehouse.getAt(warehouse, startRow + row, startCol + column);
            return dest.map((d)=>{
                return d.element;
            });
        });
    };
    const intercepts$1 = (warehouse, start, finish)=>{
        return getAnyBox(warehouse, start, finish).map((bounds)=>{
            const inside = Warehouse.filterItems(warehouse, curry(inSelection, bounds));
            return map$1(inside, (detail)=>{
                return detail.element;
            });
        });
    };
    const parentCell = (warehouse, innerCell)=>{
        const isContainedBy = (c1, c2)=>{
            return contains$1(c2, c1);
        };
        return Warehouse.findItem(warehouse, innerCell, isContainedBy).map((detail)=>{
            return detail.element;
        });
    };
    const moveBy = (cell, deltaRow, deltaColumn)=>{
        return table1(cell).bind((table)=>{
            const warehouse = getWarehouse(table);
            return moveBy$1(warehouse, cell, deltaRow, deltaColumn);
        });
    };
    const intercepts = (table, first, last)=>{
        const warehouse = getWarehouse(table);
        return intercepts$1(warehouse, first, last);
    };
    const nestedIntercepts = (table, first, firstTable, last, lastTable)=>{
        const warehouse = getWarehouse(table);
        const optStartCell = eq$1(table, firstTable) ? Optional.some(first) : parentCell(warehouse, first);
        const optLastCell = eq$1(table, lastTable) ? Optional.some(last) : parentCell(warehouse, last);
        return optStartCell.bind((startCell)=>optLastCell.bind((lastCell)=>intercepts$1(warehouse, startCell, lastCell)
            )
        );
    };
    const getBox = (table, first, last)=>{
        const warehouse = getWarehouse(table);
        return getBox$1(warehouse, first, last);
    };
    const getWarehouse = Warehouse.fromTable;
    var TagBoundaries = [
        'body',
        'p',
        'div',
        'article',
        'aside',
        'figcaption',
        'figure',
        'footer',
        'header',
        'nav',
        'section',
        'ol',
        'ul',
        'li',
        'table',
        'thead',
        'tbody',
        'tfoot',
        'caption',
        'tr',
        'td',
        'th',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'blockquote',
        'pre',
        'address'
    ];
    var DomUniverse = ()=>{
        const clone = (element)=>{
            return SugarElement.fromDom(element.dom.cloneNode(false));
        };
        const document = (element)=>documentOrOwner(element).dom
        ;
        const isBoundary = (element)=>{
            if (!isElement(element)) return false;
            if (name1(element) === 'body') return true;
            return contains$2(TagBoundaries, name1(element));
        };
        const isEmptyTag = (element)=>{
            if (!isElement(element)) return false;
            return contains$2([
                'br',
                'img',
                'hr',
                'input'
            ], name1(element));
        };
        const isNonEditable = (element)=>isElement(element) && get$b(element, 'contenteditable') === 'false'
        ;
        const comparePosition = (element, other)=>{
            return element.dom.compareDocumentPosition(other.dom);
        };
        const copyAttributesTo = (source, destination)=>{
            const as = clone$2(source);
            setAll$1(destination, as);
        };
        const isSpecial = (element)=>{
            const tag = name1(element);
            return contains$2([
                'script',
                'noscript',
                'iframe',
                'noframes',
                'noembed',
                'title',
                'style',
                'textarea',
                'xmp'
            ], tag);
        };
        const getLanguage = (element)=>isElement(element) ? getOpt(element, 'lang') : Optional.none()
        ;
        return {
            up: constant({
                selector: ancestor$1,
                closest: closest$1,
                predicate: ancestor$2,
                all: parents1
            }),
            down: constant({
                selector: descendants,
                predicate: descendants$1
            }),
            styles: constant({
                get: get$a,
                getRaw: getRaw$2,
                set: set$1,
                remove: remove$5
            }),
            attrs: constant({
                get: get$b,
                set: set$2,
                remove: remove$7,
                copyTo: copyAttributesTo
            }),
            insert: constant({
                before: before$3,
                after: after$5,
                afterAll: after$4,
                append: append$1,
                appendAll: append,
                prepend: prepend,
                wrap: wrap
            }),
            remove: constant({
                unwrap: unwrap,
                remove: remove$6
            }),
            create: constant({
                nu: SugarElement.fromTag,
                clone,
                text: SugarElement.fromText
            }),
            query: constant({
                comparePosition,
                prevSibling: prevSibling,
                nextSibling: nextSibling
            }),
            property: constant({
                children: children$2,
                name: name1,
                parent: parent1,
                document,
                isText: isText,
                isComment: isComment,
                isElement: isElement,
                isSpecial,
                getLanguage,
                getText: get$6,
                setText: set1,
                isBoundary,
                isEmptyTag,
                isNonEditable
            }),
            eq: eq$1,
            is: is$1
        };
    };
    const all1 = (universe, look, elements, f)=>{
        const head = elements[0];
        const tail = elements.slice(1);
        return f(universe, look, head, tail);
    };
    const oneAll = (universe, look, elements)=>{
        return elements.length > 0 ? all1(universe, look, elements, unsafeOne) : Optional.none();
    };
    const unsafeOne = (universe, look, head, tail)=>{
        const start = look(universe, head);
        return foldr(tail, (b, a)=>{
            const current = look(universe, a);
            return commonElement(universe, b, current);
        }, start);
    };
    const commonElement = (universe, start, end)=>{
        return start.bind((s)=>{
            return end.filter(curry(universe.eq, s));
        });
    };
    const eq = (universe, item)=>{
        return curry(universe.eq, item);
    };
    const ancestors$2 = (universe, start, end, isRoot = never)=>{
        const ps1 = [
            start
        ].concat(universe.up().all(start));
        const ps2 = [
            end
        ].concat(universe.up().all(end));
        const prune = (path)=>{
            const index = findIndex(path, isRoot);
            return index.fold(()=>{
                return path;
            }, (ind)=>{
                return path.slice(0, ind + 1);
            });
        };
        const pruned1 = prune(ps1);
        const pruned2 = prune(ps2);
        const shared = find$1(pruned1, (x)=>{
            return exists(pruned2, eq(universe, x));
        });
        return {
            firstpath: pruned1,
            secondpath: pruned2,
            shared
        };
    };
    const sharedOne$1 = oneAll;
    const ancestors$1 = ancestors$2;
    const universe$3 = DomUniverse();
    const sharedOne = (look, elements)=>{
        return sharedOne$1(universe$3, (_universe, element)=>{
            return look(element);
        }, elements);
    };
    const ancestors = (start, finish, isRoot)=>{
        return ancestors$1(universe$3, start, finish, isRoot);
    };
    const lookupTable = (container)=>{
        return ancestor$1(container, 'table');
    };
    const identify = (start, finish, isRoot)=>{
        const getIsRoot = (rootTable)=>{
            return (element)=>{
                return isRoot !== undefined && isRoot(element) || eq$1(element, rootTable);
            };
        };
        if (eq$1(start, finish)) return Optional.some({
            boxes: Optional.some([
                start
            ]),
            start,
            finish
        });
        else return lookupTable(start).bind((startTable)=>{
            return lookupTable(finish).bind((finishTable)=>{
                if (eq$1(startTable, finishTable)) return Optional.some({
                    boxes: intercepts(startTable, start, finish),
                    start,
                    finish
                });
                else if (contains$1(startTable, finishTable)) {
                    const ancestorCells = ancestors$3(finish, 'td,th', getIsRoot(startTable));
                    const finishCell = ancestorCells.length > 0 ? ancestorCells[ancestorCells.length - 1] : finish;
                    return Optional.some({
                        boxes: nestedIntercepts(startTable, start, startTable, finish, finishTable),
                        start,
                        finish: finishCell
                    });
                } else if (contains$1(finishTable, startTable)) {
                    const ancestorCells = ancestors$3(start, 'td,th', getIsRoot(finishTable));
                    const startCell = ancestorCells.length > 0 ? ancestorCells[ancestorCells.length - 1] : start;
                    return Optional.some({
                        boxes: nestedIntercepts(finishTable, start, startTable, finish, finishTable),
                        start,
                        finish: startCell
                    });
                } else return ancestors(start, finish).shared.bind((lca)=>{
                    return closest$1(lca, 'table', isRoot).bind((lcaTable)=>{
                        const finishAncestorCells = ancestors$3(finish, 'td,th', getIsRoot(lcaTable));
                        const finishCell = finishAncestorCells.length > 0 ? finishAncestorCells[finishAncestorCells.length - 1] : finish;
                        const startAncestorCells = ancestors$3(start, 'td,th', getIsRoot(lcaTable));
                        const startCell = startAncestorCells.length > 0 ? startAncestorCells[startAncestorCells.length - 1] : start;
                        return Optional.some({
                            boxes: nestedIntercepts(lcaTable, start, startTable, finish, finishTable),
                            start: startCell,
                            finish: finishCell
                        });
                    });
                });
            });
        });
    };
    const retrieve$1 = (container, selector)=>{
        const sels = descendants(container, selector);
        return sels.length > 0 ? Optional.some(sels) : Optional.none();
    };
    const getLast = (boxes, lastSelectedSelector)=>{
        return find$1(boxes, (box)=>{
            return is$2(box, lastSelectedSelector);
        });
    };
    const getEdges = (container, firstSelectedSelector, lastSelectedSelector)=>{
        return descendant(container, firstSelectedSelector).bind((first)=>{
            return descendant(container, lastSelectedSelector).bind((last)=>{
                return sharedOne(lookupTable, [
                    first,
                    last
                ]).map((table)=>{
                    return {
                        first,
                        last,
                        table
                    };
                });
            });
        });
    };
    const expandTo = (finish, firstSelectedSelector)=>{
        return ancestor$1(finish, 'table').bind((table)=>{
            return descendant(table, firstSelectedSelector).bind((start)=>{
                return identify(start, finish).bind((identified)=>{
                    return identified.boxes.map((boxes)=>{
                        return {
                            boxes,
                            start: identified.start,
                            finish: identified.finish
                        };
                    });
                });
            });
        });
    };
    const shiftSelection = (boxes, deltaRow, deltaColumn, firstSelectedSelector, lastSelectedSelector)=>{
        return getLast(boxes, lastSelectedSelector).bind((last)=>{
            return moveBy(last, deltaRow, deltaColumn).bind((finish)=>{
                return expandTo(finish, firstSelectedSelector);
            });
        });
    };
    const retrieve = (container, selector)=>{
        return retrieve$1(container, selector);
    };
    const retrieveBox = (container, firstSelectedSelector, lastSelectedSelector)=>{
        return getEdges(container, firstSelectedSelector, lastSelectedSelector).bind((edges)=>{
            const isRoot = (ancestor)=>{
                return eq$1(container, ancestor);
            };
            const sectionSelector = 'thead,tfoot,tbody,table';
            const firstAncestor = ancestor$1(edges.first, sectionSelector, isRoot);
            const lastAncestor = ancestor$1(edges.last, sectionSelector, isRoot);
            return firstAncestor.bind((fA)=>{
                return lastAncestor.bind((lA)=>{
                    return eq$1(fA, lA) ? getBox(edges.table, edges.first, edges.last) : Optional.none();
                });
            });
        });
    };
    const selection1 = identity;
    const unmergable1 = (selectedCells)=>{
        const hasSpan = (elem, type)=>getOpt(elem, type).exists((span)=>parseInt(span, 10) > 1
            )
        ;
        const hasRowOrColSpan = (elem)=>hasSpan(elem, 'rowspan') || hasSpan(elem, 'colspan')
        ;
        return selectedCells.length > 0 && forall(selectedCells, hasRowOrColSpan) ? Optional.some(selectedCells) : Optional.none();
    };
    const mergable1 = (table, selectedCells, ephemera)=>{
        if (selectedCells.length <= 1) return Optional.none();
        else return retrieveBox(table, ephemera.firstSelectedSelector, ephemera.lastSelectedSelector).map((bounds)=>({
                bounds,
                cells: selectedCells
            })
        );
    };
    const strSelected = 'data-mce-selected';
    const strSelectedSelector = 'td[' + strSelected + '],th[' + strSelected + ']';
    const strAttributeSelector = '[' + strSelected + ']';
    const strFirstSelected = 'data-mce-first-selected';
    const strFirstSelectedSelector = 'td[' + strFirstSelected + '],th[' + strFirstSelected + ']';
    const strLastSelected = 'data-mce-last-selected';
    const strLastSelectedSelector = 'td[' + strLastSelected + '],th[' + strLastSelected + ']';
    const attributeSelector = strAttributeSelector;
    const ephemera1 = {
        selected: strSelected,
        selectedSelector: strSelectedSelector,
        firstSelected: strFirstSelected,
        firstSelectedSelector: strFirstSelectedSelector,
        lastSelected: strLastSelected,
        lastSelectedSelector: strLastSelectedSelector
    };
    const forMenu = (selectedCells, table, cell)=>({
            element: cell,
            mergable: mergable1(table, selectedCells, ephemera1),
            unmergable: unmergable1(selectedCells),
            selection: selection1(selectedCells)
        })
    ;
    const paste = (element, clipboard, generators)=>({
            element,
            clipboard,
            generators
        })
    ;
    const pasteRows = (selectedCells, _cell, clipboard, generators)=>({
            selection: selection1(selectedCells),
            clipboard,
            generators
        })
    ;
    const getSelectionCellFallback = (element)=>table1(element).bind((table)=>retrieve(table, ephemera1.firstSelectedSelector)
        ).fold(constant(element), (cells)=>cells[0]
        )
    ;
    const getSelectionFromSelector = (selector)=>(initCell, isRoot)=>{
            const cellName = name1(initCell);
            const cell = cellName === 'col' || cellName === 'colgroup' ? getSelectionCellFallback(initCell) : initCell;
            return closest$1(cell, selector, isRoot);
        }
    ;
    const getSelectionCellOrCaption = getSelectionFromSelector('th,td,caption');
    const getSelectionCell = getSelectionFromSelector('th,td');
    const getCellsFromSelection = (editor)=>fromDom(editor.model.table.getSelectedCells())
    ;
    const getCellsFromFakeSelection = (editor)=>filter$2(getCellsFromSelection(editor), (cell)=>is$2(cell, ephemera1.selectedSelector)
        )
    ;
    const extractSelected = (cells)=>{
        return table1(cells[0]).map((table)=>{
            const replica = extract$1(table, attributeSelector);
            removeDataStyle(replica);
            return [
                replica
            ];
        });
    };
    const serializeElements = (editor, elements)=>map$1(elements, (elm)=>editor.selection.serializer.serialize(elm.dom, {})
        ).join('')
    ;
    const getTextContent = (elements)=>map$1(elements, (element)=>element.dom.innerText
        ).join('')
    ;
    const registerEvents = (editor, actions)=>{
        editor.on('BeforeGetContent', (e)=>{
            const multiCellContext = (cells)=>{
                e.preventDefault();
                extractSelected(cells).each((elements)=>{
                    e.content = e.format === 'text' ? getTextContent(elements) : serializeElements(editor, elements);
                });
            };
            if (e.selection === true) {
                const cells = getCellsFromFakeSelection(editor);
                if (cells.length >= 1) multiCellContext(cells);
            }
        });
        editor.on('BeforeSetContent', (e)=>{
            if (e.selection === true && e.paste === true) {
                const selectedCells = getCellsFromSelection(editor);
                head1(selectedCells).each((cell)=>{
                    table1(cell).each((table)=>{
                        const elements = filter$2(fromHtml(e.content), (content)=>{
                            return name1(content) !== 'meta';
                        });
                        const isTable = isTag('table');
                        if (elements.length === 1 && isTable(elements[0])) {
                            e.preventDefault();
                            const doc = SugarElement.fromDom(editor.getDoc());
                            const generators = paste$1(doc);
                            const targets = paste(cell, elements[0], generators);
                            actions.pasteCells(table, targets).each(()=>{
                                editor.focus();
                            });
                        }
                    });
                });
            }
        });
    };
    const point = (element, offset)=>({
            element,
            offset
        })
    ;
    const scan$1 = (universe, element, direction)=>{
        if (universe.property().isText(element) && universe.property().getText(element).trim().length === 0 || universe.property().isComment(element)) return direction(element).bind((elem)=>{
            return scan$1(universe, elem, direction).orThunk(()=>{
                return Optional.some(elem);
            });
        });
        else return Optional.none();
    };
    const toEnd = (universe, element)=>{
        if (universe.property().isText(element)) return universe.property().getText(element).length;
        const children = universe.property().children(element);
        return children.length;
    };
    const freefallRtl$2 = (universe, element)=>{
        const candidate = scan$1(universe, element, universe.query().prevSibling).getOr(element);
        if (universe.property().isText(candidate)) return point(candidate, toEnd(universe, candidate));
        const children = universe.property().children(candidate);
        return children.length > 0 ? freefallRtl$2(universe, children[children.length - 1]) : point(candidate, toEnd(universe, candidate));
    };
    const freefallRtl$1 = freefallRtl$2;
    const universe$2 = DomUniverse();
    const freefallRtl = (element)=>{
        return freefallRtl$1(universe$2, element);
    };
    const halve = (main, other)=>{
        if (!hasColspan(main)) {
            const width = getGenericWidth(main);
            width.each((w)=>{
                const newWidth = w.value / 2;
                setGenericWidth(main, newWidth, w.unit);
                setGenericWidth(other, newWidth, w.unit);
            });
        }
    };
    const zero1 = (array)=>map$1(array, constant(0))
    ;
    const surround = (sizes, startIndex, endIndex, results, f)=>f(sizes.slice(0, startIndex)).concat(results).concat(f(sizes.slice(endIndex)))
    ;
    const clampDeltaHelper = (predicate)=>(sizes, index, delta, minCellSize)=>{
            if (!predicate(delta)) return delta;
            else {
                const newSize = Math.max(minCellSize, sizes[index] - Math.abs(delta));
                const diff = Math.abs(newSize - sizes[index]);
                return delta >= 0 ? diff : -diff;
            }
        }
    ;
    const clampNegativeDelta = clampDeltaHelper((delta)=>delta < 0
    );
    const clampDelta = clampDeltaHelper(always);
    const resizeTable1 = ()=>{
        const calcFixedDeltas = (sizes, index, next, delta, minCellSize)=>{
            const clampedDelta = clampNegativeDelta(sizes, index, delta, minCellSize);
            return surround(sizes, index, next + 1, [
                clampedDelta,
                0
            ], zero1);
        };
        const calcRelativeDeltas = (sizes, index, delta, minCellSize)=>{
            const ratio = (100 + delta) / 100;
            const newThis = Math.max(minCellSize, (sizes[index] + delta) / ratio);
            return map$1(sizes, (size, idx)=>{
                const newSize = idx === index ? newThis : size / ratio;
                return newSize - size;
            });
        };
        const calcLeftEdgeDeltas = (sizes, index, next, delta, minCellSize, isRelative)=>{
            if (isRelative) return calcRelativeDeltas(sizes, index, delta, minCellSize);
            else return calcFixedDeltas(sizes, index, next, delta, minCellSize);
        };
        const calcMiddleDeltas = (sizes, _prev, index, next, delta, minCellSize, isRelative)=>calcLeftEdgeDeltas(sizes, index, next, delta, minCellSize, isRelative)
        ;
        const resizeTable = (resizer, delta)=>resizer(delta)
        ;
        const calcRightEdgeDeltas = (sizes, _prev, index, delta, minCellSize, isRelative)=>{
            if (isRelative) return calcRelativeDeltas(sizes, index, delta, minCellSize);
            else {
                const clampedDelta = clampNegativeDelta(sizes, index, delta, minCellSize);
                return zero1(sizes.slice(0, index)).concat([
                    clampedDelta
                ]);
            }
        };
        const calcRedestributedWidths = (sizes, totalWidth, pixelDelta, isRelative)=>{
            if (isRelative) {
                const tableWidth = totalWidth + pixelDelta;
                const ratio = tableWidth / totalWidth;
                const newSizes = map$1(sizes, (size)=>size / ratio
                );
                return {
                    delta: ratio * 100 - 100,
                    newSizes
                };
            } else return {
                delta: pixelDelta,
                newSizes: sizes
            };
        };
        return {
            resizeTable,
            clampTableDelta: clampNegativeDelta,
            calcLeftEdgeDeltas,
            calcMiddleDeltas,
            calcRightEdgeDeltas,
            calcRedestributedWidths
        };
    };
    const preserveTable = ()=>{
        const calcLeftEdgeDeltas = (sizes, index, next, delta, minCellSize)=>{
            const idx = delta >= 0 ? next : index;
            const clampedDelta = clampDelta(sizes, idx, delta, minCellSize);
            return surround(sizes, index, next + 1, [
                clampedDelta,
                -clampedDelta
            ], zero1);
        };
        const calcMiddleDeltas = (sizes, _prev, index, next, delta, minCellSize)=>calcLeftEdgeDeltas(sizes, index, next, delta, minCellSize)
        ;
        const resizeTable = (resizer, delta, isLastColumn)=>{
            if (isLastColumn) resizer(delta);
        };
        const calcRightEdgeDeltas = (sizes, _prev, _index, delta, _minCellSize, isRelative)=>{
            if (isRelative) return zero1(sizes);
            else {
                const diff = delta / sizes.length;
                return map$1(sizes, constant(diff));
            }
        };
        const clampTableDelta = (sizes, index, delta, minCellSize, isLastColumn)=>{
            if (isLastColumn) {
                if (delta >= 0) return delta;
                else {
                    const maxDelta = foldl(sizes, (a, b)=>a + b - minCellSize
                    , 0);
                    return Math.max(-maxDelta, delta);
                }
            } else return clampNegativeDelta(sizes, index, delta, minCellSize);
        };
        const calcRedestributedWidths = (sizes, _totalWidth, _pixelDelta, _isRelative)=>({
                delta: 0,
                newSizes: sizes
            })
        ;
        return {
            resizeTable,
            clampTableDelta,
            calcLeftEdgeDeltas,
            calcMiddleDeltas,
            calcRightEdgeDeltas,
            calcRedestributedWidths
        };
    };
    const getGridSize = (table)=>{
        const warehouse = Warehouse.fromTable(table);
        return warehouse.grid;
    };
    const isHeaderCell = isTag('th');
    const isHeaderCells1 = (cells)=>forall(cells, (cell)=>isHeaderCell(cell.element)
        )
    ;
    const getRowHeaderType = (isHeaderRow, isHeaderCells)=>{
        if (isHeaderRow && isHeaderCells) return 'sectionCells';
        else if (isHeaderRow) return 'section';
        else return 'cells';
    };
    const getRowType = (row)=>{
        const isHeaderRow = row.section === 'thead';
        const isHeaderCells = is1(findCommonCellType(row.cells), 'th');
        if (row.section === 'tfoot') return {
            type: 'footer'
        };
        else if (isHeaderRow || isHeaderCells) return {
            type: 'header',
            subType: getRowHeaderType(isHeaderRow, isHeaderCells)
        };
        else return {
            type: 'body'
        };
    };
    const findCommonCellType = (cells)=>{
        const headerCells = filter$2(cells, (cell)=>isHeaderCell(cell.element)
        );
        if (headerCells.length === 0) return Optional.some('td');
        else if (headerCells.length === cells.length) return Optional.some('th');
        else return Optional.none();
    };
    const findCommonRowType = (rows)=>{
        const rowTypes = map$1(rows, (row)=>getRowType(row).type
        );
        const hasHeader = contains$2(rowTypes, 'header');
        const hasFooter = contains$2(rowTypes, 'footer');
        if (!hasHeader && !hasFooter) return Optional.some('body');
        else {
            const hasBody = contains$2(rowTypes, 'body');
            if (hasHeader && !hasBody && !hasFooter) return Optional.some('header');
            else if (!hasHeader && !hasBody && hasFooter) return Optional.some('footer');
            else return Optional.none();
        }
    };
    const findTableRowHeaderType = (warehouse)=>findMap(warehouse.all, (row)=>{
            const rowType = getRowType(row);
            return rowType.type === 'header' ? Optional.from(rowType.subType) : Optional.none();
        })
    ;
    const transformCell = (cell, comparator, substitution)=>elementnew(substitution(cell.element, comparator), true, cell.isLocked)
    ;
    const transformRow = (row, section)=>row.section !== section ? rowcells(row.element, row.cells, section, row.isNew) : row
    ;
    const section1 = ()=>({
            transformRow,
            transformCell: (cell, comparator, substitution)=>{
                const newCell = substitution(cell.element, comparator);
                const fixedCell = name1(newCell) !== 'td' ? mutate$1(newCell, 'td') : newCell;
                return elementnew(fixedCell, cell.isNew, cell.isLocked);
            }
        })
    ;
    const sectionCells = ()=>({
            transformRow,
            transformCell
        })
    ;
    const cells1 = ()=>({
            transformRow: (row, section)=>{
                const newSection = section === 'thead' ? 'tbody' : section;
                return transformRow(row, newSection);
            },
            transformCell
        })
    ;
    const fallback1 = ()=>({
            transformRow: identity,
            transformCell
        })
    ;
    const getTableSectionType1 = (table, fallback)=>{
        const warehouse = Warehouse.fromTable(table);
        const type = findTableRowHeaderType(warehouse).getOr(fallback);
        switch(type){
            case 'section':
                return section1();
            case 'sectionCells':
                return sectionCells();
            case 'cells':
                return cells1();
        }
    };
    const TableSection = {
        getTableSectionType: getTableSectionType1,
        section: section1,
        sectionCells,
        cells: cells1,
        fallback: fallback1
    };
    const closest = (target)=>closest$1(target, '[contenteditable]')
    ;
    const isEditable$1 = (element, assumeEditable = false)=>{
        if (inBody(element)) return element.dom.isContentEditable;
        else return closest(element).fold(constant(assumeEditable), (editable)=>getRaw(editable) === 'true'
        );
    };
    const getRaw = (element)=>element.dom.contentEditable
    ;
    const setIfNot = (element, property, value, ignore)=>{
        if (value === ignore) remove$7(element, property);
        else set$2(element, property, value);
    };
    const insert$1 = (table, selector, element)=>{
        last$2(children1(table, selector)).fold(()=>prepend(table, element)
        , (child)=>after$5(child, element)
        );
    };
    const generateSection = (table, sectionName)=>{
        const section = child1(table, sectionName).getOrThunk(()=>{
            const newSection = SugarElement.fromTag(sectionName, owner(table).dom);
            if (sectionName === 'thead') insert$1(table, 'caption,colgroup', newSection);
            else if (sectionName === 'colgroup') insert$1(table, 'caption', newSection);
            else append$1(table, newSection);
            return newSection;
        });
        empty(section);
        return section;
    };
    const render$1 = (table, grid)=>{
        const newRows = [];
        const newCells = [];
        const syncRows = (gridSection)=>map$1(gridSection, (row)=>{
                if (row.isNew) newRows.push(row.element);
                const tr = row.element;
                empty(tr);
                each$2(row.cells, (cell)=>{
                    if (cell.isNew) newCells.push(cell.element);
                    setIfNot(cell.element, 'colspan', cell.colspan, 1);
                    setIfNot(cell.element, 'rowspan', cell.rowspan, 1);
                    append$1(tr, cell.element);
                });
                return tr;
            })
        ;
        const syncColGroup = (gridSection)=>bind$2(gridSection, (colGroup)=>map$1(colGroup.cells, (col)=>{
                    setIfNot(col.element, 'span', col.colspan, 1);
                    return col.element;
                })
            )
        ;
        const renderSection = (gridSection, sectionName)=>{
            const section = generateSection(table, sectionName);
            const sync = sectionName === 'colgroup' ? syncColGroup : syncRows;
            const sectionElems = sync(gridSection);
            append(section, sectionElems);
        };
        const removeSection = (sectionName)=>{
            child1(table, sectionName).each(remove$6);
        };
        const renderOrRemoveSection = (gridSection, sectionName)=>{
            if (gridSection.length > 0) renderSection(gridSection, sectionName);
            else removeSection(sectionName);
        };
        const headSection = [];
        const bodySection = [];
        const footSection = [];
        const columnGroupsSection = [];
        each$2(grid, (row)=>{
            switch(row.section){
                case 'thead':
                    headSection.push(row);
                    break;
                case 'tbody':
                    bodySection.push(row);
                    break;
                case 'tfoot':
                    footSection.push(row);
                    break;
                case 'colgroup':
                    columnGroupsSection.push(row);
                    break;
            }
        });
        renderOrRemoveSection(columnGroupsSection, 'colgroup');
        renderOrRemoveSection(headSection, 'thead');
        renderOrRemoveSection(bodySection, 'tbody');
        renderOrRemoveSection(footSection, 'tfoot');
        return {
            newRows,
            newCells
        };
    };
    const copy1 = (grid)=>map$1(grid, (row)=>{
            const tr = shallow(row.element);
            each$2(row.cells, (cell)=>{
                const clonedCell = deep(cell.element);
                setIfNot(clonedCell, 'colspan', cell.colspan, 1);
                setIfNot(clonedCell, 'rowspan', cell.rowspan, 1);
                append$1(tr, clonedCell);
            });
            return tr;
        })
    ;
    const getColumn = (grid, index)=>{
        return map$1(grid, (row)=>{
            return getCell(row, index);
        });
    };
    const getRow = (grid, index)=>{
        return grid[index];
    };
    const findDiff = (xs, comp)=>{
        if (xs.length === 0) return 0;
        const first = xs[0];
        const index = findIndex(xs, (x)=>{
            return !comp(first.element, x.element);
        });
        return index.getOr(xs.length);
    };
    const subgrid = (grid, row, column, comparator)=>{
        const gridRow = getRow(grid, row);
        const isColRow = gridRow.section === 'colgroup';
        const colspan = findDiff(gridRow.cells.slice(column), comparator);
        const rowspan = isColRow ? 1 : findDiff(getColumn(grid.slice(row), column), comparator);
        return {
            colspan,
            rowspan
        };
    };
    const toDetails = (grid, comparator)=>{
        const seen = map$1(grid, (row)=>map$1(row.cells, never)
        );
        const updateSeen = (rowIndex, columnIndex, rowspan, colspan)=>{
            for(let row = rowIndex; row < rowIndex + rowspan; row++)for(let column = columnIndex; column < columnIndex + colspan; column++)seen[row][column] = true;
        };
        return map$1(grid, (row, rowIndex)=>{
            const details = bind$2(row.cells, (cell, columnIndex)=>{
                if (seen[rowIndex][columnIndex] === false) {
                    const result = subgrid(grid, rowIndex, columnIndex, comparator);
                    updateSeen(rowIndex, columnIndex, result.rowspan, result.colspan);
                    return [
                        detailnew(cell.element, result.rowspan, result.colspan, cell.isNew)
                    ];
                } else return [];
            });
            return rowdetailnew(row.element, details, row.section, row.isNew);
        });
    };
    const toGrid = (warehouse, generators, isNew)=>{
        const grid = [];
        each$2(warehouse.colgroups, (colgroup)=>{
            const colgroupCols = [];
            for(let columnIndex = 0; columnIndex < warehouse.grid.columns; columnIndex++){
                const element = Warehouse.getColumnAt(warehouse, columnIndex).map((column)=>elementnew(column.element, isNew, false)
                ).getOrThunk(()=>elementnew(generators.colGap(), true, false)
                );
                colgroupCols.push(element);
            }
            grid.push(rowcells(colgroup.element, colgroupCols, 'colgroup', isNew));
        });
        for(let rowIndex = 0; rowIndex < warehouse.grid.rows; rowIndex++){
            const rowCells = [];
            for(let columnIndex = 0; columnIndex < warehouse.grid.columns; columnIndex++){
                const element = Warehouse.getAt(warehouse, rowIndex, columnIndex).map((item)=>elementnew(item.element, isNew, item.isLocked)
                ).getOrThunk(()=>elementnew(generators.gap(), true, false)
                );
                rowCells.push(element);
            }
            const rowDetail = warehouse.all[rowIndex];
            const row = rowcells(rowDetail.element, rowCells, rowDetail.section, isNew);
            grid.push(row);
        }
        return grid;
    };
    const fromWarehouse = (warehouse, generators)=>toGrid(warehouse, generators, false)
    ;
    const toDetailList = (grid)=>toDetails(grid, eq$1)
    ;
    const findInWarehouse = (warehouse, element)=>findMap(warehouse.all, (r)=>find$1(r.cells, (e)=>eq$1(element, e.element)
            )
        )
    ;
    const extractCells = (warehouse, target, predicate)=>{
        const details = map$1(target.selection, (cell$1)=>{
            return cell1(cell$1).bind((lc)=>findInWarehouse(warehouse, lc)
            ).filter(predicate);
        });
        const cells = cat(details);
        return someIf(cells.length > 0, cells);
    };
    const run = (operation, extract, adjustment, postAction, genWrappers)=>(table, target, generators, behaviours)=>{
            const warehouse = Warehouse.fromTable(table);
            const tableSection = Optional.from(behaviours === null || behaviours === void 0 ? void 0 : behaviours.section).getOrThunk(TableSection.fallback);
            const output = extract(warehouse, target).map((info)=>{
                const model = fromWarehouse(warehouse, generators);
                const result = operation(model, info, eq$1, genWrappers(generators), tableSection);
                const lockedColumns = getLockedColumnsFromGrid(result.grid);
                const grid = toDetailList(result.grid);
                return {
                    info,
                    grid,
                    cursor: result.cursor,
                    lockedColumns
                };
            });
            return output.bind((out)=>{
                const newElements = render$1(table, out.grid);
                const tableSizing = Optional.from(behaviours === null || behaviours === void 0 ? void 0 : behaviours.sizing).getOrThunk(()=>TableSize.getTableSize(table)
                );
                const resizing = Optional.from(behaviours === null || behaviours === void 0 ? void 0 : behaviours.resize).getOrThunk(preserveTable);
                adjustment(table, out.grid, out.info, {
                    sizing: tableSizing,
                    resize: resizing,
                    section: tableSection
                });
                postAction(table);
                remove$7(table, LOCKED_COL_ATTR);
                if (out.lockedColumns.length > 0) set$2(table, LOCKED_COL_ATTR, out.lockedColumns.join(','));
                return Optional.some({
                    cursor: out.cursor,
                    newRows: newElements.newRows,
                    newCells: newElements.newCells
                });
            });
        }
    ;
    const onPaste = (warehouse, target)=>cell1(target.element).bind((cell)=>findInWarehouse(warehouse, cell).map((details)=>{
                const value = {
                    ...details,
                    generators: target.generators,
                    clipboard: target.clipboard
                };
                return value;
            })
        )
    ;
    const onPasteByEditor = (warehouse, target)=>extractCells(warehouse, target, always).map((cells)=>({
                cells,
                generators: target.generators,
                clipboard: target.clipboard
            })
        )
    ;
    const onMergable = (_warehouse, target)=>target.mergable
    ;
    const onUnmergable = (_warehouse, target)=>target.unmergable
    ;
    const onCells = (warehouse, target)=>extractCells(warehouse, target, always)
    ;
    const onUnlockedCells = (warehouse, target)=>extractCells(warehouse, target, (detail)=>!detail.isLocked
        )
    ;
    const isUnlockedTableCell = (warehouse, cell)=>findInWarehouse(warehouse, cell).exists((detail)=>!detail.isLocked
        )
    ;
    const allUnlocked = (warehouse, cells)=>forall(cells, (cell)=>isUnlockedTableCell(warehouse, cell)
        )
    ;
    const onUnlockedMergable = (warehouse, target)=>onMergable(warehouse, target).filter((mergeable)=>allUnlocked(warehouse, mergeable.cells)
        )
    ;
    const onUnlockedUnmergable = (warehouse, target)=>onUnmergable(warehouse, target).filter((cells)=>allUnlocked(warehouse, cells)
        )
    ;
    const merge$2 = (grid, bounds, comparator, substitution)=>{
        const rows = extractGridDetails(grid).rows;
        if (rows.length === 0) return grid;
        for(let i = bounds.startRow; i <= bounds.finishRow; i++)for(let j = bounds.startCol; j <= bounds.finishCol; j++){
            const row = rows[i];
            const isLocked = getCell(row, j).isLocked;
            mutateCell(row, j, elementnew(substitution(), false, isLocked));
        }
        return grid;
    };
    const unmerge1 = (grid, target, comparator, substitution)=>{
        const rows = extractGridDetails(grid).rows;
        let first = true;
        for(let i = 0; i < rows.length; i++)for(let j = 0; j < cellLength(rows[0]); j++){
            const row = rows[i];
            const currentCell = getCell(row, j);
            const currentCellElm = currentCell.element;
            const isToReplace = comparator(currentCellElm, target);
            if (isToReplace && !first) mutateCell(row, j, elementnew(substitution(), true, currentCell.isLocked));
            else if (isToReplace) first = false;
        }
        return grid;
    };
    const uniqueCells = (row, comparator)=>{
        return foldl(row, (rest, cell)=>{
            return exists(rest, (currentCell)=>{
                return comparator(currentCell.element, cell.element);
            }) ? rest : rest.concat([
                cell
            ]);
        }, []);
    };
    const splitCols = (grid, index, comparator, substitution)=>{
        if (index > 0 && index < grid[0].cells.length) each$2(grid, (row)=>{
            const prevCell = row.cells[index - 1];
            const current = row.cells[index];
            const isToReplace = comparator(current.element, prevCell.element);
            if (isToReplace) mutateCell(row, index, elementnew(substitution(), true, current.isLocked));
        });
        return grid;
    };
    const splitRows = (grid, index, comparator, substitution)=>{
        const rows = extractGridDetails(grid).rows;
        if (index > 0 && index < rows.length) {
            const rowPrevCells = rows[index - 1].cells;
            const cells = uniqueCells(rowPrevCells, comparator);
            each$2(cells, (cell)=>{
                let replacement = Optional.none();
                for(let i = index; i < rows.length; i++)for(let j = 0; j < cellLength(rows[0]); j++){
                    const row = rows[i];
                    const current = getCell(row, j);
                    const isToReplace = comparator(current.element, cell.element);
                    if (isToReplace) {
                        if (replacement.isNone()) replacement = Optional.some(substitution());
                        replacement.each((sub)=>{
                            mutateCell(row, j, elementnew(sub, true, current.isLocked));
                        });
                    }
                }
            });
        }
        return grid;
    };
    const value$1 = (value)=>{
        const applyHelper = (fn)=>fn(value)
        ;
        const constHelper = constant(value);
        const outputHelper = ()=>output
        ;
        const output = {
            tag: true,
            inner: value,
            fold: (_onError, onValue)=>onValue(value)
            ,
            isValue: always,
            isError: never,
            map: (mapper)=>Result.value(mapper(value))
            ,
            mapError: outputHelper,
            bind: applyHelper,
            exists: applyHelper,
            forall: applyHelper,
            getOr: constHelper,
            or: outputHelper,
            getOrThunk: constHelper,
            orThunk: outputHelper,
            getOrDie: constHelper,
            each: (fn)=>{
                fn(value);
            },
            toOptional: ()=>Optional.some(value)
        };
        return output;
    };
    const error1 = (error)=>{
        const outputHelper = ()=>output
        ;
        const output = {
            tag: false,
            inner: error,
            fold: (onError, _onValue)=>onError(error)
            ,
            isValue: never,
            isError: always,
            map: outputHelper,
            mapError: (mapper)=>Result.error(mapper(error))
            ,
            bind: outputHelper,
            exists: never,
            forall: always,
            getOr: identity,
            or: identity,
            getOrThunk: apply,
            orThunk: apply,
            getOrDie: die(String(error)),
            each: noop,
            toOptional: Optional.none
        };
        return output;
    };
    const fromOption = (optional, err)=>optional.fold(()=>error1(err)
        , value$1)
    ;
    const Result = {
        value: value$1,
        error: error1,
        fromOption
    };
    const measure = (startAddress, gridA, gridB)=>{
        if (startAddress.row >= gridA.length || startAddress.column > cellLength(gridA[0])) return Result.error('invalid start address out of table bounds, row: ' + startAddress.row + ', column: ' + startAddress.column);
        const rowRemainder = gridA.slice(startAddress.row);
        const colRemainder = rowRemainder[0].cells.slice(startAddress.column);
        const colRequired = cellLength(gridB[0]);
        const rowRequired = gridB.length;
        return Result.value({
            rowDelta: rowRemainder.length - rowRequired,
            colDelta: colRemainder.length - colRequired
        });
    };
    const measureWidth = (gridA, gridB)=>{
        const colLengthA = cellLength(gridA[0]);
        const colLengthB = cellLength(gridB[0]);
        return {
            rowDelta: 0,
            colDelta: colLengthA - colLengthB
        };
    };
    const measureHeight = (gridA, gridB)=>{
        const rowLengthA = gridA.length;
        const rowLengthB = gridB.length;
        return {
            rowDelta: rowLengthA - rowLengthB,
            colDelta: 0
        };
    };
    const generateElements = (amount, row, generators, isLocked)=>{
        const generator = row.section === 'colgroup' ? generators.col : generators.cell;
        return range$1(amount, (idx)=>elementnew(generator(), true, isLocked(idx))
        );
    };
    const rowFill = (grid, amount, generators, lockedColumns)=>{
        const exampleRow = grid[grid.length - 1];
        return grid.concat(range$1(amount, ()=>{
            const generator = exampleRow.section === 'colgroup' ? generators.colgroup : generators.row;
            const row = clone1(exampleRow, generator, identity);
            const elements = generateElements(row.cells.length, row, generators, (idx)=>has$1(lockedColumns, idx.toString())
            );
            return setCells(row, elements);
        }));
    };
    const colFill = (grid, amount, generators, startIndex)=>map$1(grid, (row)=>{
            const newChildren = generateElements(amount, row, generators, never);
            return addCells(row, startIndex, newChildren);
        })
    ;
    const lockedColFill = (grid, generators, lockedColumns)=>map$1(grid, (row)=>{
            return foldl(lockedColumns, (acc, colNum)=>{
                const newChild = generateElements(1, row, generators, always)[0];
                return addCell(acc, colNum, newChild);
            }, row);
        })
    ;
    const tailor = (gridA, delta, generators)=>{
        const fillCols = delta.colDelta < 0 ? colFill : identity;
        const fillRows = delta.rowDelta < 0 ? rowFill : identity;
        const lockedColumns = getLockedColumnsFromGrid(gridA);
        const gridWidth = cellLength(gridA[0]);
        const isLastColLocked = exists(lockedColumns, (locked)=>locked === gridWidth - 1
        );
        const modifiedCols = fillCols(gridA, Math.abs(delta.colDelta), generators, isLastColLocked ? gridWidth - 1 : gridWidth);
        const newLockedColumns = getLockedColumnsFromGrid(modifiedCols);
        return fillRows(modifiedCols, Math.abs(delta.rowDelta), generators, mapToObject(newLockedColumns, always));
    };
    const isSpanning = (grid, row, col, comparator)=>{
        const candidate = getCell(grid[row], col);
        const matching = curry(comparator, candidate.element);
        const currentRow = grid[row];
        return grid.length > 1 && cellLength(currentRow) > 1 && (col > 0 && matching(getCellElement(currentRow, col - 1)) || col < currentRow.cells.length - 1 && matching(getCellElement(currentRow, col + 1)) || row > 0 && matching(getCellElement(grid[row - 1], col)) || row < grid.length - 1 && matching(getCellElement(grid[row + 1], col)));
    };
    const mergeTables = (startAddress, gridA, gridBRows, generator, comparator, lockedColumns)=>{
        const startRow = startAddress.row;
        const startCol = startAddress.column;
        const mergeHeight = gridBRows.length;
        const mergeWidth = cellLength(gridBRows[0]);
        const endRow = startRow + mergeHeight;
        const endCol = startCol + mergeWidth + lockedColumns.length;
        const lockedColumnObj = mapToObject(lockedColumns, always);
        for(let r = startRow; r < endRow; r++){
            let skippedCol = 0;
            for(let c = startCol; c < endCol; c++){
                if (lockedColumnObj[c]) {
                    skippedCol++;
                    continue;
                }
                if (isSpanning(gridA, r, c, comparator)) unmerge1(gridA, getCellElement(gridA[r], c), comparator, generator.cell);
                const gridBColIndex = c - startCol - skippedCol;
                const newCell = getCell(gridBRows[r - startRow], gridBColIndex);
                const newCellElm = newCell.element;
                const replacement = generator.replace(newCellElm);
                mutateCell(gridA[r], c, elementnew(replacement, true, newCell.isLocked));
            }
        }
        return gridA;
    };
    const getValidStartAddress = (currentStartAddress, grid, lockedColumns)=>{
        const gridColLength = cellLength(grid[0]);
        const adjustedRowAddress = extractGridDetails(grid).cols.length + currentStartAddress.row;
        const possibleColAddresses = range$1(gridColLength - currentStartAddress.column, (num)=>num + currentStartAddress.column
        );
        const validColAddress = find$1(possibleColAddresses, (num)=>forall(lockedColumns, (col)=>col !== num
            )
        ).getOr(gridColLength - 1);
        return {
            row: adjustedRowAddress,
            column: validColAddress
        };
    };
    const getLockedColumnsWithinBounds = (startAddress, rows, lockedColumns)=>filter$2(lockedColumns, (colNum)=>colNum >= startAddress.column && colNum <= cellLength(rows[0]) + startAddress.column
        )
    ;
    const merge$1 = (startAddress, gridA, gridB, generator, comparator)=>{
        const lockedColumns = getLockedColumnsFromGrid(gridA);
        const validStartAddress = getValidStartAddress(startAddress, gridA, lockedColumns);
        const gridBRows = extractGridDetails(gridB).rows;
        const lockedColumnsWithinBounds = getLockedColumnsWithinBounds(validStartAddress, gridBRows, lockedColumns);
        const result = measure(validStartAddress, gridA, gridBRows);
        return result.map((diff)=>{
            const delta = {
                ...diff,
                colDelta: diff.colDelta - lockedColumnsWithinBounds.length
            };
            const fittedGrid = tailor(gridA, delta, generator);
            const newLockedColumns = getLockedColumnsFromGrid(fittedGrid);
            const newLockedColumnsWithinBounds = getLockedColumnsWithinBounds(validStartAddress, gridBRows, newLockedColumns);
            return mergeTables(validStartAddress, fittedGrid, gridBRows, generator, comparator, newLockedColumnsWithinBounds);
        });
    };
    const insertCols = (index, gridA, gridB, generator, comparator)=>{
        splitCols(gridA, index, comparator, generator.cell);
        const delta = measureHeight(gridB, gridA);
        const fittedNewGrid = tailor(gridB, delta, generator);
        const secondDelta = measureHeight(gridA, fittedNewGrid);
        const fittedOldGrid = tailor(gridA, secondDelta, generator);
        return map$1(fittedOldGrid, (gridRow, i)=>{
            return addCells(gridRow, index, fittedNewGrid[i].cells);
        });
    };
    const insertRows = (index, gridA, gridB, generator, comparator)=>{
        splitRows(gridA, index, comparator, generator.cell);
        const locked = getLockedColumnsFromGrid(gridA);
        const diff = measureWidth(gridA, gridB);
        const delta = {
            ...diff,
            colDelta: diff.colDelta - locked.length
        };
        const fittedOldGrid = tailor(gridA, delta, generator);
        const { cols: oldCols , rows: oldRows  } = extractGridDetails(fittedOldGrid);
        const newLocked = getLockedColumnsFromGrid(fittedOldGrid);
        const secondDiff = measureWidth(gridB, gridA);
        const secondDelta = {
            ...secondDiff,
            colDelta: secondDiff.colDelta + newLocked.length
        };
        const fittedGridB = lockedColFill(gridB, generator, newLocked);
        const fittedNewGrid = tailor(fittedGridB, secondDelta, generator);
        return [
            ...oldCols,
            ...oldRows.slice(0, index),
            ...fittedNewGrid,
            ...oldRows.slice(index, oldRows.length)
        ];
    };
    const cloneRow1 = (row, cloneCell, comparator, substitution)=>clone1(row, (elem)=>substitution(elem, comparator)
        , cloneCell)
    ;
    const insertRowAt = (grid, index, example, comparator, substitution)=>{
        const { rows , cols  } = extractGridDetails(grid);
        const before = rows.slice(0, index);
        const after = rows.slice(index);
        const newRow = cloneRow1(rows[example], (ex, c)=>{
            const withinSpan = index > 0 && index < rows.length && comparator(getCellElement(rows[index - 1], c), getCellElement(rows[index], c));
            const ret = withinSpan ? getCell(rows[index], c) : elementnew(substitution(ex.element, comparator), true, ex.isLocked);
            return ret;
        }, comparator, substitution);
        return [
            ...cols,
            ...before,
            newRow,
            ...after
        ];
    };
    const getElementFor = (row, column, section, withinSpan, example, comparator, substitution)=>{
        if (section === 'colgroup' || !withinSpan) {
            const cell = getCell(row, example);
            return elementnew(substitution(cell.element, comparator), true, false);
        } else return getCell(row, column);
    };
    const insertColumnAt = (grid, index, example, comparator, substitution)=>map$1(grid, (row)=>{
            const withinSpan = index > 0 && index < cellLength(row) && comparator(getCellElement(row, index - 1), getCellElement(row, index));
            const sub = getElementFor(row, index, row.section, withinSpan, example, comparator, substitution);
            return addCell(row, index, sub);
        })
    ;
    const deleteColumnsAt = (grid, columns)=>bind$2(grid, (row)=>{
            const existingCells = row.cells;
            const cells = foldr(columns, (acc, column)=>column >= 0 && column < acc.length ? acc.slice(0, column).concat(acc.slice(column + 1)) : acc
            , existingCells);
            return cells.length > 0 ? [
                rowcells(row.element, cells, row.section, row.isNew)
            ] : [];
        })
    ;
    const deleteRowsAt = (grid, start, finish)=>{
        const { rows , cols  } = extractGridDetails(grid);
        return [
            ...cols,
            ...rows.slice(0, start),
            ...rows.slice(finish + 1)
        ];
    };
    const notInStartRow = (grid, rowIndex, colIndex, comparator)=>getCellElement(grid[rowIndex], colIndex) !== undefined && rowIndex > 0 && comparator(getCellElement(grid[rowIndex - 1], colIndex), getCellElement(grid[rowIndex], colIndex))
    ;
    const notInStartColumn = (row, index, comparator)=>index > 0 && comparator(getCellElement(row, index - 1), getCellElement(row, index))
    ;
    const isDuplicatedCell = (grid, rowIndex, colIndex, comparator)=>notInStartRow(grid, rowIndex, colIndex, comparator) || notInStartColumn(grid[rowIndex], colIndex, comparator)
    ;
    const rowReplacerPredicate = (targetRow, columnHeaders)=>{
        const entireTableIsHeader = forall(columnHeaders, identity) && isHeaderCells1(targetRow.cells);
        return entireTableIsHeader ? always : (cell, _rowIndex, colIndex)=>{
            const type = name1(cell.element);
            return !(type === 'th' && columnHeaders[colIndex]);
        };
    };
    const columnReplacePredicate = (targetColumn, rowHeaders)=>{
        const entireTableIsHeader = forall(rowHeaders, identity) && isHeaderCells1(targetColumn);
        return entireTableIsHeader ? always : (cell, rowIndex, _colIndex)=>{
            const type = name1(cell.element);
            return !(type === 'th' && rowHeaders[rowIndex]);
        };
    };
    const determineScope = (applyScope, cell, newScope, isInHeader)=>{
        const hasSpan = (scope)=>scope === 'row' ? hasRowspan(cell) : hasColspan(cell)
        ;
        const getScope = (scope)=>hasSpan(scope) ? `${scope}group` : scope
        ;
        if (applyScope) return isHeaderCell(cell) ? getScope(newScope) : null;
        else if (isInHeader && isHeaderCell(cell)) {
            const oppositeScope = newScope === 'row' ? 'col' : 'row';
            return getScope(oppositeScope);
        } else return null;
    };
    const rowScopeGenerator = (applyScope, columnHeaders)=>(cell, rowIndex, columnIndex)=>Optional.some(determineScope(applyScope, cell.element, 'col', columnHeaders[columnIndex]))
    ;
    const columnScopeGenerator = (applyScope, rowHeaders)=>(cell, rowIndex)=>Optional.some(determineScope(applyScope, cell.element, 'row', rowHeaders[rowIndex]))
    ;
    const replace = (cell, comparator, substitute)=>elementnew(substitute(cell.element, comparator), true, cell.isLocked)
    ;
    const replaceIn = (grid, targets, comparator, substitute, replacer, genScope, shouldReplace)=>{
        const isTarget = (cell)=>{
            return exists(targets, (target)=>{
                return comparator(cell.element, target.element);
            });
        };
        return map$1(grid, (row, rowIndex)=>{
            return mapCells(row, (cell, colIndex)=>{
                if (isTarget(cell)) {
                    const newCell = shouldReplace(cell, rowIndex, colIndex) ? replacer(cell, comparator, substitute) : cell;
                    genScope(newCell, rowIndex, colIndex).each((scope)=>{
                        setOptions(newCell.element, {
                            scope: Optional.from(scope)
                        });
                    });
                    return newCell;
                } else return cell;
            });
        });
    };
    const getColumnCells = (rows, columnIndex, comparator)=>bind$2(rows, (row, i)=>{
            return isDuplicatedCell(rows, i, columnIndex, comparator) ? [] : [
                getCell(row, columnIndex)
            ];
        })
    ;
    const getRowCells = (rows, rowIndex, comparator)=>{
        const targetRow = rows[rowIndex];
        return bind$2(targetRow.cells, (item, i)=>{
            return isDuplicatedCell(rows, rowIndex, i, comparator) ? [] : [
                item
            ];
        });
    };
    const replaceColumns = (grid, indexes, applyScope, comparator, substitution)=>{
        const rows = extractGridDetails(grid).rows;
        const targets = bind$2(indexes, (index)=>getColumnCells(rows, index, comparator)
        );
        const rowHeaders = map$1(rows, (row)=>isHeaderCells1(row.cells)
        );
        const shouldReplaceCell = columnReplacePredicate(targets, rowHeaders);
        const scopeGenerator = columnScopeGenerator(applyScope, rowHeaders);
        return replaceIn(grid, targets, comparator, substitution, replace, scopeGenerator, shouldReplaceCell);
    };
    const replaceRows = (grid, indexes, section, applyScope, comparator, substitution, tableSection)=>{
        const { cols , rows  } = extractGridDetails(grid);
        const targetRow = rows[indexes[0]];
        const targets = bind$2(indexes, (index)=>getRowCells(rows, index, comparator)
        );
        const columnHeaders = map$1(targetRow.cells, (_cell, index)=>isHeaderCells1(getColumnCells(rows, index, comparator))
        );
        const newRows = [
            ...rows
        ];
        each$2(indexes, (index)=>{
            newRows[index] = tableSection.transformRow(rows[index], section);
        });
        const newGrid = [
            ...cols,
            ...newRows
        ];
        const shouldReplaceCell = rowReplacerPredicate(targetRow, columnHeaders);
        const scopeGenerator = rowScopeGenerator(applyScope, columnHeaders);
        return replaceIn(newGrid, targets, comparator, substitution, tableSection.transformCell, scopeGenerator, shouldReplaceCell);
    };
    const replaceCells = (grid, details, comparator, substitution)=>{
        const rows = extractGridDetails(grid).rows;
        const targetCells = map$1(details, (detail)=>getCell(rows[detail.row], detail.column)
        );
        return replaceIn(grid, targetCells, comparator, substitution, replace, Optional.none, always);
    };
    const generate = (cases)=>{
        if (!isArray(cases)) throw new Error('cases must be an array');
        if (cases.length === 0) throw new Error('there must be at least one case');
        const constructors = [];
        const adt = {};
        each$2(cases, (acase, count)=>{
            const keys$1 = keys1(acase);
            if (keys$1.length !== 1) throw new Error('one and only one name per case');
            const key = keys$1[0];
            const value = acase[key];
            if (adt[key] !== undefined) throw new Error('duplicate key detected:' + key);
            else if (key === 'cata') throw new Error('cannot have a case named cata (sorry)');
            else if (!isArray(value)) throw new Error('case arguments must be an array');
            constructors.push(key);
            adt[key] = (...args)=>{
                const argLength = args.length;
                if (argLength !== value.length) throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);
                const match = (branches)=>{
                    const branchKeys = keys1(branches);
                    if (constructors.length !== branchKeys.length) throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\nActual: ' + branchKeys.join(','));
                    const allReqd = forall(constructors, (reqKey)=>{
                        return contains$2(branchKeys, reqKey);
                    });
                    if (!allReqd) throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\nRequired: ' + constructors.join(', '));
                    return branches[key].apply(null, args);
                };
                return {
                    fold: (...foldArgs)=>{
                        if (foldArgs.length !== cases.length) throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);
                        const target = foldArgs[count];
                        return target.apply(null, args);
                    },
                    match,
                    log: (label)=>{
                        console.log(label, {
                            constructors,
                            constructor: key,
                            params: args
                        });
                    }
                };
            };
        });
        return adt;
    };
    const Adt = {
        generate
    };
    const adt$6 = Adt.generate([
        {
            none: []
        },
        {
            only: [
                'index'
            ]
        },
        {
            left: [
                'index',
                'next'
            ]
        },
        {
            middle: [
                'prev',
                'index',
                'next'
            ]
        },
        {
            right: [
                'prev',
                'index'
            ]
        }
    ]);
    const ColumnContext = {
        ...adt$6
    };
    const neighbours = (input, index)=>{
        if (input.length === 0) return ColumnContext.none();
        if (input.length === 1) return ColumnContext.only(0);
        if (index === 0) return ColumnContext.left(0, 1);
        if (index === input.length - 1) return ColumnContext.right(index - 1, index);
        if (index > 0 && index < input.length - 1) return ColumnContext.middle(index - 1, index, index + 1);
        return ColumnContext.none();
    };
    const determine = (input, column, step, tableSize, resize)=>{
        const result = input.slice(0);
        const context = neighbours(input, column);
        const onNone = constant(map$1(result, constant(0)));
        const onOnly = (index)=>tableSize.singleColumnWidth(result[index], step)
        ;
        const onLeft = (index, next)=>resize.calcLeftEdgeDeltas(result, index, next, step, tableSize.minCellWidth(), tableSize.isRelative)
        ;
        const onMiddle = (prev, index, next)=>resize.calcMiddleDeltas(result, prev, index, next, step, tableSize.minCellWidth(), tableSize.isRelative)
        ;
        const onRight = (prev, index)=>resize.calcRightEdgeDeltas(result, prev, index, step, tableSize.minCellWidth(), tableSize.isRelative)
        ;
        return context.fold(onNone, onOnly, onLeft, onMiddle, onRight);
    };
    const total1 = (start, end, measures)=>{
        let r = 0;
        for(let i = start; i < end; i++)r += measures[i] !== undefined ? measures[i] : 0;
        return r;
    };
    const recalculateWidthForCells = (warehouse, widths)=>{
        const all = Warehouse.justCells(warehouse);
        return map$1(all, (cell)=>{
            const width = total1(cell.column, cell.column + cell.colspan, widths);
            return {
                element: cell.element,
                width,
                colspan: cell.colspan
            };
        });
    };
    const recalculateWidthForColumns = (warehouse, widths)=>{
        const groups = Warehouse.justColumns(warehouse);
        return map$1(groups, (column, index)=>({
                element: column.element,
                width: widths[index],
                colspan: column.colspan
            })
        );
    };
    const recalculateHeightForCells = (warehouse, heights)=>{
        const all = Warehouse.justCells(warehouse);
        return map$1(all, (cell)=>{
            const height = total1(cell.row, cell.row + cell.rowspan, heights);
            return {
                element: cell.element,
                height,
                rowspan: cell.rowspan
            };
        });
    };
    const matchRowHeight = (warehouse, heights)=>{
        return map$1(warehouse.all, (row, i)=>{
            return {
                element: row.element,
                height: heights[i]
            };
        });
    };
    const sumUp = (newSize)=>foldr(newSize, (b, a)=>b + a
        , 0)
    ;
    const recalculate = (warehouse, widths)=>{
        if (Warehouse.hasColumns(warehouse)) return recalculateWidthForColumns(warehouse, widths);
        else return recalculateWidthForCells(warehouse, widths);
    };
    const recalculateAndApply = (warehouse, widths, tableSize)=>{
        const newSizes = recalculate(warehouse, widths);
        each$2(newSizes, (cell)=>{
            tableSize.setElementWidth(cell.element, cell.width);
        });
    };
    const adjustWidth = (table, delta, index, resizing, tableSize)=>{
        const warehouse = Warehouse.fromTable(table);
        const step = tableSize.getCellDelta(delta);
        const widths = tableSize.getWidths(warehouse, tableSize);
        const isLastColumn = index === warehouse.grid.columns - 1;
        const clampedStep = resizing.clampTableDelta(widths, index, step, tableSize.minCellWidth(), isLastColumn);
        const deltas = determine(widths, index, clampedStep, tableSize, resizing);
        const newWidths = map$1(deltas, (dx, i)=>dx + widths[i]
        );
        recalculateAndApply(warehouse, newWidths, tableSize);
        resizing.resizeTable(tableSize.adjustTableWidth, clampedStep, isLastColumn);
    };
    const adjustHeight = (table, delta, index, direction)=>{
        const warehouse = Warehouse.fromTable(table);
        const heights = getPixelHeights(warehouse, table, direction);
        const newHeights = map$1(heights, (dy, i)=>index === i ? Math.max(delta + dy, minHeight()) : dy
        );
        const newCellSizes = recalculateHeightForCells(warehouse, newHeights);
        const newRowSizes = matchRowHeight(warehouse, newHeights);
        each$2(newRowSizes, (row)=>{
            setHeight(row.element, row.height);
        });
        each$2(newCellSizes, (cell)=>{
            setHeight(cell.element, cell.height);
        });
        const total = sumUp(newHeights);
        setHeight(table, total);
    };
    const adjustAndRedistributeWidths$1 = (_table, list, details, tableSize, resizeBehaviour)=>{
        const warehouse = Warehouse.generate(list);
        const sizes = tableSize.getWidths(warehouse, tableSize);
        const tablePixelWidth = tableSize.pixelWidth();
        const { newSizes , delta  } = resizeBehaviour.calcRedestributedWidths(sizes, tablePixelWidth, details.pixelDelta, tableSize.isRelative);
        recalculateAndApply(warehouse, newSizes, tableSize);
        tableSize.adjustTableWidth(delta);
    };
    const adjustWidthTo = (_table, list, _info, tableSize)=>{
        const warehouse = Warehouse.generate(list);
        const widths = tableSize.getWidths(warehouse, tableSize);
        recalculateAndApply(warehouse, widths, tableSize);
    };
    const uniqueColumns = (details)=>{
        const uniqueCheck = (rest, detail)=>{
            const columnExists = exists(rest, (currentDetail)=>currentDetail.column === detail.column
            );
            return columnExists ? rest : rest.concat([
                detail
            ]);
        };
        return foldl(details, uniqueCheck, []).sort((detailA, detailB)=>detailA.column - detailB.column
        );
    };
    const isCol = isTag('col');
    const isColgroup = isTag('colgroup');
    const isRow$1 = (element)=>name1(element) === 'tr' || isColgroup(element)
    ;
    const elementToData = (element)=>{
        const colspan = getAttrValue(element, 'colspan', 1);
        const rowspan = getAttrValue(element, 'rowspan', 1);
        return {
            element,
            colspan,
            rowspan
        };
    };
    const modification = (generators, toData = elementToData)=>{
        const nuCell = (data)=>isCol(data.element) ? generators.col(data) : generators.cell(data)
        ;
        const nuRow = (data)=>isColgroup(data.element) ? generators.colgroup(data) : generators.row(data)
        ;
        const add = (element)=>{
            if (isRow$1(element)) return nuRow({
                element
            });
            else {
                const cell = element;
                const replacement = nuCell(toData(cell));
                recent = Optional.some({
                    item: cell,
                    replacement
                });
                return replacement;
            }
        };
        let recent = Optional.none();
        const getOrInit = (element, comparator)=>{
            return recent.fold(()=>{
                return add(element);
            }, (p)=>{
                return comparator(element, p.item) ? p.replacement : add(element);
            });
        };
        return {
            getOrInit
        };
    };
    const transform$1 = (tag)=>{
        return (generators)=>{
            const list = [];
            const find = (element, comparator)=>{
                return find$1(list, (x)=>{
                    return comparator(x.item, element);
                });
            };
            const makeNew = (element)=>{
                const attrs = tag === 'td' ? {
                    scope: null
                } : {};
                const cell = generators.replace(element, tag, attrs);
                list.push({
                    item: element,
                    sub: cell
                });
                return cell;
            };
            const replaceOrInit = (element, comparator)=>{
                if (isRow$1(element) || isCol(element)) return element;
                else {
                    const cell = element;
                    return find(cell, comparator).fold(()=>{
                        return makeNew(cell);
                    }, (p)=>{
                        return comparator(element, p.item) ? p.sub : makeNew(cell);
                    });
                }
            };
            return {
                replaceOrInit
            };
        };
    };
    const getScopeAttribute = (cell)=>getOpt(cell, 'scope').map((attribute)=>attribute.substr(0, 3)
        )
    ;
    const merging = (generators)=>{
        const unmerge = (cell)=>{
            const scope = getScopeAttribute(cell);
            scope.each((attribute)=>set$2(cell, 'scope', attribute)
            );
            return ()=>{
                const raw = generators.cell({
                    element: cell,
                    colspan: 1,
                    rowspan: 1
                });
                remove$5(raw, 'width');
                remove$5(cell, 'width');
                scope.each((attribute)=>set$2(raw, 'scope', attribute)
                );
                return raw;
            };
        };
        const merge = (cells)=>{
            const getScopeProperty = ()=>{
                const stringAttributes = cat(map$1(cells, getScopeAttribute));
                if (stringAttributes.length === 0) return Optional.none();
                else {
                    const baseScope = stringAttributes[0];
                    const scopes = [
                        'row',
                        'col'
                    ];
                    const isMixed = exists(stringAttributes, (attribute)=>{
                        return attribute !== baseScope && contains$2(scopes, attribute);
                    });
                    return isMixed ? Optional.none() : Optional.from(baseScope);
                }
            };
            remove$5(cells[0], 'width');
            getScopeProperty().fold(()=>remove$7(cells[0], 'scope')
            , (attribute)=>set$2(cells[0], 'scope', attribute + 'group')
            );
            return constant(cells[0]);
        };
        return {
            unmerge,
            merge
        };
    };
    const Generators = {
        modification,
        transform: transform$1,
        merging
    };
    const blockList = [
        'body',
        'p',
        'div',
        'article',
        'aside',
        'figcaption',
        'figure',
        'footer',
        'header',
        'nav',
        'section',
        'ol',
        'ul',
        'table',
        'thead',
        'tfoot',
        'tbody',
        'caption',
        'tr',
        'td',
        'th',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'blockquote',
        'pre',
        'address'
    ];
    const isList$1 = (universe, item)=>{
        const tagName = universe.property().name(item);
        return contains$2([
            'ol',
            'ul'
        ], tagName);
    };
    const isBlock$1 = (universe, item)=>{
        const tagName = universe.property().name(item);
        return contains$2(blockList, tagName);
    };
    const isEmptyTag$1 = (universe, item)=>{
        return contains$2([
            'br',
            'img',
            'hr',
            'input'
        ], universe.property().name(item));
    };
    const universe$1 = DomUniverse();
    const isBlock = (element)=>{
        return isBlock$1(universe$1, element);
    };
    const isList = (element)=>{
        return isList$1(universe$1, element);
    };
    const isEmptyTag1 = (element)=>{
        return isEmptyTag$1(universe$1, element);
    };
    const merge1 = (cells)=>{
        const isBr = isTag('br');
        const advancedBr = (children)=>{
            return forall(children, (c)=>{
                return isBr(c) || isText(c) && get$6(c).trim().length === 0;
            });
        };
        const isListItem = (el)=>{
            return name1(el) === 'li' || ancestor$2(el, isList).isSome();
        };
        const siblingIsBlock = (el)=>{
            return nextSibling(el).map((rightSibling)=>{
                if (isBlock(rightSibling)) return true;
                if (isEmptyTag1(rightSibling)) return name1(rightSibling) === 'img' ? false : true;
                return false;
            }).getOr(false);
        };
        const markCell = (cell)=>{
            return last$1(cell).bind((rightEdge)=>{
                const rightSiblingIsBlock = siblingIsBlock(rightEdge);
                return parent1(rightEdge).map((parent)=>{
                    return rightSiblingIsBlock === true || isListItem(parent) || isBr(rightEdge) || isBlock(parent) && !eq$1(cell, parent) ? [] : [
                        SugarElement.fromTag('br')
                    ];
                });
            }).getOr([]);
        };
        const markContent = ()=>{
            const content = bind$2(cells, (cell)=>{
                const children = children$2(cell);
                return advancedBr(children) ? [] : children.concat(markCell(cell));
            });
            return content.length === 0 ? [
                SugarElement.fromTag('br')
            ] : content;
        };
        const contents = markContent();
        empty(cells[0]);
        append(cells[0], contents);
    };
    const isEditable = (elem)=>isEditable$1(elem, true)
    ;
    const prune1 = (table)=>{
        const cells = cells$1(table);
        if (cells.length === 0) remove$6(table);
    };
    const outcome = (grid, cursor)=>({
            grid,
            cursor
        })
    ;
    const findEditableCursorPosition = (rows)=>findMap(rows, (row)=>findMap(row.cells, (cell)=>{
                const elem = cell.element;
                return someIf(isEditable(elem), elem);
            })
        )
    ;
    const elementFromGrid = (grid, row, column)=>{
        var _a, _b;
        const rows = extractGridDetails(grid).rows;
        return Optional.from((_b = (_a = rows[row]) === null || _a === void 0 ? void 0 : _a.cells[column]) === null || _b === void 0 ? void 0 : _b.element).filter(isEditable).orThunk(()=>findEditableCursorPosition(rows)
        );
    };
    const bundle = (grid, row, column)=>{
        const cursorElement = elementFromGrid(grid, row, column);
        return outcome(grid, cursorElement);
    };
    const uniqueRows = (details)=>{
        const rowCompilation = (rest, detail)=>{
            const rowExists = exists(rest, (currentDetail)=>currentDetail.row === detail.row
            );
            return rowExists ? rest : rest.concat([
                detail
            ]);
        };
        return foldl(details, rowCompilation, []).sort((detailA, detailB)=>detailA.row - detailB.row
        );
    };
    const opInsertRowsBefore = (grid, details, comparator, genWrappers)=>{
        const targetIndex = details[0].row;
        const rows = uniqueRows(details);
        const newGrid = foldr(rows, (acc, row)=>{
            const newG = insertRowAt(acc.grid, targetIndex, row.row + acc.delta, comparator, genWrappers.getOrInit);
            return {
                grid: newG,
                delta: acc.delta + 1
            };
        }, {
            grid,
            delta: 0
        }).grid;
        return bundle(newGrid, targetIndex, details[0].column);
    };
    const opInsertRowsAfter = (grid, details, comparator, genWrappers)=>{
        const rows = uniqueRows(details);
        const target = rows[rows.length - 1];
        const targetIndex = target.row + target.rowspan;
        const newGrid = foldr(rows, (newG, row)=>{
            return insertRowAt(newG, targetIndex, row.row, comparator, genWrappers.getOrInit);
        }, grid);
        return bundle(newGrid, targetIndex, details[0].column);
    };
    const opInsertColumnsBefore = (grid, extractDetail, comparator, genWrappers)=>{
        const details = extractDetail.details;
        const columns = uniqueColumns(details);
        const targetIndex = columns[0].column;
        const newGrid = foldr(columns, (acc, col)=>{
            const newG = insertColumnAt(acc.grid, targetIndex, col.column + acc.delta, comparator, genWrappers.getOrInit);
            return {
                grid: newG,
                delta: acc.delta + 1
            };
        }, {
            grid,
            delta: 0
        }).grid;
        return bundle(newGrid, details[0].row, targetIndex);
    };
    const opInsertColumnsAfter = (grid, extractDetail, comparator, genWrappers)=>{
        const details = extractDetail.details;
        const target = details[details.length - 1];
        const targetIndex = target.column + target.colspan;
        const columns = uniqueColumns(details);
        const newGrid = foldr(columns, (newG, col)=>{
            return insertColumnAt(newG, targetIndex, col.column, comparator, genWrappers.getOrInit);
        }, grid);
        return bundle(newGrid, details[0].row, targetIndex);
    };
    const opMakeColumnsHeader = (initialGrid, details, comparator, genWrappers)=>{
        const columns = uniqueColumns(details);
        const columnIndexes = map$1(columns, (detail)=>detail.column
        );
        const newGrid = replaceColumns(initialGrid, columnIndexes, true, comparator, genWrappers.replaceOrInit);
        return bundle(newGrid, details[0].row, details[0].column);
    };
    const opMakeCellsHeader = (initialGrid, details, comparator, genWrappers)=>{
        const newGrid = replaceCells(initialGrid, details, comparator, genWrappers.replaceOrInit);
        return bundle(newGrid, details[0].row, details[0].column);
    };
    const opUnmakeColumnsHeader = (initialGrid, details, comparator, genWrappers)=>{
        const columns = uniqueColumns(details);
        const columnIndexes = map$1(columns, (detail)=>detail.column
        );
        const newGrid = replaceColumns(initialGrid, columnIndexes, false, comparator, genWrappers.replaceOrInit);
        return bundle(newGrid, details[0].row, details[0].column);
    };
    const opUnmakeCellsHeader = (initialGrid, details, comparator, genWrappers)=>{
        const newGrid = replaceCells(initialGrid, details, comparator, genWrappers.replaceOrInit);
        return bundle(newGrid, details[0].row, details[0].column);
    };
    const makeRowsSection = (section, applyScope)=>(initialGrid, details, comparator, genWrappers, tableSection)=>{
            const rows = uniqueRows(details);
            const rowIndexes = map$1(rows, (detail)=>detail.row
            );
            const newGrid = replaceRows(initialGrid, rowIndexes, section, applyScope, comparator, genWrappers.replaceOrInit, tableSection);
            return bundle(newGrid, details[0].row, details[0].column);
        }
    ;
    const opMakeRowsHeader = makeRowsSection('thead', true);
    const opMakeRowsBody = makeRowsSection('tbody', false);
    const opMakeRowsFooter = makeRowsSection('tfoot', false);
    const opEraseColumns = (grid, extractDetail, _comparator, _genWrappers)=>{
        const columns = uniqueColumns(extractDetail.details);
        const newGrid = deleteColumnsAt(grid, map$1(columns, (column)=>column.column
        ));
        const maxColIndex = newGrid.length > 0 ? newGrid[0].cells.length - 1 : 0;
        return bundle(newGrid, columns[0].row, Math.min(columns[0].column, maxColIndex));
    };
    const opEraseRows = (grid, details, _comparator, _genWrappers)=>{
        const rows = uniqueRows(details);
        const newGrid = deleteRowsAt(grid, rows[0].row, rows[rows.length - 1].row);
        const maxRowIndex = newGrid.length > 0 ? newGrid.length - 1 : 0;
        return bundle(newGrid, Math.min(details[0].row, maxRowIndex), details[0].column);
    };
    const opMergeCells = (grid, mergable, comparator, genWrappers)=>{
        const cells = mergable.cells;
        merge1(cells);
        const newGrid = merge$2(grid, mergable.bounds, comparator, genWrappers.merge(cells));
        return outcome(newGrid, Optional.from(cells[0]));
    };
    const opUnmergeCells = (grid, unmergable, comparator, genWrappers)=>{
        const unmerge$1 = (b, cell)=>unmerge1(b, cell, comparator, genWrappers.unmerge(cell))
        ;
        const newGrid = foldr(unmergable, unmerge$1, grid);
        return outcome(newGrid, Optional.from(unmergable[0]));
    };
    const opPasteCells = (grid, pasteDetails, comparator, _genWrappers)=>{
        const gridify = (table, generators)=>{
            const wh = Warehouse.fromTable(table);
            return toGrid(wh, generators, true);
        };
        const gridB = gridify(pasteDetails.clipboard, pasteDetails.generators);
        const startAddress = address(pasteDetails.row, pasteDetails.column);
        const mergedGrid = merge$1(startAddress, grid, gridB, pasteDetails.generators, comparator);
        return mergedGrid.fold(()=>outcome(grid, Optional.some(pasteDetails.element))
        , (newGrid)=>{
            return bundle(newGrid, pasteDetails.row, pasteDetails.column);
        });
    };
    const gridifyRows = (rows, generators, context)=>{
        const pasteDetails = fromPastedRows(rows, context.section);
        const wh = Warehouse.generate(pasteDetails);
        return toGrid(wh, generators, true);
    };
    const opPasteColsBefore = (grid, pasteDetails, comparator, _genWrappers)=>{
        const rows = extractGridDetails(grid).rows;
        const index = pasteDetails.cells[0].column;
        const context = rows[pasteDetails.cells[0].row];
        const gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);
        const mergedGrid = insertCols(index, grid, gridB, pasteDetails.generators, comparator);
        return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);
    };
    const opPasteColsAfter = (grid, pasteDetails, comparator, _genWrappers)=>{
        const rows = extractGridDetails(grid).rows;
        const index = pasteDetails.cells[pasteDetails.cells.length - 1].column + pasteDetails.cells[pasteDetails.cells.length - 1].colspan;
        const context = rows[pasteDetails.cells[0].row];
        const gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);
        const mergedGrid = insertCols(index, grid, gridB, pasteDetails.generators, comparator);
        return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);
    };
    const opPasteRowsBefore = (grid, pasteDetails, comparator, _genWrappers)=>{
        const rows = extractGridDetails(grid).rows;
        const index = pasteDetails.cells[0].row;
        const context = rows[index];
        const gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);
        const mergedGrid = insertRows(index, grid, gridB, pasteDetails.generators, comparator);
        return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);
    };
    const opPasteRowsAfter = (grid, pasteDetails, comparator, _genWrappers)=>{
        const rows = extractGridDetails(grid).rows;
        const index = pasteDetails.cells[pasteDetails.cells.length - 1].row + pasteDetails.cells[pasteDetails.cells.length - 1].rowspan;
        const context = rows[pasteDetails.cells[0].row];
        const gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);
        const mergedGrid = insertRows(index, grid, gridB, pasteDetails.generators, comparator);
        return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);
    };
    const opGetColumnsType = (table, target)=>{
        const house = Warehouse.fromTable(table);
        const details = onCells(house, target);
        return details.bind((selectedCells)=>{
            const lastSelectedCell = selectedCells[selectedCells.length - 1];
            const minColRange = selectedCells[0].column;
            const maxColRange = lastSelectedCell.column + lastSelectedCell.colspan;
            const selectedColumnCells = flatten(map$1(house.all, (row)=>filter$2(row.cells, (cell)=>cell.column >= minColRange && cell.column < maxColRange
                )
            ));
            return findCommonCellType(selectedColumnCells);
        }).getOr('');
    };
    const opGetCellsType = (table, target)=>{
        const house = Warehouse.fromTable(table);
        const details = onCells(house, target);
        return details.bind(findCommonCellType).getOr('');
    };
    const opGetRowsType = (table, target)=>{
        const house = Warehouse.fromTable(table);
        const details = onCells(house, target);
        return details.bind((selectedCells)=>{
            const lastSelectedCell = selectedCells[selectedCells.length - 1];
            const minRowRange = selectedCells[0].row;
            const maxRowRange = lastSelectedCell.row + lastSelectedCell.rowspan;
            const selectedRows = house.all.slice(minRowRange, maxRowRange);
            return findCommonRowType(selectedRows);
        }).getOr('');
    };
    const resize1 = (table, list, details, behaviours)=>adjustWidthTo(table, list, details, behaviours.sizing)
    ;
    const adjustAndRedistributeWidths = (table, list, details, behaviours)=>adjustAndRedistributeWidths$1(table, list, details, behaviours.sizing, behaviours.resize)
    ;
    const firstColumnIsLocked = (_warehouse, details)=>exists(details, (detail)=>detail.column === 0 && detail.isLocked
        )
    ;
    const lastColumnIsLocked = (warehouse, details)=>exists(details, (detail)=>detail.column + detail.colspan >= warehouse.grid.columns && detail.isLocked
        )
    ;
    const getColumnsWidth = (warehouse, details)=>{
        const columns$1 = columns1(warehouse);
        const uniqueCols = uniqueColumns(details);
        return foldl(uniqueCols, (acc, detail)=>{
            const column = columns$1[detail.column];
            const colWidth = column.map(getOuter$2).getOr(0);
            return acc + colWidth;
        }, 0);
    };
    const insertColumnsExtractor = (before)=>(warehouse, target)=>onCells(warehouse, target).filter((details)=>{
                const checkLocked = before ? firstColumnIsLocked : lastColumnIsLocked;
                return !checkLocked(warehouse, details);
            }).map((details)=>({
                    details,
                    pixelDelta: getColumnsWidth(warehouse, details)
                })
            )
    ;
    const eraseColumnsExtractor = (warehouse, target)=>onUnlockedCells(warehouse, target).map((details)=>({
                details,
                pixelDelta: -getColumnsWidth(warehouse, details)
            })
        )
    ;
    const pasteColumnsExtractor = (before)=>(warehouse, target)=>onPasteByEditor(warehouse, target).filter((details)=>{
                const checkLocked = before ? firstColumnIsLocked : lastColumnIsLocked;
                return !checkLocked(warehouse, details.cells);
            })
    ;
    const headerCellGenerator = Generators.transform('th');
    const bodyCellGenerator = Generators.transform('td');
    const insertRowsBefore = run(opInsertRowsBefore, onCells, noop, noop, Generators.modification);
    const insertRowsAfter = run(opInsertRowsAfter, onCells, noop, noop, Generators.modification);
    const insertColumnsBefore = run(opInsertColumnsBefore, insertColumnsExtractor(true), adjustAndRedistributeWidths, noop, Generators.modification);
    const insertColumnsAfter = run(opInsertColumnsAfter, insertColumnsExtractor(false), adjustAndRedistributeWidths, noop, Generators.modification);
    const eraseColumns = run(opEraseColumns, eraseColumnsExtractor, adjustAndRedistributeWidths, prune1, Generators.modification);
    const eraseRows = run(opEraseRows, onCells, noop, prune1, Generators.modification);
    const makeColumnsHeader = run(opMakeColumnsHeader, onUnlockedCells, noop, noop, headerCellGenerator);
    const unmakeColumnsHeader = run(opUnmakeColumnsHeader, onUnlockedCells, noop, noop, bodyCellGenerator);
    const makeRowsHeader = run(opMakeRowsHeader, onUnlockedCells, noop, noop, headerCellGenerator);
    const makeRowsBody = run(opMakeRowsBody, onUnlockedCells, noop, noop, bodyCellGenerator);
    const makeRowsFooter = run(opMakeRowsFooter, onUnlockedCells, noop, noop, bodyCellGenerator);
    const makeCellsHeader = run(opMakeCellsHeader, onUnlockedCells, noop, noop, headerCellGenerator);
    const unmakeCellsHeader = run(opUnmakeCellsHeader, onUnlockedCells, noop, noop, bodyCellGenerator);
    const mergeCells = run(opMergeCells, onUnlockedMergable, resize1, noop, Generators.merging);
    const unmergeCells = run(opUnmergeCells, onUnlockedUnmergable, resize1, noop, Generators.merging);
    const pasteCells = run(opPasteCells, onPaste, resize1, noop, Generators.modification);
    const pasteColsBefore = run(opPasteColsBefore, pasteColumnsExtractor(true), noop, noop, Generators.modification);
    const pasteColsAfter = run(opPasteColsAfter, pasteColumnsExtractor(false), noop, noop, Generators.modification);
    const pasteRowsBefore = run(opPasteRowsBefore, onPasteByEditor, noop, noop, Generators.modification);
    const pasteRowsAfter = run(opPasteRowsAfter, onPasteByEditor, noop, noop, Generators.modification);
    const getColumnsType = opGetColumnsType;
    const getCellsType = opGetCellsType;
    const getRowsType = opGetRowsType;
    const fireNewRow = (editor, row)=>editor.dispatch('NewRow', {
            node: row
        })
    ;
    const fireNewCell = (editor, cell)=>editor.dispatch('NewCell', {
            node: cell
        })
    ;
    const fireTableModified = (editor, table, data)=>{
        editor.dispatch('TableModified', {
            ...data,
            table
        });
    };
    const fireTableSelectionChange = (editor, cells, start, finish, otherCells)=>{
        editor.dispatch('TableSelectionChange', {
            cells,
            start,
            finish,
            otherCells
        });
    };
    const fireTableSelectionClear = (editor)=>{
        editor.dispatch('TableSelectionClear');
    };
    const fireObjectResizeStart = (editor, target, width, height, origin)=>{
        editor.dispatch('ObjectResizeStart', {
            target,
            width,
            height,
            origin
        });
    };
    const fireObjectResized = (editor, target, width, height, origin)=>{
        editor.dispatch('ObjectResized', {
            target,
            width,
            height,
            origin
        });
    };
    const styleModified = {
        structure: false,
        style: true
    };
    const structureModified = {
        structure: true,
        style: false
    };
    const styleAndStructureModified = {
        structure: true,
        style: true
    };
    const option = (name)=>(editor)=>editor.options.get(name)
    ;
    const determineDefaultTableStyles = (editor, defaultStyles)=>{
        var _a;
        if (isTablePixelsForced(editor)) {
            const dom = editor.dom;
            const parentBlock = (_a = dom.getParent(editor.selection.getStart(), dom.isBlock)) !== null && _a !== void 0 ? _a : editor.getBody();
            const contentWidth = getInner(SugarElement.fromDom(parentBlock));
            return {
                ...defaultStyles,
                width: contentWidth + 'px'
            };
        } else if (isTableResponsiveForced(editor)) return filter$1(defaultStyles, (_value, key)=>key !== 'width'
        );
        else return defaultStyles;
    };
    const register = (editor)=>{
        const registerOption = editor.options.register;
        registerOption('table_clone_elements', {
            processor: 'string[]'
        });
        registerOption('table_use_colgroups', {
            processor: 'boolean',
            default: true
        });
        registerOption('table_header_type', {
            processor: (value)=>{
                const valid = contains$2([
                    'section',
                    'cells',
                    'sectionCells',
                    'auto'
                ], value);
                return valid ? {
                    value,
                    valid
                } : {
                    valid: false,
                    message: 'Must be one of: section, cells, sectionCells or auto.'
                };
            },
            default: 'section'
        });
        registerOption('table_sizing_mode', {
            processor: 'string',
            default: 'auto'
        });
        registerOption('table_default_attributes', {
            processor: 'object',
            default: {
                border: '1'
            }
        });
        registerOption('table_default_styles', {
            processor: 'object',
            default: {
                'border-collapse': 'collapse',
                'width': '100%'
            }
        });
        registerOption('table_column_resizing', {
            processor: (value)=>{
                const valid = contains$2([
                    'preservetable',
                    'resizetable'
                ], value);
                return valid ? {
                    value,
                    valid
                } : {
                    valid: false,
                    message: 'Must be preservetable, or resizetable.'
                };
            },
            default: 'preservetable'
        });
        registerOption('table_resize_bars', {
            processor: 'boolean',
            default: true
        });
    };
    const getTableCloneElements = (editor)=>{
        return Optional.from(editor.options.get('table_clone_elements'));
    };
    const hasTableObjectResizing = (editor)=>{
        const objectResizing = editor.options.get('object_resizing');
        return contains$2(objectResizing.split(','), 'table');
    };
    const getTableHeaderType = option('table_header_type');
    const getTableColumnResizingBehaviour = option('table_column_resizing');
    const isPreserveTableColumnResizing = (editor)=>getTableColumnResizingBehaviour(editor) === 'preservetable'
    ;
    const isResizeTableColumnResizing = (editor)=>getTableColumnResizingBehaviour(editor) === 'resizetable'
    ;
    const getTableSizingMode = option('table_sizing_mode');
    const isTablePercentagesForced = (editor)=>getTableSizingMode(editor) === 'relative'
    ;
    const isTablePixelsForced = (editor)=>getTableSizingMode(editor) === 'fixed'
    ;
    const isTableResponsiveForced = (editor)=>getTableSizingMode(editor) === 'responsive'
    ;
    const hasTableResizeBars = option('table_resize_bars');
    const getTableDefaultAttributes = option('table_default_attributes');
    const getTableDefaultStyles = (editor)=>{
        const options = editor.options;
        const defaultStyles = options.get('table_default_styles');
        return options.isSet('table_default_styles') ? defaultStyles : determineDefaultTableStyles(editor, defaultStyles);
    };
    const tableUseColumnGroup = option('table_use_colgroups');
    const get$5 = (editor, table)=>{
        if (isTablePercentagesForced(editor)) return TableSize.percentageSize(table);
        else if (isTablePixelsForced(editor)) return TableSize.pixelSize(table);
        else return TableSize.getTableSize(table);
    };
    const TableActions = (editor1, resizeHandler, cellSelectionHandler)=>{
        const isTableBody = (editor)=>name1(getBody(editor)) === 'table'
        ;
        const lastRowGuard = (table)=>isTableBody(editor1) === false || getGridSize(table).rows > 1
        ;
        const lastColumnGuard = (table)=>isTableBody(editor1) === false || getGridSize(table).columns > 1
        ;
        const cloneFormats = getTableCloneElements(editor1);
        const colMutationOp = isResizeTableColumnResizing(editor1) ? noop : halve;
        const getTableSectionType = (table)=>{
            switch(getTableHeaderType(editor1)){
                case 'section':
                    return TableSection.section();
                case 'sectionCells':
                    return TableSection.sectionCells();
                case 'cells':
                    return TableSection.cells();
                default:
                    return TableSection.getTableSectionType(table, 'section');
            }
        };
        const setSelectionFromAction = (table, result)=>result.cursor.fold(()=>{
                const cells = cells$1(table);
                return head1(cells).filter(inBody).map((firstCell)=>{
                    cellSelectionHandler.clearSelectedCells(table.dom);
                    const rng = editor1.dom.createRng();
                    rng.selectNode(firstCell.dom);
                    editor1.selection.setRng(rng);
                    set$2(firstCell, 'data-mce-selected', '1');
                    return rng;
                });
            }, (cell)=>{
                const des = freefallRtl(cell);
                const rng = editor1.dom.createRng();
                rng.setStart(des.element.dom, des.offset);
                rng.setEnd(des.element.dom, des.offset);
                editor1.selection.setRng(rng);
                cellSelectionHandler.clearSelectedCells(table.dom);
                return Optional.some(rng);
            })
        ;
        const execute = (operation, guard, mutate, effect)=>(table, target, noEvents = false)=>{
                removeDataStyle(table);
                const doc = SugarElement.fromDom(editor1.getDoc());
                const generators = cellOperations(mutate, doc, cloneFormats);
                const behaviours = {
                    sizing: get$5(editor1, table),
                    resize: isResizeTableColumnResizing(editor1) ? resizeTable1() : preserveTable(),
                    section: getTableSectionType(table)
                };
                return guard(table) ? operation(table, target, generators, behaviours).bind((result)=>{
                    resizeHandler.refresh(table.dom);
                    each$2(result.newRows, (row)=>{
                        fireNewRow(editor1, row.dom);
                    });
                    each$2(result.newCells, (cell)=>{
                        fireNewCell(editor1, cell.dom);
                    });
                    const range = setSelectionFromAction(table, result);
                    if (inBody(table)) {
                        removeDataStyle(table);
                        if (!noEvents) fireTableModified(editor1, table.dom, effect);
                    }
                    return range.map((rng)=>({
                            rng,
                            effect
                        })
                    );
                }) : Optional.none();
            }
        ;
        const deleteRow = execute(eraseRows, lastRowGuard, noop, structureModified);
        const deleteColumn = execute(eraseColumns, lastColumnGuard, noop, structureModified);
        const insertRowsBefore$1 = execute(insertRowsBefore, always, noop, structureModified);
        const insertRowsAfter$1 = execute(insertRowsAfter, always, noop, structureModified);
        const insertColumnsBefore$1 = execute(insertColumnsBefore, always, colMutationOp, structureModified);
        const insertColumnsAfter$1 = execute(insertColumnsAfter, always, colMutationOp, structureModified);
        const mergeCells$1 = execute(mergeCells, always, noop, structureModified);
        const unmergeCells$1 = execute(unmergeCells, always, noop, structureModified);
        const pasteColsBefore$1 = execute(pasteColsBefore, always, noop, structureModified);
        const pasteColsAfter$1 = execute(pasteColsAfter, always, noop, structureModified);
        const pasteRowsBefore$1 = execute(pasteRowsBefore, always, noop, structureModified);
        const pasteRowsAfter$1 = execute(pasteRowsAfter, always, noop, structureModified);
        const pasteCells$1 = execute(pasteCells, always, noop, styleAndStructureModified);
        const makeCellsHeader$1 = execute(makeCellsHeader, always, noop, structureModified);
        const unmakeCellsHeader$1 = execute(unmakeCellsHeader, always, noop, structureModified);
        const makeColumnsHeader$1 = execute(makeColumnsHeader, always, noop, structureModified);
        const unmakeColumnsHeader$1 = execute(unmakeColumnsHeader, always, noop, structureModified);
        const makeRowsHeader$1 = execute(makeRowsHeader, always, noop, structureModified);
        const makeRowsBody$1 = execute(makeRowsBody, always, noop, structureModified);
        const makeRowsFooter$1 = execute(makeRowsFooter, always, noop, structureModified);
        const getTableCellType = getCellsType;
        const getTableColType = getColumnsType;
        const getTableRowType = getRowsType;
        return {
            deleteRow,
            deleteColumn,
            insertRowsBefore: insertRowsBefore$1,
            insertRowsAfter: insertRowsAfter$1,
            insertColumnsBefore: insertColumnsBefore$1,
            insertColumnsAfter: insertColumnsAfter$1,
            mergeCells: mergeCells$1,
            unmergeCells: unmergeCells$1,
            pasteColsBefore: pasteColsBefore$1,
            pasteColsAfter: pasteColsAfter$1,
            pasteRowsBefore: pasteRowsBefore$1,
            pasteRowsAfter: pasteRowsAfter$1,
            pasteCells: pasteCells$1,
            makeCellsHeader: makeCellsHeader$1,
            unmakeCellsHeader: unmakeCellsHeader$1,
            makeColumnsHeader: makeColumnsHeader$1,
            unmakeColumnsHeader: unmakeColumnsHeader$1,
            makeRowsHeader: makeRowsHeader$1,
            makeRowsBody: makeRowsBody$1,
            makeRowsFooter: makeRowsFooter$1,
            getTableRowType,
            getTableCellType,
            getTableColType
        };
    };
    const constrainSpan = (element, property, value)=>{
        const currentColspan = getAttrValue(element, property, 1);
        if (value === 1 || currentColspan <= 1) remove$7(element, property);
        else set$2(element, property, Math.min(value, currentColspan));
    };
    const generateColGroup = (house, minColRange, maxColRange)=>{
        if (Warehouse.hasColumns(house)) {
            const colsToCopy = filter$2(Warehouse.justColumns(house), (col)=>col.column >= minColRange && col.column < maxColRange
            );
            const copiedCols = map$1(colsToCopy, (c)=>{
                const clonedCol = deep(c.element);
                constrainSpan(clonedCol, 'span', maxColRange - minColRange);
                return clonedCol;
            });
            const fakeColgroup = SugarElement.fromTag('colgroup');
            append(fakeColgroup, copiedCols);
            return [
                fakeColgroup
            ];
        } else return [];
    };
    const generateRows = (house, minColRange, maxColRange)=>map$1(house.all, (row)=>{
            const cellsToCopy = filter$2(row.cells, (cell)=>cell.column >= minColRange && cell.column < maxColRange
            );
            const copiedCells = map$1(cellsToCopy, (cell)=>{
                const clonedCell = deep(cell.element);
                constrainSpan(clonedCell, 'colspan', maxColRange - minColRange);
                return clonedCell;
            });
            const fakeTR = SugarElement.fromTag('tr');
            append(fakeTR, copiedCells);
            return fakeTR;
        })
    ;
    const copyCols = (table, target)=>{
        const house = Warehouse.fromTable(table);
        const details = onUnlockedCells(house, target);
        return details.map((selectedCells)=>{
            const lastSelectedCell = selectedCells[selectedCells.length - 1];
            const minColRange = selectedCells[0].column;
            const maxColRange = lastSelectedCell.column + lastSelectedCell.colspan;
            const fakeColGroups = generateColGroup(house, minColRange, maxColRange);
            const fakeRows = generateRows(house, minColRange, maxColRange);
            return [
                ...fakeColGroups,
                ...fakeRows
            ];
        });
    };
    const copyRows = (table, target, generators)=>{
        const warehouse = Warehouse.fromTable(table);
        const details = onCells(warehouse, target);
        return details.bind((selectedCells)=>{
            const grid = toGrid(warehouse, generators, false);
            const rows = extractGridDetails(grid).rows;
            const slicedGrid = rows.slice(selectedCells[0].row, selectedCells[selectedCells.length - 1].row + selectedCells[selectedCells.length - 1].rowspan);
            const filteredGrid = bind$2(slicedGrid, (row)=>{
                const newCells = filter$2(row.cells, (cell)=>!cell.isLocked
                );
                return newCells.length > 0 ? [
                    {
                        ...row,
                        cells: newCells
                    }
                ] : [];
            });
            const slicedDetails = toDetailList(filteredGrid);
            return someIf(slicedDetails.length > 0, slicedDetails);
        }).map((slicedDetails)=>copy1(slicedDetails)
        );
    };
    const adt$5 = Adt.generate([
        {
            invalid: [
                'raw'
            ]
        },
        {
            pixels: [
                'value'
            ]
        },
        {
            percent: [
                'value'
            ]
        }
    ]);
    const validateFor = (suffix, type, value)=>{
        const rawAmount = value.substring(0, value.length - suffix.length);
        const amount = parseFloat(rawAmount);
        return rawAmount === amount.toString() ? type(amount) : adt$5.invalid(value);
    };
    const from = (value)=>{
        if (endsWith(value, '%')) return validateFor('%', adt$5.percent, value);
        if (endsWith(value, 'px')) return validateFor('px', adt$5.pixels, value);
        return adt$5.invalid(value);
    };
    const Size = {
        ...adt$5,
        from
    };
    const redistributeToPercent = (widths, totalWidth)=>{
        return map$1(widths, (w)=>{
            const colType = Size.from(w);
            return colType.fold(()=>{
                return w;
            }, (px)=>{
                const ratio = px / totalWidth * 100;
                return ratio + '%';
            }, (pc)=>{
                return pc + '%';
            });
        });
    };
    const redistributeToPx = (widths, totalWidth, newTotalWidth)=>{
        const scale = newTotalWidth / totalWidth;
        return map$1(widths, (w)=>{
            const colType = Size.from(w);
            return colType.fold(()=>{
                return w;
            }, (px)=>{
                return px * scale + 'px';
            }, (pc)=>{
                return pc / 100 * newTotalWidth + 'px';
            });
        });
    };
    const redistributeEmpty = (newWidthType, columns)=>{
        const f = newWidthType.fold(()=>constant('')
        , (pixels)=>{
            const num = pixels / columns;
            return constant(num + 'px');
        }, ()=>{
            const num = 100 / columns;
            return constant(num + '%');
        });
        return range$1(columns, f);
    };
    const redistributeValues = (newWidthType, widths, totalWidth)=>{
        return newWidthType.fold(()=>{
            return widths;
        }, (px)=>{
            return redistributeToPx(widths, totalWidth, px);
        }, (_pc)=>{
            return redistributeToPercent(widths, totalWidth);
        });
    };
    const redistribute$1 = (widths, totalWidth, newWidth)=>{
        const newType = Size.from(newWidth);
        const floats = forall(widths, (s)=>{
            return s === '0px';
        }) ? redistributeEmpty(newType, widths.length) : redistributeValues(newType, widths, totalWidth);
        return normalize(floats);
    };
    const sum = (values, fallback)=>{
        if (values.length === 0) return fallback;
        return foldr(values, (rest, v)=>{
            return Size.from(v).fold(constant(0), identity, identity) + rest;
        }, 0);
    };
    const roundDown = (num, unit)=>{
        const floored = Math.floor(num);
        return {
            value: floored + unit,
            remainder: num - floored
        };
    };
    const add$3 = (value, amount)=>{
        return Size.from(value).fold(constant(value), (px)=>{
            return px + amount + 'px';
        }, (pc)=>{
            return pc + amount + '%';
        });
    };
    const normalize = (values)=>{
        if (values.length === 0) return values;
        const scan = foldr(values, (rest, value)=>{
            const info = Size.from(value).fold(()=>({
                    value,
                    remainder: 0
                })
            , (num)=>roundDown(num, 'px')
            , (num)=>({
                    value: num + '%',
                    remainder: 0
                })
            );
            return {
                output: [
                    info.value
                ].concat(rest.output),
                remainder: rest.remainder + info.remainder
            };
        }, {
            output: [],
            remainder: 0
        });
        const r = scan.output;
        return r.slice(0, r.length - 1).concat([
            add$3(r[r.length - 1], Math.round(scan.remainder))
        ]);
    };
    const validate = Size.from;
    const redistributeToW = (newWidths, cells, unit)=>{
        each$2(cells, (cell)=>{
            const widths = newWidths.slice(cell.column, cell.colspan + cell.column);
            const w = sum(widths, minWidth());
            set$1(cell.element, 'width', w + unit);
        });
    };
    const redistributeToColumns = (newWidths, columns, unit)=>{
        each$2(columns, (column, index)=>{
            const width = sum([
                newWidths[index]
            ], minWidth());
            set$1(column.element, 'width', width + unit);
        });
    };
    const redistributeToH = (newHeights, rows, cells, unit)=>{
        each$2(cells, (cell)=>{
            const heights = newHeights.slice(cell.row, cell.rowspan + cell.row);
            const h = sum(heights, minHeight());
            set$1(cell.element, 'height', h + unit);
        });
        each$2(rows, (row, i)=>{
            set$1(row.element, 'height', newHeights[i]);
        });
    };
    const getUnit = (newSize)=>{
        return validate(newSize).fold(constant('px'), constant('px'), constant('%'));
    };
    const redistribute = (table, optWidth, optHeight)=>{
        const warehouse = Warehouse.fromTable(table);
        const rows = warehouse.all;
        const cells = Warehouse.justCells(warehouse);
        const columns = Warehouse.justColumns(warehouse);
        optWidth.each((newWidth)=>{
            const widthUnit = getUnit(newWidth);
            const totalWidth = get$9(table);
            const oldWidths = getRawWidths(warehouse, table);
            const nuWidths = redistribute$1(oldWidths, totalWidth, newWidth);
            if (Warehouse.hasColumns(warehouse)) redistributeToColumns(nuWidths, columns, widthUnit);
            else redistributeToW(nuWidths, cells, widthUnit);
            set$1(table, 'width', newWidth);
        });
        optHeight.each((newHeight)=>{
            const hUnit = getUnit(newHeight);
            const totalHeight = get$8(table);
            const oldHeights = getRawHeights(warehouse, table, height1);
            const nuHeights = redistribute$1(oldHeights, totalHeight, newHeight);
            redistributeToH(nuHeights, rows, cells, hUnit);
            set$1(table, 'height', newHeight);
        });
    };
    const isPercentSizing = isPercentSizing$1;
    const isPixelSizing = isPixelSizing$1;
    const isNoneSizing = isNoneSizing$1;
    const cleanupLegacyAttributes = (element)=>{
        remove$7(element, 'width');
    };
    const convertToPercentSize = (table)=>{
        const newWidth = getPercentTableWidth(table);
        redistribute(table, Optional.some(newWidth), Optional.none());
        cleanupLegacyAttributes(table);
    };
    const convertToPixelSize = (table)=>{
        const newWidth = getPixelTableWidth(table);
        redistribute(table, Optional.some(newWidth), Optional.none());
        cleanupLegacyAttributes(table);
    };
    const convertToNoneSize = (table)=>{
        remove$5(table, 'width');
        const columns = columns$11(table);
        const rowElements = columns.length > 0 ? columns : cells$1(table);
        each$2(rowElements, (cell)=>{
            remove$5(cell, 'width');
            cleanupLegacyAttributes(cell);
        });
        cleanupLegacyAttributes(table);
    };
    const DefaultRenderOptions = {
        styles: {
            'border-collapse': 'collapse',
            'width': '100%'
        },
        attributes: {
            border: '1'
        },
        colGroups: false
    };
    const tableHeaderCell = ()=>SugarElement.fromTag('th')
    ;
    const tableCell = ()=>SugarElement.fromTag('td')
    ;
    const tableColumn = ()=>SugarElement.fromTag('col')
    ;
    const createRow = (columns, rowHeaders, columnHeaders, rowIndex)=>{
        const tr = SugarElement.fromTag('tr');
        for(let j = 0; j < columns; j++){
            const td = rowIndex < rowHeaders || j < columnHeaders ? tableHeaderCell() : tableCell();
            if (j < columnHeaders) set$2(td, 'scope', 'row');
            if (rowIndex < rowHeaders) set$2(td, 'scope', 'col');
            append$1(td, SugarElement.fromTag('br'));
            append$1(tr, td);
        }
        return tr;
    };
    const createGroupRow = (columns)=>{
        const columnGroup = SugarElement.fromTag('colgroup');
        range$1(columns, ()=>append$1(columnGroup, tableColumn())
        );
        return columnGroup;
    };
    const createRows = (rows, columns, rowHeaders, columnHeaders)=>range$1(rows, (r)=>createRow(columns, rowHeaders, columnHeaders, r)
        )
    ;
    const render = (rows, columns, rowHeaders, columnHeaders, headerType, renderOpts = DefaultRenderOptions)=>{
        const table = SugarElement.fromTag('table');
        const rowHeadersGoInThead = headerType !== 'cells';
        setAll(table, renderOpts.styles);
        setAll$1(table, renderOpts.attributes);
        if (renderOpts.colGroups) append$1(table, createGroupRow(columns));
        const actualRowHeaders = Math.min(rows, rowHeaders);
        if (rowHeadersGoInThead && rowHeaders > 0) {
            const thead = SugarElement.fromTag('thead');
            append$1(table, thead);
            const theadRowHeaders = headerType === 'sectionCells' ? actualRowHeaders : 0;
            const theadRows = createRows(rowHeaders, columns, theadRowHeaders, columnHeaders);
            append(thead, theadRows);
        }
        const tbody = SugarElement.fromTag('tbody');
        append$1(table, tbody);
        const numRows = rowHeadersGoInThead ? rows - actualRowHeaders : rows;
        const numRowHeaders = rowHeadersGoInThead ? 0 : rowHeaders;
        const tbodyRows = createRows(numRows, columns, numRowHeaders, columnHeaders);
        append(tbody, tbodyRows);
        return table;
    };
    const get$4 = (element)=>element.dom.innerHTML
    ;
    const getOuter1 = (element)=>{
        const container = SugarElement.fromTag('div');
        const clone = SugarElement.fromDom(element.dom.cloneNode(true));
        append$1(container, clone);
        return get$4(container);
    };
    const placeCaretInCell = (editor, cell)=>{
        editor.selection.select(cell.dom, true);
        editor.selection.collapse(true);
    };
    const selectFirstCellInTable = (editor, tableElm)=>{
        descendant(tableElm, 'td,th').each(curry(placeCaretInCell, editor));
    };
    const fireEvents = (editor, table)=>{
        each$2(descendants(table, 'tr'), (row)=>{
            fireNewRow(editor, row.dom);
            each$2(descendants(row, 'th,td'), (cell)=>{
                fireNewCell(editor, cell.dom);
            });
        });
    };
    const isPercentage = (width)=>isString(width) && width.indexOf('%') !== -1
    ;
    const insert = (editor, columns, rows, colHeaders, rowHeaders)=>{
        const defaultStyles = getTableDefaultStyles(editor);
        const options = {
            styles: defaultStyles,
            attributes: getTableDefaultAttributes(editor),
            colGroups: tableUseColumnGroup(editor)
        };
        editor.undoManager.ignore(()=>{
            const table = render(rows, columns, rowHeaders, colHeaders, getTableHeaderType(editor), options);
            set$2(table, 'data-mce-id', '__mce');
            const html = getOuter1(table);
            editor.insertContent(html);
            editor.addVisual();
        });
        return descendant(getBody(editor), 'table[data-mce-id="__mce"]').map((table)=>{
            if (isTablePixelsForced(editor)) convertToPixelSize(table);
            else if (isTableResponsiveForced(editor)) convertToNoneSize(table);
            else if (isTablePercentagesForced(editor) || isPercentage(defaultStyles.width)) convertToPercentSize(table);
            removeDataStyle(table);
            remove$7(table, 'data-mce-id');
            fireEvents(editor, table);
            selectFirstCellInTable(editor, table);
            return table.dom;
        }).getOr(null);
    };
    const insertTable = (editor, rows, columns, options = {})=>{
        const checkInput = (val)=>isNumber(val) && val > 0
        ;
        if (checkInput(rows) && checkInput(columns)) {
            const headerRows = options.headerRows || 0;
            const headerColumns = options.headerColumns || 0;
            return insert(editor, columns, rows, headerColumns, headerRows);
        } else {
            console.error('Invalid values for mceInsertTable - rows and columns values are required to insert a table.');
            return null;
        }
    };
    var global = tinymce.util.Tools.resolve('tinymce.FakeClipboard');
    const tableTypeBase = 'x-tinymce/dom-table-';
    const tableTypeRow = tableTypeBase + 'rows';
    const tableTypeColumn = tableTypeBase + 'columns';
    const setData = (items)=>{
        const fakeClipboardItem = global.FakeClipboardItem(items);
        global.write([
            fakeClipboardItem
        ]);
    };
    const getData = (type)=>{
        var _a;
        const items = (_a = global.read()) !== null && _a !== void 0 ? _a : [];
        return findMap(items, (item)=>Optional.from(item.getType(type))
        );
    };
    const clearData = (type)=>{
        if (getData(type).isSome()) global.clear();
    };
    const setRows = (rowsOpt)=>{
        rowsOpt.fold(clearRows, (rows)=>setData({
                [tableTypeRow]: rows
            })
        );
    };
    const getRows1 = ()=>getData(tableTypeRow)
    ;
    const clearRows = ()=>clearData(tableTypeRow)
    ;
    const setColumns = (columnsOpt)=>{
        columnsOpt.fold(clearColumns, (columns)=>setData({
                [tableTypeColumn]: columns
            })
        );
    };
    const getColumns = ()=>getData(tableTypeColumn)
    ;
    const clearColumns = ()=>clearData(tableTypeColumn)
    ;
    const getSelectionStartCellOrCaption = (editor)=>getSelectionCellOrCaption(getSelectionStart(editor), getIsRoot1(editor))
    ;
    const getSelectionStartCell = (editor)=>getSelectionCell(getSelectionStart(editor), getIsRoot1(editor))
    ;
    const registerCommands = (editor, actions)=>{
        const isRoot = getIsRoot1(editor);
        const eraseTable = ()=>getSelectionStartCellOrCaption(editor).each((cellOrCaption)=>{
                table1(cellOrCaption, isRoot).filter(not(isRoot)).each((table)=>{
                    const cursor = SugarElement.fromText('');
                    after$5(table, cursor);
                    remove$6(table);
                    if (editor.dom.isEmpty(editor.getBody())) {
                        editor.setContent('');
                        editor.selection.setCursorLocation();
                    } else {
                        const rng = editor.dom.createRng();
                        rng.setStart(cursor.dom, 0);
                        rng.setEnd(cursor.dom, 0);
                        editor.selection.setRng(rng);
                        editor.nodeChanged();
                    }
                });
            })
        ;
        const setSizingMode = (sizing)=>getSelectionStartCellOrCaption(editor).each((cellOrCaption)=>{
                const isForcedSizing = isTableResponsiveForced(editor) || isTablePixelsForced(editor) || isTablePercentagesForced(editor);
                if (!isForcedSizing) table1(cellOrCaption, isRoot).each((table)=>{
                    if (sizing === 'relative' && !isPercentSizing(table)) convertToPercentSize(table);
                    else if (sizing === 'fixed' && !isPixelSizing(table)) convertToPixelSize(table);
                    else if (sizing === 'responsive' && !isNoneSizing(table)) convertToNoneSize(table);
                    removeDataStyle(table);
                    fireTableModified(editor, table.dom, structureModified);
                });
            })
        ;
        const getTableFromCell = (cell)=>table1(cell, isRoot)
        ;
        const performActionOnSelection = (action)=>getSelectionStartCell(editor).bind((cell)=>getTableFromCell(cell).map((table)=>action(table, cell)
                )
            )
        ;
        const toggleTableClass = (_ui, clazz)=>{
            performActionOnSelection((table)=>{
                editor.formatter.toggle('tableclass', {
                    value: clazz
                }, table.dom);
                fireTableModified(editor, table.dom, styleModified);
            });
        };
        const toggleTableCellClass = (_ui, clazz)=>{
            performActionOnSelection((table)=>{
                const selectedCells = getCellsFromSelection(editor);
                const allHaveClass = forall(selectedCells, (cell)=>editor.formatter.match('tablecellclass', {
                        value: clazz
                    }, cell.dom)
                );
                const formatterAction = allHaveClass ? editor.formatter.remove : editor.formatter.apply;
                each$2(selectedCells, (cell)=>formatterAction('tablecellclass', {
                        value: clazz
                    }, cell.dom)
                );
                fireTableModified(editor, table.dom, styleModified);
            });
        };
        const toggleCaption = ()=>{
            getSelectionStartCellOrCaption(editor).each((cellOrCaption)=>{
                table1(cellOrCaption, isRoot).each((table)=>{
                    child1(table, 'caption').fold(()=>{
                        const caption = SugarElement.fromTag('caption');
                        append$1(caption, SugarElement.fromText('Caption'));
                        appendAt(table, caption, 0);
                        editor.selection.setCursorLocation(caption.dom, 0);
                    }, (caption)=>{
                        if (isTag('caption')(cellOrCaption)) one('td', table).each((td)=>editor.selection.setCursorLocation(td.dom, 0)
                        );
                        remove$6(caption);
                    });
                    fireTableModified(editor, table.dom, structureModified);
                });
            });
        };
        const postExecute = (_data)=>{
            editor.focus();
        };
        const actOnSelection = (execute, noEvents = false)=>performActionOnSelection((table, startCell)=>{
                const targets = forMenu(getCellsFromSelection(editor), table, startCell);
                execute(table, targets, noEvents).each(postExecute);
            })
        ;
        const copyRowSelection = ()=>performActionOnSelection((table, startCell)=>{
                const targets = forMenu(getCellsFromSelection(editor), table, startCell);
                const generators = cellOperations(noop, SugarElement.fromDom(editor.getDoc()), Optional.none());
                return copyRows(table, targets, generators);
            })
        ;
        const copyColSelection = ()=>performActionOnSelection((table, startCell)=>{
                const targets = forMenu(getCellsFromSelection(editor), table, startCell);
                return copyCols(table, targets);
            })
        ;
        const pasteOnSelection = (execute, getRows)=>getRows().each((rows)=>{
                const clonedRows = map$1(rows, (row)=>deep(row)
                );
                performActionOnSelection((table, startCell)=>{
                    const generators = paste$1(SugarElement.fromDom(editor.getDoc()));
                    const targets = pasteRows(getCellsFromSelection(editor), startCell, clonedRows, generators);
                    execute(table, targets).each(postExecute);
                });
            })
        ;
        const actOnType = (getAction)=>(_ui, args)=>get$c(args, 'type').each((type)=>{
                    actOnSelection(getAction(type), args.no_events);
                })
        ;
        each$1({
            mceTableSplitCells: ()=>actOnSelection(actions.unmergeCells)
            ,
            mceTableMergeCells: ()=>actOnSelection(actions.mergeCells)
            ,
            mceTableInsertRowBefore: ()=>actOnSelection(actions.insertRowsBefore)
            ,
            mceTableInsertRowAfter: ()=>actOnSelection(actions.insertRowsAfter)
            ,
            mceTableInsertColBefore: ()=>actOnSelection(actions.insertColumnsBefore)
            ,
            mceTableInsertColAfter: ()=>actOnSelection(actions.insertColumnsAfter)
            ,
            mceTableDeleteCol: ()=>actOnSelection(actions.deleteColumn)
            ,
            mceTableDeleteRow: ()=>actOnSelection(actions.deleteRow)
            ,
            mceTableCutCol: ()=>copyColSelection().each((selection)=>{
                    setColumns(selection);
                    actOnSelection(actions.deleteColumn);
                })
            ,
            mceTableCutRow: ()=>copyRowSelection().each((selection)=>{
                    setRows(selection);
                    actOnSelection(actions.deleteRow);
                })
            ,
            mceTableCopyCol: ()=>copyColSelection().each((selection)=>setColumns(selection)
                )
            ,
            mceTableCopyRow: ()=>copyRowSelection().each((selection)=>setRows(selection)
                )
            ,
            mceTablePasteColBefore: ()=>pasteOnSelection(actions.pasteColsBefore, getColumns)
            ,
            mceTablePasteColAfter: ()=>pasteOnSelection(actions.pasteColsAfter, getColumns)
            ,
            mceTablePasteRowBefore: ()=>pasteOnSelection(actions.pasteRowsBefore, getRows1)
            ,
            mceTablePasteRowAfter: ()=>pasteOnSelection(actions.pasteRowsAfter, getRows1)
            ,
            mceTableDelete: eraseTable,
            mceTableCellToggleClass: toggleTableCellClass,
            mceTableToggleClass: toggleTableClass,
            mceTableToggleCaption: toggleCaption,
            mceTableSizingMode: (_ui, sizing)=>setSizingMode(sizing)
            ,
            mceTableCellType: actOnType((type)=>type === 'th' ? actions.makeCellsHeader : actions.unmakeCellsHeader
            ),
            mceTableColType: actOnType((type)=>type === 'th' ? actions.makeColumnsHeader : actions.unmakeColumnsHeader
            ),
            mceTableRowType: actOnType((type)=>{
                switch(type){
                    case 'header':
                        return actions.makeRowsHeader;
                    case 'footer':
                        return actions.makeRowsFooter;
                    default:
                        return actions.makeRowsBody;
                }
            })
        }, (func, name)=>editor.addCommand(name, func)
        );
        editor.addCommand('mceInsertTable', (_ui, args)=>{
            insertTable(editor, args.rows, args.columns, args.options);
        });
        editor.addCommand('mceTableApplyCellStyle', (_ui, args)=>{
            const getFormatName = (style)=>'tablecell' + style.toLowerCase().replace('-', '')
            ;
            if (!isObject(args)) return;
            const cells = getCellsFromSelection(editor);
            if (cells.length === 0) return;
            const validArgs = filter$1(args, (value, style)=>editor.formatter.has(getFormatName(style)) && isString(value)
            );
            if (isEmpty(validArgs)) return;
            each$1(validArgs, (value, style)=>{
                const formatName = getFormatName(style);
                each$2(cells, (cell)=>{
                    if (value === '') editor.formatter.remove(formatName, {
                        value: null
                    }, cell.dom, true);
                    else editor.formatter.apply(formatName, {
                        value
                    }, cell.dom);
                });
            });
            getTableFromCell(cells[0]).each((table)=>fireTableModified(editor, table.dom, styleModified)
            );
        });
    };
    const registerQueryCommands = (editor, actions)=>{
        const isRoot = getIsRoot1(editor);
        const lookupOnSelection = (action)=>getSelectionCell(getSelectionStart(editor)).bind((cell)=>table1(cell, isRoot).map((table)=>{
                    const targets = forMenu(getCellsFromSelection(editor), table, cell);
                    return action(table, targets);
                })
            ).getOr('')
        ;
        each$1({
            mceTableRowType: ()=>lookupOnSelection(actions.getTableRowType)
            ,
            mceTableCellType: ()=>lookupOnSelection(actions.getTableCellType)
            ,
            mceTableColType: ()=>lookupOnSelection(actions.getTableColType)
        }, (func, name)=>editor.addQueryValueHandler(name, func)
        );
    };
    const adt$4 = Adt.generate([
        {
            before: [
                'element'
            ]
        },
        {
            on: [
                'element',
                'offset'
            ]
        },
        {
            after: [
                'element'
            ]
        }
    ]);
    const cata$1 = (subject, onBefore, onOn, onAfter)=>subject.fold(onBefore, onOn, onAfter)
    ;
    const getStart$1 = (situ)=>situ.fold(identity, identity, identity)
    ;
    const before$2 = adt$4.before;
    const on1 = adt$4.on;
    const after$3 = adt$4.after;
    const Situ = {
        before: before$2,
        on: on1,
        after: after$3,
        cata: cata$1,
        getStart: getStart$1
    };
    const create$4 = (selection, kill)=>({
            selection,
            kill
        })
    ;
    const Response = {
        create: create$4
    };
    const selectNode1 = (win, element)=>{
        const rng = win.document.createRange();
        rng.selectNode(element.dom);
        return rng;
    };
    const selectNodeContents = (win, element)=>{
        const rng = win.document.createRange();
        selectNodeContentsUsing(rng, element);
        return rng;
    };
    const selectNodeContentsUsing = (rng, element)=>rng.selectNodeContents(element.dom)
    ;
    const setStart = (rng, situ)=>{
        situ.fold((e)=>{
            rng.setStartBefore(e.dom);
        }, (e, o)=>{
            rng.setStart(e.dom, o);
        }, (e)=>{
            rng.setStartAfter(e.dom);
        });
    };
    const setFinish = (rng, situ)=>{
        situ.fold((e)=>{
            rng.setEndBefore(e.dom);
        }, (e, o)=>{
            rng.setEnd(e.dom, o);
        }, (e)=>{
            rng.setEndAfter(e.dom);
        });
    };
    const relativeToNative = (win, startSitu, finishSitu)=>{
        const range = win.document.createRange();
        setStart(range, startSitu);
        setFinish(range, finishSitu);
        return range;
    };
    const exactToNative = (win, start, soffset, finish, foffset)=>{
        const rng = win.document.createRange();
        rng.setStart(start.dom, soffset);
        rng.setEnd(finish.dom, foffset);
        return rng;
    };
    const toRect = (rect)=>({
            left: rect.left,
            top: rect.top,
            right: rect.right,
            bottom: rect.bottom,
            width: rect.width,
            height: rect.height
        })
    ;
    const getFirstRect$1 = (rng)=>{
        const rects = rng.getClientRects();
        const rect = rects.length > 0 ? rects[0] : rng.getBoundingClientRect();
        return rect.width > 0 || rect.height > 0 ? Optional.some(rect).map(toRect) : Optional.none();
    };
    const adt$3 = Adt.generate([
        {
            ltr: [
                'start',
                'soffset',
                'finish',
                'foffset'
            ]
        },
        {
            rtl: [
                'start',
                'soffset',
                'finish',
                'foffset'
            ]
        }
    ]);
    const fromRange = (win, type, range)=>type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset)
    ;
    const getRanges = (win, selection)=>selection.match({
            domRange: (rng)=>{
                return {
                    ltr: constant(rng),
                    rtl: Optional.none
                };
            },
            relative: (startSitu, finishSitu)=>{
                return {
                    ltr: cached(()=>relativeToNative(win, startSitu, finishSitu)
                    ),
                    rtl: cached(()=>Optional.some(relativeToNative(win, finishSitu, startSitu))
                    )
                };
            },
            exact: (start, soffset, finish, foffset)=>{
                return {
                    ltr: cached(()=>exactToNative(win, start, soffset, finish, foffset)
                    ),
                    rtl: cached(()=>Optional.some(exactToNative(win, finish, foffset, start, soffset))
                    )
                };
            }
        })
    ;
    const doDiagnose = (win, ranges)=>{
        const rng = ranges.ltr();
        if (rng.collapsed) {
            const reversed = ranges.rtl().filter((rev)=>rev.collapsed === false
            );
            return reversed.map((rev)=>adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)
            ).getOrThunk(()=>fromRange(win, adt$3.ltr, rng)
            );
        } else return fromRange(win, adt$3.ltr, rng);
    };
    const diagnose = (win, selection)=>{
        const ranges = getRanges(win, selection);
        return doDiagnose(win, ranges);
    };
    const asLtrRange = (win, selection)=>{
        const diagnosis = diagnose(win, selection);
        return diagnosis.match({
            ltr: (start, soffset, finish, foffset)=>{
                const rng = win.document.createRange();
                rng.setStart(start.dom, soffset);
                rng.setEnd(finish.dom, foffset);
                return rng;
            },
            rtl: (start, soffset, finish, foffset)=>{
                const rng = win.document.createRange();
                rng.setStart(finish.dom, foffset);
                rng.setEnd(start.dom, soffset);
                return rng;
            }
        });
    };
    adt$3.ltr;
    adt$3.rtl;
    const create$3 = (start, soffset, finish, foffset)=>({
            start,
            soffset,
            finish,
            foffset
        })
    ;
    const SimRange = {
        create: create$3
    };
    const create$2 = (start, soffset, finish, foffset)=>{
        return {
            start: Situ.on(start, soffset),
            finish: Situ.on(finish, foffset)
        };
    };
    const Situs = {
        create: create$2
    };
    const convertToRange = (win, selection)=>{
        const rng = asLtrRange(win, selection);
        return SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset);
    };
    const makeSitus = Situs.create;
    const sync1 = (container, isRoot, start, soffset, finish, foffset, selectRange)=>{
        if (!(eq$1(start, finish) && soffset === foffset)) return closest$1(start, 'td,th', isRoot).bind((s)=>{
            return closest$1(finish, 'td,th', isRoot).bind((f)=>{
                return detect(container, isRoot, s, f, selectRange);
            });
        });
        else return Optional.none();
    };
    const detect = (container, isRoot, start, finish, selectRange)=>{
        if (!eq$1(start, finish)) return identify(start, finish, isRoot).bind((cellSel)=>{
            const boxes = cellSel.boxes.getOr([]);
            if (boxes.length > 1) {
                selectRange(container, boxes, cellSel.start, cellSel.finish);
                return Optional.some(Response.create(Optional.some(makeSitus(start, 0, start, getEnd(start))), true));
            } else return Optional.none();
        });
        else return Optional.none();
    };
    const update1 = (rows, columns, container, selected, annotations)=>{
        const updateSelection = (newSels)=>{
            annotations.clearBeforeUpdate(container);
            annotations.selectRange(container, newSels.boxes, newSels.start, newSels.finish);
            return newSels.boxes;
        };
        return shiftSelection(selected, rows, columns, annotations.firstSelectedSelector, annotations.lastSelectedSelector).map(updateSelection);
    };
    const traverse = (item, mode)=>({
            item,
            mode
        })
    ;
    const backtrack = (universe, item, _direction, transition = sidestep)=>{
        return universe.property().parent(item).map((p)=>{
            return traverse(p, transition);
        });
    };
    const sidestep = (universe, item, direction, transition = advance)=>{
        return direction.sibling(universe, item).map((p)=>{
            return traverse(p, transition);
        });
    };
    const advance = (universe, item, direction, transition = advance)=>{
        const children = universe.property().children(item);
        const result = direction.first(children);
        return result.map((r)=>{
            return traverse(r, transition);
        });
    };
    const successors = [
        {
            current: backtrack,
            next: sidestep,
            fallback: Optional.none()
        },
        {
            current: sidestep,
            next: advance,
            fallback: Optional.some(backtrack)
        },
        {
            current: advance,
            next: advance,
            fallback: Optional.some(sidestep)
        }
    ];
    const go1 = (universe, item, mode, direction, rules = successors)=>{
        const ruleOpt = find$1(rules, (succ)=>{
            return succ.current === mode;
        });
        return ruleOpt.bind((rule)=>{
            return rule.current(universe, item, direction, rule.next).orThunk(()=>{
                return rule.fallback.bind((fb)=>{
                    return go1(universe, item, fb, direction);
                });
            });
        });
    };
    const left$1 = ()=>{
        const sibling = (universe, item)=>{
            return universe.query().prevSibling(item);
        };
        const first = (children)=>{
            return children.length > 0 ? Optional.some(children[children.length - 1]) : Optional.none();
        };
        return {
            sibling,
            first
        };
    };
    const right$1 = ()=>{
        const sibling = (universe, item)=>{
            return universe.query().nextSibling(item);
        };
        const first = (children)=>{
            return children.length > 0 ? Optional.some(children[0]) : Optional.none();
        };
        return {
            sibling,
            first
        };
    };
    const Walkers = {
        left: left$1,
        right: right$1
    };
    const hone = (universe, item, predicate, mode, direction, isRoot)=>{
        const next = go1(universe, item, mode, direction);
        return next.bind((n)=>{
            if (isRoot(n.item)) return Optional.none();
            else return predicate(n.item) ? Optional.some(n.item) : hone(universe, n.item, predicate, n.mode, direction, isRoot);
        });
    };
    const left1 = (universe, item, predicate, isRoot)=>{
        return hone(universe, item, predicate, sidestep, Walkers.left(), isRoot);
    };
    const right = (universe, item, predicate, isRoot)=>{
        return hone(universe, item, predicate, sidestep, Walkers.right(), isRoot);
    };
    const isLeaf = (universe)=>(element)=>universe.property().children(element).length === 0
    ;
    const before$1 = (universe, item, isRoot)=>{
        return seekLeft$1(universe, item, isLeaf(universe), isRoot);
    };
    const after$2 = (universe, item, isRoot)=>{
        return seekRight$1(universe, item, isLeaf(universe), isRoot);
    };
    const seekLeft$1 = left1;
    const seekRight$1 = right;
    const universe1 = DomUniverse();
    const before1 = (element, isRoot)=>{
        return before$1(universe1, element, isRoot);
    };
    const after$1 = (element, isRoot)=>{
        return after$2(universe1, element, isRoot);
    };
    const seekLeft = (element, predicate, isRoot)=>{
        return seekLeft$1(universe1, element, predicate, isRoot);
    };
    const seekRight = (element, predicate, isRoot)=>{
        return seekRight$1(universe1, element, predicate, isRoot);
    };
    const ancestor1 = (scope, predicate, isRoot)=>ancestor$2(scope, predicate, isRoot).isSome()
    ;
    const adt$2 = Adt.generate([
        {
            none: [
                'message'
            ]
        },
        {
            success: []
        },
        {
            failedUp: [
                'cell'
            ]
        },
        {
            failedDown: [
                'cell'
            ]
        }
    ]);
    const isOverlapping = (bridge, before, after)=>{
        const beforeBounds = bridge.getRect(before);
        const afterBounds = bridge.getRect(after);
        return afterBounds.right > beforeBounds.left && afterBounds.left < beforeBounds.right;
    };
    const isRow = (elem)=>{
        return closest$1(elem, 'tr');
    };
    const verify = (bridge, before, beforeOffset, after, afterOffset, failure, isRoot)=>{
        return closest$1(after, 'td,th', isRoot).bind((afterCell)=>{
            return closest$1(before, 'td,th', isRoot).map((beforeCell)=>{
                if (!eq$1(afterCell, beforeCell)) return sharedOne(isRow, [
                    afterCell,
                    beforeCell
                ]).fold(()=>{
                    return isOverlapping(bridge, beforeCell, afterCell) ? adt$2.success() : failure(beforeCell);
                }, (_sharedRow)=>{
                    return failure(beforeCell);
                });
                else return eq$1(after, afterCell) && getEnd(afterCell) === afterOffset ? failure(beforeCell) : adt$2.none('in same cell');
            });
        }).getOr(adt$2.none('default'));
    };
    const cata = (subject, onNone, onSuccess, onFailedUp, onFailedDown)=>{
        return subject.fold(onNone, onSuccess, onFailedUp, onFailedDown);
    };
    const BeforeAfter = {
        ...adt$2,
        verify,
        cata
    };
    const inParent = (parent, children, element, index)=>({
            parent,
            children,
            element,
            index
        })
    ;
    const indexInParent = (element)=>parent1(element).bind((parent)=>{
            const children = children$2(parent);
            return indexOf(children, element).map((index)=>inParent(parent, children, element, index)
            );
        })
    ;
    const indexOf = (elements, element)=>findIndex(elements, curry(eq$1, element))
    ;
    const isBr1 = isTag('br');
    const gatherer = (cand, gather, isRoot)=>{
        return gather(cand, isRoot).bind((target)=>{
            return isText(target) && get$6(target).trim().length === 0 ? gatherer(target, gather, isRoot) : Optional.some(target);
        });
    };
    const handleBr = (isRoot, element, direction)=>{
        return direction.traverse(element).orThunk(()=>{
            return gatherer(element, direction.gather, isRoot);
        }).map(direction.relative);
    };
    const findBr = (element, offset)=>{
        return child$2(element, offset).filter(isBr1).orThunk(()=>{
            return child$2(element, offset - 1).filter(isBr1);
        });
    };
    const handleParent = (isRoot, element, offset, direction)=>{
        return findBr(element, offset).bind((br)=>{
            return direction.traverse(br).fold(()=>{
                return gatherer(br, direction.gather, isRoot).map(direction.relative);
            }, (adjacent)=>{
                return indexInParent(adjacent).map((info)=>{
                    return Situ.on(info.parent, info.index);
                });
            });
        });
    };
    const tryBr = (isRoot, element, offset, direction)=>{
        const target = isBr1(element) ? handleBr(isRoot, element, direction) : handleParent(isRoot, element, offset, direction);
        return target.map((tgt)=>{
            return {
                start: tgt,
                finish: tgt
            };
        });
    };
    const process = (analysis)=>{
        return BeforeAfter.cata(analysis, (_message)=>{
            return Optional.none();
        }, ()=>{
            return Optional.none();
        }, (cell)=>{
            return Optional.some(point(cell, 0));
        }, (cell)=>{
            return Optional.some(point(cell, getEnd(cell)));
        });
    };
    const moveDown = (caret, amount)=>{
        return {
            left: caret.left,
            top: caret.top + amount,
            right: caret.right,
            bottom: caret.bottom + amount
        };
    };
    const moveUp = (caret, amount)=>{
        return {
            left: caret.left,
            top: caret.top - amount,
            right: caret.right,
            bottom: caret.bottom - amount
        };
    };
    const translate1 = (caret, xDelta, yDelta)=>{
        return {
            left: caret.left + xDelta,
            top: caret.top + yDelta,
            right: caret.right + xDelta,
            bottom: caret.bottom + yDelta
        };
    };
    const getTop = (caret)=>{
        return caret.top;
    };
    const getBottom = (caret)=>{
        return caret.bottom;
    };
    const getPartialBox = (bridge, element, offset)=>{
        if (offset >= 0 && offset < getEnd(element)) return bridge.getRangedRect(element, offset, element, offset + 1);
        else if (offset > 0) return bridge.getRangedRect(element, offset - 1, element, offset);
        return Optional.none();
    };
    const toCaret = (rect)=>({
            left: rect.left,
            top: rect.top,
            right: rect.right,
            bottom: rect.bottom
        })
    ;
    const getElemBox = (bridge, element)=>{
        return Optional.some(bridge.getRect(element));
    };
    const getBoxAt = (bridge, element, offset)=>{
        if (isElement(element)) return getElemBox(bridge, element).map(toCaret);
        else if (isText(element)) return getPartialBox(bridge, element, offset).map(toCaret);
        else return Optional.none();
    };
    const getEntireBox = (bridge, element)=>{
        if (isElement(element)) return getElemBox(bridge, element).map(toCaret);
        else if (isText(element)) return bridge.getRangedRect(element, 0, element, getEnd(element)).map(toCaret);
        else return Optional.none();
    };
    const JUMP_SIZE = 5;
    const NUM_RETRIES = 100;
    const adt$1 = Adt.generate([
        {
            none: []
        },
        {
            retry: [
                'caret'
            ]
        }
    ]);
    const isOutside = (caret, box)=>{
        return caret.left < box.left || Math.abs(box.right - caret.left) < 1 || caret.left > box.right;
    };
    const inOutsideBlock = (bridge, element, caret)=>{
        return closest$2(element, isBlock).fold(never, (cell)=>{
            return getEntireBox(bridge, cell).exists((box)=>{
                return isOutside(caret, box);
            });
        });
    };
    const adjustDown = (bridge, element, guessBox, original, caret)=>{
        const lowerCaret = moveDown(caret, JUMP_SIZE);
        if (Math.abs(guessBox.bottom - original.bottom) < 1) return adt$1.retry(lowerCaret);
        else if (guessBox.top > caret.bottom) return adt$1.retry(lowerCaret);
        else if (guessBox.top === caret.bottom) return adt$1.retry(moveDown(caret, 1));
        else return inOutsideBlock(bridge, element, caret) ? adt$1.retry(translate1(lowerCaret, JUMP_SIZE, 0)) : adt$1.none();
    };
    const adjustUp = (bridge, element, guessBox, original, caret)=>{
        const higherCaret = moveUp(caret, JUMP_SIZE);
        if (Math.abs(guessBox.top - original.top) < 1) return adt$1.retry(higherCaret);
        else if (guessBox.bottom < caret.top) return adt$1.retry(higherCaret);
        else if (guessBox.bottom === caret.top) return adt$1.retry(moveUp(caret, 1));
        else return inOutsideBlock(bridge, element, caret) ? adt$1.retry(translate1(higherCaret, JUMP_SIZE, 0)) : adt$1.none();
    };
    const upMovement = {
        point: getTop,
        adjuster: adjustUp,
        move: moveUp,
        gather: before1
    };
    const downMovement = {
        point: getBottom,
        adjuster: adjustDown,
        move: moveDown,
        gather: after$1
    };
    const isAtTable = (bridge, x, y)=>{
        return bridge.elementFromPoint(x, y).filter((elm)=>{
            return name1(elm) === 'table';
        }).isSome();
    };
    const adjustForTable = (bridge, movement, original, caret, numRetries)=>{
        return adjustTil(bridge, movement, original, movement.move(caret, JUMP_SIZE), numRetries);
    };
    const adjustTil = (bridge, movement, original, caret, numRetries)=>{
        if (numRetries === 0) return Optional.some(caret);
        if (isAtTable(bridge, caret.left, movement.point(caret))) return adjustForTable(bridge, movement, original, caret, numRetries - 1);
        return bridge.situsFromPoint(caret.left, movement.point(caret)).bind((guess)=>{
            return guess.start.fold(Optional.none, (element)=>{
                return getEntireBox(bridge, element).bind((guessBox)=>{
                    return movement.adjuster(bridge, element, guessBox, original, caret).fold(Optional.none, (newCaret)=>{
                        return adjustTil(bridge, movement, original, newCaret, numRetries - 1);
                    });
                }).orThunk(()=>{
                    return Optional.some(caret);
                });
            }, Optional.none);
        });
    };
    const checkScroll = (movement, adjusted, bridge)=>{
        if (movement.point(adjusted) > bridge.getInnerHeight()) return Optional.some(movement.point(adjusted) - bridge.getInnerHeight());
        else if (movement.point(adjusted) < 0) return Optional.some(-movement.point(adjusted));
        else return Optional.none();
    };
    const retry = (movement, bridge, caret)=>{
        const moved = movement.move(caret, JUMP_SIZE);
        const adjusted = adjustTil(bridge, movement, caret, moved, NUM_RETRIES).getOr(moved);
        return checkScroll(movement, adjusted, bridge).fold(()=>{
            return bridge.situsFromPoint(adjusted.left, movement.point(adjusted));
        }, (delta)=>{
            bridge.scrollBy(0, delta);
            return bridge.situsFromPoint(adjusted.left, movement.point(adjusted) - delta);
        });
    };
    const Retries = {
        tryUp: curry(retry, upMovement),
        tryDown: curry(retry, downMovement),
        getJumpSize: constant(JUMP_SIZE)
    };
    const MAX_RETRIES = 20;
    const findSpot = (bridge, isRoot, direction)=>{
        return bridge.getSelection().bind((sel)=>{
            return tryBr(isRoot, sel.finish, sel.foffset, direction).fold(()=>{
                return Optional.some(point(sel.finish, sel.foffset));
            }, (brNeighbour)=>{
                const range = bridge.fromSitus(brNeighbour);
                const analysis = BeforeAfter.verify(bridge, sel.finish, sel.foffset, range.finish, range.foffset, direction.failure, isRoot);
                return process(analysis);
            });
        });
    };
    const scan1 = (bridge, isRoot, element, offset, direction, numRetries)=>{
        if (numRetries === 0) return Optional.none();
        return tryCursor(bridge, isRoot, element, offset, direction).bind((situs)=>{
            const range = bridge.fromSitus(situs);
            const analysis = BeforeAfter.verify(bridge, element, offset, range.finish, range.foffset, direction.failure, isRoot);
            return BeforeAfter.cata(analysis, ()=>{
                return Optional.none();
            }, ()=>{
                return Optional.some(situs);
            }, (cell)=>{
                if (eq$1(element, cell) && offset === 0) return tryAgain(bridge, element, offset, moveUp, direction);
                else return scan1(bridge, isRoot, cell, 0, direction, numRetries - 1);
            }, (cell)=>{
                if (eq$1(element, cell) && offset === getEnd(cell)) return tryAgain(bridge, element, offset, moveDown, direction);
                else return scan1(bridge, isRoot, cell, getEnd(cell), direction, numRetries - 1);
            });
        });
    };
    const tryAgain = (bridge, element, offset, move, direction)=>{
        return getBoxAt(bridge, element, offset).bind((box)=>{
            return tryAt(bridge, direction, move(box, Retries.getJumpSize()));
        });
    };
    const tryAt = (bridge, direction, box)=>{
        const browser = detect$2().browser;
        if (browser.isChromium() || browser.isSafari() || browser.isFirefox()) return direction.retry(bridge, box);
        else return Optional.none();
    };
    const tryCursor = (bridge, isRoot, element, offset, direction)=>{
        return getBoxAt(bridge, element, offset).bind((box)=>{
            return tryAt(bridge, direction, box);
        });
    };
    const handle$1 = (bridge, isRoot, direction)=>{
        return findSpot(bridge, isRoot, direction).bind((spot)=>{
            return scan1(bridge, isRoot, spot.element, spot.offset, direction, MAX_RETRIES).map(bridge.fromSitus);
        });
    };
    const inSameTable = (elem, table)=>{
        return ancestor1(elem, (e)=>{
            return parent1(e).exists((p)=>{
                return eq$1(p, table);
            });
        });
    };
    const simulate = (bridge, isRoot, direction, initial, anchor)=>{
        return closest$1(initial, 'td,th', isRoot).bind((start)=>{
            return closest$1(start, 'table', isRoot).bind((table)=>{
                if (!inSameTable(anchor, table)) return Optional.none();
                return handle$1(bridge, isRoot, direction).bind((range)=>{
                    return closest$1(range.finish, 'td,th', isRoot).map((finish)=>{
                        return {
                            start,
                            finish,
                            range
                        };
                    });
                });
            });
        });
    };
    const navigate = (bridge, isRoot, direction, initial, anchor, precheck)=>{
        return precheck(initial, isRoot).orThunk(()=>{
            return simulate(bridge, isRoot, direction, initial, anchor).map((info)=>{
                const range = info.range;
                return Response.create(Optional.some(makeSitus(range.start, range.soffset, range.finish, range.foffset)), true);
            });
        });
    };
    const firstUpCheck = (initial, isRoot)=>{
        return closest$1(initial, 'tr', isRoot).bind((startRow)=>{
            return closest$1(startRow, 'table', isRoot).bind((table)=>{
                const rows = descendants(table, 'tr');
                if (eq$1(startRow, rows[0])) return seekLeft(table, (element)=>{
                    return last$1(element).isSome();
                }, isRoot).map((last)=>{
                    const lastOffset = getEnd(last);
                    return Response.create(Optional.some(makeSitus(last, lastOffset, last, lastOffset)), true);
                });
                else return Optional.none();
            });
        });
    };
    const lastDownCheck = (initial, isRoot)=>{
        return closest$1(initial, 'tr', isRoot).bind((startRow)=>{
            return closest$1(startRow, 'table', isRoot).bind((table)=>{
                const rows = descendants(table, 'tr');
                if (eq$1(startRow, rows[rows.length - 1])) return seekRight(table, (element)=>{
                    return first1(element).isSome();
                }, isRoot).map((first)=>{
                    return Response.create(Optional.some(makeSitus(first, 0, first, 0)), true);
                });
                else return Optional.none();
            });
        });
    };
    const select = (bridge, container, isRoot, direction, initial, anchor, selectRange)=>{
        return simulate(bridge, isRoot, direction, initial, anchor).bind((info)=>{
            return detect(container, isRoot, info.start, info.finish, selectRange);
        });
    };
    const Cell = (initial)=>{
        let value = initial;
        const get = ()=>{
            return value;
        };
        const set = (v)=>{
            value = v;
        };
        return {
            get,
            set
        };
    };
    const singleton = (doRevoke)=>{
        const subject = Cell(Optional.none());
        const revoke = ()=>subject.get().each(doRevoke)
        ;
        const clear = ()=>{
            revoke();
            subject.set(Optional.none());
        };
        const isSet = ()=>subject.get().isSome()
        ;
        const get = ()=>subject.get()
        ;
        const set = (s)=>{
            revoke();
            subject.set(Optional.some(s));
        };
        return {
            clear,
            isSet,
            get,
            set
        };
    };
    const value1 = ()=>{
        const subject = singleton(noop);
        const on = (f)=>subject.get().each(f)
        ;
        return {
            ...subject,
            on
        };
    };
    const findCell = (target, isRoot)=>closest$1(target, 'td,th', isRoot)
    ;
    const MouseSelection = (bridge, container, isRoot, annotations)=>{
        const cursor = value1();
        const clearstate = cursor.clear;
        const applySelection = (event)=>{
            cursor.on((start)=>{
                annotations.clearBeforeUpdate(container);
                findCell(event.target, isRoot).each((finish)=>{
                    identify(start, finish, isRoot).each((cellSel)=>{
                        const boxes = cellSel.boxes.getOr([]);
                        if (boxes.length === 1) {
                            const singleCell = boxes[0];
                            const isNonEditableCell = getRaw(singleCell) === 'false';
                            const isCellClosestContentEditable = is1(closest(event.target), singleCell, eq$1);
                            if (isNonEditableCell && isCellClosestContentEditable) {
                                annotations.selectRange(container, boxes, singleCell, singleCell);
                                bridge.selectContents(singleCell);
                            }
                        } else if (boxes.length > 1) {
                            annotations.selectRange(container, boxes, cellSel.start, cellSel.finish);
                            bridge.selectContents(finish);
                        }
                    });
                });
            });
        };
        const mousedown = (event)=>{
            annotations.clear(container);
            findCell(event.target, isRoot).each(cursor.set);
        };
        const mouseover = (event)=>{
            applySelection(event);
        };
        const mouseup = (event)=>{
            applySelection(event);
            clearstate();
        };
        return {
            clearstate,
            mousedown,
            mouseover,
            mouseup
        };
    };
    const down = {
        traverse: nextSibling,
        gather: after$1,
        relative: Situ.before,
        retry: Retries.tryDown,
        failure: BeforeAfter.failedDown
    };
    const up = {
        traverse: prevSibling,
        gather: before1,
        relative: Situ.before,
        retry: Retries.tryUp,
        failure: BeforeAfter.failedUp
    };
    const isKey = (key)=>{
        return (keycode)=>{
            return keycode === key;
        };
    };
    const isUp = isKey(38);
    const isDown = isKey(40);
    const isNavigation = (keycode)=>{
        return keycode >= 37 && keycode <= 40;
    };
    const ltr = {
        isBackward: isKey(37),
        isForward: isKey(39)
    };
    const rtl = {
        isBackward: isKey(39),
        isForward: isKey(37)
    };
    const get$3 = (_DOC)=>{
        const doc = _DOC !== undefined ? _DOC.dom : document;
        const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;
        const y = doc.body.scrollTop || doc.documentElement.scrollTop;
        return SugarPosition(x, y);
    };
    const by = (x, y, _DOC)=>{
        const doc = _DOC !== undefined ? _DOC.dom : document;
        const win = doc.defaultView;
        if (win) win.scrollBy(x, y);
    };
    const adt1 = Adt.generate([
        {
            domRange: [
                'rng'
            ]
        },
        {
            relative: [
                'startSitu',
                'finishSitu'
            ]
        },
        {
            exact: [
                'start',
                'soffset',
                'finish',
                'foffset'
            ]
        }
    ]);
    const exactFromRange = (simRange)=>adt1.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset)
    ;
    const getStart1 = (selection)=>selection.match({
            domRange: (rng)=>SugarElement.fromDom(rng.startContainer)
            ,
            relative: (startSitu, _finishSitu)=>Situ.getStart(startSitu)
            ,
            exact: (start, _soffset, _finish, _foffset)=>start
        })
    ;
    const domRange = adt1.domRange;
    const relative1 = adt1.relative;
    const exact1 = adt1.exact;
    const getWin = (selection)=>{
        const start = getStart1(selection);
        return defaultView(start);
    };
    const range1 = SimRange.create;
    const SimSelection = {
        domRange,
        relative: relative1,
        exact: exact1,
        exactFromRange,
        getWin,
        range: range1
    };
    const caretPositionFromPoint = (doc, x, y)=>{
        var _a, _b;
        return Optional.from((_b = (_a = doc.dom).caretPositionFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y)).bind((pos)=>{
            if (pos.offsetNode === null) return Optional.none();
            const r = doc.dom.createRange();
            r.setStart(pos.offsetNode, pos.offset);
            r.collapse();
            return Optional.some(r);
        });
    };
    const caretRangeFromPoint = (doc, x, y)=>{
        var _a, _b;
        return Optional.from((_b = (_a = doc.dom).caretRangeFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y));
    };
    const availableSearch = (()=>{
        if (document.caretPositionFromPoint) return caretPositionFromPoint;
        else if (document.caretRangeFromPoint) return caretRangeFromPoint;
        else return Optional.none;
    })();
    const fromPoint = (win, x, y)=>{
        const doc = SugarElement.fromDom(win.document);
        return availableSearch(doc, x, y).map((rng)=>SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset)
        );
    };
    const beforeSpecial = (element, offset)=>{
        const name$1 = name1(element);
        if ('input' === name$1) return Situ.after(element);
        else if (!contains$2([
            'br',
            'img'
        ], name$1)) return Situ.on(element, offset);
        else return offset === 0 ? Situ.before(element) : Situ.after(element);
    };
    const preprocessRelative = (startSitu, finishSitu)=>{
        const start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);
        const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);
        return SimSelection.relative(start, finish);
    };
    const preprocessExact = (start, soffset, finish, foffset)=>{
        const startSitu = beforeSpecial(start, soffset);
        const finishSitu = beforeSpecial(finish, foffset);
        return SimSelection.relative(startSitu, finishSitu);
    };
    const makeRange = (start, soffset, finish, foffset)=>{
        const doc = owner(start);
        const rng = doc.dom.createRange();
        rng.setStart(start.dom, soffset);
        rng.setEnd(finish.dom, foffset);
        return rng;
    };
    const after1 = (start, soffset, finish, foffset)=>{
        const r = makeRange(start, soffset, finish, foffset);
        const same = eq$1(start, finish) && soffset === foffset;
        return r.collapsed && !same;
    };
    const getNativeSelection = (win)=>Optional.from(win.getSelection())
    ;
    const doSetNativeRange = (win, rng)=>{
        getNativeSelection(win).each((selection)=>{
            selection.removeAllRanges();
            selection.addRange(rng);
        });
    };
    const doSetRange = (win, start, soffset, finish, foffset)=>{
        const rng = exactToNative(win, start, soffset, finish, foffset);
        doSetNativeRange(win, rng);
    };
    const setLegacyRtlRange = (win, selection, start, soffset, finish, foffset)=>{
        selection.collapse(start.dom, soffset);
        selection.extend(finish.dom, foffset);
    };
    const setRangeFromRelative = (win, relative)=>diagnose(win, relative).match({
            ltr: (start, soffset, finish, foffset)=>{
                doSetRange(win, start, soffset, finish, foffset);
            },
            rtl: (start, soffset, finish, foffset)=>{
                getNativeSelection(win).each((selection)=>{
                    if (selection.setBaseAndExtent) selection.setBaseAndExtent(start.dom, soffset, finish.dom, foffset);
                    else if (selection.extend) try {
                        setLegacyRtlRange(win, selection, start, soffset, finish, foffset);
                    } catch (e) {
                        doSetRange(win, finish, foffset, start, soffset);
                    }
                    else doSetRange(win, finish, foffset, start, soffset);
                });
            }
        })
    ;
    const setExact = (win, start, soffset, finish, foffset)=>{
        const relative = preprocessExact(start, soffset, finish, foffset);
        setRangeFromRelative(win, relative);
    };
    const setRelative = (win, startSitu, finishSitu)=>{
        const relative = preprocessRelative(startSitu, finishSitu);
        setRangeFromRelative(win, relative);
    };
    const readRange = (selection)=>{
        if (selection.rangeCount > 0) {
            const firstRng = selection.getRangeAt(0);
            const lastRng = selection.getRangeAt(selection.rangeCount - 1);
            return Optional.some(SimRange.create(SugarElement.fromDom(firstRng.startContainer), firstRng.startOffset, SugarElement.fromDom(lastRng.endContainer), lastRng.endOffset));
        } else return Optional.none();
    };
    const doGetExact = (selection)=>{
        if (selection.anchorNode === null || selection.focusNode === null) return readRange(selection);
        else {
            const anchor = SugarElement.fromDom(selection.anchorNode);
            const focus = SugarElement.fromDom(selection.focusNode);
            return after1(anchor, selection.anchorOffset, focus, selection.focusOffset) ? Optional.some(SimRange.create(anchor, selection.anchorOffset, focus, selection.focusOffset)) : readRange(selection);
        }
    };
    const setToElement = (win, element, selectNodeContents$1 = true)=>{
        const rngGetter = selectNodeContents$1 ? selectNodeContents : selectNode1;
        const rng = rngGetter(win, element);
        doSetNativeRange(win, rng);
    };
    const getExact = (win)=>getNativeSelection(win).filter((sel)=>sel.rangeCount > 0
        ).bind(doGetExact)
    ;
    const get$2 = (win)=>getExact(win).map((range)=>SimSelection.exact(range.start, range.soffset, range.finish, range.foffset)
        )
    ;
    const getFirstRect = (win, selection)=>{
        const rng = asLtrRange(win, selection);
        return getFirstRect$1(rng);
    };
    const getAtPoint = (win, x, y)=>fromPoint(win, x, y)
    ;
    const clear1 = (win)=>{
        getNativeSelection(win).each((selection)=>selection.removeAllRanges()
        );
    };
    const WindowBridge = (win)=>{
        const elementFromPoint = (x, y)=>{
            return SugarElement.fromPoint(SugarElement.fromDom(win.document), x, y);
        };
        const getRect = (element)=>{
            return element.dom.getBoundingClientRect();
        };
        const getRangedRect = (start, soffset, finish, foffset)=>{
            const sel = SimSelection.exact(start, soffset, finish, foffset);
            return getFirstRect(win, sel);
        };
        const getSelection = ()=>{
            return get$2(win).map((exactAdt)=>{
                return convertToRange(win, exactAdt);
            });
        };
        const fromSitus = (situs)=>{
            const relative = SimSelection.relative(situs.start, situs.finish);
            return convertToRange(win, relative);
        };
        const situsFromPoint = (x, y)=>{
            return getAtPoint(win, x, y).map((exact)=>{
                return Situs.create(exact.start, exact.soffset, exact.finish, exact.foffset);
            });
        };
        const clearSelection = ()=>{
            clear1(win);
        };
        const collapseSelection = (toStart = false)=>{
            get$2(win).each((sel)=>sel.fold((rng)=>rng.collapse(toStart)
                , (startSitu, finishSitu)=>{
                    const situ = toStart ? startSitu : finishSitu;
                    setRelative(win, situ, situ);
                }, (start, soffset, finish, foffset)=>{
                    const node = toStart ? start : finish;
                    const offset = toStart ? soffset : foffset;
                    setExact(win, node, offset, node, offset);
                })
            );
        };
        const selectNode = (element)=>{
            setToElement(win, element, false);
        };
        const selectContents = (element)=>{
            setToElement(win, element);
        };
        const setSelection = (sel)=>{
            setExact(win, sel.start, sel.soffset, sel.finish, sel.foffset);
        };
        const setRelativeSelection = (start, finish)=>{
            setRelative(win, start, finish);
        };
        const getInnerHeight = ()=>{
            return win.innerHeight;
        };
        const getScrollY = ()=>{
            const pos = get$3(SugarElement.fromDom(win.document));
            return pos.top;
        };
        const scrollBy = (x, y)=>{
            by(x, y, SugarElement.fromDom(win.document));
        };
        return {
            elementFromPoint,
            getRect,
            getRangedRect,
            getSelection,
            fromSitus,
            situsFromPoint,
            clearSelection,
            collapseSelection,
            setSelection,
            setRelativeSelection,
            selectNode,
            selectContents,
            getInnerHeight,
            getScrollY,
            scrollBy
        };
    };
    const rc = (rows, cols)=>({
            rows,
            cols
        })
    ;
    const mouse = (win, container, isRoot, annotations)=>{
        const bridge = WindowBridge(win);
        const handlers = MouseSelection(bridge, container, isRoot, annotations);
        return {
            clearstate: handlers.clearstate,
            mousedown: handlers.mousedown,
            mouseover: handlers.mouseover,
            mouseup: handlers.mouseup
        };
    };
    const keyboard = (win, container, isRoot, annotations)=>{
        const bridge = WindowBridge(win);
        const clearToNavigate = ()=>{
            annotations.clear(container);
            return Optional.none();
        };
        const keydown = (event, start, soffset, finish, foffset, direction)=>{
            const realEvent = event.raw;
            const keycode = realEvent.which;
            const shiftKey = realEvent.shiftKey === true;
            const handler = retrieve$1(container, annotations.selectedSelector).fold(()=>{
                if (isNavigation(keycode) && !shiftKey) annotations.clearBeforeUpdate(container);
                if (isDown(keycode) && shiftKey) return curry(select, bridge, container, isRoot, down, finish, start, annotations.selectRange);
                else if (isUp(keycode) && shiftKey) return curry(select, bridge, container, isRoot, up, finish, start, annotations.selectRange);
                else if (isDown(keycode)) return curry(navigate, bridge, isRoot, down, finish, start, lastDownCheck);
                else if (isUp(keycode)) return curry(navigate, bridge, isRoot, up, finish, start, firstUpCheck);
                else return Optional.none;
            }, (selected)=>{
                const update$1 = (attempts)=>{
                    return ()=>{
                        const navigation = findMap(attempts, (delta)=>{
                            return update1(delta.rows, delta.cols, container, selected, annotations);
                        });
                        return navigation.fold(()=>{
                            return getEdges(container, annotations.firstSelectedSelector, annotations.lastSelectedSelector).map((edges)=>{
                                const relative = isDown(keycode) || direction.isForward(keycode) ? Situ.after : Situ.before;
                                bridge.setRelativeSelection(Situ.on(edges.first, 0), relative(edges.table));
                                annotations.clear(container);
                                return Response.create(Optional.none(), true);
                            });
                        }, (_)=>{
                            return Optional.some(Response.create(Optional.none(), true));
                        });
                    };
                };
                if (isDown(keycode) && shiftKey) return update$1([
                    rc(1, 0)
                ]);
                else if (isUp(keycode) && shiftKey) return update$1([
                    rc(-1, 0)
                ]);
                else if (direction.isBackward(keycode) && shiftKey) return update$1([
                    rc(0, -1),
                    rc(-1, 0)
                ]);
                else if (direction.isForward(keycode) && shiftKey) return update$1([
                    rc(0, 1),
                    rc(1, 0)
                ]);
                else if (isNavigation(keycode) && !shiftKey) return clearToNavigate;
                else return Optional.none;
            });
            return handler();
        };
        const keyup = (event, start, soffset, finish, foffset)=>{
            return retrieve$1(container, annotations.selectedSelector).fold(()=>{
                const realEvent = event.raw;
                const keycode = realEvent.which;
                const shiftKey = realEvent.shiftKey === true;
                if (!shiftKey) return Optional.none();
                if (isNavigation(keycode)) return sync1(container, isRoot, start, soffset, finish, foffset, annotations.selectRange);
                else return Optional.none();
            }, Optional.none);
        };
        return {
            keydown,
            keyup
        };
    };
    const external = (win, container, isRoot, annotations)=>{
        const bridge = WindowBridge(win);
        return (start, finish)=>{
            annotations.clearBeforeUpdate(container);
            identify(start, finish, isRoot).each((cellSel)=>{
                const boxes = cellSel.boxes.getOr([]);
                annotations.selectRange(container, boxes, cellSel.start, cellSel.finish);
                bridge.selectContents(finish);
                bridge.collapseSelection();
            });
        };
    };
    const read = (element, attr)=>{
        const value = get$b(element, attr);
        return value === undefined || value === '' ? [] : value.split(' ');
    };
    const add$2 = (element, attr, id)=>{
        const old = read(element, attr);
        const nu = old.concat([
            id
        ]);
        set$2(element, attr, nu.join(' '));
        return true;
    };
    const remove$4 = (element, attr, id)=>{
        const nu = filter$2(read(element, attr), (v)=>v !== id
        );
        if (nu.length > 0) set$2(element, attr, nu.join(' '));
        else remove$7(element, attr);
        return false;
    };
    const supports = (element)=>element.dom.classList !== undefined
    ;
    const get$1 = (element)=>read(element, 'class')
    ;
    const add$1 = (element, clazz)=>add$2(element, 'class', clazz)
    ;
    const remove$3 = (element, clazz)=>remove$4(element, 'class', clazz)
    ;
    const add1 = (element, clazz)=>{
        if (supports(element)) element.dom.classList.add(clazz);
        else add$1(element, clazz);
    };
    const cleanClass = (element)=>{
        const classList = supports(element) ? element.dom.classList : get$1(element);
        if (classList.length === 0) remove$7(element, 'class');
    };
    const remove$2 = (element, clazz)=>{
        if (supports(element)) {
            const classList = element.dom.classList;
            classList.remove(clazz);
        } else remove$3(element, clazz);
        cleanClass(element);
    };
    const has = (element, clazz)=>supports(element) && element.dom.classList.contains(clazz)
    ;
    const remove$1 = (element, classes)=>{
        each$2(classes, (x)=>{
            remove$2(element, x);
        });
    };
    const addClass = (clazz)=>(element)=>{
            add1(element, clazz);
        }
    ;
    const removeClasses = (classes)=>(element)=>{
            remove$1(element, classes);
        }
    ;
    const byClass = (ephemera)=>{
        const addSelectionClass = addClass(ephemera.selected);
        const removeSelectionClasses = removeClasses([
            ephemera.selected,
            ephemera.lastSelected,
            ephemera.firstSelected
        ]);
        const clear = (container)=>{
            const sels = descendants(container, ephemera.selectedSelector);
            each$2(sels, removeSelectionClasses);
        };
        const selectRange = (container, cells, start, finish)=>{
            clear(container);
            each$2(cells, addSelectionClass);
            add1(start, ephemera.firstSelected);
            add1(finish, ephemera.lastSelected);
        };
        return {
            clearBeforeUpdate: clear,
            clear,
            selectRange,
            selectedSelector: ephemera.selectedSelector,
            firstSelectedSelector: ephemera.firstSelectedSelector,
            lastSelectedSelector: ephemera.lastSelectedSelector
        };
    };
    const byAttr = (ephemera, onSelection, onClear)=>{
        const removeSelectionAttributes = (element)=>{
            remove$7(element, ephemera.selected);
            remove$7(element, ephemera.firstSelected);
            remove$7(element, ephemera.lastSelected);
        };
        const addSelectionAttribute = (element)=>{
            set$2(element, ephemera.selected, '1');
        };
        const clear = (container)=>{
            clearBeforeUpdate(container);
            onClear();
        };
        const clearBeforeUpdate = (container)=>{
            const sels = descendants(container, `${ephemera.selectedSelector},${ephemera.firstSelectedSelector},${ephemera.lastSelectedSelector}`);
            each$2(sels, removeSelectionAttributes);
        };
        const selectRange = (container, cells, start, finish)=>{
            clear(container);
            each$2(cells, addSelectionAttribute);
            set$2(start, ephemera.firstSelected, '1');
            set$2(finish, ephemera.lastSelected, '1');
            onSelection(cells, start, finish);
        };
        return {
            clearBeforeUpdate,
            clear,
            selectRange,
            selectedSelector: ephemera.selectedSelector,
            firstSelectedSelector: ephemera.firstSelectedSelector,
            lastSelectedSelector: ephemera.lastSelectedSelector
        };
    };
    const SelectionAnnotation = {
        byClass,
        byAttr
    };
    const fold = (subject, onNone, onMultiple, onSingle)=>{
        switch(subject.tag){
            case 'none':
                return onNone();
            case 'single':
                return onSingle(subject.element);
            case 'multiple':
                return onMultiple(subject.elements);
        }
    };
    const none = ()=>({
            tag: 'none'
        })
    ;
    const multiple = (elements)=>({
            tag: 'multiple',
            elements
        })
    ;
    const single = (element)=>({
            tag: 'single',
            element
        })
    ;
    const Selections = (lazyRoot, getStart, selectedSelector)=>{
        const get = ()=>retrieve(lazyRoot(), selectedSelector).fold(()=>getStart().fold(none, single)
            , multiple)
        ;
        return {
            get
        };
    };
    const getUpOrLeftCells = (grid, selectedCells)=>{
        const upGrid = grid.slice(0, selectedCells[selectedCells.length - 1].row + 1);
        const upDetails = toDetailList(upGrid);
        return bind$2(upDetails, (detail)=>{
            const slicedCells = detail.cells.slice(0, selectedCells[selectedCells.length - 1].column + 1);
            return map$1(slicedCells, (cell)=>cell.element
            );
        });
    };
    const getDownOrRightCells = (grid, selectedCells)=>{
        const downGrid = grid.slice(selectedCells[0].row + selectedCells[0].rowspan - 1, grid.length);
        const downDetails = toDetailList(downGrid);
        return bind$2(downDetails, (detail)=>{
            const slicedCells = detail.cells.slice(selectedCells[0].column + selectedCells[0].colspan - 1, detail.cells.length);
            return map$1(slicedCells, (cell)=>cell.element
            );
        });
    };
    const getOtherCells = (table, target, generators)=>{
        const warehouse = Warehouse.fromTable(table);
        const details = onCells(warehouse, target);
        return details.map((selectedCells)=>{
            const grid = toGrid(warehouse, generators, false);
            const { rows  } = extractGridDetails(grid);
            const upOrLeftCells = getUpOrLeftCells(rows, selectedCells);
            const downOrRightCells = getDownOrRightCells(rows, selectedCells);
            return {
                upOrLeftCells,
                downOrRightCells
            };
        });
    };
    const mkEvent = (target, x, y, stop, prevent, kill, raw)=>({
            target,
            x,
            y,
            stop,
            prevent,
            kill,
            raw
        })
    ;
    const fromRawEvent$1 = (rawEvent)=>{
        const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));
        const stop = ()=>rawEvent.stopPropagation()
        ;
        const prevent = ()=>rawEvent.preventDefault()
        ;
        const kill = compose(prevent, stop);
        return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);
    };
    const handle = (filter, handler)=>(rawEvent)=>{
            if (filter(rawEvent)) handler(fromRawEvent$1(rawEvent));
        }
    ;
    const binder1 = (element, event, filter, handler, useCapture)=>{
        const wrapped = handle(filter, handler);
        element.dom.addEventListener(event, wrapped, useCapture);
        return {
            unbind: curry(unbind1, element, event, wrapped, useCapture)
        };
    };
    const bind$1 = (element, event, filter, handler)=>binder1(element, event, filter, handler, false)
    ;
    const unbind1 = (element, event, handler, useCapture)=>{
        element.dom.removeEventListener(event, handler, useCapture);
    };
    const filter1 = always;
    const bind1 = (element, event, handler)=>bind$1(element, event, filter1, handler)
    ;
    const fromRawEvent = fromRawEvent$1;
    const hasInternalTarget = (e)=>has(SugarElement.fromDom(e.target), 'ephox-snooker-resizer-bar') === false
    ;
    const TableCellSelectionHandler = (editor, resizeHandler)=>{
        const cellSelection = Selections(()=>SugarElement.fromDom(editor.getBody())
        , ()=>getSelectionCell(getSelectionStart(editor), getIsRoot1(editor))
        , ephemera1.selectedSelector);
        const onSelection = (cells, start, finish)=>{
            const tableOpt = table1(start);
            tableOpt.each((table)=>{
                const cloneFormats = getTableCloneElements(editor);
                const generators = cellOperations(noop, SugarElement.fromDom(editor.getDoc()), cloneFormats);
                const selectedCells = getCellsFromSelection(editor);
                const otherCells = getOtherCells(table, {
                    selection: selectedCells
                }, generators);
                fireTableSelectionChange(editor, cells, start, finish, otherCells);
            });
        };
        const onClear = ()=>fireTableSelectionClear(editor)
        ;
        const annotations = SelectionAnnotation.byAttr(ephemera1, onSelection, onClear);
        editor.on('init', (_e)=>{
            const win = editor.getWin();
            const body = getBody(editor);
            const isRoot = getIsRoot1(editor);
            const syncSelection = ()=>{
                const sel = editor.selection;
                const start = SugarElement.fromDom(sel.getStart());
                const end = SugarElement.fromDom(sel.getEnd());
                const shared = sharedOne(table1, [
                    start,
                    end
                ]);
                shared.fold(()=>annotations.clear(body)
                , noop);
            };
            const mouseHandlers = mouse(win, body, isRoot, annotations);
            const keyHandlers = keyboard(win, body, isRoot, annotations);
            const external$1 = external(win, body, isRoot, annotations);
            const hasShiftKey = (event)=>event.raw.shiftKey === true
            ;
            editor.on('TableSelectorChange', (e)=>external$1(e.start, e.finish)
            );
            const handleResponse = (event, response)=>{
                if (!hasShiftKey(event)) return;
                if (response.kill) event.kill();
                response.selection.each((ns)=>{
                    const relative = SimSelection.relative(ns.start, ns.finish);
                    const rng = asLtrRange(win, relative);
                    editor.selection.setRng(rng);
                });
            };
            const keyup = (event)=>{
                const wrappedEvent = fromRawEvent(event);
                if (wrappedEvent.raw.shiftKey && isNavigation(wrappedEvent.raw.which)) {
                    const rng = editor.selection.getRng();
                    const start = SugarElement.fromDom(rng.startContainer);
                    const end = SugarElement.fromDom(rng.endContainer);
                    keyHandlers.keyup(wrappedEvent, start, rng.startOffset, end, rng.endOffset).each((response)=>{
                        handleResponse(wrappedEvent, response);
                    });
                }
            };
            const keydown = (event)=>{
                const wrappedEvent = fromRawEvent(event);
                resizeHandler.hide();
                const rng = editor.selection.getRng();
                const start = SugarElement.fromDom(rng.startContainer);
                const end = SugarElement.fromDom(rng.endContainer);
                const direction = onDirection(ltr, rtl)(SugarElement.fromDom(editor.selection.getStart()));
                keyHandlers.keydown(wrappedEvent, start, rng.startOffset, end, rng.endOffset, direction).each((response)=>{
                    handleResponse(wrappedEvent, response);
                });
                resizeHandler.show();
            };
            const isLeftMouse = (raw)=>raw.button === 0
            ;
            const isLeftButtonPressed = (raw)=>{
                if (raw.buttons === undefined) return true;
                return (raw.buttons & 1) !== 0;
            };
            const dragStart = (_e)=>{
                mouseHandlers.clearstate();
            };
            const mouseDown = (e)=>{
                if (isLeftMouse(e) && hasInternalTarget(e)) mouseHandlers.mousedown(fromRawEvent(e));
            };
            const mouseOver = (e)=>{
                if (isLeftButtonPressed(e) && hasInternalTarget(e)) mouseHandlers.mouseover(fromRawEvent(e));
            };
            const mouseUp = (e)=>{
                if (isLeftMouse(e) && hasInternalTarget(e)) mouseHandlers.mouseup(fromRawEvent(e));
            };
            const getDoubleTap = ()=>{
                const lastTarget = Cell(SugarElement.fromDom(body));
                const lastTimeStamp = Cell(0);
                const touchEnd = (t)=>{
                    const target = SugarElement.fromDom(t.target);
                    if (isTag('td')(target) || isTag('th')(target)) {
                        const lT = lastTarget.get();
                        const lTS = lastTimeStamp.get();
                        if (eq$1(lT, target) && t.timeStamp - lTS < 300) {
                            t.preventDefault();
                            external$1(target, target);
                        }
                    }
                    lastTarget.set(target);
                    lastTimeStamp.set(t.timeStamp);
                };
                return {
                    touchEnd
                };
            };
            const doubleTap = getDoubleTap();
            editor.on('dragstart', dragStart);
            editor.on('mousedown', mouseDown);
            editor.on('mouseover', mouseOver);
            editor.on('mouseup', mouseUp);
            editor.on('touchend', doubleTap.touchEnd);
            editor.on('keyup', keyup);
            editor.on('keydown', keydown);
            editor.on('NodeChange', syncSelection);
        });
        editor.on('PreInit', ()=>{
            editor.serializer.addTempAttr(ephemera1.firstSelected);
            editor.serializer.addTempAttr(ephemera1.lastSelected);
        });
        const clearSelectedCells = (container)=>annotations.clear(SugarElement.fromDom(container))
        ;
        const getSelectedCells = ()=>fold(cellSelection.get(), constant([]), (cells)=>{
                return map$1(cells, (cell)=>cell.dom
                );
            }, (cell)=>[
                    cell.dom
                ]
            )
        ;
        return {
            getSelectedCells,
            clearSelectedCells
        };
    };
    const Event = (fields)=>{
        let handlers = [];
        const bind = (handler)=>{
            if (handler === undefined) throw new Error('Event bind error: undefined handler');
            handlers.push(handler);
        };
        const unbind = (handler)=>{
            handlers = filter$2(handlers, (h)=>{
                return h !== handler;
            });
        };
        const trigger = (...args)=>{
            const event = {};
            each$2(fields, (name, i)=>{
                event[name] = args[i];
            });
            each$2(handlers, (handler)=>{
                handler(event);
            });
        };
        return {
            bind,
            unbind,
            trigger
        };
    };
    const create$1 = (typeDefs)=>{
        const registry = map(typeDefs, (event)=>{
            return {
                bind: event.bind,
                unbind: event.unbind
            };
        });
        const trigger = map(typeDefs, (event)=>{
            return event.trigger;
        });
        return {
            registry,
            trigger
        };
    };
    const last1 = (fn, rate)=>{
        let timer = null;
        const cancel = ()=>{
            if (!isNull(timer)) {
                clearTimeout(timer);
                timer = null;
            }
        };
        const throttle = (...args)=>{
            cancel();
            timer = setTimeout(()=>{
                timer = null;
                fn.apply(null, args);
            }, rate);
        };
        return {
            cancel,
            throttle
        };
    };
    const sort = (arr)=>{
        return arr.slice(0).sort();
    };
    const reqMessage = (required, keys)=>{
        throw new Error('All required keys (' + sort(required).join(', ') + ') were not specified. Specified keys were: ' + sort(keys).join(', ') + '.');
    };
    const unsuppMessage = (unsupported)=>{
        throw new Error('Unsupported keys for object: ' + sort(unsupported).join(', '));
    };
    const validateStrArr = (label, array)=>{
        if (!isArray(array)) throw new Error('The ' + label + ' fields must be an array. Was: ' + array + '.');
        each$2(array, (a)=>{
            if (!isString(a)) throw new Error('The value ' + a + ' in the ' + label + ' fields was not a string.');
        });
    };
    const invalidTypeMessage = (incorrect, type)=>{
        throw new Error('All values need to be of type: ' + type + '. Keys (' + sort(incorrect).join(', ') + ') were not.');
    };
    const checkDupes = (everything)=>{
        const sorted = sort(everything);
        const dupe = find$1(sorted, (s, i)=>{
            return i < sorted.length - 1 && s === sorted[i + 1];
        });
        dupe.each((d)=>{
            throw new Error('The field: ' + d + ' occurs more than once in the combined fields: [' + sorted.join(', ') + '].');
        });
    };
    const base1 = (handleUnsupported, required)=>{
        return baseWith(handleUnsupported, required, {
            validate: isFunction,
            label: 'function'
        });
    };
    const baseWith = (handleUnsupported, required, pred)=>{
        if (required.length === 0) throw new Error('You must specify at least one required field.');
        validateStrArr('required', required);
        checkDupes(required);
        return (obj)=>{
            const keys$1 = keys1(obj);
            const allReqd = forall(required, (req)=>{
                return contains$2(keys$1, req);
            });
            if (!allReqd) reqMessage(required, keys$1);
            handleUnsupported(required, keys$1);
            const invalidKeys = filter$2(required, (key)=>{
                return !pred.validate(obj[key], key);
            });
            if (invalidKeys.length > 0) invalidTypeMessage(invalidKeys, pred.label);
            return obj;
        };
    };
    const handleExact = (required, keys)=>{
        const unsupported = filter$2(keys, (key)=>{
            return !contains$2(required, key);
        });
        if (unsupported.length > 0) unsuppMessage(unsupported);
    };
    const exactly = (required)=>base1(handleExact, required)
    ;
    const DragMode = exactly([
        'compare',
        'extract',
        'mutate',
        'sink'
    ]);
    const DragSink = exactly([
        'element',
        'start',
        'stop',
        'destroy'
    ]);
    const DragApi = exactly([
        'forceDrop',
        'drop',
        'move',
        'delayDrop'
    ]);
    const InDrag = ()=>{
        let previous = Optional.none();
        const reset = ()=>{
            previous = Optional.none();
        };
        const update = (mode, nu)=>{
            const result = previous.map((old)=>{
                return mode.compare(old, nu);
            });
            previous = Optional.some(nu);
            return result;
        };
        const onEvent = (event, mode)=>{
            const dataOption = mode.extract(event);
            dataOption.each((data)=>{
                const offset = update(mode, data);
                offset.each((d)=>{
                    events.trigger.move(d);
                });
            });
        };
        const events = create$1({
            move: Event([
                'info'
            ])
        });
        return {
            onEvent,
            reset,
            events: events.registry
        };
    };
    const NoDrag = ()=>{
        const events = create$1({
            move: Event([
                'info'
            ])
        });
        return {
            onEvent: noop,
            reset: noop,
            events: events.registry
        };
    };
    const Movement = ()=>{
        const noDragState = NoDrag();
        const inDragState = InDrag();
        let dragState = noDragState;
        const on = ()=>{
            dragState.reset();
            dragState = inDragState;
        };
        const off = ()=>{
            dragState.reset();
            dragState = noDragState;
        };
        const onEvent = (event, mode)=>{
            dragState.onEvent(event, mode);
        };
        const isOn = ()=>{
            return dragState === inDragState;
        };
        return {
            on,
            off,
            isOn,
            onEvent,
            events: inDragState.events
        };
    };
    const setup = (mutation, mode, settings)=>{
        let active = false;
        const events = create$1({
            start: Event([]),
            stop: Event([])
        });
        const movement = Movement();
        const drop = ()=>{
            sink.stop();
            if (movement.isOn()) {
                movement.off();
                events.trigger.stop();
            }
        };
        const throttledDrop = last1(drop, 200);
        const go = (parent)=>{
            sink.start(parent);
            movement.on();
            events.trigger.start();
        };
        const mousemove = (event)=>{
            throttledDrop.cancel();
            movement.onEvent(event, mode);
        };
        movement.events.move.bind((event)=>{
            mode.mutate(mutation, event.info);
        });
        const on = ()=>{
            active = true;
        };
        const off = ()=>{
            active = false;
        };
        const runIfActive = (f)=>{
            return (...args)=>{
                if (active) f.apply(null, args);
            };
        };
        const sink = mode.sink(DragApi({
            forceDrop: drop,
            drop: runIfActive(drop),
            move: runIfActive(mousemove),
            delayDrop: runIfActive(throttledDrop.throttle)
        }), settings);
        const destroy = ()=>{
            sink.destroy();
        };
        return {
            element: sink.element,
            go,
            on,
            off,
            destroy,
            events: events.registry
        };
    };
    const css1 = (namespace)=>{
        const dashNamespace = namespace.replace(/\./g, '-');
        const resolve = (str)=>{
            return dashNamespace + '-' + str;
        };
        return {
            resolve
        };
    };
    const styles$1 = css1('ephox-dragster');
    const resolve$1 = styles$1.resolve;
    const Blocker = (options)=>{
        const settings = {
            layerClass: resolve$1('blocker'),
            ...options
        };
        const div = SugarElement.fromTag('div');
        set$2(div, 'role', 'presentation');
        setAll(div, {
            position: 'fixed',
            left: '0px',
            top: '0px',
            width: '100%',
            height: '100%'
        });
        add1(div, resolve$1('blocker'));
        add1(div, settings.layerClass);
        const element = constant(div);
        const destroy = ()=>{
            remove$6(div);
        };
        return {
            element,
            destroy
        };
    };
    const compare = (old, nu)=>{
        return SugarPosition(nu.left - old.left, nu.top - old.top);
    };
    const extract1 = (event)=>{
        return Optional.some(SugarPosition(event.x, event.y));
    };
    const mutate1 = (mutation, info)=>{
        mutation.mutate(info.left, info.top);
    };
    const sink1 = (dragApi, settings)=>{
        const blocker = Blocker(settings);
        const mdown = bind1(blocker.element(), 'mousedown', dragApi.forceDrop);
        const mup = bind1(blocker.element(), 'mouseup', dragApi.drop);
        const mmove = bind1(blocker.element(), 'mousemove', dragApi.move);
        const mout = bind1(blocker.element(), 'mouseout', dragApi.delayDrop);
        const destroy = ()=>{
            blocker.destroy();
            mup.unbind();
            mmove.unbind();
            mout.unbind();
            mdown.unbind();
        };
        const start = (parent)=>{
            append$1(parent, blocker.element());
        };
        const stop = ()=>{
            remove$6(blocker.element());
        };
        return DragSink({
            element: blocker.element,
            start,
            stop,
            destroy
        });
    };
    var MouseDrag = DragMode({
        compare,
        extract: extract1,
        sink: sink1,
        mutate: mutate1
    });
    const transform = (mutation, settings = {})=>{
        var _a;
        const mode = (_a = settings.mode) !== null && _a !== void 0 ? _a : MouseDrag;
        return setup(mutation, mode, settings);
    };
    const styles1 = css1('ephox-snooker');
    const resolve1 = styles1.resolve;
    const Mutation = ()=>{
        const events = create$1({
            drag: Event([
                'xDelta',
                'yDelta'
            ])
        });
        const mutate = (x, y)=>{
            events.trigger.drag(x, y);
        };
        return {
            mutate,
            events: events.registry
        };
    };
    const BarMutation = ()=>{
        const events = create$1({
            drag: Event([
                'xDelta',
                'yDelta',
                'target'
            ])
        });
        let target = Optional.none();
        const delegate = Mutation();
        delegate.events.drag.bind((event)=>{
            target.each((t)=>{
                events.trigger.drag(event.xDelta, event.yDelta, t);
            });
        });
        const assign = (t)=>{
            target = Optional.some(t);
        };
        const get = ()=>{
            return target;
        };
        return {
            assign,
            get,
            mutate: delegate.mutate,
            events: events.registry
        };
    };
    const col1 = (column, x, y, w, h)=>{
        const bar = SugarElement.fromTag('div');
        setAll(bar, {
            position: 'absolute',
            left: x - w / 2 + 'px',
            top: y + 'px',
            height: h + 'px',
            width: w + 'px'
        });
        setAll$1(bar, {
            'data-column': column,
            'role': 'presentation'
        });
        return bar;
    };
    const row1 = (r, x, y, w, h)=>{
        const bar = SugarElement.fromTag('div');
        setAll(bar, {
            position: 'absolute',
            left: x + 'px',
            top: y - h / 2 + 'px',
            height: h + 'px',
            width: w + 'px'
        });
        setAll$1(bar, {
            'data-row': r,
            'role': 'presentation'
        });
        return bar;
    };
    const resizeBar = resolve1('resizer-bar');
    const resizeRowBar = resolve1('resizer-rows');
    const resizeColBar = resolve1('resizer-cols');
    const BAR_THICKNESS = 7;
    const resizableRows = (warehouse, isResizable)=>bind$2(warehouse.all, (row, i)=>isResizable(row.element) ? [
                i
            ] : []
        )
    ;
    const resizableColumns = (warehouse, isResizable)=>{
        const resizableCols = [];
        range$1(warehouse.grid.columns, (index)=>{
            const colElmOpt = Warehouse.getColumnAt(warehouse, index).map((col)=>col.element
            );
            if (colElmOpt.forall(isResizable)) resizableCols.push(index);
        });
        return filter$2(resizableCols, (colIndex)=>{
            const columnCells = Warehouse.filterItems(warehouse, (cell)=>cell.column === colIndex
            );
            return forall(columnCells, (cell)=>isResizable(cell.element)
            );
        });
    };
    const destroy1 = (wire)=>{
        const previous = descendants(wire.parent(), '.' + resizeBar);
        each$2(previous, remove$6);
    };
    const drawBar = (wire, positions, create)=>{
        const origin = wire.origin();
        each$2(positions, (cpOption)=>{
            cpOption.each((cp)=>{
                const bar = create(origin, cp);
                add1(bar, resizeBar);
                append$1(wire.parent(), bar);
            });
        });
    };
    const refreshCol = (wire, colPositions, position, tableHeight)=>{
        drawBar(wire, colPositions, (origin, cp)=>{
            const colBar = col1(cp.col, cp.x - origin.left, position.top - origin.top, BAR_THICKNESS, tableHeight);
            add1(colBar, resizeColBar);
            return colBar;
        });
    };
    const refreshRow = (wire, rowPositions, position, tableWidth)=>{
        drawBar(wire, rowPositions, (origin, cp)=>{
            const rowBar = row1(cp.row, position.left - origin.left, cp.y - origin.top, tableWidth, BAR_THICKNESS);
            add1(rowBar, resizeRowBar);
            return rowBar;
        });
    };
    const refreshGrid = (warhouse, wire, table, rows, cols)=>{
        const position = absolute(table);
        const isResizable = wire.isResizable;
        const rowPositions = rows.length > 0 ? height1.positions(rows, table) : [];
        const resizableRowBars = rowPositions.length > 0 ? resizableRows(warhouse, isResizable) : [];
        const resizableRowPositions = filter$2(rowPositions, (_pos, i)=>exists(resizableRowBars, (barIndex)=>i === barIndex
            )
        );
        refreshRow(wire, resizableRowPositions, position, getOuter$2(table));
        const colPositions = cols.length > 0 ? width1.positions(cols, table) : [];
        const resizableColBars = colPositions.length > 0 ? resizableColumns(warhouse, isResizable) : [];
        const resizableColPositions = filter$2(colPositions, (_pos, i)=>exists(resizableColBars, (barIndex)=>i === barIndex
            )
        );
        refreshCol(wire, resizableColPositions, position, getOuter$1(table));
    };
    const refresh1 = (wire, table)=>{
        destroy1(wire);
        if (wire.isResizable(table)) {
            const warehouse = Warehouse.fromTable(table);
            const rows$1 = rows1(warehouse);
            const cols = columns1(warehouse);
            refreshGrid(warehouse, wire, table, rows$1, cols);
        }
    };
    const each = (wire, f)=>{
        const bars = descendants(wire.parent(), '.' + resizeBar);
        each$2(bars, f);
    };
    const hide1 = (wire)=>{
        each(wire, (bar)=>{
            set$1(bar, 'display', 'none');
        });
    };
    const show1 = (wire)=>{
        each(wire, (bar)=>{
            set$1(bar, 'display', 'block');
        });
    };
    const isRowBar = (element)=>{
        return has(element, resizeRowBar);
    };
    const isColBar = (element)=>{
        return has(element, resizeColBar);
    };
    const resizeBarDragging = resolve1('resizer-bar-dragging');
    const BarManager = (wire)=>{
        const mutation = BarMutation();
        const resizing = transform(mutation, {});
        let hoverTable = Optional.none();
        const getResizer = (element, type)=>{
            return Optional.from(get$b(element, type));
        };
        mutation.events.drag.bind((event)=>{
            getResizer(event.target, 'data-row').each((_dataRow)=>{
                const currentRow = getCssValue(event.target, 'top');
                set$1(event.target, 'top', currentRow + event.yDelta + 'px');
            });
            getResizer(event.target, 'data-column').each((_dataCol)=>{
                const currentCol = getCssValue(event.target, 'left');
                set$1(event.target, 'left', currentCol + event.xDelta + 'px');
            });
        });
        const getDelta = (target, dir)=>{
            const newX = getCssValue(target, dir);
            const oldX = getAttrValue(target, 'data-initial-' + dir, 0);
            return newX - oldX;
        };
        resizing.events.stop.bind(()=>{
            mutation.get().each((target)=>{
                hoverTable.each((table)=>{
                    getResizer(target, 'data-row').each((row)=>{
                        const delta = getDelta(target, 'top');
                        remove$7(target, 'data-initial-top');
                        events.trigger.adjustHeight(table, delta, parseInt(row, 10));
                    });
                    getResizer(target, 'data-column').each((column)=>{
                        const delta = getDelta(target, 'left');
                        remove$7(target, 'data-initial-left');
                        events.trigger.adjustWidth(table, delta, parseInt(column, 10));
                    });
                    refresh1(wire, table);
                });
            });
        });
        const handler = (target, dir)=>{
            events.trigger.startAdjust();
            mutation.assign(target);
            set$2(target, 'data-initial-' + dir, getCssValue(target, dir));
            add1(target, resizeBarDragging);
            set$1(target, 'opacity', '0.2');
            resizing.go(wire.parent());
        };
        const mousedown = bind1(wire.parent(), 'mousedown', (event)=>{
            if (isRowBar(event.target)) handler(event.target, 'top');
            if (isColBar(event.target)) handler(event.target, 'left');
        });
        const isRoot = (e)=>{
            return eq$1(e, wire.view());
        };
        const findClosestEditableTable = (target)=>closest$1(target, 'table', isRoot).filter(isEditable$1)
        ;
        const mouseover = bind1(wire.view(), 'mouseover', (event)=>{
            findClosestEditableTable(event.target).fold(()=>{
                if (inBody(event.target)) destroy1(wire);
            }, (table)=>{
                hoverTable = Optional.some(table);
                refresh1(wire, table);
            });
        });
        const destroy$1 = ()=>{
            mousedown.unbind();
            mouseover.unbind();
            resizing.destroy();
            destroy1(wire);
        };
        const refresh$1 = (tbl)=>{
            refresh1(wire, tbl);
        };
        const events = create$1({
            adjustHeight: Event([
                'table',
                'delta',
                'row'
            ]),
            adjustWidth: Event([
                'table',
                'delta',
                'column'
            ]),
            startAdjust: Event([])
        });
        return {
            destroy: destroy$1,
            refresh: refresh$1,
            on: resizing.on,
            off: resizing.off,
            hideBars: curry(hide1, wire),
            showBars: curry(show1, wire),
            events: events.registry
        };
    };
    const create1 = (wire, resizing, lazySizing)=>{
        const hdirection = height1;
        const vdirection = width1;
        const manager = BarManager(wire);
        const events = create$1({
            beforeResize: Event([
                'table',
                'type'
            ]),
            afterResize: Event([
                'table',
                'type'
            ]),
            startDrag: Event([])
        });
        manager.events.adjustHeight.bind((event)=>{
            const table = event.table;
            events.trigger.beforeResize(table, 'row');
            const delta = hdirection.delta(event.delta, table);
            adjustHeight(table, delta, event.row, hdirection);
            events.trigger.afterResize(table, 'row');
        });
        manager.events.startAdjust.bind((_event)=>{
            events.trigger.startDrag();
        });
        manager.events.adjustWidth.bind((event)=>{
            const table = event.table;
            events.trigger.beforeResize(table, 'col');
            const delta = vdirection.delta(event.delta, table);
            const tableSize = lazySizing(table);
            adjustWidth(table, delta, event.column, resizing, tableSize);
            events.trigger.afterResize(table, 'col');
        });
        return {
            on: manager.on,
            off: manager.off,
            refreshBars: manager.refresh,
            hideBars: manager.hideBars,
            showBars: manager.showBars,
            destroy: manager.destroy,
            events: events.registry
        };
    };
    const TableResize = {
        create: create1
    };
    const only = (element, isResizable)=>{
        const parent = isDocument(element) ? documentElement(element) : element;
        return {
            parent: constant(parent),
            view: constant(element),
            origin: constant(SugarPosition(0, 0)),
            isResizable
        };
    };
    const detached = (editable, chrome, isResizable)=>{
        const origin = ()=>absolute(chrome)
        ;
        return {
            parent: constant(chrome),
            view: constant(editable),
            origin,
            isResizable
        };
    };
    const body1 = (editable, chrome, isResizable)=>{
        return {
            parent: constant(chrome),
            view: constant(editable),
            origin: constant(SugarPosition(0, 0)),
            isResizable
        };
    };
    const ResizeWire = {
        only,
        detached,
        body: body1
    };
    const createContainer = ()=>{
        const container = SugarElement.fromTag('div');
        setAll(container, {
            position: 'static',
            height: '0',
            width: '0',
            padding: '0',
            margin: '0',
            border: '0'
        });
        append$1(body$1(), container);
        return container;
    };
    const get1 = (editor, isResizable)=>{
        return editor.inline ? ResizeWire.body(SugarElement.fromDom(editor.getBody()), createContainer(), isResizable) : ResizeWire.only(SugarElement.fromDom(editor.getDoc()), isResizable);
    };
    const remove = (editor, wire)=>{
        if (editor.inline) remove$6(wire.parent());
    };
    const isTable1 = (node)=>isNonNullable(node) && node.tagName === 'TABLE'
    ;
    const barResizerPrefix = 'bar-';
    const isResizable1 = (elm)=>get$b(elm, 'data-mce-resize') !== 'false'
    ;
    const syncPixels = (table)=>{
        const warehouse = Warehouse.fromTable(table);
        if (!Warehouse.hasColumns(warehouse)) each$2(cells$1(table), (cell)=>{
            const computedWidth = get$a(cell, 'width');
            set$1(cell, 'width', computedWidth);
            remove$7(cell, 'width');
        });
    };
    const TableResizeHandler = (editor)=>{
        const selectionRng = value1();
        const tableResize = value1();
        const resizeWire = value1();
        let startW;
        let startRawW;
        const lazySizing = (table)=>get$5(editor, table)
        ;
        const lazyResizingBehaviour = ()=>isPreserveTableColumnResizing(editor) ? preserveTable() : resizeTable1()
        ;
        const getNumColumns = (table)=>getGridSize(table).columns
        ;
        const afterCornerResize = (table, origin, width)=>{
            const isRightEdgeResize = endsWith(origin, 'e');
            if (startRawW === '') convertToPercentSize(table);
            if (width !== startW && startRawW !== '') {
                set$1(table, 'width', startRawW);
                const resizing = lazyResizingBehaviour();
                const tableSize = lazySizing(table);
                const col = isPreserveTableColumnResizing(editor) || isRightEdgeResize ? getNumColumns(table) - 1 : 0;
                adjustWidth(table, width - startW, col, resizing, tableSize);
            } else if (isPercentage$1(startRawW)) {
                const percentW = parseFloat(startRawW.replace('%', ''));
                const targetPercentW = width * percentW / startW;
                set$1(table, 'width', targetPercentW + '%');
            }
            if (isPixel(startRawW)) syncPixels(table);
        };
        const destroy = ()=>{
            tableResize.on((sz)=>{
                sz.destroy();
            });
            resizeWire.on((w)=>{
                remove(editor, w);
            });
        };
        editor.on('init', ()=>{
            const rawWire = get1(editor, isResizable1);
            resizeWire.set(rawWire);
            if (hasTableObjectResizing(editor) && hasTableResizeBars(editor)) {
                const resizing = lazyResizingBehaviour();
                const sz = TableResize.create(rawWire, resizing, lazySizing);
                sz.on();
                sz.events.startDrag.bind((_event)=>{
                    selectionRng.set(editor.selection.getRng());
                });
                sz.events.beforeResize.bind((event)=>{
                    const rawTable = event.table.dom;
                    fireObjectResizeStart(editor, rawTable, getPixelWidth(rawTable), getPixelHeight(rawTable), barResizerPrefix + event.type);
                });
                sz.events.afterResize.bind((event)=>{
                    const table = event.table;
                    const rawTable = table.dom;
                    removeDataStyle(table);
                    selectionRng.on((rng)=>{
                        editor.selection.setRng(rng);
                        editor.focus();
                    });
                    fireObjectResized(editor, rawTable, getPixelWidth(rawTable), getPixelHeight(rawTable), barResizerPrefix + event.type);
                    editor.undoManager.add();
                });
                tableResize.set(sz);
            }
        });
        editor.on('ObjectResizeStart', (e)=>{
            const targetElm = e.target;
            if (isTable1(targetElm)) {
                const table = SugarElement.fromDom(targetElm);
                each$2(editor.dom.select('.mce-clonedresizable'), (clone)=>{
                    editor.dom.addClass(clone, 'mce-' + getTableColumnResizingBehaviour(editor) + '-columns');
                });
                if (!isPixelSizing(table) && isTablePixelsForced(editor)) convertToPixelSize(table);
                else if (!isPercentSizing(table) && isTablePercentagesForced(editor)) convertToPercentSize(table);
                if (isNoneSizing(table) && startsWith(e.origin, barResizerPrefix)) convertToPercentSize(table);
                startW = e.width;
                startRawW = isTableResponsiveForced(editor) ? '' : getRawWidth(editor, targetElm).getOr('');
            }
        });
        editor.on('ObjectResized', (e)=>{
            const targetElm = e.target;
            if (isTable1(targetElm)) {
                const table = SugarElement.fromDom(targetElm);
                const origin = e.origin;
                if (startsWith(origin, 'corner-')) afterCornerResize(table, origin, e.width);
                removeDataStyle(table);
                fireTableModified(editor, table.dom, styleModified);
            }
        });
        editor.on('SwitchMode', ()=>{
            tableResize.on((resize)=>{
                if (editor.mode.isReadOnly()) resize.hideBars();
                else resize.showBars();
            });
        });
        editor.on('remove', ()=>{
            destroy();
        });
        const refresh = (table)=>{
            tableResize.on((resize)=>resize.refreshBars(SugarElement.fromDom(table))
            );
        };
        const hide = ()=>{
            tableResize.on((resize)=>resize.hideBars()
            );
        };
        const show = ()=>{
            tableResize.on((resize)=>resize.showBars()
            );
        };
        return {
            refresh,
            hide,
            show
        };
    };
    const setupTable = (editor)=>{
        register(editor);
        const resizeHandler = TableResizeHandler(editor);
        const cellSelectionHandler = TableCellSelectionHandler(editor, resizeHandler);
        const actions = TableActions(editor, resizeHandler, cellSelectionHandler);
        registerCommands(editor, actions);
        registerQueryCommands(editor, actions);
        registerEvents(editor, actions);
        return {
            getSelectedCells: cellSelectionHandler.getSelectedCells,
            clearSelectedCells: cellSelectionHandler.clearSelectedCells
        };
    };
    const DomModel = (editor)=>{
        const table = setupTable(editor);
        return {
            table
        };
    };
    var Model = ()=>{
        global$1.add('dom', DomModel);
    };
    Model();
})();


</script>
  <script referrerpolicy="origin">
/**
 * TinyMCE version 6.0.1 (2022-03-23)
 */ (function() {
    var global$5 = tinymce.util.Tools.resolve('tinymce.PluginManager');
    var global$4 = tinymce.util.Tools.resolve('tinymce.util.VK');
    const hasProto = (v, constructor, predicate)=>{
        var _a;
        if (predicate(v, constructor.prototype)) return true;
        else return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;
    };
    const typeOf = (x)=>{
        const t = typeof x;
        if (x === null) return 'null';
        else if (t === 'object' && Array.isArray(x)) return 'array';
        else if (t === 'object' && hasProto(x, String, (o, proto)=>proto.isPrototypeOf(o)
        )) return 'string';
        else return t;
    };
    const isType = (type)=>(value)=>typeOf(value) === type
    ;
    const isSimpleType = (type)=>(value)=>typeof value === type
    ;
    const eq = (t)=>(a)=>t === a
    ;
    const isString = isType('string');
    const isObject = isType('object');
    const isArray = isType('array');
    const isNull = eq(null);
    const isBoolean = isSimpleType('boolean');
    const isNullable = (a)=>a === null || a === undefined
    ;
    const isNonNullable = (a)=>!isNullable(a)
    ;
    const isFunction = isSimpleType('function');
    const isArrayOf = (value, pred)=>{
        if (isArray(value)) {
            for(let i = 0, len = value.length; i < len; ++i){
                if (!pred(value[i])) return false;
            }
            return true;
        }
        return false;
    };
    const noop = ()=>{};
    const tripleEquals = (a, b)=>{
        return a === b;
    };
    class Optional {
        constructor(tag, value){
            this.tag = tag;
            this.value = value;
        }
        static some(value) {
            return new Optional(true, value);
        }
        static none() {
            return Optional.singletonNone;
        }
        fold(onNone, onSome) {
            if (this.tag) return onSome(this.value);
            else return onNone();
        }
        isSome() {
            return this.tag;
        }
        isNone() {
            return !this.tag;
        }
        map(mapper) {
            if (this.tag) return Optional.some(mapper(this.value));
            else return Optional.none();
        }
        bind(binder) {
            if (this.tag) return binder(this.value);
            else return Optional.none();
        }
        exists(predicate) {
            return this.tag && predicate(this.value);
        }
        forall(predicate) {
            return !this.tag || predicate(this.value);
        }
        filter(predicate) {
            if (!this.tag || predicate(this.value)) return this;
            else return Optional.none();
        }
        getOr(replacement) {
            return this.tag ? this.value : replacement;
        }
        or(replacement) {
            return this.tag ? this : replacement;
        }
        getOrThunk(thunk) {
            return this.tag ? this.value : thunk();
        }
        orThunk(thunk) {
            return this.tag ? this : thunk();
        }
        getOrDie(message) {
            if (!this.tag) throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');
            else return this.value;
        }
        static from(value) {
            return isNonNullable(value) ? Optional.some(value) : Optional.none();
        }
        getOrNull() {
            return this.tag ? this.value : null;
        }
        getOrUndefined() {
            return this.value;
        }
        each(worker) {
            if (this.tag) worker(this.value);
        }
        toArray() {
            return this.tag ? [
                this.value
            ] : [];
        }
        toString() {
            return this.tag ? `some(${this.value})` : 'none()';
        }
    }
    Optional.singletonNone = new Optional(false);
    const nativeIndexOf = Array.prototype.indexOf;
    const nativePush = Array.prototype.push;
    const rawIndexOf = (ts, t)=>nativeIndexOf.call(ts, t)
    ;
    const contains = (xs, x)=>rawIndexOf(xs, x) > -1
    ;
    const map = (xs, f)=>{
        const len = xs.length;
        const r = new Array(len);
        for(let i = 0; i < len; i++){
            const x = xs[i];
            r[i] = f(x, i);
        }
        return r;
    };
    const each$1 = (xs, f)=>{
        for(let i = 0, len = xs.length; i < len; i++){
            const x = xs[i];
            f(x, i);
        }
    };
    const foldl = (xs, f, acc)=>{
        each$1(xs, (x, i)=>{
            acc = f(acc, x, i);
        });
        return acc;
    };
    const flatten = (xs)=>{
        const r = [];
        for(let i = 0, len = xs.length; i < len; ++i){
            if (!isArray(xs[i])) throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);
            nativePush.apply(r, xs[i]);
        }
        return r;
    };
    const bind = (xs, f)=>flatten(map(xs, f))
    ;
    const findMap = (arr, f)=>{
        for(let i = 0; i < arr.length; i++){
            const r = f(arr[i], i);
            if (r.isSome()) return r;
        }
        return Optional.none();
    };
    const is = (lhs, rhs, comparator = tripleEquals)=>lhs.exists((left)=>comparator(left, rhs)
        )
    ;
    const cat = (arr)=>{
        const r = [];
        const push = (x)=>{
            r.push(x);
        };
        for(let i = 0; i < arr.length; i++)arr[i].each(push);
        return r;
    };
    const someIf = (b, a)=>b ? Optional.some(a) : Optional.none()
    ;
    const option = (name)=>(editor)=>editor.options.get(name)
    ;
    const register$1 = (editor)=>{
        const registerOption = editor.options.register;
        registerOption('link_assume_external_targets', {
            processor: (value)=>{
                const valid = isString(value) || isBoolean(value);
                if (valid) {
                    if (value === true) return {
                        value: 1,
                        valid
                    };
                    else if (value === 'http' || value === 'https') return {
                        value,
                        valid
                    };
                    else return {
                        value: 0,
                        valid
                    };
                } else return {
                    valid: false,
                    message: 'Must be a string or a boolean.'
                };
            },
            default: false
        });
        registerOption('link_context_toolbar', {
            processor: 'boolean',
            default: false
        });
        registerOption('link_list', {
            processor: (value)=>isString(value) || isFunction(value) || isArrayOf(value, isObject)
        });
        registerOption('link_default_target', {
            processor: 'string'
        });
        registerOption('link_default_protocol', {
            processor: 'string',
            default: 'https'
        });
        registerOption('link_target_list', {
            processor: (value)=>isBoolean(value) || isArrayOf(value, isObject)
            ,
            default: true
        });
        registerOption('link_rel_list', {
            processor: 'object[]',
            default: []
        });
        registerOption('link_class_list', {
            processor: 'object[]',
            default: []
        });
        registerOption('link_title', {
            processor: 'boolean',
            default: true
        });
        registerOption('allow_unsafe_link_target', {
            processor: 'boolean',
            default: false
        });
        registerOption('link_quicklink', {
            processor: 'boolean',
            default: false
        });
    };
    const assumeExternalTargets1 = option('link_assume_external_targets');
    const hasContextToolbar = option('link_context_toolbar');
    const getLinkList = option('link_list');
    const getDefaultLinkTarget = option('link_default_target');
    const getDefaultLinkProtocol = option('link_default_protocol');
    const getTargetList = option('link_target_list');
    const getRelList = option('link_rel_list');
    const getLinkClassList = option('link_class_list');
    const shouldShowLinkTitle = option('link_title');
    const allowUnsafeLinkTarget = option('allow_unsafe_link_target');
    const useQuickLink = option('link_quicklink');
    var global$3 = tinymce.util.Tools.resolve('tinymce.util.Tools');
    const getValue = (item)=>isString(item.value) ? item.value : ''
    ;
    const getText = (item)=>{
        if (isString(item.text)) return item.text;
        else if (isString(item.title)) return item.title;
        else return '';
    };
    const sanitizeList = (list, extractValue)=>{
        const out = [];
        global$3.each(list, (item)=>{
            const text = getText(item);
            if (item.menu !== undefined) {
                const items = sanitizeList(item.menu, extractValue);
                out.push({
                    text,
                    items
                });
            } else {
                const value = extractValue(item);
                out.push({
                    text,
                    value
                });
            }
        });
        return out;
    };
    const sanitizeWith = (extracter = getValue)=>(list1)=>Optional.from(list1).map((list)=>sanitizeList(list, extracter)
            )
    ;
    const sanitize = (list)=>sanitizeWith(getValue)(list)
    ;
    const createUi = (name, label)=>(items)=>({
                name,
                type: 'listbox',
                label,
                items
            })
    ;
    const ListOptions = {
        sanitize,
        sanitizeWith,
        createUi,
        getValue
    };
    const keys = Object.keys;
    const hasOwnProperty = Object.hasOwnProperty;
    const each = (obj, f)=>{
        const props = keys(obj);
        for(let k = 0, len = props.length; k < len; k++){
            const i = props[k];
            const x = obj[i];
            f(x, i);
        }
    };
    const objAcc = (r)=>(x, i)=>{
            r[i] = x;
        }
    ;
    const internalFilter = (obj, pred, onTrue, onFalse)=>{
        const r = {};
        each(obj, (x, i)=>{
            (pred(x, i) ? onTrue : onFalse)(x, i);
        });
        return r;
    };
    const filter = (obj, pred)=>{
        const t = {};
        internalFilter(obj, pred, objAcc(t), noop);
        return t;
    };
    const has = (obj, key)=>hasOwnProperty.call(obj, key)
    ;
    const hasNonNullableKey = (obj, key)=>has(obj, key) && obj[key] !== undefined && obj[key] !== null
    ;
    var global$2 = tinymce.util.Tools.resolve('tinymce.dom.TreeWalker');
    var global$1 = tinymce.util.Tools.resolve('tinymce.util.URI');
    const isAnchor = (elm)=>elm && elm.nodeName.toLowerCase() === 'a'
    ;
    const isLink = (elm)=>isAnchor(elm) && !!getHref(elm)
    ;
    const collectNodesInRange = (rng, predicate)=>{
        if (rng.collapsed) return [];
        else {
            const contents = rng.cloneContents();
            const walker = new global$2(contents.firstChild, contents);
            const elements = [];
            let current = contents.firstChild;
            do if (predicate(current)) elements.push(current);
            while (current = walker.next())
            return elements;
        }
    };
    const hasProtocol = (url)=>/^\w+:/i.test(url)
    ;
    const getHref = (elm)=>{
        const href = elm.getAttribute('data-mce-href');
        return href ? href : elm.getAttribute('href');
    };
    const applyRelTargetRules = (rel, isUnsafe)=>{
        const rules = [
            'noopener'
        ];
        const rels1 = rel ? rel.split(/\s+/) : [];
        const toString = (rels)=>global$3.trim(rels.sort().join(' '))
        ;
        const addTargetRules = (rels)=>{
            rels = removeTargetRules(rels);
            return rels.length > 0 ? rels.concat(rules) : rules;
        };
        const removeTargetRules = (rels)=>rels.filter((val)=>global$3.inArray(rules, val) === -1
            )
        ;
        const newRels = isUnsafe ? addTargetRules(rels1) : removeTargetRules(rels1);
        return newRels.length > 0 ? toString(newRels) : '';
    };
    const trimCaretContainers = (text)=>text.replace(/\uFEFF/g, '')
    ;
    const getAnchorElement = (editor, selectedElm)=>{
        selectedElm = selectedElm || editor.selection.getNode();
        if (isImageFigure(selectedElm)) return editor.dom.select('a[href]', selectedElm)[0];
        else return editor.dom.getParent(selectedElm, 'a[href]');
    };
    const getAnchorText = (selection, anchorElm)=>{
        const text = anchorElm ? anchorElm.innerText || anchorElm.textContent : selection.getContent({
            format: 'text'
        });
        return trimCaretContainers(text);
    };
    const hasLinks = (elements)=>global$3.grep(elements, isLink).length > 0
    ;
    const hasLinksInSelection = (rng)=>collectNodesInRange(rng, isLink).length > 0
    ;
    const isOnlyTextSelected = (editor)=>{
        const inlineTextElements = editor.schema.getTextInlineElements();
        const isElement = (elm)=>elm.nodeType === 1 && !isAnchor(elm) && !has(inlineTextElements, elm.nodeName.toLowerCase())
        ;
        const elements = collectNodesInRange(editor.selection.getRng(), isElement);
        return elements.length === 0;
    };
    const isImageFigure = (elm)=>elm && elm.nodeName === 'FIGURE' && /\bimage\b/i.test(elm.className)
    ;
    const getLinkAttrs = (data)=>{
        const attrs = [
            'title',
            'rel',
            'class',
            'target'
        ];
        return foldl(attrs, (acc, key)=>{
            data[key].each((value)=>{
                acc[key] = value.length > 0 ? value : null;
            });
            return acc;
        }, {
            href: data.href
        });
    };
    const handleExternalTargets = (href, assumeExternalTargets)=>{
        if ((assumeExternalTargets === 'http' || assumeExternalTargets === 'https') && !hasProtocol(href)) return assumeExternalTargets + '://' + href;
        return href;
    };
    const applyLinkOverrides = (editor, linkAttrs)=>{
        const newLinkAttrs = {
            ...linkAttrs
        };
        if (getRelList(editor).length === 0 && !allowUnsafeLinkTarget(editor)) {
            const newRel = applyRelTargetRules(newLinkAttrs.rel, newLinkAttrs.target === '_blank');
            newLinkAttrs.rel = newRel ? newRel : null;
        }
        if (Optional.from(newLinkAttrs.target).isNone() && getTargetList(editor) === false) newLinkAttrs.target = getDefaultLinkTarget(editor);
        newLinkAttrs.href = handleExternalTargets(newLinkAttrs.href, assumeExternalTargets1(editor));
        return newLinkAttrs;
    };
    const updateLink = (editor, anchorElm, text1, linkAttrs)=>{
        text1.each((text)=>{
            if (has(anchorElm, 'innerText')) anchorElm.innerText = text;
            else anchorElm.textContent = text;
        });
        editor.dom.setAttribs(anchorElm, linkAttrs);
        editor.selection.select(anchorElm);
    };
    const createLink = (editor, selectedElm, text2, linkAttrs)=>{
        if (isImageFigure(selectedElm)) linkImageFigure(editor, selectedElm, linkAttrs);
        else text2.fold(()=>{
            editor.execCommand('mceInsertLink', false, linkAttrs);
        }, (text)=>{
            editor.insertContent(editor.dom.createHTML('a', linkAttrs, editor.dom.encode(text)));
        });
    };
    const linkDomMutation = (editor, attachState, data)=>{
        const selectedElm = editor.selection.getNode();
        const anchorElm = getAnchorElement(editor, selectedElm);
        const linkAttrs = applyLinkOverrides(editor, getLinkAttrs(data));
        editor.undoManager.transact(()=>{
            if (data.href === attachState.href) attachState.attach();
            if (anchorElm) {
                editor.focus();
                updateLink(editor, anchorElm, data.text, linkAttrs);
            } else createLink(editor, selectedElm, data.text, linkAttrs);
        });
    };
    const unlinkSelection = (editor)=>{
        const dom = editor.dom, selection = editor.selection;
        const bookmark = selection.getBookmark();
        const rng = selection.getRng().cloneRange();
        const startAnchorElm = dom.getParent(rng.startContainer, 'a[href]', editor.getBody());
        const endAnchorElm = dom.getParent(rng.endContainer, 'a[href]', editor.getBody());
        if (startAnchorElm) rng.setStartBefore(startAnchorElm);
        if (endAnchorElm) rng.setEndAfter(endAnchorElm);
        selection.setRng(rng);
        editor.execCommand('unlink');
        selection.moveToBookmark(bookmark);
    };
    const unlinkDomMutation = (editor)=>{
        editor.undoManager.transact(()=>{
            const node = editor.selection.getNode();
            if (isImageFigure(node)) unlinkImageFigure(editor, node);
            else unlinkSelection(editor);
            editor.focus();
        });
    };
    const unwrapOptions = (data)=>{
        const { class: cls , href , rel , target , text , title  } = data;
        return filter({
            class: cls.getOrNull(),
            href,
            rel: rel.getOrNull(),
            target: target.getOrNull(),
            text: text.getOrNull(),
            title: title.getOrNull()
        }, (v, _k)=>isNull(v) === false
        );
    };
    const sanitizeData = (editor, data)=>{
        const getOption = editor.options.get;
        const uriOptions = {
            allow_html_data_urls: getOption('allow_html_data_urls'),
            allow_script_urls: getOption('allow_script_urls'),
            allow_svg_data_urls: getOption('allow_svg_data_urls')
        };
        const href = data.href;
        return {
            ...data,
            href: global$1.isDomSafe(href, 'a', uriOptions) ? href : ''
        };
    };
    const link1 = (editor, attachState, data)=>{
        const sanitizedData = sanitizeData(editor, data);
        editor.hasPlugin('rtc', true) ? editor.execCommand('createlink', false, unwrapOptions(sanitizedData)) : linkDomMutation(editor, attachState, sanitizedData);
    };
    const unlink = (editor)=>{
        editor.hasPlugin('rtc', true) ? editor.execCommand('unlink') : unlinkDomMutation(editor);
    };
    const unlinkImageFigure = (editor, fig)=>{
        const img = editor.dom.select('img', fig)[0];
        if (img) {
            const a = editor.dom.getParents(img, 'a[href]', fig)[0];
            if (a) {
                a.parentNode.insertBefore(img, a);
                editor.dom.remove(a);
            }
        }
    };
    const linkImageFigure = (editor, fig, attrs)=>{
        const img = editor.dom.select('img', fig)[0];
        if (img) {
            const a = editor.dom.create('a', attrs);
            img.parentNode.insertBefore(a, img);
            a.appendChild(img);
        }
    };
    const isListGroup = (item)=>hasNonNullableKey(item, 'items')
    ;
    const findTextByValue = (value, catalog)=>findMap(catalog, (item)=>{
            if (isListGroup(item)) return findTextByValue(value, item.items);
            else return someIf(item.value === value, item);
        })
    ;
    const getDelta = (persistentText, fieldName, catalog, data)=>{
        const value = data[fieldName];
        const hasPersistentText = persistentText.length > 0;
        return value !== undefined ? findTextByValue(value, catalog).map((i)=>({
                url: {
                    value: i.value,
                    meta: {
                        text: hasPersistentText ? persistentText : i.text,
                        attach: noop
                    }
                },
                text: hasPersistentText ? persistentText : i.text
            })
        ) : Optional.none();
    };
    const findCatalog = (catalogs, fieldName)=>{
        if (fieldName === 'link') return catalogs.link;
        else if (fieldName === 'anchor') return catalogs.anchor;
        else return Optional.none();
    };
    const init = (initialData, linkCatalog)=>{
        const persistentData = {
            text: initialData.text,
            title: initialData.title
        };
        const getTitleFromUrlChange = (url)=>someIf(persistentData.title.length <= 0, Optional.from(url.meta.title).getOr(''))
        ;
        const getTextFromUrlChange = (url)=>someIf(persistentData.text.length <= 0, Optional.from(url.meta.text).getOr(url.value))
        ;
        const onUrlChange = (data)=>{
            const text3 = getTextFromUrlChange(data.url);
            const title1 = getTitleFromUrlChange(data.url);
            if (text3.isSome() || title1.isSome()) return Optional.some({
                ...text3.map((text)=>({
                        text
                    })
                ).getOr({}),
                ...title1.map((title)=>({
                        title
                    })
                ).getOr({})
            });
            else return Optional.none();
        };
        const onCatalogChange = (data, change)=>{
            const catalog = findCatalog(linkCatalog, change.name).getOr([]);
            return getDelta(persistentData.text, change.name, catalog, data);
        };
        const onChange = (getData, change)=>{
            const name = change.name;
            if (name === 'url') return onUrlChange(getData());
            else if (contains([
                'anchor',
                'link'
            ], name)) return onCatalogChange(getData(), change);
            else if (name === 'text' || name === 'title') {
                persistentData[name] = getData()[name];
                return Optional.none();
            } else return Optional.none();
        };
        return {
            onChange
        };
    };
    const DialogChanges = {
        init,
        getDelta
    };
    var global = tinymce.util.Tools.resolve('tinymce.util.Delay');
    const delayedConfirm = (editor, message, callback)=>{
        const rng = editor.selection.getRng();
        global.setEditorTimeout(editor, ()=>{
            editor.windowManager.confirm(message, (state)=>{
                editor.selection.setRng(rng);
                callback(state);
            });
        });
    };
    const tryEmailTransform = (data)=>{
        const url = data.href;
        const suggestMailTo = url.indexOf('@') > 0 && url.indexOf('/') === -1 && url.indexOf('mailto:') === -1;
        return suggestMailTo ? Optional.some({
            message: 'The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?',
            preprocess: (oldData)=>({
                    ...oldData,
                    href: 'mailto:' + url
                })
        }) : Optional.none();
    };
    const tryProtocolTransform = (assumeExternalTargets, defaultLinkProtocol)=>(data)=>{
            const url = data.href;
            const suggestProtocol = assumeExternalTargets === 1 && !hasProtocol(url) || assumeExternalTargets === 0 && /^\s*www(\.|\d\.)/i.test(url);
            return suggestProtocol ? Optional.some({
                message: `The URL you entered seems to be an external link. Do you want to add the required ${defaultLinkProtocol}:// prefix?`,
                preprocess: (oldData)=>({
                        ...oldData,
                        href: defaultLinkProtocol + '://' + url
                    })
            }) : Optional.none();
        }
    ;
    const preprocess = (editor, data)=>findMap([
            tryEmailTransform,
            tryProtocolTransform(assumeExternalTargets1(editor), getDefaultLinkProtocol(editor))
        ], (f)=>f(data)
        ).fold(()=>Promise.resolve(data)
        , (transform)=>new Promise((callback)=>{
                delayedConfirm(editor, transform.message, (state)=>{
                    callback(state ? transform.preprocess(data) : data);
                });
            })
        )
    ;
    const DialogConfirms = {
        preprocess
    };
    const getAnchors = (editor)=>{
        const anchorNodes = editor.dom.select('a:not([href])');
        const anchors = bind(anchorNodes, (anchor)=>{
            const id = anchor.name || anchor.id;
            return id ? [
                {
                    text: id,
                    value: '#' + id
                }
            ] : [];
        });
        return anchors.length > 0 ? Optional.some([
            {
                text: 'None',
                value: ''
            }
        ].concat(anchors)) : Optional.none();
    };
    const AnchorListOptions = {
        getAnchors
    };
    const getClasses = (editor)=>{
        const list = getLinkClassList(editor);
        if (list.length > 0) return ListOptions.sanitize(list);
        return Optional.none();
    };
    const ClassListOptions = {
        getClasses
    };
    const parseJson = (text)=>{
        try {
            return Optional.some(JSON.parse(text));
        } catch (err) {
            return Optional.none();
        }
    };
    const getLinks = (editor)=>{
        const extractor = (item)=>editor.convertURL(item.value || item.url, 'href')
        ;
        const linkList = getLinkList(editor);
        return new Promise((resolve)=>{
            if (isString(linkList)) fetch(linkList).then((res)=>res.ok ? res.text().then(parseJson) : Promise.reject()
            ).then(resolve, ()=>resolve(Optional.none())
            );
            else if (isFunction(linkList)) linkList((output)=>resolve(Optional.some(output))
            );
            else resolve(Optional.from(linkList));
        }).then((optItems)=>optItems.bind(ListOptions.sanitizeWith(extractor)).map((items)=>{
                if (items.length > 0) {
                    const noneItem = [
                        {
                            text: 'None',
                            value: ''
                        }
                    ];
                    return noneItem.concat(items);
                } else return items;
            })
        );
    };
    const LinkListOptions = {
        getLinks
    };
    const getRels = (editor, initialTarget)=>{
        const list = getRelList(editor);
        if (list.length > 0) {
            const isTargetBlank = is(initialTarget, '_blank');
            const enforceSafe = allowUnsafeLinkTarget(editor) === false;
            const safeRelExtractor = (item)=>applyRelTargetRules(ListOptions.getValue(item), isTargetBlank)
            ;
            const sanitizer = enforceSafe ? ListOptions.sanitizeWith(safeRelExtractor) : ListOptions.sanitize;
            return sanitizer(list);
        }
        return Optional.none();
    };
    const RelOptions = {
        getRels
    };
    const fallbacks = [
        {
            text: 'Current window',
            value: ''
        },
        {
            text: 'New window',
            value: '_blank'
        }
    ];
    const getTargets = (editor)=>{
        const list = getTargetList(editor);
        if (isArray(list)) return ListOptions.sanitize(list).orThunk(()=>Optional.some(fallbacks)
        );
        else if (list === false) return Optional.none();
        return Optional.some(fallbacks);
    };
    const TargetOptions = {
        getTargets
    };
    const nonEmptyAttr = (dom, elem, name)=>{
        const val = dom.getAttrib(elem, name);
        return val !== null && val.length > 0 ? Optional.some(val) : Optional.none();
    };
    const extractFromAnchor = (editor, anchor)=>{
        const dom = editor.dom;
        const onlyText = isOnlyTextSelected(editor);
        const text = onlyText ? Optional.some(getAnchorText(editor.selection, anchor)) : Optional.none();
        const url = anchor ? Optional.some(dom.getAttrib(anchor, 'href')) : Optional.none();
        const target = anchor ? Optional.from(dom.getAttrib(anchor, 'target')) : Optional.none();
        const rel = nonEmptyAttr(dom, anchor, 'rel');
        const linkClass = nonEmptyAttr(dom, anchor, 'class');
        const title = nonEmptyAttr(dom, anchor, 'title');
        return {
            url,
            text,
            title,
            target,
            rel,
            linkClass
        };
    };
    const collect = (editor, linkNode)=>LinkListOptions.getLinks(editor).then((links)=>{
            const anchor = extractFromAnchor(editor, linkNode);
            return {
                anchor,
                catalogs: {
                    targets: TargetOptions.getTargets(editor),
                    rels: RelOptions.getRels(editor, anchor.target),
                    classes: ClassListOptions.getClasses(editor),
                    anchor: AnchorListOptions.getAnchors(editor),
                    link: links
                },
                optNode: Optional.from(linkNode),
                flags: {
                    titleEnabled: shouldShowLinkTitle(editor)
                }
            };
        })
    ;
    const DialogInfo = {
        collect
    };
    const handleSubmit = (editor, info)=>(api)=>{
            const data = api.getData();
            if (!data.url.value) {
                unlink(editor);
                api.close();
                return;
            }
            const getChangedValue = (key)=>Optional.from(data[key]).filter((value)=>!is(info.anchor[key], value)
                )
            ;
            const changedData = {
                href: data.url.value,
                text: getChangedValue('text'),
                target: getChangedValue('target'),
                rel: getChangedValue('rel'),
                class: getChangedValue('linkClass'),
                title: getChangedValue('title')
            };
            const attachState = {
                href: data.url.value,
                attach: data.url.meta !== undefined && data.url.meta.attach ? data.url.meta.attach : noop
            };
            DialogConfirms.preprocess(editor, changedData).then((pData)=>{
                link1(editor, attachState, pData);
            });
            api.close();
        }
    ;
    const collectData = (editor)=>{
        const anchorNode = getAnchorElement(editor);
        return DialogInfo.collect(editor, anchorNode);
    };
    const getInitialData = (info, defaultTarget)=>{
        const anchor = info.anchor;
        const url = anchor.url.getOr('');
        return {
            url: {
                value: url,
                meta: {
                    original: {
                        value: url
                    }
                }
            },
            text: anchor.text.getOr(''),
            title: anchor.title.getOr(''),
            anchor: url,
            link: url,
            rel: anchor.rel.getOr(''),
            target: anchor.target.or(defaultTarget).getOr(''),
            linkClass: anchor.linkClass.getOr('')
        };
    };
    const makeDialog = (settings, onSubmit, editor)=>{
        const urlInput = [
            {
                name: 'url',
                type: 'urlinput',
                filetype: 'file',
                label: 'URL'
            }
        ];
        const displayText = settings.anchor.text.map(()=>({
                name: 'text',
                type: 'input',
                label: 'Text to display'
            })
        ).toArray();
        const titleText = settings.flags.titleEnabled ? [
            {
                name: 'title',
                type: 'input',
                label: 'Title'
            }
        ] : [];
        const defaultTarget = Optional.from(getDefaultLinkTarget(editor));
        const initialData = getInitialData(settings, defaultTarget);
        const catalogs = settings.catalogs;
        const dialogDelta = DialogChanges.init(initialData, catalogs);
        const body = {
            type: 'panel',
            items: flatten([
                urlInput,
                displayText,
                titleText,
                cat([
                    catalogs.anchor.map(ListOptions.createUi('anchor', 'Anchors')),
                    catalogs.rels.map(ListOptions.createUi('rel', 'Rel')),
                    catalogs.targets.map(ListOptions.createUi('target', 'Open link in...')),
                    catalogs.link.map(ListOptions.createUi('link', 'Link list')),
                    catalogs.classes.map(ListOptions.createUi('linkClass', 'Class'))
                ])
            ])
        };
        return {
            title: 'Insert/Edit Link',
            size: 'normal',
            body,
            buttons: [
                {
                    type: 'cancel',
                    name: 'cancel',
                    text: 'Cancel'
                },
                {
                    type: 'submit',
                    name: 'save',
                    text: 'Save',
                    primary: true
                }
            ],
            initialData,
            onChange: (api, { name  })=>{
                dialogDelta.onChange(api.getData, {
                    name
                }).each((newData)=>{
                    api.setData(newData);
                });
            },
            onSubmit
        };
    };
    const open$1 = (editor)=>{
        const data = collectData(editor);
        data.then((info)=>{
            const onSubmit = handleSubmit(editor, info);
            return makeDialog(info, onSubmit, editor);
        }).then((spec)=>{
            editor.windowManager.open(spec);
        });
    };
    const appendClickRemove = (link, evt)=>{
        document.body.appendChild(link);
        link.dispatchEvent(evt);
        document.body.removeChild(link);
    };
    const open = (url)=>{
        const link = document.createElement('a');
        link.target = '_blank';
        link.href = url;
        link.rel = 'noreferrer noopener';
        const evt = document.createEvent('MouseEvents');
        evt.initMouseEvent('click', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
        appendClickRemove(link, evt);
    };
    const getLink = (editor, elm)=>editor.dom.getParent(elm, 'a[href]')
    ;
    const getSelectedLink = (editor)=>getLink(editor, editor.selection.getStart())
    ;
    const hasOnlyAltModifier = (e)=>{
        return e.altKey === true && e.shiftKey === false && e.ctrlKey === false && e.metaKey === false;
    };
    const gotoLink = (editor, a)=>{
        if (a) {
            const href = getHref(a);
            if (/^#/.test(href)) {
                const targetEl = editor.dom.select(href);
                if (targetEl.length) editor.selection.scrollIntoView(targetEl[0], true);
            } else open(a.href);
        }
    };
    const openDialog = (editor)=>()=>{
            open$1(editor);
        }
    ;
    const gotoSelectedLink = (editor)=>()=>{
            gotoLink(editor, getSelectedLink(editor));
        }
    ;
    const setupGotoLinks = (editor)=>{
        editor.on('click', (e)=>{
            const link = getLink(editor, e.target);
            if (link && global$4.metaKeyPressed(e)) {
                e.preventDefault();
                gotoLink(editor, link);
            }
        });
        editor.on('keydown', (e)=>{
            const link = getSelectedLink(editor);
            if (link && e.keyCode === 13 && hasOnlyAltModifier(e)) {
                e.preventDefault();
                gotoLink(editor, link);
            }
        });
    };
    const toggleState = (editor, toggler)=>{
        editor.on('NodeChange', toggler);
        return ()=>editor.off('NodeChange', toggler)
        ;
    };
    const toggleActiveState = (editor)=>(api)=>{
            const updateState = ()=>api.setActive(!editor.mode.isReadOnly() && getAnchorElement(editor, editor.selection.getNode()) !== null)
            ;
            updateState();
            return toggleState(editor, updateState);
        }
    ;
    const toggleEnabledState = (editor)=>(api)=>{
            const updateState = ()=>api.setEnabled(getAnchorElement(editor, editor.selection.getNode()) !== null)
            ;
            updateState();
            return toggleState(editor, updateState);
        }
    ;
    const toggleUnlinkState = (editor)=>(api)=>{
            const hasLinks$1 = (parents)=>hasLinks(parents) || hasLinksInSelection(editor.selection.getRng())
            ;
            const parents1 = editor.dom.getParents(editor.selection.getStart());
            api.setEnabled(hasLinks$1(parents1));
            return toggleState(editor, (e)=>api.setEnabled(hasLinks$1(e.parents))
            );
        }
    ;
    const register = (editor)=>{
        editor.addCommand('mceLink', ()=>{
            if (useQuickLink(editor)) editor.dispatch('contexttoolbar-show', {
                toolbarKey: 'quicklink'
            });
            else openDialog(editor)();
        });
    };
    const setup = (editor)=>{
        editor.addShortcut('Meta+K', '', ()=>{
            editor.execCommand('mceLink');
        });
    };
    const setupButtons = (editor)=>{
        editor.ui.registry.addToggleButton('link', {
            icon: 'link',
            tooltip: 'Insert/edit link',
            onAction: openDialog(editor),
            onSetup: toggleActiveState(editor)
        });
        editor.ui.registry.addButton('openlink', {
            icon: 'new-tab',
            tooltip: 'Open link',
            onAction: gotoSelectedLink(editor),
            onSetup: toggleEnabledState(editor)
        });
        editor.ui.registry.addButton('unlink', {
            icon: 'unlink',
            tooltip: 'Remove link',
            onAction: ()=>unlink(editor)
            ,
            onSetup: toggleUnlinkState(editor)
        });
    };
    const setupMenuItems = (editor)=>{
        editor.ui.registry.addMenuItem('openlink', {
            text: 'Open link',
            icon: 'new-tab',
            onAction: gotoSelectedLink(editor),
            onSetup: toggleEnabledState(editor)
        });
        editor.ui.registry.addMenuItem('link', {
            icon: 'link',
            text: 'Link...',
            shortcut: 'Meta+K',
            onAction: openDialog(editor)
        });
        editor.ui.registry.addMenuItem('unlink', {
            icon: 'unlink',
            text: 'Remove link',
            onAction: ()=>unlink(editor)
            ,
            onSetup: toggleUnlinkState(editor)
        });
    };
    const setupContextMenu = (editor)=>{
        const inLink = 'link unlink openlink';
        const noLink = 'link';
        editor.ui.registry.addContextMenu('link', {
            update: (element)=>hasLinks(editor.dom.getParents(element, 'a')) ? inLink : noLink
        });
    };
    const setupContextToolbars = (editor1)=>{
        const collapseSelectionToEnd = (editor)=>{
            editor.selection.collapse(false);
        };
        const onSetupLink = (buttonApi)=>{
            const node = editor1.selection.getNode();
            buttonApi.setEnabled(getAnchorElement(editor1, node) !== null);
            return noop;
        };
        const getLinkText = (value)=>{
            const anchor = getAnchorElement(editor1);
            const onlyText = isOnlyTextSelected(editor1);
            if (!anchor && onlyText) {
                const text = getAnchorText(editor1.selection, anchor);
                return Optional.some(text.length > 0 ? text : value);
            } else return Optional.none();
        };
        editor1.ui.registry.addContextForm('quicklink', {
            launch: {
                type: 'contextformtogglebutton',
                icon: 'link',
                tooltip: 'Link',
                onSetup: toggleActiveState(editor1)
            },
            label: 'Link',
            predicate: (node)=>!!getAnchorElement(editor1, node) && hasContextToolbar(editor1)
            ,
            initValue: ()=>{
                const elm = getAnchorElement(editor1);
                return !!elm ? getHref(elm) : '';
            },
            commands: [
                {
                    type: 'contextformtogglebutton',
                    icon: 'link',
                    tooltip: 'Link',
                    primary: true,
                    onSetup: (buttonApi)=>{
                        const node = editor1.selection.getNode();
                        buttonApi.setActive(!!getAnchorElement(editor1, node));
                        return toggleActiveState(editor1)(buttonApi);
                    },
                    onAction: (formApi)=>{
                        const value = formApi.getValue();
                        const text = getLinkText(value);
                        const attachState = {
                            href: value,
                            attach: noop
                        };
                        link1(editor1, attachState, {
                            href: value,
                            text,
                            title: Optional.none(),
                            rel: Optional.none(),
                            target: Optional.none(),
                            class: Optional.none()
                        });
                        collapseSelectionToEnd(editor1);
                        formApi.hide();
                    }
                },
                {
                    type: 'contextformbutton',
                    icon: 'unlink',
                    tooltip: 'Remove link',
                    onSetup: onSetupLink,
                    onAction: (formApi)=>{
                        unlink(editor1);
                        formApi.hide();
                    }
                },
                {
                    type: 'contextformbutton',
                    icon: 'new-tab',
                    tooltip: 'Open link',
                    onSetup: onSetupLink,
                    onAction: (formApi)=>{
                        gotoSelectedLink(editor1)();
                        formApi.hide();
                    }
                }
            ]
        });
    };
    var Plugin = ()=>{
        global$5.add('link', (editor)=>{
            register$1(editor);
            setupButtons(editor);
            setupMenuItems(editor);
            setupContextMenu(editor);
            setupContextToolbars(editor);
            setupGotoLinks(editor);
            register(editor);
            setup(editor);
        });
    };
    Plugin();
})();


</script>
  <script>
tinymce.addI18n('de', {
    "Redo": "Wiederholen",
    "Undo": "R\u00fcckg\u00e4ngig machen",
    "Cut": "Ausschneiden",
    "Copy": "Kopieren",
    "Paste": "Einf\u00fcgen",
    "Select all": "Alles ausw\u00e4hlen",
    "New document": "Neues Dokument",
    "Ok": "Ok",
    "Cancel": "Abbrechen",
    "Visual aids": "Visuelle Hilfen",
    "Bold": "Fett",
    "Italic": "Kursiv",
    "Underline": "Unterstrichen",
    "Strikethrough": "Durchgestrichen",
    "Superscript": "Hochgestellt",
    "Subscript": "Tiefgestellt",
    "Clear formatting": "Formatierung entfernen",
    "Align left": "Linksb\u00fcndig ausrichten",
    "Align center": "Zentrieren",
    "Align right": "Rechtsb\u00fcndig ausrichten",
    "Justify": "Blocksatz",
    "Bullet list": "Aufz\u00e4hlung",
    "Numbered list": "Nummerierte Liste",
    "Decrease indent": "Einzug verkleinern",
    "Increase indent": "Einzug vergr\u00f6\u00dfern",
    "Close": "Schlie\u00dfen",
    "Formats": "Formate",
    "Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X\/C\/V keyboard shortcuts instead.": "Ihr Browser unterst\u00fctzt leider keinen direkten Zugriff auf die Zwischenablage. Bitte benutzen Sie die Tastenkombinationen Strg+X\/C\/V.",
    "Headers": "\u00dcberschriften",
    "Header 1": "\u00dcberschrift 1",
    "Header 2": "\u00dcberschrift 2",
    "Header 3": "\u00dcberschrift 3",
    "Header 4": "\u00dcberschrift 4",
    "Header 5": "\u00dcberschrift 5",
    "Header 6": "\u00dcberschrift 6",
    "Headings": "\u00dcberschriften",
    "Heading 1": "Kopfzeile 1",
    "Heading 2": "Kopfzeile 2",
    "Heading 3": "Kopfzeile 3",
    "Heading 4": "Kopfzeile 4",
    "Heading 5": "Kopfzeile 5",
    "Heading 6": "Kopfzeile 6",
    "Preformatted": "Vorformatiert",
    "Div": "Div",
    "Pre": "Pre",
    "Code": "Code",
    "Paragraph": "Absatz",
    "Blockquote": "Blockquote",
    "Inline": "Zeichenformate",
    "Blocks": "Bl\u00f6cke",
    "Paste is now in plain text mode. Contents will now be pasted as plain text until you toggle this option off.": "Einf\u00fcgen ist nun im einfachen Textmodus. Inhalte werden ab jetzt als unformatierter Text eingef\u00fcgt, bis Sie diese Einstellung wieder ausschalten!",
    "Fonts": "Schriftarten",
    "Font Sizes": "Schriftgr\u00f6\u00dfe",
    "Class": "Klasse",
    "Browse for an image": "Bild...",
    "OR": "ODER",
    "Drop an image here": "Bild hier ablegen",
    "Upload": "Hochladen",
    "Block": "Blocksatz",
    "Align": "Ausrichten",
    "Default": "Standard",
    "Circle": "Kreis",
    "Disc": "Punkt",
    "Square": "Quadrat",
    "Lower Alpha": "Kleinbuchstaben",
    "Lower Greek": "Griechische Kleinbuchstaben",
    "Lower Roman": "R\u00f6mische Zahlen (Kleinbuchstaben)",
    "Upper Alpha": "Gro\u00dfbuchstaben",
    "Upper Roman": "R\u00f6mische Zahlen (Gro\u00dfbuchstaben)",
    "Anchor...": "Textmarke",
    "Name": "Name",
    "Id": "Kennung",
    "Id should start with a letter, followed only by letters, numbers, dashes, dots, colons or underscores.": "Die Kennung sollte mit einem Buchstaben anfangen. Nachfolgend nur Buchstaben, Zahlen, Striche (Minus), Punkte, Kommas und Unterstriche.",
    "You have unsaved changes are you sure you want to navigate away?": "Die \u00c4nderungen wurden noch nicht gespeichert, sind Sie sicher, dass Sie diese Seite verlassen wollen?",
    "Restore last draft": "Letzten Entwurf wiederherstellen",
    "Special character...": "Sonderzeichen...",
    "Source code": "Quelltext",
    "Insert\/Edit code sample": "Codebeispiel einf\u00fcgen\/bearbeiten",
    "Language": "Sprache",
    "Code sample...": "Codebeispiel...",
    "Color Picker": "Farbwahl",
    "R": "R",
    "G": "G",
    "B": "B",
    "Left to right": "Von links nach rechts",
    "Right to left": "Von rechts nach links",
    "Emoticons": "Emoticons",
    "Emoticons...": "Emoticons...",
    "Metadata and Document Properties": "Dokument-Eigenschaften und -Metadaten",
    "Title": "Titel",
    "Keywords": "Sch\u00fcsselw\u00f6rter",
    "Description": "Beschreibung",
    "Robots": "Robots",
    "Author": "Verfasser",
    "Encoding": "Zeichenkodierung",
    "Fullscreen": "Vollbild",
    "Action": "Aktion",
    "Shortcut": "Shortcut",
    "Help": "Hilfe",
    "Address": "Adresse",
    "Focus to menubar": "Fokus auf Men\u00fcleiste",
    "Focus to toolbar": "Fokus auf Werkzeugleiste",
    "Focus to element path": "Fokus auf Elementpfad",
    "Focus to contextual toolbar": "Fokus auf kontextbezogene Werkzeugleiste",
    "Insert link (if link plugin activated)": "Link einf\u00fcgen (wenn Link-Plugin aktiviert ist)",
    "Save (if save plugin activated)": "Speichern (wenn Save-Plugin aktiviert ist)",
    "Find (if searchreplace plugin activated)": "Suchen einf\u00fcgen (wenn Suchen\/Ersetzen-Plugin aktiviert ist)",
    "Plugins installed ({0}):": "installierte Plugins ({0}):",
    "Premium plugins:": "Premium Plugins:",
    "Learn more...": "Erfahren Sie mehr dazu...",
    "You are using {0}": "Sie verwenden {0}",
    "Plugins": "Plugins",
    "Handy Shortcuts": "Praktische Tastenkombinationen",
    "Horizontal line": "Horizontale Linie",
    "Insert\/edit image": "Bild einf\u00fcgen\/bearbeiten",
    "Alternative description": "Alternative Beschreibung",
    "Accessibility": "Barrierefreiheit",
    "Image is decorative": "Bild ist dekorativ",
    "Source": "Quelle",
    "Dimensions": "Abmessungen",
    "Constrain proportions": "Seitenverh\u00e4ltnis beibehalten",
    "General": "Allgemein",
    "Advanced": "Erweitert",
    "Style": "Stil",
    "Vertical space": "Vertikaler Abstand",
    "Horizontal space": "Horizontaler Abstand",
    "Border": "Rahmen",
    "Insert image": "Bild einf\u00fcgen",
    "Image...": "Bild...",
    "Image list": "Bildliste",
    "Rotate counterclockwise": "Gegen den Uhrzeigersinn drehen",
    "Rotate clockwise": "Im Uhrzeigersinn drehen",
    "Flip vertically": "Vertikal spiegeln",
    "Flip horizontally": "Horizontal spiegeln",
    "Edit image": "Bild bearbeiten",
    "Image options": "Bildeigenschaften",
    "Zoom in": "Ansicht vergr\u00f6\u00dfern",
    "Zoom out": "Ansicht verkleinern",
    "Crop": "Bescheiden",
    "Resize": "Skalieren",
    "Orientation": "Ausrichtung",
    "Brightness": "Helligkeit",
    "Sharpen": "Sch\u00e4rfen",
    "Contrast": "Kontrast",
    "Color levels": "Farbwerte",
    "Gamma": "Gamma",
    "Invert": "Invertieren",
    "Apply": "Anwenden",
    "Back": "Zur\u00fcck",
    "Insert date\/time": "Datum\/Uhrzeit einf\u00fcgen ",
    "Date\/time": "Datum\/Uhrzeit",
    "Insert\/edit link": "Link einf\u00fcgen\/bearbeiten",
    "Text to display": "Anzuzeigender Text",
    "Url": "URL",
    "Open link in...": "Link \u00f6ffnen in...",
    "Current window": "Aktuelles Fenster",
    "None": "Keine",
    "New window": "Neues Fenster",
    "Open link": "Link \u00f6ffnen",
    "Remove link": "Link entfernen",
    "Anchors": "Textmarken",
    "Link...": "Link...",
    "Paste or type a link": "Link einf\u00fcgen oder eintippen",
    "The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?": "Diese Adresse scheint eine E-Mail-Adresse zu sein. M\u00f6chten Sie das dazu ben\u00f6tigte \"mailto:\" voranstellen?",
    "The URL you entered seems to be an external link. Do you want to add the required http:\/\/ prefix?": "Diese Adresse scheint ein externer Link zu sein. M\u00f6chten Sie das dazu ben\u00f6tigte \"http:\/\/\" voranstellen?",
    "The URL you entered seems to be an external link. Do you want to add the required https:\/\/ prefix?": "Die eingegebene URL scheint ein externer Link zu sein. Soll das fehlende https:\/\/ davor erg\u00e4nzt werden?",
    "Link list": "Linkliste",
    "Insert video": "Video einf\u00fcgen",
    "Insert\/edit video": "Video einf\u00fcgen\/bearbeiten",
    "Insert\/edit media": "Medien einf\u00fcgen\/bearbeiten",
    "Alternative source": "Alternative Quelle",
    "Alternative source URL": "URL der alternativen Quelle",
    "Media poster (Image URL)": "Medienposter (Bild-URL)",
    "Paste your embed code below:": "F\u00fcgen Sie Ihren Einbettungscode hier ein:",
    "Embed": "Einbetten",
    "Media...": "Medien...",
    "Nonbreaking space": "Gesch\u00fctztes Leerzeichen",
    "Page break": "Seitenumbruch",
    "Paste as text": "Als Text einf\u00fcgen",
    "Preview": "Vorschau",
    "Print...": "Drucken...",
    "Save": "Speichern",
    "Find": "Suchen",
    "Replace with": "Ersetzen durch",
    "Replace": "Ersetzen",
    "Replace all": "Alles ersetzen",
    "Previous": "Vorherige",
    "Next": "Weiter",
    "Find and Replace": "Suchen und Ersetzen",
    "Find and replace...": "Suchen und ersetzen...",
    "Could not find the specified string.": "Die Zeichenfolge wurde nicht gefunden.",
    "Match case": "Gro\u00df-\/Kleinschreibung beachten",
    "Find whole words only": "Nur ganze W\u00f6rter suchen",
    "Find in selection": "In Auswahl suchen",
    "Spellcheck": "Rechtschreibpr\u00fcfung",
    "Spellcheck Language": "Sprache f\u00fcr die Rechtschreibpr\u00fcfung",
    "No misspellings found.": "Keine Rechtschreibfehler gefunden",
    "Ignore": "Ignorieren",
    "Ignore all": "Alles Ignorieren",
    "Finish": "Ende",
    "Add to Dictionary": "Zum W\u00f6rterbuch hinzuf\u00fcgen",
    "Insert table": "Tabelle einf\u00fcgen",
    "Table properties": "Tabelleneigenschaften",
    "Delete table": "Tabelle l\u00f6schen",
    "Cell": "Zelle",
    "Row": "Zeile",
    "Column": "Spalte",
    "Cell properties": "Zelleneigenschaften",
    "Merge cells": "Zellen verbinden",
    "Split cell": "Zelle aufteilen",
    "Insert row before": "Neue Zeile davor einf\u00fcgen ",
    "Insert row after": "Neue Zeile danach einf\u00fcgen",
    "Delete row": "Zeile l\u00f6schen",
    "Row properties": "Zeileneigenschaften",
    "Cut row": "Zeile ausschneiden",
    "Copy row": "Zeile kopieren",
    "Paste row before": "Zeile davor einf\u00fcgen",
    "Paste row after": "Zeile danach einf\u00fcgen",
    "Insert column before": "Neue Spalte davor einf\u00fcgen",
    "Insert column after": "Neue Spalte danach einf\u00fcgen",
    "Delete column": "Spalte l\u00f6schen",
    "Cols": "Spalten",
    "Rows": "Zeilen",
    "Width": "Breite",
    "Height": "H\u00f6he",
    "Cell spacing": "Zellenabstand",
    "Cell padding": "Zelleninnenabstand",
    "Caption": "Beschriftung",
    "Show caption": "Beschriftung anzeigen",
    "Left": "Linksb\u00fcndig",
    "Center": "Zentriert",
    "Right": "Rechtsb\u00fcndig",
    "Cell type": "Zellentyp",
    "Scope": "G\u00fcltigkeitsbereich",
    "Alignment": "Ausrichtung",
    "H Align": "Horizontale Ausrichtung",
    "V Align": "Vertikale Ausrichtung",
    "Top": "Oben",
    "Middle": "Mitte",
    "Bottom": "Unten",
    "Header cell": "Kopfzelle",
    "Row group": "Zeilengruppe",
    "Column group": "Spaltengruppe",
    "Row type": "Zeilentyp",
    "Header": "Kopfzeile",
    "Body": "Inhalt",
    "Footer": "Fu\u00dfzeile",
    "Border color": "Rahmenfarbe",
    "Insert template...": "Vorlage einf\u00fcgen...",
    "Templates": "Vorlagen",
    "Template": "Vorlage",
    "Text color": "Textfarbe",
    "Background color": "Hintergrundfarbe",
    "Custom...": "Benutzerdefiniert...",
    "Custom color": "Benutzerdefinierte Farbe",
    "No color": "Keine Farbe",
    "Remove color": "Farbauswahl aufheben",
    "Table of Contents": "Inhaltsverzeichnis",
    "Show blocks": "Bl\u00f6cke anzeigen",
    "Show invisible characters": "Unsichtbare Zeichen anzeigen",
    "Word count": "Anzahl der W\u00f6rter",
    "Count": "Anzahl",
    "Document": "Dokument",
    "Selection": "Auswahl",
    "Words": "W\u00f6rter",
    "Words: {0}": "W\u00f6rter: {0}",
    "{0} words": "{0} W\u00f6rter",
    "File": "Datei",
    "Edit": "Bearbeiten",
    "Insert": "Einf\u00fcgen",
    "View": "Ansicht",
    "Format": "Format",
    "Table": "Tabelle",
    "Tools": "Werkzeuge",
    "Powered by {0}": "Betrieben von {0}",
    "Rich Text Area. Press ALT-F9 for menu. Press ALT-F10 for toolbar. Press ALT-0 for help": "Rich-Text- Area. Dr\u00fccken Sie ALT-F9 f\u00fcr das Men\u00fc. Dr\u00fccken Sie ALT-F10 f\u00fcr Symbolleiste. Dr\u00fccken Sie ALT-0 f\u00fcr Hilfe",
    "Image title": "Bildtitel",
    "Border width": "Rahmenbreite",
    "Border style": "Rahmenstil",
    "Error": "Fehler",
    "Warn": "Warnung",
    "Valid": "G\u00fcltig",
    "To open the popup, press Shift+Enter": "Dr\u00fccken Sie Umschalt+Eingabe, um das Popup-Fenster zu \u00f6ffnen.",
    "Rich Text Area. Press ALT-0 for help.": "Rich-Text-Bereich. Dr\u00fccken Sie Alt+0 f\u00fcr Hilfe.",
    "System Font": "Betriebssystemschriftart",
    "Failed to upload image: {0}": "Bild konnte nicht hochgeladen werden: {0}",
    "Failed to load plugin: {0} from url {1}": "Plugin konnte nicht geladen werden: {0} von URL {1}",
    "Failed to load plugin url: {0}": "Plugin-URL konnte nicht geladen werden: {0}",
    "Failed to initialize plugin: {0}": "Plugin konnte nicht initialisiert werden: {0}",
    "example": "Beispiel",
    "Search": "Suchen",
    "All": "Alles",
    "Currency": "W\u00e4hrung",
    "Text": "Text",
    "Quotations": "Anf\u00fchrungszeichen",
    "Mathematical": "Mathematisch",
    "Extended Latin": "Erweitertes Latein",
    "Symbols": "Symbole",
    "Arrows": "Pfeile",
    "User Defined": "Benutzerdefiniert",
    "dollar sign": "Dollarzeichen",
    "currency sign": "W\u00e4hrungssymbol",
    "euro-currency sign": "Eurozeichen",
    "colon sign": "Doppelpunkt",
    "cruzeiro sign": "Cruzeirozeichen",
    "french franc sign": "Franczeichen",
    "lira sign": "Lirezeichen",
    "mill sign": "Millzeichen",
    "naira sign": "Nairazeichen",
    "peseta sign": "Pesetazeichen",
    "rupee sign": "Rupiezeichen",
    "won sign": "Wonzeichen",
    "new sheqel sign": "Schekelzeichen",
    "dong sign": "Dongzeichen",
    "kip sign": "Kipzeichen",
    "tugrik sign": "Tugrikzeichen",
    "drachma sign": "Drachmezeichen",
    "german penny symbol": "Pfennigzeichen",
    "peso sign": "Pesozeichen",
    "guarani sign": "Guaranizeichen",
    "austral sign": "Australzeichen",
    "hryvnia sign": "Hrywnjazeichen",
    "cedi sign": "Cedizeichen",
    "livre tournois sign": "Livrezeichen",
    "spesmilo sign": "Spesmilozeichen",
    "tenge sign": "Tengezeichen",
    "indian rupee sign": "Indisches Rupiezeichen",
    "turkish lira sign": "T\u00fcrkisches Lirazeichen",
    "nordic mark sign": "Zeichen nordische Mark",
    "manat sign": "Manatzeichen",
    "ruble sign": "Rubelzeichen",
    "yen character": "Yenzeichen",
    "yuan character": "Yuanzeichen",
    "yuan character, in hong kong and taiwan": "Yuanzeichen in Hongkong und Taiwan",
    "yen\/yuan character variant one": "Yen-\/Yuanzeichen Variante 1",
    "Loading emoticons...": "Emoticons werden geladen...",
    "Could not load emoticons": "Emoticons konnten nicht geladen werden",
    "People": "Menschen",
    "Animals and Nature": "Tiere und Natur",
    "Food and Drink": "Essen und Trinken",
    "Activity": "Aktivit\u00e4t",
    "Travel and Places": "Reisen und Orte",
    "Objects": "Objekte",
    "Flags": "Flaggen",
    "Characters": "Zeichen",
    "Characters (no spaces)": "Zeichen (ohne Leerzeichen)",
    "{0} characters": "{0}\u00a0Zeichen",
    "Error: Form submit field collision.": "Fehler: Kollision der Formularbest\u00e4tigungsfelder.",
    "Error: No form element found.": "Fehler: Kein Formularelement gefunden.",
    "Update": "Aktualisieren",
    "Color swatch": "Farbpalette",
    "Turquoise": "T\u00fcrkis",
    "Green": "Gr\u00fcn",
    "Blue": "Blau",
    "Purple": "Violett",
    "Navy Blue": "Marineblau",
    "Dark Turquoise": "Dunkelt\u00fcrkis",
    "Dark Green": "Dunkelgr\u00fcn",
    "Medium Blue": "Mittleres Blau",
    "Medium Purple": "Mittelviolett",
    "Midnight Blue": "Mitternachtsblau",
    "Yellow": "Gelb",
    "Orange": "Orange",
    "Red": "Rot",
    "Light Gray": "Hellgrau",
    "Gray": "Grau",
    "Dark Yellow": "Dunkelgelb",
    "Dark Orange": "Dunkelorange",
    "Dark Red": "Dunkelrot",
    "Medium Gray": "Mittelgrau",
    "Dark Gray": "Dunkelgrau",
    "Light Green": "Hellgr\u00fcn",
    "Light Yellow": "Hellgelb",
    "Light Red": "Hellrot",
    "Light Purple": "Helllila",
    "Light Blue": "Hellblau",
    "Dark Purple": "Dunkellila",
    "Dark Blue": "Dunkelblau",
    "Black": "Schwarz",
    "White": "Wei\u00df",
    "Switch to or from fullscreen mode": "Vollbildmodus umschalten",
    "Open help dialog": "Hilfe-Dialog \u00f6ffnen",
    "history": "Historie",
    "styles": "Stile",
    "formatting": "Formatierung",
    "alignment": "Ausrichtung",
    "indentation": "Einr\u00fcckungen",
    "Font": "Schriftart",
    "Size": "Schriftgr\u00f6\u00dfe",
    "More...": "Mehr...",
    "Select...": "Auswahl...",
    "Preferences": "Einstellungen",
    "Yes": "Ja",
    "No": "Nein",
    "Keyboard Navigation": "Tastaturnavigation",
    "Version": "Version",
    "Code view": "Code Ansicht",
    "Open popup menu for split buttons": "\u00d6ffne Popup Menge um Buttons zu trennen",
    "List Properties": "Liste Eigenschaften",
    "List properties...": "Liste Eigenschaften",
    "Start list at number": "Beginne Liste mit Nummer",
    "Line height": "Liniendicke",
    "comments": "Anmerkungen",
    "Format Painter": "Format-Painter",
    "Insert\/edit iframe": "iframe einf\u00fcgen\/bearbeiten",
    "Capitalization": "Gro\u00dfschreibung",
    "lowercase": "Kleinbuchstaben",
    "UPPERCASE": "Gro\u00dfbuchstaben",
    "Title Case": "Gro\u00df-\/Kleinschreibung des Titels",
    "permanent pen": "Textmarker",
    "Permanent Pen Properties": "Eigenschaften von Permanent Pen",
    "Permanent pen properties...": "Eigenschaften von Permanent Pen...",
    "case change": "Gro\u00df-\/Kleinschreibung",
    "page embed": "Seite einbetten",
    "Advanced sort...": "Erweiterte Sortierung...",
    "Advanced Sort": "Erweiterte Sortierung",
    "Sort table by column ascending": "Tabelle aufsteigend nach Spalten sortieren",
    "Sort table by column descending": "Tabelle absteigend nach Spalten sortieren",
    "Sort": "Sortieren",
    "Order": "Reihenfolge",
    "Sort by": "Sortieren nach",
    "Ascending": "Aufsteigend",
    "Descending": "Absteigend",
    "Column {0}": "Spalte {0}",
    "Row {0}": "Reihe {0}",
    "Spellcheck...": "Rechtschreibpr\u00fcfung...",
    "Misspelled word": "Rechtschreibfehler",
    "Suggestions": "Vorschl\u00e4ge",
    "Change": "Ver\u00e4ndere",
    "Finding word suggestions": "Finde Wort Vorschl\u00e4ge",
    "Success": "Erfolg",
    "Repair": "Reparieren",
    "Issue {0} of {1}": "Fehler {0} von {1}",
    "Images must be marked as decorative or have an alternative text description": "Bilder m\u00fcssen entweder als dekorativ markiert werden oder eine alternative Beschreibung bekommen",
    "Images must have an alternative text description. Decorative images are not allowed.": "Bilder ben\u00f6tigen alternativen Text. Dekorative Bilder nicht erlaubt!",
    "Or provide alternative text:": "Oder definiere alternativen Text:",
    "Make image decorative:": "Markiere Bild als dekorativ:",
    "ID attribute must be unique": "ID muss einzigartig sein",
    "Make ID unique": "Mache diese ID einzigartig",
    "Keep this ID and remove all others": "Behalte diese ID und entferne alle anderen",
    "Remove this ID": "Entferne diese ID",
    "Remove all IDs": "Entferne alle IDs",
    "Checklist": "Checkliste",
    "Anchor": "Textmarke",
    "Special character": "Sonderzeichen",
    "Code sample": "Codebeispiel",
    "Color": "Farbe",
    "Document properties": "Dokumenteigenschaften",
    "Image description": "Bildbeschreibung",
    "Image": "Bild",
    "Insert link": "Link einf\u00fcgen",
    "Target": "Ziel",
    "Link": "Link",
    "Poster": "Poster",
    "Media": "Medium",
    "Print": "Drucken",
    "Prev": "Zur\u00fcck",
    "Find and replace": "Suchen und ersetzen",
    "Whole words": "Nur ganze W\u00f6rter",
    "Insert template": "Vorlage einf\u00fcgen "
});


</script>
  <script>


</script>

  <script>window.initEditor = function(parameter) {
    tinymce.get("textarea").setContent(parameter);
};
tinymce.init({
    selector: '#textarea',
    skin: "bootstrap",
    icons: "bootstrap",
    branding: false,
    menubar: 'edit insert format',
    plugins: 'link',
    language: 'de'
});
function saveResult() {
    var content = tinymce.get("textarea").getContent();
    FileMaker.PerformScript("speichern", content);
}

</script>

</head>

<body>
  <form method="post" style id="form">
    <textarea id="textarea"></textarea>
  </form>
  <br>
  <button id="save" onclick="saveResult()" style="font-size: 14px">Speichern</button>
</body>

</html>